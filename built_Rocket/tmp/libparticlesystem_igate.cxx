/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/particlesystem -Ipanda/src/particlesystem -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libparticlesystem_igate.cxx -od built_Rocket/pandac/input/libparticlesystem.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/particlesystem -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAPHYSICS -module pandaphysics -library libparticlesystem arcEmitter.h baseParticle.h baseParticleEmitter.h baseParticleFactory.h baseParticleRenderer.h boxEmitter.h colorInterpolationManager.h config_particlesystem.h discEmitter.h geomParticleRenderer.h lineEmitter.h lineParticleRenderer.h particleCommonFuncs.h particleSystem.h particleSystemManager.h particlesystem_composite.cxx pointEmitter.h pointParticle.h pointParticleFactory.h pointParticleRenderer.h rectangleEmitter.h ringEmitter.h sparkleParticleRenderer.h sphereSurfaceEmitter.h sphereVolumeEmitter.h spriteParticleRenderer.h tangentRingEmitter.h zSpinParticle.h zSpinParticleFactory.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libparticlesystem
#include "py_panda.h"  

#include "arcEmitter.h"
#include "baseParticle.h"
#include "baseParticleEmitter.h"
#include "baseParticleFactory.h"
#include "baseParticleRenderer.h"
#include "boxEmitter.h"
#include "colorBlendAttrib.h"
#include "colorInterpolationManager.h"
#include "config_particlesystem.h"
#include "dconfig.h"
#include "discEmitter.h"
#include "geom.h"
#include "geomLines.h"
#include "geomNode.h"
#include "geomParticleRenderer.h"
#include "geomVertexData.h"
#include "lineEmitter.h"
#include "lineParticleRenderer.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pStatTimer.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "particleCommonFuncs.h"
#include "particleSystem.h"
#include "particleSystemManager.h"
#include "pdeque.h"
#include "physical.h"
#include "physicsObject.h"
#include "plist.h"
#include "pointEmitter.h"
#include "pointParticle.h"
#include "pointParticleFactory.h"
#include "pointParticleRenderer.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pvector.h"
#include "rectangleEmitter.h"
#include "referenceCount.h"
#include "renderState.h"
#include "ringEmitter.h"
#include "sparkleParticleRenderer.h"
#include "sphereSurfaceEmitter.h"
#include "sphereVolumeEmitter.h"
#include "spriteParticleRenderer.h"
#include <stdlib.h>
#include "tangentRingEmitter.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "zSpinParticle.h"
#include "zSpinParticleFactory.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. BaseParticleEmitter
//********************************************************************
typedef  BaseParticleEmitter  BaseParticleEmitter_localtype;
Define_Module_ClassRef(pandaphysics,BaseParticleEmitter,BaseParticleEmitter_localtype,BaseParticleEmitter);
//********************************************************************
//*** prototypes for .. RingEmitter
//********************************************************************
typedef  RingEmitter  RingEmitter_localtype;
Define_Module_ClassRef(pandaphysics,RingEmitter,RingEmitter_localtype,RingEmitter);
//********************************************************************
//*** prototypes for .. ArcEmitter
//********************************************************************
typedef  ArcEmitter  ArcEmitter_localtype;
Define_Module_ClassRef(pandaphysics,ArcEmitter,ArcEmitter_localtype,ArcEmitter);
//********************************************************************
//*** prototypes for .. BaseParticleFactory
//********************************************************************
typedef  BaseParticleFactory  BaseParticleFactory_localtype;
Define_Module_ClassRef(pandaphysics,BaseParticleFactory,BaseParticleFactory_localtype,BaseParticleFactory);
//********************************************************************
//*** prototypes for .. BaseParticleRenderer
//********************************************************************
typedef  BaseParticleRenderer  BaseParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,BaseParticleRenderer,BaseParticleRenderer_localtype,BaseParticleRenderer);
//********************************************************************
//*** prototypes for .. BoxEmitter
//********************************************************************
typedef  BoxEmitter  BoxEmitter_localtype;
Define_Module_ClassRef(pandaphysics,BoxEmitter,BoxEmitter_localtype,BoxEmitter);
//********************************************************************
//*** prototypes for .. ColorInterpolationFunctionConstant
//********************************************************************
typedef  ColorInterpolationFunctionConstant  ColorInterpolationFunctionConstant_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationFunctionConstant,ColorInterpolationFunctionConstant_localtype,ColorInterpolationFunctionConstant);
//********************************************************************
//*** prototypes for .. ColorInterpolationFunctionLinear
//********************************************************************
typedef  ColorInterpolationFunctionLinear  ColorInterpolationFunctionLinear_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationFunctionLinear,ColorInterpolationFunctionLinear_localtype,ColorInterpolationFunctionLinear);
//********************************************************************
//*** prototypes for .. ColorInterpolationFunctionStepwave
//********************************************************************
typedef  ColorInterpolationFunctionStepwave  ColorInterpolationFunctionStepwave_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationFunctionStepwave,ColorInterpolationFunctionStepwave_localtype,ColorInterpolationFunctionStepwave);
//********************************************************************
//*** prototypes for .. ColorInterpolationFunctionSinusoid
//********************************************************************
typedef  ColorInterpolationFunctionSinusoid  ColorInterpolationFunctionSinusoid_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationFunctionSinusoid,ColorInterpolationFunctionSinusoid_localtype,ColorInterpolationFunctionSinusoid);
//********************************************************************
//*** prototypes for .. ColorInterpolationSegment
//********************************************************************
typedef  ColorInterpolationSegment  ColorInterpolationSegment_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationSegment,ColorInterpolationSegment_localtype,ColorInterpolationSegment);
//********************************************************************
//*** prototypes for .. ColorInterpolationManager
//********************************************************************
typedef  ColorInterpolationManager  ColorInterpolationManager_localtype;
Define_Module_ClassRef(pandaphysics,ColorInterpolationManager,ColorInterpolationManager_localtype,ColorInterpolationManager);
//********************************************************************
//*** prototypes for .. DiscEmitter
//********************************************************************
typedef  DiscEmitter  DiscEmitter_localtype;
Define_Module_ClassRef(pandaphysics,DiscEmitter,DiscEmitter_localtype,DiscEmitter);
//********************************************************************
//*** prototypes for .. GeomParticleRenderer
//********************************************************************
typedef  GeomParticleRenderer  GeomParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,GeomParticleRenderer,GeomParticleRenderer_localtype,GeomParticleRenderer);
//********************************************************************
//*** prototypes for .. LineEmitter
//********************************************************************
typedef  LineEmitter  LineEmitter_localtype;
Define_Module_ClassRef(pandaphysics,LineEmitter,LineEmitter_localtype,LineEmitter);
//********************************************************************
//*** prototypes for .. LineParticleRenderer
//********************************************************************
typedef  LineParticleRenderer  LineParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,LineParticleRenderer,LineParticleRenderer_localtype,LineParticleRenderer);
//********************************************************************
//*** prototypes for .. ParticleSystem
//********************************************************************
typedef  ParticleSystem  ParticleSystem_localtype;
Define_Module_ClassRef(pandaphysics,ParticleSystem,ParticleSystem_localtype,ParticleSystem);
//********************************************************************
//*** prototypes for .. ParticleSystemManager
//********************************************************************
typedef  ParticleSystemManager  ParticleSystemManager_localtype;
Define_Module_Class(pandaphysics,ParticleSystemManager,ParticleSystemManager_localtype,ParticleSystemManager);
//********************************************************************
//*** prototypes for .. PointEmitter
//********************************************************************
typedef  PointEmitter  PointEmitter_localtype;
Define_Module_ClassRef(pandaphysics,PointEmitter,PointEmitter_localtype,PointEmitter);
//********************************************************************
//*** prototypes for .. PointParticleFactory
//********************************************************************
typedef  PointParticleFactory  PointParticleFactory_localtype;
Define_Module_ClassRef(pandaphysics,PointParticleFactory,PointParticleFactory_localtype,PointParticleFactory);
//********************************************************************
//*** prototypes for .. PointParticleRenderer
//********************************************************************
typedef  PointParticleRenderer  PointParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,PointParticleRenderer,PointParticleRenderer_localtype,PointParticleRenderer);
//********************************************************************
//*** prototypes for .. RectangleEmitter
//********************************************************************
typedef  RectangleEmitter  RectangleEmitter_localtype;
Define_Module_ClassRef(pandaphysics,RectangleEmitter,RectangleEmitter_localtype,RectangleEmitter);
//********************************************************************
//*** prototypes for .. SparkleParticleRenderer
//********************************************************************
typedef  SparkleParticleRenderer  SparkleParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,SparkleParticleRenderer,SparkleParticleRenderer_localtype,SparkleParticleRenderer);
//********************************************************************
//*** prototypes for .. SphereSurfaceEmitter
//********************************************************************
typedef  SphereSurfaceEmitter  SphereSurfaceEmitter_localtype;
Define_Module_ClassRef(pandaphysics,SphereSurfaceEmitter,SphereSurfaceEmitter_localtype,SphereSurfaceEmitter);
//********************************************************************
//*** prototypes for .. SphereVolumeEmitter
//********************************************************************
typedef  SphereVolumeEmitter  SphereVolumeEmitter_localtype;
Define_Module_ClassRef(pandaphysics,SphereVolumeEmitter,SphereVolumeEmitter_localtype,SphereVolumeEmitter);
//********************************************************************
//*** prototypes for .. SpriteAnim
//********************************************************************
typedef  SpriteAnim  SpriteAnim_localtype;
Define_Module_ClassRef(pandaphysics,SpriteAnim,SpriteAnim_localtype,SpriteAnim);
//********************************************************************
//*** prototypes for .. SpriteParticleRenderer
//********************************************************************
typedef  SpriteParticleRenderer  SpriteParticleRenderer_localtype;
Define_Module_ClassRef(pandaphysics,SpriteParticleRenderer,SpriteParticleRenderer_localtype,SpriteParticleRenderer);
//********************************************************************
//*** prototypes for .. TangentRingEmitter
//********************************************************************
typedef  TangentRingEmitter  TangentRingEmitter_localtype;
Define_Module_ClassRef(pandaphysics,TangentRingEmitter,TangentRingEmitter_localtype,TangentRingEmitter);
//********************************************************************
//*** prototypes for .. ZSpinParticleFactory
//********************************************************************
typedef  ZSpinParticleFactory  ZSpinParticleFactory_localtype;
Define_Module_ClassRef(pandaphysics,ZSpinParticleFactory,ZSpinParticleFactory_localtype,ZSpinParticleFactory);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ColorBlendAttrib;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Physical;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. BaseParticleEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual BaseParticleEmitter *BaseParticleEmitter::make_copy(void) = 0
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_make_copy_4(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual BaseParticleEmitter *BaseParticleEmitter::make_copy(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            BaseParticleEmitter *return_value = (local_this)->make_copy();
            if (return_value != (BaseParticleEmitter *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BaseParticleEmitter,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleEmitter.makeCopy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(non-const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_make_copy_4_comment =
    "C++ Interface:\n"
    "makeCopy(non-const BaseParticleEmitter this)\n"
    "\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_make_copy_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BaseParticleEmitter::generate(LPoint3f &pos, LVector3f &vel)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_generate_5(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void BaseParticleEmitter::generate(LPoint3f &pos, LVector3f &vel)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"pos", (char *)"vel", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:generate", key_word_list, &param1, &param2))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BaseParticleEmitter.generate", 0, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "BaseParticleEmitter.generate", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->generate(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleEmitter.generate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const BaseParticleEmitter this, non-const Point3 pos, non-const Vec3 vel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_generate_5_comment =
    "C++ Interface:\n"
    "generate(non-const BaseParticleEmitter this, non-const Point3 pos, non-const Vec3 vel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : generate\n"
    "//      Access : Public\n"
    "// Description : parent generation function\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_generate_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_emission_type(BaseParticleEmitter::emissionType et)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_emission_type_6(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleEmitter::set_emission_type(BaseParticleEmitter::emissionType et)
        int param1;
        static char * key_word_list[] = {(char *)"et", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setEmissionType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setEmissionType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_emission_type((BaseParticleEmitter::emissionType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleEmitter.setEmissionType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEmissionType(non-const BaseParticleEmitter this, int et)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_emission_type_6_comment =
    "C++ Interface:\n"
    "setEmissionType(non-const BaseParticleEmitter this, int et)\n"
    "\n"
    "// Filename: baseParticleEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_emission_type\n"
    "//      Access : Public\n"
    "// Description : emission type assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_emission_type_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_amplitude(float a)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_amplitude_7(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleEmitter::set_amplitude(float a)
        double param1;
        static char * key_word_list[] = {(char *)"a", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAmplitude", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAmplitude", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_amplitude((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleEmitter.setAmplitude() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAmplitude(non-const BaseParticleEmitter this, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_amplitude_7_comment =
    "C++ Interface:\n"
    "setAmplitude(non-const BaseParticleEmitter this, float a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_amplitude\n"
    "//      Access : Public\n"
    "// Description : amplitude assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_amplitude_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_amplitude_spread(float as)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_amplitude_spread_8(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleEmitter::set_amplitude_spread(float as)
        double param1;
        static char * key_word_list[] = {(char *)"as", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAmplitudeSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAmplitudeSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_amplitude_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleEmitter.setAmplitudeSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAmplitudeSpread(non-const BaseParticleEmitter this, float as)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment =
    "C++ Interface:\n"
    "setAmplitudeSpread(non-const BaseParticleEmitter this, float as)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_amplitude_spread\n"
    "//      Access : Public\n"
    "// Description : amplitude spread assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_offset_force(LVector3f const &of)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_offset_force_9(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleEmitter::set_offset_force(LVector3f const &of)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"of", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOffsetForce", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "BaseParticleEmitter.setOffsetForce", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_offset_force(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleEmitter.setOffsetForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffsetForce(non-const BaseParticleEmitter this, const Vec3 of)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_offset_force_9_comment =
    "C++ Interface:\n"
    "setOffsetForce(non-const BaseParticleEmitter this, const Vec3 of)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_offset_force\n"
    "//      Access : Public\n"
    "// Description : user-defined force\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_offset_force_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_explicit_launch_vector(LVector3f const &elv)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_explicit_launch_vector_10(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleEmitter::set_explicit_launch_vector(LVector3f const &elv)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"elv", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setExplicitLaunchVector", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setExplicitLaunchVector", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "BaseParticleEmitter.setExplicitLaunchVector", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_explicit_launch_vector(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleEmitter.setExplicitLaunchVector() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExplicitLaunchVector(non-const BaseParticleEmitter this, const Vec3 elv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment =
    "C++ Interface:\n"
    "setExplicitLaunchVector(non-const BaseParticleEmitter this, const Vec3 elv)\n"
    "\n"
    "// this is a constant force applied to all particles\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_explicit_launch_vector\n"
    "//      Access : Public\n"
    "// Description : assignment of explicit emission launch vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleEmitter::set_radiate_origin(LPoint3f const &ro)
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_set_radiate_origin_11(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleEmitter::set_radiate_origin(LPoint3f const &ro)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ro", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRadiateOrigin", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRadiateOrigin", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BaseParticleEmitter.setRadiateOrigin", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_radiate_origin(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleEmitter.setRadiateOrigin() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadiateOrigin(non-const BaseParticleEmitter this, const Point3 ro)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_set_radiate_origin_11_comment =
    "C++ Interface:\n"
    "setRadiateOrigin(non-const BaseParticleEmitter this, const Point3 ro)\n"
    "\n"
    "// this is a constant force applied to all particles\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radiate_origin\n"
    "//      Access : Public\n"
    "// Description : assignment of radiate emission origin point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_set_radiate_origin_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleEmitter::emissionType BaseParticleEmitter::get_emission_type(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_emission_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleEmitter::emissionType BaseParticleEmitter::get_emission_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEmissionType", key_word_list));
        else
            (PyArg_Parse(args, ":getEmissionType"));
        if(!PyErr_Occurred())
        {
            BaseParticleEmitter::emissionType return_value = ((const BaseParticleEmitter*)local_this)->get_emission_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEmissionType(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_emission_type_12_comment =
    "C++ Interface:\n"
    "getEmissionType(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_emission_type\n"
    "//      Access : Public\n"
    "// Description : emission type query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_emission_type_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleEmitter::get_amplitude(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_amplitude_13(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleEmitter::get_amplitude(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAmplitude", key_word_list));
        else
            (PyArg_Parse(args, ":getAmplitude"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleEmitter*)local_this)->get_amplitude();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAmplitude(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_amplitude_13_comment =
    "C++ Interface:\n"
    "getAmplitude(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_amplitude\n"
    "//      Access : Public\n"
    "// Description : amplitude query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_amplitude_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleEmitter::get_amplitude_spread(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_amplitude_spread_14(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleEmitter::get_amplitude_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAmplitudeSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getAmplitudeSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleEmitter*)local_this)->get_amplitude_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAmplitudeSpread(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment =
    "C++ Interface:\n"
    "getAmplitudeSpread(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_amplitude_spread\n"
    "//      Access : Public\n"
    "// Description : amplitude spread query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f BaseParticleEmitter::get_offset_force(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_offset_force_15(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f BaseParticleEmitter::get_offset_force(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffsetForce", key_word_list));
        else
            (PyArg_Parse(args, ":getOffsetForce"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const BaseParticleEmitter*)local_this)->get_offset_force();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffsetForce(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_offset_force_15_comment =
    "C++ Interface:\n"
    "getOffsetForce(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_offset_force\n"
    "//      Access : Public\n"
    "// Description : user-defined force\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_offset_force_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f BaseParticleEmitter::get_explicit_launch_vector(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_explicit_launch_vector_16(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f BaseParticleEmitter::get_explicit_launch_vector(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExplicitLaunchVector", key_word_list));
        else
            (PyArg_Parse(args, ":getExplicitLaunchVector"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const BaseParticleEmitter*)local_this)->get_explicit_launch_vector();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExplicitLaunchVector(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment =
    "C++ Interface:\n"
    "getExplicitLaunchVector(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_explicit_launch_vector\n"
    "//      Access : Public\n"
    "// Description : query for explicit emission launch vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BaseParticleEmitter::get_radiate_origin(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_get_radiate_origin_17(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BaseParticleEmitter::get_radiate_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadiateOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getRadiateOrigin"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BaseParticleEmitter*)local_this)->get_radiate_origin();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadiateOrigin(const BaseParticleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_get_radiate_origin_17_comment =
    "C++ Interface:\n"
    "getRadiateOrigin(const BaseParticleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radiate_origin\n"
    "//      Access : Public\n"
    "// Description : query for explicit emission launch vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_get_radiate_origin_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleEmitter::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_output_18(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BaseParticleEmitter::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleEmitter.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BaseParticleEmitter*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BaseParticleEmitter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_output_18_comment =
    "C++ Interface:\n"
    "output(const BaseParticleEmitter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_output_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleEmitter::write(ostream &out, int indent) const
 * virtual void BaseParticleEmitter::write(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleEmitter_write_19(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleEmitter::write(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleEmitter.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleEmitter*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleEmitter::write(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleEmitter.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleEmitter*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BaseParticleEmitter this, non-const Ostream out)\n"
          "write(const BaseParticleEmitter this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleEmitter_write_19_comment =
    "C++ Interface:\n"
    "write(const BaseParticleEmitter this, non-const Ostream out)\n"
    "write(const BaseParticleEmitter this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleEmitter_write_19_comment = NULL;
#endif

int  Dtool_Init_BaseParticleEmitter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BaseParticleEmitter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BaseParticleEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BaseParticleEmitter)
    {
        printf("BaseParticleEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BaseParticleEmitter * local_this = (BaseParticleEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BaseParticleEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BaseParticleEmitter)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BaseParticleEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RingEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RingEmitter::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_RingEmitter_set_radius_22(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RingEmitter::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RingEmitter.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const RingEmitter this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_set_radius_22_comment =
    "C++ Interface:\n"
    "setRadius(non-const RingEmitter this, float r)\n"
    "\n"
    "// Filename: ringEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius\n"
    "//      Access : public\n"
    "// Description : radius set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_set_radius_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RingEmitter::set_angle(float angle)
 *******************************************************************/
static PyObject *Dtool_RingEmitter_set_angle_23(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RingEmitter::set_angle(float angle)
        double param1;
        static char * key_word_list[] = {(char *)"angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RingEmitter.setAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAngle(non-const RingEmitter this, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_set_angle_23_comment =
    "C++ Interface:\n"
    "setAngle(non-const RingEmitter this, float angle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_angle\n"
    "//      Access : public\n"
    "// Description : angle of elevation set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_set_angle_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RingEmitter::set_radius_spread(float spread)
 *******************************************************************/
static PyObject *Dtool_RingEmitter_set_radius_spread_24(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RingEmitter::set_radius_spread(float spread)
        double param1;
        static char * key_word_list[] = {(char *)"spread", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadiusSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadiusSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RingEmitter.setRadiusSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadiusSpread(non-const RingEmitter this, float spread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_set_radius_spread_24_comment =
    "C++ Interface:\n"
    "setRadiusSpread(non-const RingEmitter this, float spread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius_spread\n"
    "//      Access : public\n"
    "// Description : radius_spread set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_set_radius_spread_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RingEmitter::set_uniform_emission(int uniform_emission)
 *******************************************************************/
static PyObject *Dtool_RingEmitter_set_uniform_emission_25(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void RingEmitter::set_uniform_emission(int uniform_emission)
        int param1;
        static char * key_word_list[] = {(char *)"uniform_emission", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setUniformEmission", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setUniformEmission", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_uniform_emission((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call RingEmitter.setUniformEmission() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUniformEmission(non-const RingEmitter this, int uniform_emission)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_set_uniform_emission_25_comment =
    "C++ Interface:\n"
    "setUniformEmission(non-const RingEmitter this, int uniform_emission)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_uniform_emission\n"
    "//      Access : public\n"
    "// Description : uniform_emission set               \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_set_uniform_emission_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RingEmitter::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_RingEmitter_get_radius_26(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float RingEmitter::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const RingEmitter*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const RingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_get_radius_26_comment =
    "C++ Interface:\n"
    "getRadius(const RingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius\n"
    "//      Access : public\n"
    "// Description : radius get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_get_radius_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RingEmitter::get_angle(void) const
 *******************************************************************/
static PyObject *Dtool_RingEmitter_get_angle_27(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float RingEmitter::get_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const RingEmitter*)local_this)->get_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle(const RingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_get_angle_27_comment =
    "C++ Interface:\n"
    "getAngle(const RingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_angle\n"
    "//      Access : public\n"
    "// Description : angle of elevation get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_get_angle_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RingEmitter::get_radius_spread(void) const
 *******************************************************************/
static PyObject *Dtool_RingEmitter_get_radius_spread_28(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float RingEmitter::get_radius_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadiusSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getRadiusSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const RingEmitter*)local_this)->get_radius_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadiusSpread(const RingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_get_radius_spread_28_comment =
    "C++ Interface:\n"
    "getRadiusSpread(const RingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius_spread\n"
    "//      Access : public\n"
    "// Description : radius_spread get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_get_radius_spread_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RingEmitter::get_uniform_emission(void) const
 *******************************************************************/
static PyObject *Dtool_RingEmitter_get_uniform_emission_29(PyObject *self, PyObject *args,PyObject *kwds) {
    RingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int RingEmitter::get_uniform_emission(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUniformEmission", key_word_list));
        else
            (PyArg_Parse(args, ":getUniformEmission"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const RingEmitter*)local_this)->get_uniform_emission();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUniformEmission(const RingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RingEmitter_get_uniform_emission_29_comment =
    "C++ Interface:\n"
    "getUniformEmission(const RingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_uniform_emission\n"
    "//      Access : public\n"
    "// Description : uniform_emission get               \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RingEmitter_get_uniform_emission_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RingEmitter::RingEmitter(void)
 * RingEmitter::RingEmitter(RingEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_RingEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-RingEmitter::RingEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":RingEmitter", key_word_list))
            {
                RingEmitter *return_value = new RingEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_RingEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-RingEmitter::RingEmitter(RingEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:RingEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:RingEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    RingEmitter *param0_this = (RingEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_RingEmitter, 0, "RingEmitter.RingEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        RingEmitter *return_value = new RingEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_RingEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "RingEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "RingEmitter()\n"
          "RingEmitter(const RingEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RingEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RingEmitter)
    {
        printf("RingEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RingEmitter * local_this = (RingEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RingEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RingEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RingEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (RingEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (RingEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ArcEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ArcEmitter::set_start_angle(float angle)
 *******************************************************************/
static PyObject *Dtool_ArcEmitter_set_start_angle_32(PyObject *self, PyObject *args,PyObject *kwds) {
    ArcEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ArcEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ArcEmitter::set_start_angle(float angle)
        double param1;
        static char * key_word_list[] = {(char *)"angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStartAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStartAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_start_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ArcEmitter.setStartAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartAngle(non-const ArcEmitter this, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ArcEmitter_set_start_angle_32_comment =
    "C++ Interface:\n"
    "setStartAngle(non-const ArcEmitter this, float angle)\n"
    "\n"
    "// Filename: arcEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_start_angle\n"
    "//      Access : public\n"
    "// Description : start angle set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ArcEmitter_set_start_angle_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ArcEmitter::set_end_angle(float angle)
 *******************************************************************/
static PyObject *Dtool_ArcEmitter_set_end_angle_33(PyObject *self, PyObject *args,PyObject *kwds) {
    ArcEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ArcEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ArcEmitter::set_end_angle(float angle)
        double param1;
        static char * key_word_list[] = {(char *)"angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setEndAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setEndAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_end_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ArcEmitter.setEndAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndAngle(non-const ArcEmitter this, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ArcEmitter_set_end_angle_33_comment =
    "C++ Interface:\n"
    "setEndAngle(non-const ArcEmitter this, float angle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_end_angle\n"
    "//      Access : public\n"
    "// Description : end angle set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ArcEmitter_set_end_angle_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ArcEmitter::set_arc(float startAngle, float endAngle)
 *******************************************************************/
static PyObject *Dtool_ArcEmitter_set_arc_34(PyObject *self, PyObject *args,PyObject *kwds) {
    ArcEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ArcEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ArcEmitter::set_arc(float startAngle, float endAngle)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"startAngle", (char *)"endAngle", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setArc", key_word_list, &param1, &param2))
        {
            (local_this)->set_arc((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ArcEmitter.setArc() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setArc(non-const ArcEmitter this, float startAngle, float endAngle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ArcEmitter_set_arc_34_comment =
    "C++ Interface:\n"
    "setArc(non-const ArcEmitter this, float startAngle, float endAngle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_arc\n"
    "//      Access : public\n"
    "// Description : arc sweep set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ArcEmitter_set_arc_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ArcEmitter::get_start_angle(void)
 *******************************************************************/
static PyObject *Dtool_ArcEmitter_get_start_angle_35(PyObject *self, PyObject *args,PyObject *kwds) {
    ArcEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ArcEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float ArcEmitter::get_start_angle(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getStartAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_start_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ArcEmitter.getStartAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartAngle(non-const ArcEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ArcEmitter_get_start_angle_35_comment =
    "C++ Interface:\n"
    "getStartAngle(non-const ArcEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_start_angle\n"
    "//      Access : public\n"
    "// Description : get start angle\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ArcEmitter_get_start_angle_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ArcEmitter::get_end_angle(void)
 *******************************************************************/
static PyObject *Dtool_ArcEmitter_get_end_angle_36(PyObject *self, PyObject *args,PyObject *kwds) {
    ArcEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ArcEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float ArcEmitter::get_end_angle(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getEndAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_end_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ArcEmitter.getEndAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndAngle(non-const ArcEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ArcEmitter_get_end_angle_36_comment =
    "C++ Interface:\n"
    "getEndAngle(non-const ArcEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_end_angle\n"
    "//      Access : public\n"
    "// Description : get end angle\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ArcEmitter_get_end_angle_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ArcEmitter::ArcEmitter(void)
 * ArcEmitter::ArcEmitter(ArcEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_ArcEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ArcEmitter::ArcEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ArcEmitter", key_word_list))
            {
                ArcEmitter *return_value = new ArcEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ArcEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ArcEmitter::ArcEmitter(ArcEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ArcEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ArcEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    ArcEmitter *param0_this = (ArcEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ArcEmitter, 0, "ArcEmitter.ArcEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ArcEmitter *return_value = new ArcEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ArcEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ArcEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ArcEmitter()\n"
          "ArcEmitter(const ArcEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ArcEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ArcEmitter)
    {
        printf("ArcEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ArcEmitter * local_this = (ArcEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ArcEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *)( RingEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *)( RingEmitter *) local_this;
    if(requested_type == &Dtool_RingEmitter)
        return ( RingEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ArcEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ArcEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (ArcEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ArcEmitter*)other_this;
    }
    if(from_type == &Dtool_RingEmitter)
    {
          RingEmitter* other_this = (RingEmitter*)from_this;
          return (ArcEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BaseParticleFactory 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_lifespan_base(float lb)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_lifespan_base_38(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_lifespan_base(float lb)
        double param1;
        static char * key_word_list[] = {(char *)"lb", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLifespanBase", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLifespanBase", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_lifespan_base((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setLifespanBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLifespanBase(non-const BaseParticleFactory this, float lb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_lifespan_base_38_comment =
    "C++ Interface:\n"
    "setLifespanBase(non-const BaseParticleFactory this, float lb)\n"
    "\n"
    "// Filename: baseParticleFactory.I\n"
    "// Created by:  charles (05Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_lifespan_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_lifespan_base_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_lifespan_spread(float ls)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_lifespan_spread_39(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_lifespan_spread(float ls)
        double param1;
        static char * key_word_list[] = {(char *)"ls", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLifespanSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLifespanSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_lifespan_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setLifespanSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLifespanSpread(non-const BaseParticleFactory this, float ls)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_lifespan_spread_39_comment =
    "C++ Interface:\n"
    "setLifespanSpread(non-const BaseParticleFactory this, float ls)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_lifespan_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_lifespan_spread_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_mass_base(float mb)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_mass_base_40(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_mass_base(float mb)
        double param1;
        static char * key_word_list[] = {(char *)"mb", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMassBase", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMassBase", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mass_base((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setMassBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMassBase(non-const BaseParticleFactory this, float mb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_mass_base_40_comment =
    "C++ Interface:\n"
    "setMassBase(non-const BaseParticleFactory this, float mb)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_mass_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_mass_base_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_mass_spread(float ms)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_mass_spread_41(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_mass_spread(float ms)
        double param1;
        static char * key_word_list[] = {(char *)"ms", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMassSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMassSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mass_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setMassSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMassSpread(non-const BaseParticleFactory this, float ms)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_mass_spread_41_comment =
    "C++ Interface:\n"
    "setMassSpread(non-const BaseParticleFactory this, float ms)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_mass_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_mass_spread_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_terminal_velocity_base(float tvb)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_terminal_velocity_base_42(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_terminal_velocity_base(float tvb)
        double param1;
        static char * key_word_list[] = {(char *)"tvb", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTerminalVelocityBase", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTerminalVelocityBase", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_terminal_velocity_base((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setTerminalVelocityBase() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTerminalVelocityBase(non-const BaseParticleFactory this, float tvb)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment =
    "C++ Interface:\n"
    "setTerminalVelocityBase(non-const BaseParticleFactory this, float tvb)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_terminal_velocity_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleFactory::set_terminal_velocity_spread(float tvs)
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_set_terminal_velocity_spread_43(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleFactory::set_terminal_velocity_spread(float tvs)
        double param1;
        static char * key_word_list[] = {(char *)"tvs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTerminalVelocitySpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTerminalVelocitySpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_terminal_velocity_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleFactory.setTerminalVelocitySpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTerminalVelocitySpread(non-const BaseParticleFactory this, float tvs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment =
    "C++ Interface:\n"
    "setTerminalVelocitySpread(non-const BaseParticleFactory this, float tvs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_terminal_velocity_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_lifespan_base(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_lifespan_base_44(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_lifespan_base(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLifespanBase", key_word_list));
        else
            (PyArg_Parse(args, ":getLifespanBase"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_lifespan_base();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLifespanBase(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_lifespan_base_44_comment =
    "C++ Interface:\n"
    "getLifespanBase(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_lifespan_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_lifespan_base_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_lifespan_spread(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_lifespan_spread_45(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_lifespan_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLifespanSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getLifespanSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_lifespan_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLifespanSpread(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_lifespan_spread_45_comment =
    "C++ Interface:\n"
    "getLifespanSpread(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_lifespan_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_lifespan_spread_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_mass_base(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_mass_base_46(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_mass_base(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMassBase", key_word_list));
        else
            (PyArg_Parse(args, ":getMassBase"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_mass_base();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMassBase(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_mass_base_46_comment =
    "C++ Interface:\n"
    "getMassBase(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_mass_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_mass_base_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_mass_spread(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_mass_spread_47(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_mass_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMassSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getMassSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_mass_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMassSpread(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_mass_spread_47_comment =
    "C++ Interface:\n"
    "getMassSpread(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_mass_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_mass_spread_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_terminal_velocity_base(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_terminal_velocity_base_48(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_terminal_velocity_base(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTerminalVelocityBase", key_word_list));
        else
            (PyArg_Parse(args, ":getTerminalVelocityBase"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_terminal_velocity_base();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTerminalVelocityBase(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment =
    "C++ Interface:\n"
    "getTerminalVelocityBase(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_terminal_velocity_base\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleFactory::get_terminal_velocity_spread(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_get_terminal_velocity_spread_49(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleFactory::get_terminal_velocity_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTerminalVelocitySpread", key_word_list));
        else
            (PyArg_Parse(args, ":getTerminalVelocitySpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleFactory*)local_this)->get_terminal_velocity_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTerminalVelocitySpread(const BaseParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment =
    "C++ Interface:\n"
    "getTerminalVelocitySpread(const BaseParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_terminal_velocity_spread\n"
    "// Description : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleFactory::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_output_52(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BaseParticleFactory::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleFactory.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BaseParticleFactory*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BaseParticleFactory this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_output_52_comment =
    "C++ Interface:\n"
    "output(const BaseParticleFactory this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_output_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleFactory::write(ostream &out, int indent) const
 * virtual void BaseParticleFactory::write(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleFactory_write_53(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleFactory::write(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleFactory.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleFactory*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleFactory::write(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleFactory.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleFactory*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BaseParticleFactory this, non-const Ostream out)\n"
          "write(const BaseParticleFactory this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleFactory_write_53_comment =
    "C++ Interface:\n"
    "write(const BaseParticleFactory this, non-const Ostream out)\n"
    "write(const BaseParticleFactory this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleFactory_write_53_comment = NULL;
#endif

int  Dtool_Init_BaseParticleFactory(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BaseParticleFactory)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BaseParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BaseParticleFactory)
    {
        printf("BaseParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BaseParticleFactory * local_this = (BaseParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BaseParticleFactory)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BaseParticleFactory(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BaseParticleFactory)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BaseParticleFactory*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BaseParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline GeomNode *BaseParticleRenderer::get_render_node(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_get_render_node_57(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline GeomNode *BaseParticleRenderer::get_render_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderNode", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderNode"));
        if(!PyErr_Occurred())
        {
            GeomNode *return_value = ((const BaseParticleRenderer*)local_this)->get_render_node();
            if (return_value != (GeomNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GeomNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderNode(const BaseParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_get_render_node_57_comment =
    "C++ Interface:\n"
    "getRenderNode(const BaseParticleRenderer this)\n"
    "\n"
    "// Filename: baseParticleRenderer.I\n"
    "// Created by:  charles (20Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::get_render_node\n"
    "//       Class : Published\n"
    "// Description : Query the geomnode pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_get_render_node_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath BaseParticleRenderer::get_render_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_get_render_node_path_58(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath BaseParticleRenderer::get_render_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const BaseParticleRenderer*)local_this)->get_render_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderNodePath(const BaseParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_get_render_node_path_58_comment =
    "C++ Interface:\n"
    "getRenderNodePath(const BaseParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::get_render_node_path\n"
    "//       Class : Published\n"
    "// Description : Query the geomnode pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_get_render_node_path_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleRenderer::set_alpha_mode(BaseParticleRenderer::ParticleRendererAlphaMode am)
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_set_alpha_mode_59(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleRenderer::set_alpha_mode(BaseParticleRenderer::ParticleRendererAlphaMode am)
        int param1;
        static char * key_word_list[] = {(char *)"am", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlphaMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlphaMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_alpha_mode((BaseParticleRenderer::ParticleRendererAlphaMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleRenderer.setAlphaMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlphaMode(non-const BaseParticleRenderer this, int am)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_set_alpha_mode_59_comment =
    "C++ Interface:\n"
    "setAlphaMode(non-const BaseParticleRenderer this, int am)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::set_alpha_mode\n"
    "//      Access : Published\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_set_alpha_mode_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleRenderer::ParticleRendererAlphaMode BaseParticleRenderer::get_alpha_mode(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_get_alpha_mode_60(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleRenderer::ParticleRendererAlphaMode BaseParticleRenderer::get_alpha_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaMode", key_word_list));
        else
            (PyArg_Parse(args, ":getAlphaMode"));
        if(!PyErr_Occurred())
        {
            BaseParticleRenderer::ParticleRendererAlphaMode return_value = ((const BaseParticleRenderer*)local_this)->get_alpha_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaMode(const BaseParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_get_alpha_mode_60_comment =
    "C++ Interface:\n"
    "getAlphaMode(const BaseParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::get_alpha_mode\n"
    "//      Access : Published\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_get_alpha_mode_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleRenderer::set_user_alpha(float ua)
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_set_user_alpha_61(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseParticleRenderer::set_user_alpha(float ua)
        double param1;
        static char * key_word_list[] = {(char *)"ua", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUserAlpha", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUserAlpha", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_user_alpha((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleRenderer.setUserAlpha() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUserAlpha(non-const BaseParticleRenderer this, float ua)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_set_user_alpha_61_comment =
    "C++ Interface:\n"
    "setUserAlpha(non-const BaseParticleRenderer this, float ua)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::set_user_alpha\n"
    "//      Access : Published\n"
    "// Description : sets alpha for \"user\" alpha mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_set_user_alpha_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BaseParticleRenderer::get_user_alpha(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_get_user_alpha_62(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BaseParticleRenderer::get_user_alpha(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUserAlpha", key_word_list));
        else
            (PyArg_Parse(args, ":getUserAlpha"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BaseParticleRenderer*)local_this)->get_user_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUserAlpha(const BaseParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_get_user_alpha_62_comment =
    "C++ Interface:\n"
    "getUserAlpha(const BaseParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::get_user_alpha\n"
    "//      Access : Published\n"
    "// Description : gets alpha for \"user\" alpha mode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_get_user_alpha_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa, ColorBlendAttrib::Operand ob)
 * inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa, ColorBlendAttrib::Operand ob = (O_zero))
 * inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa = (O_zero), ColorBlendAttrib::Operand ob = (O_zero))
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_set_color_blend_mode_63(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa = (O_zero), ColorBlendAttrib::Operand ob = (O_zero))
            int param1;
            static char * key_word_list[] = {(char *)"bm", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:setColorBlendMode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:setColorBlendMode", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_color_blend_mode((ColorBlendAttrib::Mode)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleRenderer.setColorBlendMode() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa, ColorBlendAttrib::Operand ob = (O_zero))
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"bm", (char *)"oa", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setColorBlendMode", key_word_list, &param1, &param2))
            {
                (local_this)->set_color_blend_mode((ColorBlendAttrib::Mode)param1, (ColorBlendAttrib::Operand)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleRenderer.setColorBlendMode() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BaseParticleRenderer::set_color_blend_mode(ColorBlendAttrib::Mode bm, ColorBlendAttrib::Operand oa, ColorBlendAttrib::Operand ob)
            int param1;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"bm", (char *)"oa", (char *)"ob", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:setColorBlendMode", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_color_blend_mode((ColorBlendAttrib::Mode)param1, (ColorBlendAttrib::Operand)param2, (ColorBlendAttrib::Operand)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BaseParticleRenderer.setColorBlendMode() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setColorBlendMode() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setColorBlendMode(non-const BaseParticleRenderer this, int bm)\n"
          "setColorBlendMode(non-const BaseParticleRenderer this, int bm, int oa)\n"
          "setColorBlendMode(non-const BaseParticleRenderer this, int bm, int oa, int ob)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment =
    "C++ Interface:\n"
    "setColorBlendMode(non-const BaseParticleRenderer this, int bm)\n"
    "setColorBlendMode(non-const BaseParticleRenderer this, int bm, int oa)\n"
    "setColorBlendMode(non-const BaseParticleRenderer this, int bm, int oa, int ob)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::set_color_blend_mode\n"
    "//      Access : Published\n"
    "// Description : sets the ColorBlendAttrib on the _render_node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BaseParticleRenderer::set_ignore_scale(bool ignore_scale)
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_set_ignore_scale_64(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BaseParticleRenderer::set_ignore_scale(bool ignore_scale)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"ignore_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIgnoreScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setIgnoreScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_ignore_scale((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseParticleRenderer.setIgnoreScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIgnoreScale(non-const BaseParticleRenderer this, bool ignore_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_set_ignore_scale_64_comment =
    "C++ Interface:\n"
    "setIgnoreScale(non-const BaseParticleRenderer this, bool ignore_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::set_ignore_scale\n"
    "//      Access : Published\n"
    "// Description : Sets the \"ignore scale\" flag.  When this is true,\n"
    "//               particles will be drawn as if they had no scale,\n"
    "//               regardless of whatever scale might be inherited from\n"
    "//               above the render node in the scene graph.\n"
    "//\n"
    "//               This flag is mainly useful to support legacy code\n"
    "//               that was written for a very early version of Panda,\n"
    "//               whose sprite particle renderer had a bug that\n"
    "//               incorrectly ignored the inherited scale.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_set_ignore_scale_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BaseParticleRenderer::get_ignore_scale(void) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_get_ignore_scale_65(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BaseParticleRenderer::get_ignore_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIgnoreScale", key_word_list));
        else
            (PyArg_Parse(args, ":getIgnoreScale"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BaseParticleRenderer*)local_this)->get_ignore_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIgnoreScale(const BaseParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_get_ignore_scale_65_comment =
    "C++ Interface:\n"
    "getIgnoreScale(const BaseParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : BaseParticleRender::get_ignore_scale\n"
    "//      Access : Published\n"
    "// Description : Returns the \"ignore scale\" flag.  See\n"
    "//               set_ignore_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_get_ignore_scale_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleRenderer::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_output_66(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BaseParticleRenderer::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleRenderer.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BaseParticleRenderer*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BaseParticleRenderer this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_output_66_comment =
    "C++ Interface:\n"
    "output(const BaseParticleRenderer this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : BaseParticleRender::output\n"
    "//       Access : Published\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_output_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseParticleRenderer::write(ostream &out, int indent) const
 * virtual void BaseParticleRenderer::write(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseParticleRenderer_write_67(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleRenderer::write(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleRenderer.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleRenderer*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseParticleRenderer::write(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseParticleRenderer.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseParticleRenderer*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BaseParticleRenderer this, non-const Ostream out)\n"
          "write(const BaseParticleRenderer this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseParticleRenderer_write_67_comment =
    "C++ Interface:\n"
    "write(const BaseParticleRenderer this, non-const Ostream out)\n"
    "write(const BaseParticleRenderer this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : BaseParticleRender::write\n"
    "//       Access : Published\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseParticleRenderer_write_67_comment = NULL;
#endif

int  Dtool_Init_BaseParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BaseParticleRenderer)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BaseParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BaseParticleRenderer)
    {
        printf("BaseParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BaseParticleRenderer * local_this = (BaseParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BaseParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BaseParticleRenderer)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BaseParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoxEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void BoxEmitter::set_min_bound(LPoint3f const &vmin)
 *******************************************************************/
static PyObject *Dtool_BoxEmitter_set_min_bound_70(PyObject *self, PyObject *args,PyObject *kwds) {
    BoxEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoxEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BoxEmitter::set_min_bound(LPoint3f const &vmin)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vmin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMinBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMinBound", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BoxEmitter.setMinBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_min_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BoxEmitter.setMinBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinBound(non-const BoxEmitter this, const Point3 vmin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoxEmitter_set_min_bound_70_comment =
    "C++ Interface:\n"
    "setMinBound(non-const BoxEmitter this, const Point3 vmin)\n"
    "\n"
    "// Filename: boxEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_min_bound\n"
    "//      Access : Public\n"
    "// Description : boundary assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoxEmitter_set_min_bound_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BoxEmitter::set_max_bound(LPoint3f const &vmax)
 *******************************************************************/
static PyObject *Dtool_BoxEmitter_set_max_bound_71(PyObject *self, PyObject *args,PyObject *kwds) {
    BoxEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoxEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void BoxEmitter::set_max_bound(LPoint3f const &vmax)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vmax", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMaxBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMaxBound", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BoxEmitter.setMaxBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_max_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BoxEmitter.setMaxBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxBound(non-const BoxEmitter this, const Point3 vmax)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoxEmitter_set_max_bound_71_comment =
    "C++ Interface:\n"
    "setMaxBound(non-const BoxEmitter this, const Point3 vmax)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_max_bound\n"
    "//      Access : Public\n"
    "// Description : boundary assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoxEmitter_set_max_bound_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoxEmitter::get_min_bound(void) const
 *******************************************************************/
static PyObject *Dtool_BoxEmitter_get_min_bound_72(PyObject *self, PyObject *args,PyObject *kwds) {
    BoxEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoxEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoxEmitter::get_min_bound(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinBound", key_word_list));
        else
            (PyArg_Parse(args, ":getMinBound"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoxEmitter*)local_this)->get_min_bound();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinBound(const BoxEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoxEmitter_get_min_bound_72_comment =
    "C++ Interface:\n"
    "getMinBound(const BoxEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_min_bound\n"
    "//      Access : Public\n"
    "// Description : boundary accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoxEmitter_get_min_bound_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoxEmitter::get_max_bound(void) const
 *******************************************************************/
static PyObject *Dtool_BoxEmitter_get_max_bound_73(PyObject *self, PyObject *args,PyObject *kwds) {
    BoxEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoxEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoxEmitter::get_max_bound(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxBound", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxBound"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoxEmitter*)local_this)->get_max_bound();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxBound(const BoxEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoxEmitter_get_max_bound_73_comment =
    "C++ Interface:\n"
    "getMaxBound(const BoxEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_max_bound\n"
    "//      Access : Public\n"
    "// Description : boundary accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoxEmitter_get_max_bound_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BoxEmitter::BoxEmitter(void)
 * BoxEmitter::BoxEmitter(BoxEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_BoxEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-BoxEmitter::BoxEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BoxEmitter", key_word_list))
            {
                BoxEmitter *return_value = new BoxEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BoxEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BoxEmitter::BoxEmitter(BoxEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BoxEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BoxEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    BoxEmitter *param0_this = (BoxEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_BoxEmitter, 0, "BoxEmitter.BoxEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        BoxEmitter *return_value = new BoxEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoxEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BoxEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BoxEmitter()\n"
          "BoxEmitter(const BoxEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BoxEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoxEmitter)
    {
        printf("BoxEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoxEmitter * local_this = (BoxEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoxEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoxEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoxEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (BoxEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoxEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationFunctionConstant 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f ColorInterpolationFunctionConstant::get_color_a(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionConstant_get_color_a_76(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionConstant * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionConstant,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f ColorInterpolationFunctionConstant::get_color_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorA", key_word_list));
        else
            (PyArg_Parse(args, ":getColorA"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const ColorInterpolationFunctionConstant*)local_this)->get_color_a();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorA(const ColorInterpolationFunctionConstant this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment =
    "C++ Interface:\n"
    "getColorA(const ColorInterpolationFunctionConstant this)\n"
    "\n"
    "// Filename: colorInterpolationManager.I\n"
    "// Created by:  joswilso (02Jun05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionConstant::get_color_a\n"
    "//      Access : public\n"
    "// Description : Returns the primary color of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationFunctionConstant::set_color_a(LVecBase4f const c)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionConstant_set_color_a_77(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionConstant * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionConstant,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ColorInterpolationFunctionConstant::set_color_a(LVecBase4f const c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColorA", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColorA", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "ColorInterpolationFunctionConstant.setColorA", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color_a(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationFunctionConstant.setColorA() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorA(non-const ColorInterpolationFunctionConstant this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment =
    "C++ Interface:\n"
    "setColorA(non-const ColorInterpolationFunctionConstant this, const VBase4 c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionConstant::set_color_a\n"
    "//      Access : public\n"
    "// Description : Sets the primary color of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ColorInterpolationFunctionConstant::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionConstant_get_class_type_78(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ColorInterpolationFunctionConstant::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ColorInterpolationFunctionConstant::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment = NULL;
#endif

int  Dtool_Init_ColorInterpolationFunctionConstant(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ColorInterpolationFunctionConstant)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ColorInterpolationFunctionConstant(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationFunctionConstant)
    {
        printf("ColorInterpolationFunctionConstant ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationFunctionConstant * local_this = (ColorInterpolationFunctionConstant *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationFunctionConstant)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( ColorInterpolationFunction *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( ColorInterpolationFunction *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( ColorInterpolationFunction *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationFunctionConstant(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationFunctionConstant)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationFunctionConstant*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ColorInterpolationFunctionConstant*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ColorInterpolationFunctionConstant*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationFunctionLinear 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f ColorInterpolationFunctionLinear::get_color_b(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionLinear_get_color_b_81(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionLinear * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionLinear,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f ColorInterpolationFunctionLinear::get_color_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorB", key_word_list));
        else
            (PyArg_Parse(args, ":getColorB"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const ColorInterpolationFunctionLinear*)local_this)->get_color_b();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorB(const ColorInterpolationFunctionLinear this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment =
    "C++ Interface:\n"
    "getColorB(const ColorInterpolationFunctionLinear this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionLinear::get_color_b\n"
    "//      Access : public\n"
    "// Description : Returns the secondary color of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationFunctionLinear::set_color_b(LVecBase4f const c)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionLinear_set_color_b_82(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionLinear * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionLinear,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ColorInterpolationFunctionLinear::set_color_b(LVecBase4f const c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColorB", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColorB", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "ColorInterpolationFunctionLinear.setColorB", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color_b(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationFunctionLinear.setColorB() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorB(non-const ColorInterpolationFunctionLinear this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment =
    "C++ Interface:\n"
    "setColorB(non-const ColorInterpolationFunctionLinear this, const VBase4 c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionLinear::set_color_b\n"
    "//      Access : public\n"
    "// Description : Sets the secondary color of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ColorInterpolationFunctionLinear::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionLinear_get_class_type_83(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ColorInterpolationFunctionLinear::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ColorInterpolationFunctionLinear::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment = NULL;
#endif

int  Dtool_Init_ColorInterpolationFunctionLinear(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ColorInterpolationFunctionLinear)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ColorInterpolationFunctionLinear(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationFunctionLinear)
    {
        printf("ColorInterpolationFunctionLinear ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationFunctionLinear * local_this = (ColorInterpolationFunctionLinear *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationFunctionLinear)
        return local_this;
    if(requested_type == &Dtool_ColorInterpolationFunctionConstant)
        return ( ColorInterpolationFunctionConstant *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationFunctionLinear(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationFunctionLinear)
        return from_this;
    if(from_type == &Dtool_ColorInterpolationFunctionConstant)
    {
          ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
          return (ColorInterpolationFunctionLinear*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationFunctionLinear*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ColorInterpolationFunctionLinear*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ColorInterpolationFunctionLinear*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationFunctionStepwave 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float ColorInterpolationFunctionStepwave::get_width_a(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_width_a_86(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionStepwave * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionStepwave,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ColorInterpolationFunctionStepwave::get_width_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidthA", key_word_list));
        else
            (PyArg_Parse(args, ":getWidthA"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ColorInterpolationFunctionStepwave*)local_this)->get_width_a();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidthA(const ColorInterpolationFunctionStepwave this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment =
    "C++ Interface:\n"
    "getWidthA(const ColorInterpolationFunctionStepwave this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionStepwave::get_width_a\n"
    "//      Access : public\n"
    "// Description : Returns the primary width of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ColorInterpolationFunctionStepwave::get_width_b(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_width_b_87(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionStepwave * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionStepwave,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ColorInterpolationFunctionStepwave::get_width_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidthB", key_word_list));
        else
            (PyArg_Parse(args, ":getWidthB"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ColorInterpolationFunctionStepwave*)local_this)->get_width_b();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidthB(const ColorInterpolationFunctionStepwave this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment =
    "C++ Interface:\n"
    "getWidthB(const ColorInterpolationFunctionStepwave this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionStepwave::get_width_b\n"
    "//      Access : public\n"
    "// Description : Returns the secondary width of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationFunctionStepwave::set_width_a(float const w)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionStepwave_set_width_a_88(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionStepwave * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionStepwave,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationFunctionStepwave::set_width_a(float const w)
        double param1;
        static char * key_word_list[] = {(char *)"w", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWidthA", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWidthA", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_width_a((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationFunctionStepwave.setWidthA() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidthA(non-const ColorInterpolationFunctionStepwave this, float w)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment =
    "C++ Interface:\n"
    "setWidthA(non-const ColorInterpolationFunctionStepwave this, float w)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionStepwave::set_width_a\n"
    "//      Access : public\n"
    "// Description : Sets the primary width of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationFunctionStepwave::set_width_b(float const w)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionStepwave_set_width_b_89(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionStepwave * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionStepwave,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationFunctionStepwave::set_width_b(float const w)
        double param1;
        static char * key_word_list[] = {(char *)"w", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWidthB", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWidthB", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_width_b((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationFunctionStepwave.setWidthB() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidthB(non-const ColorInterpolationFunctionStepwave this, float w)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment =
    "C++ Interface:\n"
    "setWidthB(non-const ColorInterpolationFunctionStepwave this, float w)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionStepwave::set_width_b\n"
    "//      Access : public\n"
    "// Description : Sets the secondary width of the function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ColorInterpolationFunctionStepwave::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionStepwave_get_class_type_90(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ColorInterpolationFunctionStepwave::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ColorInterpolationFunctionStepwave::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment = NULL;
#endif

int  Dtool_Init_ColorInterpolationFunctionStepwave(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ColorInterpolationFunctionStepwave)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ColorInterpolationFunctionStepwave(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationFunctionStepwave)
    {
        printf("ColorInterpolationFunctionStepwave ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationFunctionStepwave * local_this = (ColorInterpolationFunctionStepwave *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationFunctionStepwave)
        return local_this;
    if(requested_type == &Dtool_ColorInterpolationFunctionConstant)
        return ( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_ColorInterpolationFunctionLinear)
        return ( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationFunctionStepwave(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationFunctionStepwave)
        return from_this;
    if(from_type == &Dtool_ColorInterpolationFunctionConstant)
    {
          ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
          return (ColorInterpolationFunctionStepwave*)other_this;
    }
    if(from_type == &Dtool_ColorInterpolationFunctionLinear)
    {
          ColorInterpolationFunctionLinear* other_this = (ColorInterpolationFunctionLinear*)from_this;
          return (ColorInterpolationFunctionStepwave*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationFunctionStepwave*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ColorInterpolationFunctionStepwave*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ColorInterpolationFunctionStepwave*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationFunctionSinusoid 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float ColorInterpolationFunctionSinusoid::get_period(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_get_period_93(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionSinusoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionSinusoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ColorInterpolationFunctionSinusoid::get_period(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPeriod", key_word_list));
        else
            (PyArg_Parse(args, ":getPeriod"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ColorInterpolationFunctionSinusoid*)local_this)->get_period();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPeriod(const ColorInterpolationFunctionSinusoid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment =
    "C++ Interface:\n"
    "getPeriod(const ColorInterpolationFunctionSinusoid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionSinusoid::get_period\n"
    "//      Access : public\n"
    "// Description : Returns the time to transition from A to B then back\n"
    "//               to A again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationFunctionSinusoid::set_period(float const p)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_set_period_94(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationFunctionSinusoid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationFunctionSinusoid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationFunctionSinusoid::set_period(float const p)
        double param1;
        static char * key_word_list[] = {(char *)"p", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPeriod", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPeriod", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_period((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationFunctionSinusoid.setPeriod() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPeriod(non-const ColorInterpolationFunctionSinusoid this, float p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment =
    "C++ Interface:\n"
    "setPeriod(non-const ColorInterpolationFunctionSinusoid this, float p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationFunctionSinusoid::set_period\n"
    "//      Access : public\n"
    "// Description : Sets the time to transition from A to B then back\n"
    "//               to A again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ColorInterpolationFunctionSinusoid::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ColorInterpolationFunctionSinusoid::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ColorInterpolationFunctionSinusoid::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment = NULL;
#endif

int  Dtool_Init_ColorInterpolationFunctionSinusoid(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ColorInterpolationFunctionSinusoid)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ColorInterpolationFunctionSinusoid(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationFunctionSinusoid)
    {
        printf("ColorInterpolationFunctionSinusoid ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationFunctionSinusoid * local_this = (ColorInterpolationFunctionSinusoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationFunctionSinusoid)
        return local_this;
    if(requested_type == &Dtool_ColorInterpolationFunctionConstant)
        return ( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_ColorInterpolationFunctionLinear)
        return ( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( ColorInterpolationFunction *)( ColorInterpolationFunctionConstant *)( ColorInterpolationFunctionLinear *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationFunctionSinusoid(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationFunctionSinusoid)
        return from_this;
    if(from_type == &Dtool_ColorInterpolationFunctionConstant)
    {
          ColorInterpolationFunctionConstant* other_this = (ColorInterpolationFunctionConstant*)from_this;
          return (ColorInterpolationFunctionSinusoid*)other_this;
    }
    if(from_type == &Dtool_ColorInterpolationFunctionLinear)
    {
          ColorInterpolationFunctionLinear* other_this = (ColorInterpolationFunctionLinear*)from_this;
          return (ColorInterpolationFunctionSinusoid*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationFunctionSinusoid*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ColorInterpolationFunctionSinusoid*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ColorInterpolationFunctionSinusoid*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationSegment 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline TypedReferenceCount *ColorInterpolationSegment::get_function(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_get_function_99(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypedReferenceCount *ColorInterpolationSegment::get_function(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFunction", key_word_list));
        else
            (PyArg_Parse(args, ":getFunction"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = ((const ColorInterpolationSegment*)local_this)->get_function();
            if (return_value != (TypedReferenceCount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFunction(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_get_function_99_comment =
    "C++ Interface:\n"
    "getFunction(const ColorInterpolationSegment this)\n"
    "\n"
    "//  INLINE ColorInterpolationFunction* get_function() const;\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::get_function\n"
    "//      Access : public\n"
    "// Description : Returns a reference to the function object \n"
    "//               corresponding to this segment.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_get_function_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ColorInterpolationSegment::get_time_begin(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_get_time_begin_100(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ColorInterpolationSegment::get_time_begin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimeBegin", key_word_list));
        else
            (PyArg_Parse(args, ":getTimeBegin"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ColorInterpolationSegment*)local_this)->get_time_begin();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimeBegin(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_get_time_begin_100_comment =
    "C++ Interface:\n"
    "getTimeBegin(const ColorInterpolationSegment this)\n"
    "\n"
    "//  INLINE ColorInterpolationFunction* get_function() const;\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::get_time_begin\n"
    "//      Access : public\n"
    "// Description : Returns the point in the particle's lifetime at which\n"
    "//               this segment begins its effect.  It is an interpolated\n"
    "//               value in the range [0,1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_get_time_begin_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ColorInterpolationSegment::get_time_end(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_get_time_end_101(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ColorInterpolationSegment::get_time_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimeEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getTimeEnd"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ColorInterpolationSegment*)local_this)->get_time_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimeEnd(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_get_time_end_101_comment =
    "C++ Interface:\n"
    "getTimeEnd(const ColorInterpolationSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::get_time_end\n"
    "//      Access : public\n"
    "// Description : Returns the point in the particle's lifetime at which\n"
    "//               this segment's effect stops.  It is an interpolated\n"
    "//               value in the range [0,1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_get_time_end_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ColorInterpolationSegment::is_modulated(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_is_modulated_102(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ColorInterpolationSegment::is_modulated(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isModulated", key_word_list));
        else
            (PyArg_Parse(args, ":isModulated"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ColorInterpolationSegment*)local_this)->is_modulated();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isModulated(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_is_modulated_102_comment =
    "C++ Interface:\n"
    "isModulated(const ColorInterpolationSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::is_modulated\n"
    "//      Access : public\n"
    "// Description : Returns whether the function is additive or modulated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_is_modulated_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ColorInterpolationSegment::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_get_id_103(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ColorInterpolationSegment::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ColorInterpolationSegment*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_get_id_103_comment =
    "C++ Interface:\n"
    "getId(const ColorInterpolationSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::get_id\n"
    "//      Access : public\n"
    "// Description : Returns the id assigned to this segment by the\n"
    "//               manager that created it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_get_id_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ColorInterpolationSegment::is_enabled(void) const
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_is_enabled_104(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ColorInterpolationSegment::is_enabled(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEnabled", key_word_list));
        else
            (PyArg_Parse(args, ":isEnabled"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ColorInterpolationSegment*)local_this)->is_enabled();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEnabled(const ColorInterpolationSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_is_enabled_104_comment =
    "C++ Interface:\n"
    "isEnabled(const ColorInterpolationSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::is_enabled()\n"
    "//      Access : public\n"
    "// Description : Returns whether the segments effects are being applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_is_enabled_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationSegment::set_time_begin(float const time)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_set_time_begin_106(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationSegment::set_time_begin(float const time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTimeBegin", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTimeBegin", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_time_begin((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationSegment.setTimeBegin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimeBegin(non-const ColorInterpolationSegment this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_set_time_begin_106_comment =
    "C++ Interface:\n"
    "setTimeBegin(non-const ColorInterpolationSegment this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::set_time_begin\n"
    "//      Access : public\n"
    "// Description : Sets the point in the particle's lifetime at which\n"
    "//               this segment begins its effect.  It is an interpolated\n"
    "//               value in the range [0,1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_set_time_begin_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationSegment::set_time_end(float const time)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_set_time_end_107(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationSegment::set_time_end(float const time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTimeEnd", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTimeEnd", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_time_end((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationSegment.setTimeEnd() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimeEnd(non-const ColorInterpolationSegment this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_set_time_end_107_comment =
    "C++ Interface:\n"
    "setTimeEnd(non-const ColorInterpolationSegment this, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::set_time_end\n"
    "//      Access : public\n"
    "// Description : Sets the point in the particle's lifetime at which\n"
    "//               this segment's effect ends.  It is an interpolated\n"
    "//               value in the range [0,1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_set_time_end_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationSegment::set_is_modulated(bool const flag)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_set_is_modulated_108(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationSegment::set_is_modulated(bool const flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIsModulated", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setIsModulated", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_is_modulated((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationSegment.setIsModulated() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIsModulated(non-const ColorInterpolationSegment this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_set_is_modulated_108_comment =
    "C++ Interface:\n"
    "setIsModulated(non-const ColorInterpolationSegment this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::set_is_modulated\n"
    "//      Access : public\n"
    "// Description : Sets how the function is applied to the final color.\n"
    "//               If true, the value is multiplied. If false, the value\n"
    "//               is simply added. Default is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_set_is_modulated_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationSegment::set_enabled(bool const enabled)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationSegment_set_enabled_109(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ColorInterpolationSegment::set_enabled(bool const enabled)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"enabled", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEnabled", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setEnabled", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_enabled((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationSegment.setEnabled() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEnabled(non-const ColorInterpolationSegment this, bool enabled)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationSegment_set_enabled_109_comment =
    "C++ Interface:\n"
    "setEnabled(non-const ColorInterpolationSegment this, bool enabled)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationSegment::set_enabled()\n"
    "//      Access : public\n"
    "// Description : Sets whether the segments effects should be applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationSegment_set_enabled_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Rejected Remap [ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationFunction *function, float const &time_begin, float const &time_end, bool const is_modulated, int const id)]
 * ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationSegment const &s)
 *******************************************************************/
int  Dtool_Init_ColorInterpolationSegment(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-ColorInterpolationSegment::ColorInterpolationSegment(ColorInterpolationSegment const &s)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"s", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ColorInterpolationSegment", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ColorInterpolationSegment", &param0));
            if(!PyErr_Occurred())
            {
                ColorInterpolationSegment *param0_this = (ColorInterpolationSegment *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ColorInterpolationSegment, 0, "ColorInterpolationSegment.ColorInterpolationSegment", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ColorInterpolationSegment *return_value = new ColorInterpolationSegment(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ColorInterpolationSegment,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ColorInterpolationSegment(const ColorInterpolationSegment s)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ColorInterpolationSegment(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationSegment)
    {
        printf("ColorInterpolationSegment ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationSegment * local_this = (ColorInterpolationSegment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationSegment)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationSegment(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationSegment)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationSegment*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ColorInterpolationManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color, bool const is_modulated)
 * int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color, bool const is_modulated = (1))
 * int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_constant(float const time_begin, float const time_end = (1), LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_constant(float const time_begin = (0), float const time_end = (1), LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_add_constant_112(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_constant(float const time_begin = (0), float const time_end = (1), LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":addConstant", key_word_list));
            else
                (PyArg_Parse(args, ":addConstant"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_constant();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addConstant() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_constant(float const time_begin, float const time_end = (1), LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
            double param1;
            static char * key_word_list[] = {(char *)"time_begin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:addConstant", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:addConstant", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_constant((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addConstant() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color = ((Colorf(1, 1, 1, 1))), bool const is_modulated = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addConstant", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->add_constant((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addConstant() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color, bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:addConstant", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addConstant", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        int return_value = (local_this)->add_constant((float)param1, (float)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addConstant() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_constant(float const time_begin, float const time_end, LVecBase4f const color, bool const is_modulated)
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color", (char *)"is_modulated", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOO:addConstant", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addConstant", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        int return_value = (local_this)->add_constant((float)param1, (float)param2, *param3_this, (PyObject_IsTrue(param4)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addConstant() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addConstant() takes 1, 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addConstant(non-const ColorInterpolationManager this)\n"
          "addConstant(non-const ColorInterpolationManager this, float time_begin)\n"
          "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
          "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color)\n"
          "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color, bool is_modulated)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_add_constant_112_comment =
    "C++ Interface:\n"
    "addConstant(non-const ColorInterpolationManager this)\n"
    "addConstant(non-const ColorInterpolationManager this, float time_begin)\n"
    "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
    "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color)\n"
    "addConstant(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color, bool is_modulated)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::add_constant\n"
    "//      Access : public\n"
    "// Description : Adds a constant segment of the specified color to the\n"
    "//               manager and returns the segment's id as known\n"
    "//               by the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_add_constant_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, bool const is_modulated)
 * int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, bool const is_modulated = (1))
 * int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_linear(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_linear(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_add_linear_113(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_linear(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":addLinear", key_word_list));
            else
                (PyArg_Parse(args, ":addLinear"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_linear();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addLinear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_linear(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
            double param1;
            static char * key_word_list[] = {(char *)"time_begin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:addLinear", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:addLinear", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_linear((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addLinear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addLinear", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->add_linear((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addLinear() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:addLinear", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addLinear", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        int return_value = (local_this)->add_linear((float)param1, (float)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addLinear() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOO:addLinear", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addLinear", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addLinear", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_linear((float)param1, (float)param2, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addLinear() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_linear(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, bool const is_modulated)
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"is_modulated", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOO:addLinear", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addLinear", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addLinear", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_linear((float)param1, (float)param2, *param3_this, *param4_this, (PyObject_IsTrue(param5)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addLinear() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addLinear() takes 1, 2, 3, 4, 5, or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addLinear(non-const ColorInterpolationManager this)\n"
          "addLinear(non-const ColorInterpolationManager this, float time_begin)\n"
          "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
          "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
          "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
          "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, bool is_modulated)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_add_linear_113_comment =
    "C++ Interface:\n"
    "addLinear(non-const ColorInterpolationManager this)\n"
    "addLinear(non-const ColorInterpolationManager this, float time_begin)\n"
    "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
    "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
    "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
    "addLinear(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, bool is_modulated)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::add_linear\n"
    "//      Access : public\n"
    "// Description : Adds a linear segment between two colors to the manager \n"
    "//               and returns the segment's id as known by the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_add_linear_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b, bool const is_modulated)
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b, bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b = (0.5), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_stepwave(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_add_stepwave_114(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_stepwave(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":addStepwave", key_word_list));
            else
                (PyArg_Parse(args, ":addStepwave"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_stepwave();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
            double param1;
            static char * key_word_list[] = {(char *)"time_begin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:addStepwave", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:addStepwave", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_stepwave((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addStepwave", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->add_stepwave((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:addStepwave", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        int return_value = (local_this)->add_stepwave((float)param1, (float)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a = (0.5), float const width_b = (0.5), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOO:addStepwave", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_stepwave((float)param1, (float)param2, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b = (0.5), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                double param5;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"width_a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOd:addStepwave", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_stepwave((float)param1, (float)param2, *param3_this, *param4_this, (float)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b, bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                double param5;
                double param6;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"width_a", (char *)"width_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOdd:addStepwave", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_stepwave((float)param1, (float)param2, *param3_this, *param4_this, (float)param5, (float)param6);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_stepwave(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const width_a, float const width_b, bool const is_modulated)
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                double param5;
                double param6;
                PyObject *param7;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"width_a", (char *)"width_b", (char *)"is_modulated", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOddO:addStepwave", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addStepwave", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_stepwave((float)param1, (float)param2, *param3_this, *param4_this, (float)param5, (float)param6, (PyObject_IsTrue(param7)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addStepwave() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addStepwave() takes 1, 2, 3, 4, 5, 6, 7, or 8 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addStepwave(non-const ColorInterpolationManager this)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a, float width_b)\n"
          "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a, float width_b, bool is_modulated)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_add_stepwave_114_comment =
    "C++ Interface:\n"
    "addStepwave(non-const ColorInterpolationManager this)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a, float width_b)\n"
    "addStepwave(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float width_a, float width_b, bool is_modulated)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::add_stepwave\n"
    "//      Access : public\n"
    "// Description : Adds a stepwave segment of two colors to the manager \n"
    "//               and returns the segment's id as known by the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_add_stepwave_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period, bool const is_modulated)
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period, bool const is_modulated = (1))
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period = (1), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
 * int ColorInterpolationManager::add_sinusoid(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_add_sinusoid_115(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin = (0), float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":addSinusoid", key_word_list));
            else
                (PyArg_Parse(args, ":addSinusoid"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_sinusoid();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end = (1), LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
            double param1;
            static char * key_word_list[] = {(char *)"time_begin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:addSinusoid", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:addSinusoid", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->add_sinusoid((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a = ((Colorf(1, 0, 0, 1))), LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addSinusoid", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->add_sinusoid((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b = ((Colorf(0, 1, 0, 1))), float const period = (1), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:addSinusoid", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        int return_value = (local_this)->add_sinusoid((float)param1, (float)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period = (1), bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOO:addSinusoid", key_word_list, &param1, &param2, &param3, &param4))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_sinusoid((float)param1, (float)param2, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period, bool const is_modulated = (1))
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                double param5;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"period", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOd:addSinusoid", key_word_list, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_sinusoid((float)param1, (float)param2, *param3_this, *param4_this, (float)param5);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int ColorInterpolationManager::add_sinusoid(float const time_begin, float const time_end, LVecBase4f const color_a, LVecBase4f const color_b, float const period, bool const is_modulated)
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                double param5;
                PyObject *param6;
                static char * key_word_list[] = {(char *)"time_begin", (char *)"time_end", (char *)"color_a", (char *)"color_b", (char *)"period", (char *)"is_modulated", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddOOdO:addSinusoid", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ColorInterpolationManager.addSinusoid", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)|| (param4_this == NULL)))
                    {
                        int return_value = (local_this)->add_sinusoid((float)param1, (float)param2, *param3_this, *param4_this, (float)param5, (PyObject_IsTrue(param6)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ColorInterpolationManager.addSinusoid() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addSinusoid() takes 1, 2, 3, 4, 5, 6, or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addSinusoid(non-const ColorInterpolationManager this)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float period)\n"
          "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float period, bool is_modulated)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_add_sinusoid_115_comment =
    "C++ Interface:\n"
    "addSinusoid(non-const ColorInterpolationManager this)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float period)\n"
    "addSinusoid(non-const ColorInterpolationManager this, float time_begin, float time_end, const VBase4 color_a, const VBase4 color_b, float period, bool is_modulated)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::add_sinusoid\n"
    "//      Access : public\n"
    "// Description : Adds a stepwave segment of two colors and a specified\n"
    "//               period to the manager and returns the segment's \n"
    "//               id as known by the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_add_sinusoid_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ColorInterpolationManager::set_default_color(LVecBase4f const &c)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_set_default_color_116(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ColorInterpolationManager::set_default_color(LVecBase4f const &c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefaultColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDefaultColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "ColorInterpolationManager.setDefaultColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_default_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ColorInterpolationManager.setDefaultColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultColor(non-const ColorInterpolationManager this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_set_default_color_116_comment =
    "C++ Interface:\n"
    "setDefaultColor(non-const ColorInterpolationManager this, const VBase4 c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::set_default_color\n"
    "//      Access : public\n"
    "// Description : Sets the color to used if no segments are present\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_set_default_color_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ColorInterpolationSegment *ColorInterpolationManager::get_segment(int const seg_id)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_get_segment_117(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline ColorInterpolationSegment *ColorInterpolationManager::get_segment(int const seg_id)
        int param1;
        static char * key_word_list[] = {(char *)"seg_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSegment", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSegment", &param1));
        if(!PyErr_Occurred())
        {
            ColorInterpolationSegment *return_value = (local_this)->get_segment((int)param1);
            if (return_value != (ColorInterpolationSegment *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ColorInterpolationSegment,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationManager.getSegment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSegment(non-const ColorInterpolationManager this, int seg_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_get_segment_117_comment =
    "C++ Interface:\n"
    "getSegment(non-const ColorInterpolationManager this, int seg_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::get_segment\n"
    "//      Access : public\n"
    "// Description : Returns the segment that corresponds to 'seg_id'.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_get_segment_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ColorInterpolationManager::get_segment_id_list(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_get_segment_id_list_118(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > ColorInterpolationManager::get_segment_id_list(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSegmentIdList", key_word_list));
        else
            (PyArg_Parse(args, ":getSegmentIdList"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_segment_id_list();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationManager.getSegmentIdList() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSegmentIdList(non-const ColorInterpolationManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_get_segment_id_list_118_comment =
    "C++ Interface:\n"
    "getSegmentIdList(non-const ColorInterpolationManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::get_segment_id_list\n"
    "//      Access : public\n"
    "// Description : Returns a space delimited list of all of the ids\n"
    "//               in the manager at the time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_get_segment_id_list_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ColorInterpolationManager::clear_segment(int const seg_id)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_clear_segment_119(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ColorInterpolationManager::clear_segment(int const seg_id)
        int param1;
        static char * key_word_list[] = {(char *)"seg_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearSegment", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearSegment", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_segment((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationManager.clearSegment() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSegment(non-const ColorInterpolationManager this, int seg_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_clear_segment_119_comment =
    "C++ Interface:\n"
    "clearSegment(non-const ColorInterpolationManager this, int seg_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::clear_segment\n"
    "//      Access : public\n"
    "// Description : Removes the segment of 'id' from the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_clear_segment_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ColorInterpolationManager::clear_to_initial(void)
 *******************************************************************/
static PyObject *Dtool_ColorInterpolationManager_clear_to_initial_120(PyObject *self, PyObject *args,PyObject *kwds) {
    ColorInterpolationManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ColorInterpolationManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ColorInterpolationManager::clear_to_initial(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearToInitial", key_word_list));
        else
            (PyArg_Parse(args, ":clearToInitial"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_to_initial();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ColorInterpolationManager.clearToInitial() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearToInitial(non-const ColorInterpolationManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ColorInterpolationManager_clear_to_initial_120_comment =
    "C++ Interface:\n"
    "clearToInitial(non-const ColorInterpolationManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : ColorInterpolationManager::clear_to_initial\n"
    "//      Access : public\n"
    "// Description : Removes all segments from the manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ColorInterpolationManager_clear_to_initial_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ColorInterpolationManager::ColorInterpolationManager(void)
 * ColorInterpolationManager::ColorInterpolationManager(ColorInterpolationManager const &copy)
 * ColorInterpolationManager::ColorInterpolationManager(LVecBase4f const &c)
 *******************************************************************/
int  Dtool_Init_ColorInterpolationManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ColorInterpolationManager::ColorInterpolationManager(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ColorInterpolationManager", key_word_list))
            {
                ColorInterpolationManager *return_value = new ColorInterpolationManager();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ColorInterpolationManager,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 ColorInterpolationManager::ColorInterpolationManager(ColorInterpolationManager const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ColorInterpolationManager", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ColorInterpolationManager", &param0));
                if(!PyErr_Occurred())
                {
                    ColorInterpolationManager *param0_this = (ColorInterpolationManager *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ColorInterpolationManager, 0, "ColorInterpolationManager.ColorInterpolationManager", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ColorInterpolationManager *return_value = new ColorInterpolationManager(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ColorInterpolationManager,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ColorInterpolationManager::ColorInterpolationManager(LVecBase4f const &c)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"c", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ColorInterpolationManager", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ColorInterpolationManager", &param0));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "ColorInterpolationManager.ColorInterpolationManager", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ColorInterpolationManager *return_value = new ColorInterpolationManager(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ColorInterpolationManager,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ColorInterpolationManager() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ColorInterpolationManager()\n"
          "ColorInterpolationManager(const ColorInterpolationManager copy)\n"
          "ColorInterpolationManager(const VBase4 c)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ColorInterpolationManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ColorInterpolationManager)
    {
        printf("ColorInterpolationManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ColorInterpolationManager * local_this = (ColorInterpolationManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ColorInterpolationManager)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ColorInterpolationManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ColorInterpolationManager)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ColorInterpolationManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DiscEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_radius_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const DiscEmitter this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_radius_123_comment =
    "C++ Interface:\n"
    "setRadius(non-const DiscEmitter this, float r)\n"
    "\n"
    "// Filename: discEmitter.I\n"
    "// Created by:  charles (22Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius\n"
    "//      Access : Public\n"
    "// Description : radius assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_radius_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_outer_angle(float o_angle)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_outer_angle_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_outer_angle(float o_angle)
        double param1;
        static char * key_word_list[] = {(char *)"o_angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setOuterAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setOuterAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_outer_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setOuterAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOuterAngle(non-const DiscEmitter this, float o_angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_outer_angle_124_comment =
    "C++ Interface:\n"
    "setOuterAngle(non-const DiscEmitter this, float o_angle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_outer_angle\n"
    "//      Access : Public\n"
    "// Description : aoe assignement\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_outer_angle_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_inner_angle(float i_angle)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_inner_angle_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_inner_angle(float i_angle)
        double param1;
        static char * key_word_list[] = {(char *)"i_angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInnerAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInnerAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_inner_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setInnerAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInnerAngle(non-const DiscEmitter this, float i_angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_inner_angle_125_comment =
    "C++ Interface:\n"
    "setInnerAngle(non-const DiscEmitter this, float i_angle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_inner_angle\n"
    "//      Access : Public\n"
    "// Description : aoe assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_inner_angle_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_outer_magnitude(float o_mag)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_outer_magnitude_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_outer_magnitude(float o_mag)
        double param1;
        static char * key_word_list[] = {(char *)"o_mag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setOuterMagnitude", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setOuterMagnitude", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_outer_magnitude((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setOuterMagnitude() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOuterMagnitude(non-const DiscEmitter this, float o_mag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_outer_magnitude_126_comment =
    "C++ Interface:\n"
    "setOuterMagnitude(non-const DiscEmitter this, float o_mag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_outer_magnitude\n"
    "//      Access : public\n"
    "// Description : mag assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_outer_magnitude_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_inner_magnitude(float i_mag)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_inner_magnitude_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_inner_magnitude(float i_mag)
        double param1;
        static char * key_word_list[] = {(char *)"i_mag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInnerMagnitude", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInnerMagnitude", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_inner_magnitude((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setInnerMagnitude() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInnerMagnitude(non-const DiscEmitter this, float i_mag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_inner_magnitude_127_comment =
    "C++ Interface:\n"
    "setInnerMagnitude(non-const DiscEmitter this, float i_mag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_inner_magnitude\n"
    "//      Access : public\n"
    "// Description : mag assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_inner_magnitude_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DiscEmitter::set_cubic_lerping(bool clerp)
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_set_cubic_lerping_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DiscEmitter::set_cubic_lerping(bool clerp)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"clerp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCubicLerping", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setCubicLerping", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cubic_lerping((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DiscEmitter.setCubicLerping() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCubicLerping(non-const DiscEmitter this, bool clerp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_set_cubic_lerping_128_comment =
    "C++ Interface:\n"
    "setCubicLerping(non-const DiscEmitter this, bool clerp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_cubic_lerping\n"
    "//      Access : public\n"
    "// Description : clerp flag\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_set_cubic_lerping_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DiscEmitter::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_radius_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DiscEmitter::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DiscEmitter*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_radius_129_comment =
    "C++ Interface:\n"
    "getRadius(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius\n"
    "//      Access : Public\n"
    "// Description : radius accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_radius_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DiscEmitter::get_outer_angle(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_outer_angle_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DiscEmitter::get_outer_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOuterAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getOuterAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DiscEmitter*)local_this)->get_outer_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOuterAngle(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_outer_angle_130_comment =
    "C++ Interface:\n"
    "getOuterAngle(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_outer_angle\n"
    "//      Access : Public\n"
    "// Description : aoe accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_outer_angle_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DiscEmitter::get_inner_angle(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_inner_angle_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DiscEmitter::get_inner_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInnerAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getInnerAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DiscEmitter*)local_this)->get_inner_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInnerAngle(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_inner_angle_131_comment =
    "C++ Interface:\n"
    "getInnerAngle(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_inner_angle\n"
    "//      Access : Public\n"
    "// Description : aoe accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_inner_angle_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DiscEmitter::get_outer_magnitude(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_outer_magnitude_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DiscEmitter::get_outer_magnitude(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOuterMagnitude", key_word_list));
        else
            (PyArg_Parse(args, ":getOuterMagnitude"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DiscEmitter*)local_this)->get_outer_magnitude();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOuterMagnitude(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_outer_magnitude_132_comment =
    "C++ Interface:\n"
    "getOuterMagnitude(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_outer_magnitude\n"
    "//      Access : public\n"
    "// Description : mag accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_outer_magnitude_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DiscEmitter::get_inner_magnitude(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_inner_magnitude_133(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DiscEmitter::get_inner_magnitude(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInnerMagnitude", key_word_list));
        else
            (PyArg_Parse(args, ":getInnerMagnitude"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DiscEmitter*)local_this)->get_inner_magnitude();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInnerMagnitude(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_inner_magnitude_133_comment =
    "C++ Interface:\n"
    "getInnerMagnitude(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_inner_magnitude\n"
    "//      Access : public\n"
    "// Description : mag accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_inner_magnitude_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DiscEmitter::get_cubic_lerping(void) const
 *******************************************************************/
static PyObject *Dtool_DiscEmitter_get_cubic_lerping_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DiscEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DiscEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DiscEmitter::get_cubic_lerping(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCubicLerping", key_word_list));
        else
            (PyArg_Parse(args, ":getCubicLerping"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DiscEmitter*)local_this)->get_cubic_lerping();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCubicLerping(const DiscEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DiscEmitter_get_cubic_lerping_134_comment =
    "C++ Interface:\n"
    "getCubicLerping(const DiscEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_cubic_lerping\n"
    "//      Access : public\n"
    "// Description : clerp flag accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DiscEmitter_get_cubic_lerping_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DiscEmitter::DiscEmitter(void)
 * DiscEmitter::DiscEmitter(DiscEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_DiscEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DiscEmitter::DiscEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DiscEmitter", key_word_list))
            {
                DiscEmitter *return_value = new DiscEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DiscEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DiscEmitter::DiscEmitter(DiscEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DiscEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DiscEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    DiscEmitter *param0_this = (DiscEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DiscEmitter, 0, "DiscEmitter.DiscEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DiscEmitter *return_value = new DiscEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DiscEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DiscEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DiscEmitter()\n"
          "DiscEmitter(const DiscEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DiscEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DiscEmitter)
    {
        printf("DiscEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DiscEmitter * local_this = (DiscEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DiscEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DiscEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DiscEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (DiscEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DiscEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GeomParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_geom_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_geom_node_137(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void GeomParticleRenderer::set_geom_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGeomNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setGeomNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "GeomParticleRenderer.setGeomNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_geom_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeomParticleRenderer.setGeomNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGeomNode(non-const GeomParticleRenderer this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_geom_node_137_comment =
    "C++ Interface:\n"
    "setGeomNode(non-const GeomParticleRenderer this, non-const PandaNode node)\n"
    "\n"
    "// Filename: geomParticleRenderer.I\n"
    "// Created by:  charles (05Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : set_geom_node\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// we're forcing a pool resize to remove every node in the vector.\n"
    "// this is because nodes are reference-counted, and we have to\n"
    "// explicitly remove them from the node they were previously parented\n"
    "// to.\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_geom_node_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *GeomParticleRenderer::get_geom_node(void)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_geom_node_138(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PandaNode *GeomParticleRenderer::get_geom_node(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGeomNode", key_word_list));
        else
            (PyArg_Parse(args, ":getGeomNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = (local_this)->get_geom_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.getGeomNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeomNode(non-const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_geom_node_138_comment =
    "C++ Interface:\n"
    "getGeomNode(non-const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_geom_node\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_geom_node_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ColorInterpolationManager *GeomParticleRenderer::get_color_interpolation_manager(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_color_interpolation_manager_139(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ColorInterpolationManager *GeomParticleRenderer::get_color_interpolation_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorInterpolationManager", key_word_list));
        else
            (PyArg_Parse(args, ":getColorInterpolationManager"));
        if(!PyErr_Occurred())
        {
            ColorInterpolationManager *return_value = ((const GeomParticleRenderer*)local_this)->get_color_interpolation_manager();
            if (return_value != (ColorInterpolationManager *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ColorInterpolationManager,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorInterpolationManager(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment =
    "C++ Interface:\n"
    "getColorInterpolationManager(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_color_interpolation_manager\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_x_scale_flag_140(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_x_ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setXScaleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setXScaleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_x_scale_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setXScaleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setXScaleFlag(non-const GeomParticleRenderer this, bool animate_x_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment =
    "C++ Interface:\n"
    "setXScaleFlag(non-const GeomParticleRenderer this, bool animate_x_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_x_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_y_scale_flag_141(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_y_ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setYScaleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setYScaleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_y_scale_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setYScaleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setYScaleFlag(non-const GeomParticleRenderer this, bool animate_y_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment =
    "C++ Interface:\n"
    "setYScaleFlag(non-const GeomParticleRenderer this, bool animate_y_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_y_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_z_scale_flag(bool animate_z_ratio)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_z_scale_flag_142(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_z_scale_flag(bool animate_z_ratio)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_z_ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setZScaleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setZScaleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_z_scale_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setZScaleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZScaleFlag(non-const GeomParticleRenderer this, bool animate_z_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment =
    "C++ Interface:\n"
    "setZScaleFlag(non-const GeomParticleRenderer this, bool animate_z_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_z_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_initial_x_scale(float initial_x_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_initial_x_scale_143(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_initial_x_scale(float initial_x_scale)
        double param1;
        static char * key_word_list[] = {(char *)"initial_x_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialXScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialXScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_x_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setInitialXScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialXScale(non-const GeomParticleRenderer this, float initial_x_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment =
    "C++ Interface:\n"
    "setInitialXScale(non-const GeomParticleRenderer this, float initial_x_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_initial_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_final_x_scale(float final_x_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_final_x_scale_144(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_final_x_scale(float final_x_scale)
        double param1;
        static char * key_word_list[] = {(char *)"final_x_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalXScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalXScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_x_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setFinalXScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalXScale(non-const GeomParticleRenderer this, float final_x_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_final_x_scale_144_comment =
    "C++ Interface:\n"
    "setFinalXScale(non-const GeomParticleRenderer this, float final_x_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_final_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_final_x_scale_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_initial_y_scale(float initial_y_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_initial_y_scale_145(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_initial_y_scale(float initial_y_scale)
        double param1;
        static char * key_word_list[] = {(char *)"initial_y_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialYScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialYScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_y_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setInitialYScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialYScale(non-const GeomParticleRenderer this, float initial_y_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment =
    "C++ Interface:\n"
    "setInitialYScale(non-const GeomParticleRenderer this, float initial_y_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_initial_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_final_y_scale(float final_y_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_final_y_scale_146(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_final_y_scale(float final_y_scale)
        double param1;
        static char * key_word_list[] = {(char *)"final_y_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalYScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalYScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_y_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setFinalYScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalYScale(non-const GeomParticleRenderer this, float final_y_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_final_y_scale_146_comment =
    "C++ Interface:\n"
    "setFinalYScale(non-const GeomParticleRenderer this, float final_y_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_final_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_final_y_scale_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_initial_z_scale(float initial_z_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_initial_z_scale_147(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_initial_z_scale(float initial_z_scale)
        double param1;
        static char * key_word_list[] = {(char *)"initial_z_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialZScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialZScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_z_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setInitialZScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialZScale(non-const GeomParticleRenderer this, float initial_z_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment =
    "C++ Interface:\n"
    "setInitialZScale(non-const GeomParticleRenderer this, float initial_z_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_initial_z_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GeomParticleRenderer::set_final_z_scale(float final_z_scale)
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_set_final_z_scale_148(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void GeomParticleRenderer::set_final_z_scale(float final_z_scale)
        double param1;
        static char * key_word_list[] = {(char *)"final_z_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalZScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalZScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_z_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GeomParticleRenderer.setFinalZScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalZScale(non-const GeomParticleRenderer this, float final_z_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_set_final_z_scale_148_comment =
    "C++ Interface:\n"
    "setFinalZScale(non-const GeomParticleRenderer this, float final_z_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::set_final_z_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_set_final_z_scale_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeomParticleRenderer::get_x_scale_flag(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_x_scale_flag_149(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GeomParticleRenderer::get_x_scale_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXScaleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getXScaleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GeomParticleRenderer*)local_this)->get_x_scale_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXScaleFlag(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment =
    "C++ Interface:\n"
    "getXScaleFlag(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_x_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeomParticleRenderer::get_y_scale_flag(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_y_scale_flag_150(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GeomParticleRenderer::get_y_scale_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYScaleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getYScaleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GeomParticleRenderer*)local_this)->get_y_scale_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYScaleFlag(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment =
    "C++ Interface:\n"
    "getYScaleFlag(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_y_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeomParticleRenderer::get_z_scale_flag(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_z_scale_flag_151(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool GeomParticleRenderer::get_z_scale_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZScaleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getZScaleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GeomParticleRenderer*)local_this)->get_z_scale_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZScaleFlag(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment =
    "C++ Interface:\n"
    "getZScaleFlag(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_z_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_initial_x_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_initial_x_scale_152(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_initial_x_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialXScale", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialXScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_initial_x_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialXScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment =
    "C++ Interface:\n"
    "getInitialXScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_initial_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_final_x_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_final_x_scale_153(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_final_x_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalXScale", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalXScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_final_x_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalXScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_final_x_scale_153_comment =
    "C++ Interface:\n"
    "getFinalXScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_final_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_final_x_scale_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_initial_y_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_initial_y_scale_154(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_initial_y_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialYScale", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialYScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_initial_y_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialYScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment =
    "C++ Interface:\n"
    "getInitialYScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_initial_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_final_y_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_final_y_scale_155(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_final_y_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalYScale", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalYScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_final_y_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalYScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_final_y_scale_155_comment =
    "C++ Interface:\n"
    "getFinalYScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_final_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_final_y_scale_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_initial_z_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_initial_z_scale_156(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_initial_z_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialZScale", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialZScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_initial_z_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialZScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment =
    "C++ Interface:\n"
    "getInitialZScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_initial_z_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float GeomParticleRenderer::get_final_z_scale(void) const
 *******************************************************************/
static PyObject *Dtool_GeomParticleRenderer_get_final_z_scale_157(PyObject *self, PyObject *args,PyObject *kwds) {
    GeomParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeomParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float GeomParticleRenderer::get_final_z_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalZScale", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalZScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const GeomParticleRenderer*)local_this)->get_final_z_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalZScale(const GeomParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeomParticleRenderer_get_final_z_scale_157_comment =
    "C++ Interface:\n"
    "getFinalZScale(const GeomParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : GeomParticleRenderer::get_final_z_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeomParticleRenderer_get_final_z_scale_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
 * GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node = ((PandaNode *)((void *)(0))))
 * GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am = (PR_ALPHA_NONE), PandaNode *geom_node = ((PandaNode *)((void *)(0))))
 * GeomParticleRenderer::GeomParticleRenderer(GeomParticleRenderer const &copy)
 *******************************************************************/
int  Dtool_Init_GeomParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am = (PR_ALPHA_NONE), PandaNode *geom_node = ((PandaNode *)((void *)(0))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":GeomParticleRenderer", key_word_list))
            {
                GeomParticleRenderer *return_value = new GeomParticleRenderer();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_GeomParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 GeomParticleRenderer::GeomParticleRenderer(GeomParticleRenderer const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:GeomParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:GeomParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    GeomParticleRenderer *param0_this = (GeomParticleRenderer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GeomParticleRenderer, 0, "GeomParticleRenderer.GeomParticleRenderer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        GeomParticleRenderer *return_value = new GeomParticleRenderer(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_GeomParticleRenderer,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node = ((PandaNode *)((void *)(0))))
                int param0;
                static char * key_word_list[] = {(char *)"am", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:GeomParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:GeomParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_GeomParticleRenderer,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-GeomParticleRenderer::GeomParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode am, PandaNode *geom_node)
                int param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"am", (char *)"geom_node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:GeomParticleRenderer", key_word_list, &param0, &param1))
                {
                    PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "GeomParticleRenderer.GeomParticleRenderer", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        GeomParticleRenderer *return_value = new GeomParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_GeomParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "GeomParticleRenderer() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "GeomParticleRenderer()\n"
          "GeomParticleRenderer(const GeomParticleRenderer copy)\n"
          "GeomParticleRenderer(int am)\n"
          "GeomParticleRenderer(int am, non-const PandaNode geom_node)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_GeomParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GeomParticleRenderer)
    {
        printf("GeomParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GeomParticleRenderer * local_this = (GeomParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GeomParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return ( BaseParticleRenderer *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleRenderer *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GeomParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GeomParticleRenderer)
        return from_this;
    if(from_type == &Dtool_BaseParticleRenderer)
    {
          BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
          return (GeomParticleRenderer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GeomParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LineEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LineEmitter::set_endpoint1(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_LineEmitter_set_endpoint1_160(PyObject *self, PyObject *args,PyObject *kwds) {
    LineEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineEmitter::set_endpoint1(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndpoint1", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndpoint1", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "LineEmitter.setEndpoint1", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_endpoint1(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineEmitter.setEndpoint1() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndpoint1(non-const LineEmitter this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineEmitter_set_endpoint1_160_comment =
    "C++ Interface:\n"
    "setEndpoint1(non-const LineEmitter this, const Point3 point)\n"
    "\n"
    "// Filename: lineEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_endpoint1\n"
    "//      Access : Public\n"
    "// Description : endpoint assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineEmitter_set_endpoint1_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LineEmitter::set_endpoint2(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_LineEmitter_set_endpoint2_161(PyObject *self, PyObject *args,PyObject *kwds) {
    LineEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineEmitter::set_endpoint2(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndpoint2", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndpoint2", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "LineEmitter.setEndpoint2", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_endpoint2(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineEmitter.setEndpoint2() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndpoint2(non-const LineEmitter this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineEmitter_set_endpoint2_161_comment =
    "C++ Interface:\n"
    "setEndpoint2(non-const LineEmitter this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_endpoint2\n"
    "//      Access : Public\n"
    "// Description : endpoint assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineEmitter_set_endpoint2_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f LineEmitter::get_endpoint1(void) const
 *******************************************************************/
static PyObject *Dtool_LineEmitter_get_endpoint1_162(PyObject *self, PyObject *args,PyObject *kwds) {
    LineEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f LineEmitter::get_endpoint1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndpoint1", key_word_list));
        else
            (PyArg_Parse(args, ":getEndpoint1"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const LineEmitter*)local_this)->get_endpoint1();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndpoint1(const LineEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineEmitter_get_endpoint1_162_comment =
    "C++ Interface:\n"
    "getEndpoint1(const LineEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_endpoint1\n"
    "//      Access : Public\n"
    "// Description : endpoint accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineEmitter_get_endpoint1_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f LineEmitter::get_endpoint2(void) const
 *******************************************************************/
static PyObject *Dtool_LineEmitter_get_endpoint2_163(PyObject *self, PyObject *args,PyObject *kwds) {
    LineEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f LineEmitter::get_endpoint2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndpoint2", key_word_list));
        else
            (PyArg_Parse(args, ":getEndpoint2"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const LineEmitter*)local_this)->get_endpoint2();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndpoint2(const LineEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineEmitter_get_endpoint2_163_comment =
    "C++ Interface:\n"
    "getEndpoint2(const LineEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_endpoint2\n"
    "//      Access : Public\n"
    "// Description : endpoint accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineEmitter_get_endpoint2_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LineEmitter::LineEmitter(void)
 * LineEmitter::LineEmitter(LineEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_LineEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LineEmitter::LineEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LineEmitter", key_word_list))
            {
                LineEmitter *return_value = new LineEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LineEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LineEmitter::LineEmitter(LineEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LineEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LineEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    LineEmitter *param0_this = (LineEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LineEmitter, 0, "LineEmitter.LineEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LineEmitter *return_value = new LineEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LineEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LineEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LineEmitter()\n"
          "LineEmitter(const LineEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LineEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LineEmitter)
    {
        printf("LineEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LineEmitter * local_this = (LineEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LineEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LineEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LineEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (LineEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LineEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LineParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LineParticleRenderer::set_head_color(LVecBase4f const &c)
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_set_head_color_166(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineParticleRenderer::set_head_color(LVecBase4f const &c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHeadColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHeadColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LineParticleRenderer.setHeadColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_head_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineParticleRenderer.setHeadColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeadColor(non-const LineParticleRenderer this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_set_head_color_166_comment =
    "C++ Interface:\n"
    "setHeadColor(non-const LineParticleRenderer this, const VBase4 c)\n"
    "\n"
    "// Filename: lineParticleRenderer.I\n"
    "// Created by:  darren (06Oct00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_head_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_set_head_color_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LineParticleRenderer::set_tail_color(LVecBase4f const &c)
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_set_tail_color_167(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LineParticleRenderer::set_tail_color(LVecBase4f const &c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTailColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTailColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LineParticleRenderer.setTailColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_tail_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LineParticleRenderer.setTailColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTailColor(non-const LineParticleRenderer this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_set_tail_color_167_comment =
    "C++ Interface:\n"
    "setTailColor(non-const LineParticleRenderer this, const VBase4 c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_tail_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_set_tail_color_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &LineParticleRenderer::get_head_color(void) const
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_get_head_color_168(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &LineParticleRenderer::get_head_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeadColor", key_word_list));
        else
            (PyArg_Parse(args, ":getHeadColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const LineParticleRenderer*)local_this)->get_head_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeadColor(const LineParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_get_head_color_168_comment =
    "C++ Interface:\n"
    "getHeadColor(const LineParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_head_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_get_head_color_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &LineParticleRenderer::get_tail_color(void) const
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_get_tail_color_169(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &LineParticleRenderer::get_tail_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTailColor", key_word_list));
        else
            (PyArg_Parse(args, ":getTailColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const LineParticleRenderer*)local_this)->get_tail_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTailColor(const LineParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_get_tail_color_169_comment =
    "C++ Interface:\n"
    "getTailColor(const LineParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_tail_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_get_tail_color_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LineParticleRenderer::set_line_scale_factor(float sf)
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_set_line_scale_factor_170(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LineParticleRenderer::set_line_scale_factor(float sf)
        double param1;
        static char * key_word_list[] = {(char *)"sf", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLineScaleFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLineScaleFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_line_scale_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LineParticleRenderer.setLineScaleFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLineScaleFactor(non-const LineParticleRenderer this, float sf)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_set_line_scale_factor_170_comment =
    "C++ Interface:\n"
    "setLineScaleFactor(non-const LineParticleRenderer this, float sf)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_line_scale_factor\n"
    "// Description : accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_set_line_scale_factor_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LineParticleRenderer::get_line_scale_factor(void) const
 *******************************************************************/
static PyObject *Dtool_LineParticleRenderer_get_line_scale_factor_171(PyObject *self, PyObject *args,PyObject *kwds) {
    LineParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LineParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LineParticleRenderer::get_line_scale_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLineScaleFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getLineScaleFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LineParticleRenderer*)local_this)->get_line_scale_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLineScaleFactor(const LineParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LineParticleRenderer_get_line_scale_factor_171_comment =
    "C++ Interface:\n"
    "getLineScaleFactor(const LineParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_line_scale_factor\n"
    "// Description : accessor\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LineParticleRenderer_get_line_scale_factor_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LineParticleRenderer::LineParticleRenderer(void)
 * LineParticleRenderer::LineParticleRenderer(LVecBase4f const &head, LVecBase4f const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
 * LineParticleRenderer::LineParticleRenderer(LineParticleRenderer const &copy)
 *******************************************************************/
int  Dtool_Init_LineParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LineParticleRenderer::LineParticleRenderer(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LineParticleRenderer", key_word_list))
            {
                LineParticleRenderer *return_value = new LineParticleRenderer();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LineParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LineParticleRenderer::LineParticleRenderer(LineParticleRenderer const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LineParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LineParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    LineParticleRenderer *param0_this = (LineParticleRenderer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LineParticleRenderer, 0, "LineParticleRenderer.LineParticleRenderer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LineParticleRenderer *return_value = new LineParticleRenderer(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LineParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LineParticleRenderer::LineParticleRenderer(LVecBase4f const &head, LVecBase4f const &tail, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"head", (char *)"tail", (char *)"alpha_mode", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:LineParticleRenderer", key_word_list, &param0, &param1, &param2))
                {
                    LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "LineParticleRenderer.LineParticleRenderer", 1, coerced_ptr, report_errors);
LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LineParticleRenderer.LineParticleRenderer", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        LineParticleRenderer *return_value = new LineParticleRenderer(*param0_this, *param1_this, (BaseParticleRenderer::ParticleRendererAlphaMode)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LineParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LineParticleRenderer() takes 0, 1, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LineParticleRenderer()\n"
          "LineParticleRenderer(const LineParticleRenderer copy)\n"
          "LineParticleRenderer(const VBase4 head, const VBase4 tail, int alpha_mode)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LineParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LineParticleRenderer)
    {
        printf("LineParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LineParticleRenderer * local_this = (LineParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LineParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return ( BaseParticleRenderer *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleRenderer *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LineParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LineParticleRenderer)
        return from_this;
    if(from_type == &Dtool_BaseParticleRenderer)
    {
          BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
          return (LineParticleRenderer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LineParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ParticleSystem 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_pool_size(int size)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_pool_size_175(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_pool_size(int size)
        int param1;
        static char * key_word_list[] = {(char *)"size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPoolSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPoolSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pool_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setPoolSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPoolSize(non-const ParticleSystem this, int size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_pool_size_175_comment =
    "C++ Interface:\n"
    "setPoolSize(non-const ParticleSystem this, int size)\n"
    "\n"
    "// access/queries\n"
    "\n"
    "////             ///////////////////////////////////////////////////////\n"
    "//// SET METHODS ///////////////////////////////////////////////////////\n"
    "////             ///////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_pool_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_pool_size_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_birth_rate(float new_br)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_birth_rate_176(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_birth_rate(float new_br)
        double param1;
        static char * key_word_list[] = {(char *)"new_br", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBirthRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBirthRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_birth_rate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setBirthRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBirthRate(non-const ParticleSystem this, float new_br)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_birth_rate_176_comment =
    "C++ Interface:\n"
    "setBirthRate(non-const ParticleSystem this, float new_br)\n"
    "\n"
    "// access/queries\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_birth_rate\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_birth_rate_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_soft_birth_rate(float new_br)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_soft_birth_rate_177(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_soft_birth_rate(float new_br)
        double param1;
        static char * key_word_list[] = {(char *)"new_br", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSoftBirthRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSoftBirthRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_soft_birth_rate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setSoftBirthRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSoftBirthRate(non-const ParticleSystem this, float new_br)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_soft_birth_rate_177_comment =
    "C++ Interface:\n"
    "setSoftBirthRate(non-const ParticleSystem this, float new_br)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_soft_birth_rate\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_soft_birth_rate_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_litter_size(int new_ls)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_litter_size_178(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_litter_size(int new_ls)
        int param1;
        static char * key_word_list[] = {(char *)"new_ls", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLitterSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLitterSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_litter_size((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setLitterSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLitterSize(non-const ParticleSystem this, int new_ls)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_litter_size_178_comment =
    "C++ Interface:\n"
    "setLitterSize(non-const ParticleSystem this, int new_ls)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_litter_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_litter_size_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_litter_spread(int new_ls)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_litter_spread_179(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_litter_spread(int new_ls)
        int param1;
        static char * key_word_list[] = {(char *)"new_ls", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLitterSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLitterSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_litter_spread((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setLitterSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLitterSpread(non-const ParticleSystem this, int new_ls)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_litter_spread_179_comment =
    "C++ Interface:\n"
    "setLitterSpread(non-const ParticleSystem this, int new_ls)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_litter_spread\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_litter_spread_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_local_velocity_flag(bool lv)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_local_velocity_flag_180(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_local_velocity_flag(bool lv)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"lv", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLocalVelocityFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setLocalVelocityFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_local_velocity_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setLocalVelocityFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLocalVelocityFlag(non-const ParticleSystem this, bool lv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_local_velocity_flag_180_comment =
    "C++ Interface:\n"
    "setLocalVelocityFlag(non-const ParticleSystem this, bool lv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_local_velocity_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_local_velocity_flag_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_system_grows_older_flag(bool sgo)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_system_grows_older_flag_181(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_system_grows_older_flag(bool sgo)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"sgo", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSystemGrowsOlderFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSystemGrowsOlderFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_system_grows_older_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setSystemGrowsOlderFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSystemGrowsOlderFlag(non-const ParticleSystem this, bool sgo)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_system_grows_older_flag_181_comment =
    "C++ Interface:\n"
    "setSystemGrowsOlderFlag(non-const ParticleSystem this, bool sgo)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_system_grows_older_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_system_grows_older_flag_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_system_lifespan(float sl)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_system_lifespan_182(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_system_lifespan(float sl)
        double param1;
        static char * key_word_list[] = {(char *)"sl", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSystemLifespan", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSystemLifespan", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_system_lifespan((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setSystemLifespan() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSystemLifespan(non-const ParticleSystem this, float sl)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_system_lifespan_182_comment =
    "C++ Interface:\n"
    "setSystemLifespan(non-const ParticleSystem this, float sl)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_system_lifespan\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_system_lifespan_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_system_age(float age)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_system_age_183(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_system_age(float age)
        double param1;
        static char * key_word_list[] = {(char *)"age", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSystemAge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSystemAge", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_system_age((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setSystemAge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSystemAge(non-const ParticleSystem this, float age)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_system_age_183_comment =
    "C++ Interface:\n"
    "setSystemAge(non-const ParticleSystem this, float age)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_system_age\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_system_age_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_active_system_flag(bool a)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_active_system_flag_184(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_active_system_flag(bool a)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"a", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActiveSystemFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActiveSystemFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active_system_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setActiveSystemFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActiveSystemFlag(non-const ParticleSystem this, bool a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_active_system_flag_184_comment =
    "C++ Interface:\n"
    "setActiveSystemFlag(non-const ParticleSystem this, bool a)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_active_state\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_active_system_flag_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_spawn_on_death_flag(bool sod)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_spawn_on_death_flag_185(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_spawn_on_death_flag(bool sod)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"sod", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpawnOnDeathFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSpawnOnDeathFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_spawn_on_death_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setSpawnOnDeathFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpawnOnDeathFlag(non-const ParticleSystem this, bool sod)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment =
    "C++ Interface:\n"
    "setSpawnOnDeathFlag(non-const ParticleSystem this, bool sod)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_spawn_on_death_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_spawn_render_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_spawn_render_node_186(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::set_spawn_render_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpawnRenderNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSpawnRenderNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "ParticleSystem.setSpawnRenderNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_spawn_render_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.setSpawnRenderNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpawnRenderNode(non-const ParticleSystem this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_spawn_render_node_186_comment =
    "C++ Interface:\n"
    "setSpawnRenderNode(non-const ParticleSystem this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_spawn_render_node\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_spawn_render_node_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_spawn_render_node_path(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_spawn_render_node_path_187(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::set_spawn_render_node_path(NodePath const &node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpawnRenderNodePath", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSpawnRenderNodePath", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ParticleSystem.setSpawnRenderNodePath", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_spawn_render_node_path(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.setSpawnRenderNodePath() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpawnRenderNodePath(non-const ParticleSystem this, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_spawn_render_node_path_187_comment =
    "C++ Interface:\n"
    "setSpawnRenderNodePath(non-const ParticleSystem this, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_spawn_render_node_path\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_spawn_render_node_path_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_template_system_flag(bool tsf)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_template_system_flag_188(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_template_system_flag(bool tsf)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"tsf", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTemplateSystemFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTemplateSystemFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_template_system_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setTemplateSystemFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTemplateSystemFlag(non-const ParticleSystem this, bool tsf)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_template_system_flag_188_comment =
    "C++ Interface:\n"
    "setTemplateSystemFlag(non-const ParticleSystem this, bool tsf)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_template_system_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_template_system_flag_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_render_parent(NodePath const &node)
 * inline void ParticleSystem::set_render_parent(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_render_parent_189(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void ParticleSystem::set_render_parent(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRenderParent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRenderParent", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "ParticleSystem.setRenderParent", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_render_parent(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void ParticleSystem::set_render_parent(NodePath const &node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRenderParent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRenderParent", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ParticleSystem.setRenderParent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_render_parent(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRenderParent(non-const ParticleSystem this, non-const PandaNode node)\n"
          "setRenderParent(non-const ParticleSystem this, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_render_parent_189_comment =
    "C++ Interface:\n"
    "setRenderParent(non-const ParticleSystem this, non-const PandaNode node)\n"
    "setRenderParent(non-const ParticleSystem this, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_render_parent\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_render_parent\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_render_parent_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_renderer(BaseParticleRenderer *r)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_renderer_190(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::set_renderer(BaseParticleRenderer *r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRenderer", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRenderer", &param1));
            if(!PyErr_Occurred())
            {
                BaseParticleRenderer *param1_this = (BaseParticleRenderer *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BaseParticleRenderer, 1, "ParticleSystem.setRenderer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_renderer(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.setRenderer() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRenderer(non-const ParticleSystem this, non-const BaseParticleRenderer r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_renderer_190_comment =
    "C++ Interface:\n"
    "setRenderer(non-const ParticleSystem this, non-const BaseParticleRenderer r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_renderer\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_renderer_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_emitter(BaseParticleEmitter *e)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_emitter_191(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::set_emitter(BaseParticleEmitter *e)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"e", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEmitter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEmitter", &param1));
            if(!PyErr_Occurred())
            {
                BaseParticleEmitter *param1_this = (BaseParticleEmitter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BaseParticleEmitter, 1, "ParticleSystem.setEmitter", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_emitter(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.setEmitter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEmitter(non-const ParticleSystem this, non-const BaseParticleEmitter e)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_emitter_191_comment =
    "C++ Interface:\n"
    "setEmitter(non-const ParticleSystem this, non-const BaseParticleEmitter e)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_emitter\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_emitter_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_factory(BaseParticleFactory *f)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_factory_192(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::set_factory(BaseParticleFactory *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFactory", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFactory", &param1));
            if(!PyErr_Occurred())
            {
                BaseParticleFactory *param1_this = (BaseParticleFactory *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BaseParticleFactory, 1, "ParticleSystem.setFactory", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_factory(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.setFactory() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFactory(non-const ParticleSystem this, non-const BaseParticleFactory f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_factory_192_comment =
    "C++ Interface:\n"
    "setFactory(non-const ParticleSystem this, non-const BaseParticleFactory f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_factory\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_factory_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::set_floor_z(float z)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_set_floor_z_193(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::set_floor_z(float z)
        double param1;
        static char * key_word_list[] = {(char *)"z", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFloorZ", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFloorZ", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_floor_z((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.setFloorZ() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFloorZ(non-const ParticleSystem this, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_set_floor_z_193_comment =
    "C++ Interface:\n"
    "setFloorZ(non-const ParticleSystem this, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_floor_z\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_set_floor_z_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::clear_floor_z(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_clear_floor_z_194(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::clear_floor_z(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearFloorZ", key_word_list));
        else
            (PyArg_Parse(args, ":clearFloorZ"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_floor_z();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.clearFloorZ() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearFloorZ(non-const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_clear_floor_z_194_comment =
    "C++ Interface:\n"
    "clearFloorZ(non-const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_floor_z\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_clear_floor_z_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParticleSystem::get_pool_size(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_pool_size_195(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParticleSystem::get_pool_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPoolSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPoolSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParticleSystem*)local_this)->get_pool_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoolSize(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_pool_size_195_comment =
    "C++ Interface:\n"
    "getPoolSize(const ParticleSystem this)\n"
    "\n"
    "////             /////////////////////////////////////////////////////\n"
    "//// GET METHODS /////////////////////////////////////////////////////\n"
    "////             /////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_pool_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_pool_size_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParticleSystem::get_birth_rate(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_birth_rate_196(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParticleSystem::get_birth_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBirthRate", key_word_list));
        else
            (PyArg_Parse(args, ":getBirthRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParticleSystem*)local_this)->get_birth_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBirthRate(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_birth_rate_196_comment =
    "C++ Interface:\n"
    "getBirthRate(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_birth_rate\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_birth_rate_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParticleSystem::get_soft_birth_rate(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_soft_birth_rate_197(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParticleSystem::get_soft_birth_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSoftBirthRate", key_word_list));
        else
            (PyArg_Parse(args, ":getSoftBirthRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParticleSystem*)local_this)->get_soft_birth_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSoftBirthRate(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_soft_birth_rate_197_comment =
    "C++ Interface:\n"
    "getSoftBirthRate(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_soft_birth_rate\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_soft_birth_rate_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParticleSystem::get_litter_size(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_litter_size_198(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParticleSystem::get_litter_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLitterSize", key_word_list));
        else
            (PyArg_Parse(args, ":getLitterSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParticleSystem*)local_this)->get_litter_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLitterSize(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_litter_size_198_comment =
    "C++ Interface:\n"
    "getLitterSize(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_litter_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_litter_size_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParticleSystem::get_litter_spread(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_litter_spread_199(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParticleSystem::get_litter_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLitterSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getLitterSpread"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParticleSystem*)local_this)->get_litter_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLitterSpread(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_litter_spread_199_comment =
    "C++ Interface:\n"
    "getLitterSpread(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_litter_spread\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_litter_spread_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParticleSystem::get_local_velocity_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_local_velocity_flag_200(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ParticleSystem::get_local_velocity_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalVelocityFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getLocalVelocityFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParticleSystem*)local_this)->get_local_velocity_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalVelocityFlag(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_local_velocity_flag_200_comment =
    "C++ Interface:\n"
    "getLocalVelocityFlag(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_local_velocity_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_local_velocity_flag_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParticleSystem::get_system_grows_older_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_system_grows_older_flag_201(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ParticleSystem::get_system_grows_older_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSystemGrowsOlderFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getSystemGrowsOlderFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParticleSystem*)local_this)->get_system_grows_older_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSystemGrowsOlderFlag(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_system_grows_older_flag_201_comment =
    "C++ Interface:\n"
    "getSystemGrowsOlderFlag(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_system_grows_older_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_system_grows_older_flag_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParticleSystem::get_system_lifespan(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_system_lifespan_202(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParticleSystem::get_system_lifespan(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSystemLifespan", key_word_list));
        else
            (PyArg_Parse(args, ":getSystemLifespan"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParticleSystem*)local_this)->get_system_lifespan();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSystemLifespan(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_system_lifespan_202_comment =
    "C++ Interface:\n"
    "getSystemLifespan(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_system_lifespan\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_system_lifespan_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParticleSystem::get_system_age(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_system_age_203(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParticleSystem::get_system_age(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSystemAge", key_word_list));
        else
            (PyArg_Parse(args, ":getSystemAge"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParticleSystem*)local_this)->get_system_age();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSystemAge(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_system_age_203_comment =
    "C++ Interface:\n"
    "getSystemAge(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_system_age\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_system_age_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParticleSystem::get_active_system_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_active_system_flag_204(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ParticleSystem::get_active_system_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActiveSystemFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getActiveSystemFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParticleSystem*)local_this)->get_active_system_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActiveSystemFlag(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_active_system_flag_204_comment =
    "C++ Interface:\n"
    "getActiveSystemFlag(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_active_state\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_active_system_flag_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParticleSystem::get_spawn_on_death_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_spawn_on_death_flag_205(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ParticleSystem::get_spawn_on_death_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpawnOnDeathFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getSpawnOnDeathFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParticleSystem*)local_this)->get_spawn_on_death_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpawnOnDeathFlag(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment =
    "C++ Interface:\n"
    "getSpawnOnDeathFlag(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_spawn_on_death_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *ParticleSystem::get_spawn_render_node(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_spawn_render_node_206(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *ParticleSystem::get_spawn_render_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpawnRenderNode", key_word_list));
        else
            (PyArg_Parse(args, ":getSpawnRenderNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const ParticleSystem*)local_this)->get_spawn_render_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpawnRenderNode(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_spawn_render_node_206_comment =
    "C++ Interface:\n"
    "getSpawnRenderNode(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_spawn_render_node\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_spawn_render_node_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath ParticleSystem::get_spawn_render_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_spawn_render_node_path_207(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath ParticleSystem::get_spawn_render_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpawnRenderNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getSpawnRenderNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const ParticleSystem*)local_this)->get_spawn_render_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpawnRenderNodePath(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_spawn_render_node_path_207_comment =
    "C++ Interface:\n"
    "getSpawnRenderNodePath(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_spawn_render_node_path\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_spawn_render_node_path_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ParticleSystem::get_i_was_spawned_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_i_was_spawned_flag_208(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ParticleSystem::get_i_was_spawned_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIWasSpawnedFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getIWasSpawnedFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ParticleSystem*)local_this)->get_i_was_spawned_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIWasSpawnedFlag(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment =
    "C++ Interface:\n"
    "getIWasSpawnedFlag(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_i_was_spawned_flag\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParticleSystem::get_living_particles(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_living_particles_209(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParticleSystem::get_living_particles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLivingParticles", key_word_list));
        else
            (PyArg_Parse(args, ":getLivingParticles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParticleSystem*)local_this)->get_living_particles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLivingParticles(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_living_particles_209_comment =
    "C++ Interface:\n"
    "getLivingParticles(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_living_particles\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_living_particles_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath ParticleSystem::get_render_parent(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_render_parent_210(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath ParticleSystem::get_render_parent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderParent", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderParent"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const ParticleSystem*)local_this)->get_render_parent();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderParent(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_render_parent_210_comment =
    "C++ Interface:\n"
    "getRenderParent(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_render_parent\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_render_parent_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleRenderer *ParticleSystem::get_renderer(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_renderer_211(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleRenderer *ParticleSystem::get_renderer(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRenderer", key_word_list));
        else
            (PyArg_Parse(args, ":getRenderer"));
        if(!PyErr_Occurred())
        {
            BaseParticleRenderer *return_value = ((const ParticleSystem*)local_this)->get_renderer();
            if (return_value != (BaseParticleRenderer *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BaseParticleRenderer,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRenderer(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_renderer_211_comment =
    "C++ Interface:\n"
    "getRenderer(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_renderer\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_renderer_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleEmitter *ParticleSystem::get_emitter(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_emitter_212(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleEmitter *ParticleSystem::get_emitter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEmitter", key_word_list));
        else
            (PyArg_Parse(args, ":getEmitter"));
        if(!PyErr_Occurred())
        {
            BaseParticleEmitter *return_value = ((const ParticleSystem*)local_this)->get_emitter();
            if (return_value != (BaseParticleEmitter *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BaseParticleEmitter,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEmitter(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_emitter_212_comment =
    "C++ Interface:\n"
    "getEmitter(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_emitter\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_emitter_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleFactory *ParticleSystem::get_factory(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_factory_213(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleFactory *ParticleSystem::get_factory(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFactory", key_word_list));
        else
            (PyArg_Parse(args, ":getFactory"));
        if(!PyErr_Occurred())
        {
            BaseParticleFactory *return_value = ((const ParticleSystem*)local_this)->get_factory();
            if (return_value != (BaseParticleFactory *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BaseParticleFactory,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFactory(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_factory_213_comment =
    "C++ Interface:\n"
    "getFactory(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_factory\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_factory_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ParticleSystem::get_floor_z(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_floor_z_214(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ParticleSystem::get_floor_z(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFloorZ", key_word_list));
        else
            (PyArg_Parse(args, ":getFloorZ"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ParticleSystem*)local_this)->get_floor_z();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFloorZ(const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_floor_z_214_comment =
    "C++ Interface:\n"
    "getFloorZ(const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_factory\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_floor_z_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::add_spawn_template(ParticleSystem *ps)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_add_spawn_template_215(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::add_spawn_template(ParticleSystem *ps)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ps", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addSpawnTemplate", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addSpawnTemplate", &param1));
            if(!PyErr_Occurred())
            {
                ParticleSystem *param1_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParticleSystem, 1, "ParticleSystem.addSpawnTemplate", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_spawn_template(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.addSpawnTemplate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSpawnTemplate(non-const ParticleSystem this, non-const ParticleSystem ps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_add_spawn_template_215_comment =
    "C++ Interface:\n"
    "addSpawnTemplate(non-const ParticleSystem this, non-const ParticleSystem ps)\n"
    "\n"
    "// particle template vector\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_spawn_template\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_add_spawn_template_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::clear_spawn_templates(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_clear_spawn_templates_216(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::clear_spawn_templates(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSpawnTemplates", key_word_list));
        else
            (PyArg_Parse(args, ":clearSpawnTemplates"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_spawn_templates();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.clearSpawnTemplates() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSpawnTemplates(non-const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_clear_spawn_templates_216_comment =
    "C++ Interface:\n"
    "clearSpawnTemplates(non-const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_spawn_templates\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_clear_spawn_templates_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::render(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_render_217(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::render(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":render", key_word_list));
        else
            (PyArg_Parse(args, ":render"));
        if(!PyErr_Occurred())
        {
            (local_this)->render();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.render() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "render(non-const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_render_217_comment =
    "C++ Interface:\n"
    "render(non-const ParticleSystem this)\n"
    "\n"
    "// methods\n"
    "\n"
    "// Filename: particleSystem.I\n"
    "// Created by:  charles (14Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : render\n"
    "//      Access : Public\n"
    "// Description : Populates an attached GeomNode structure with the\n"
    "//               particle geometry for rendering.  This is a\n"
    "//               wrapper for accessability.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_render_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::induce_labor(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_induce_labor_218(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::induce_labor(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":induceLabor", key_word_list));
        else
            (PyArg_Parse(args, ":induceLabor"));
        if(!PyErr_Occurred())
        {
            (local_this)->induce_labor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.induceLabor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "induceLabor(non-const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_induce_labor_218_comment =
    "C++ Interface:\n"
    "induceLabor(non-const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : induce_labor\n"
    "//      Access : Public\n"
    "// Description : Forces the birth of a particle litter this frame\n"
    "//               by resetting _tics_since_birth\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_induce_labor_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::clear_to_initial(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_clear_to_initial_219(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystem::clear_to_initial(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearToInitial", key_word_list));
        else
            (PyArg_Parse(args, ":clearToInitial"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_to_initial();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.clearToInitial() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearToInitial(non-const ParticleSystem this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_clear_to_initial_219_comment =
    "C++ Interface:\n"
    "clearToInitial(non-const ParticleSystem this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_to_initial\n"
    "//      Access : Public\n"
    "// Description : Resets the system to its start state by resizing to 0,\n"
    "//               then resizing back to current size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_clear_to_initial_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::soft_stop(float br)
 * inline void ParticleSystem::soft_stop(float br = (0))
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_soft_stop_220(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::soft_stop(float br = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":softStop", key_word_list));
            else
                (PyArg_Parse(args, ":softStop"));
            if(!PyErr_Occurred())
            {
                (local_this)->soft_stop();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.softStop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::soft_stop(float br)
            double param1;
            static char * key_word_list[] = {(char *)"br", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:softStop", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:softStop", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->soft_stop((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.softStop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "softStop() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "softStop(non-const ParticleSystem this)\n"
          "softStop(non-const ParticleSystem this, float br)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_soft_stop_220_comment =
    "C++ Interface:\n"
    "softStop(non-const ParticleSystem this)\n"
    "softStop(non-const ParticleSystem this, float br)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : soft_stop\n"
    "//      Access : Public\n"
    "// Description : Causes system to use birth rate set by \n"
    "//               set_soft_birth_rate()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_soft_stop_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystem::soft_start(float br)
 * inline void ParticleSystem::soft_start(float br = (0))
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_soft_start_221(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::soft_start(float br = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":softStart", key_word_list));
            else
                (PyArg_Parse(args, ":softStart"));
            if(!PyErr_Occurred())
            {
                (local_this)->soft_start();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.softStart() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystem::soft_start(float br)
            double param1;
            static char * key_word_list[] = {(char *)"br", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:softStart", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:softStart", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->soft_start((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystem.softStart() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "softStart() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "softStart(non-const ParticleSystem this)\n"
          "softStart(non-const ParticleSystem this, float br)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_soft_start_221_comment =
    "C++ Interface:\n"
    "softStart(non-const ParticleSystem this)\n"
    "softStart(non-const ParticleSystem this, float br)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : soft_start\n"
    "//      Access : Public\n"
    "// Description : Causes system to use birth rate set by set_birth_rate()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_soft_start_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParticleSystem::update(float dt)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_update_222(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ParticleSystem::update(float dt)
        double param1;
        static char * key_word_list[] = {(char *)"dt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:update", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:update", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->update((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystem.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const ParticleSystem this, float dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_update_222_comment =
    "C++ Interface:\n"
    "update(non-const ParticleSystem this, float dt)\n"
    "\n"
    "";
#else
static const char * Dtool_ParticleSystem_update_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent) const
 * virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_write_free_particle_fifo_223(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeFreeParticleFifo", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeFreeParticleFifo", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.writeFreeParticleFifo", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write_free_particle_fifo(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write_free_particle_fifo(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeFreeParticleFifo", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.writeFreeParticleFifo", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write_free_particle_fifo(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeFreeParticleFifo() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeFreeParticleFifo(const ParticleSystem this, non-const Ostream out)\n"
          "writeFreeParticleFifo(const ParticleSystem this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_write_free_particle_fifo_223_comment =
    "C++ Interface:\n"
    "writeFreeParticleFifo(const ParticleSystem this, non-const Ostream out)\n"
    "writeFreeParticleFifo(const ParticleSystem this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_free_particle_fifo\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_write_free_particle_fifo_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent) const
 * virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_write_spawn_templates_224(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeSpawnTemplates", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeSpawnTemplates", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.writeSpawnTemplates", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write_spawn_templates(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write_spawn_templates(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeSpawnTemplates", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.writeSpawnTemplates", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write_spawn_templates(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeSpawnTemplates() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeSpawnTemplates(const ParticleSystem this, non-const Ostream out)\n"
          "writeSpawnTemplates(const ParticleSystem this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_write_spawn_templates_224_comment =
    "C++ Interface:\n"
    "writeSpawnTemplates(const ParticleSystem this, non-const Ostream out)\n"
    "writeSpawnTemplates(const ParticleSystem this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_spawn_templates\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_write_spawn_templates_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystem::write(ostream &out, int indent) const
 * virtual void ParticleSystem::write(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_write_225(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystem::write(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystem.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystem*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const ParticleSystem this, non-const Ostream out)\n"
          "write(const ParticleSystem this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_write_225_comment =
    "C++ Interface:\n"
    "write(const ParticleSystem this, non-const Ostream out)\n"
    "write(const ParticleSystem this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystem_write_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ParticleSystem::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystem_get_class_type_226(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ParticleSystem::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ParticleSystem::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystem_get_class_type_226_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ParticleSystem_get_class_type_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParticleSystem::ParticleSystem(ParticleSystem const &copy)
 * ParticleSystem::ParticleSystem(int pool_size)
 * ParticleSystem::ParticleSystem(int pool_size = (0))
 *******************************************************************/
int  Dtool_Init_ParticleSystem(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ParticleSystem::ParticleSystem(int pool_size = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ParticleSystem", key_word_list))
            {
                ParticleSystem *return_value = new ParticleSystem();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ParticleSystem,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 ParticleSystem::ParticleSystem(ParticleSystem const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ParticleSystem", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ParticleSystem", &param0));
                if(!PyErr_Occurred())
                {
                    ParticleSystem *param0_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ParticleSystem, 0, "ParticleSystem.ParticleSystem", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ParticleSystem *return_value = new ParticleSystem(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ParticleSystem,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ParticleSystem::ParticleSystem(int pool_size)
                int param0;
                static char * key_word_list[] = {(char *)"pool_size", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:ParticleSystem", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:ParticleSystem", &param0));
                if(!PyErr_Occurred())
                {
                    ParticleSystem *return_value = new ParticleSystem((int)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ParticleSystem,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ParticleSystem() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ParticleSystem()\n"
          "ParticleSystem(const ParticleSystem copy)\n"
          "ParticleSystem(int pool_size)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ParticleSystem(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ParticleSystem)
    {
        printf("ParticleSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ParticleSystem * local_this = (ParticleSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ParticleSystem)
        return local_this;
    if(requested_type == &Dtool_Physical)
        return ( Physical *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( Physical *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( Physical *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( Physical *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ParticleSystem(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ParticleSystem)
        return from_this;
    if(from_type == &Dtool_Physical)
    {
          Physical* other_this = (Physical*)from_this;
          return (ParticleSystem*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ParticleSystem*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ParticleSystem*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ParticleSystem*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ParticleSystemManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystemManager::set_frame_stepping(int every_nth_frame)
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_set_frame_stepping_230(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystemManager::set_frame_stepping(int every_nth_frame)
        int param1;
        static char * key_word_list[] = {(char *)"every_nth_frame", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFrameStepping", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFrameStepping", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_stepping((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystemManager.setFrameStepping() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameStepping(non-const ParticleSystemManager this, int every_nth_frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_set_frame_stepping_230_comment =
    "C++ Interface:\n"
    "setFrameStepping(non-const ParticleSystemManager this, int every_nth_frame)\n"
    "\n"
    "// Filename: particleSystemManager.I\n"
    "// Created by:  charles (28Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_frame_stepping\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_set_frame_stepping_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ParticleSystemManager::get_frame_stepping(void) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_get_frame_stepping_231(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ParticleSystemManager::get_frame_stepping(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameStepping", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameStepping"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ParticleSystemManager*)local_this)->get_frame_stepping();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameStepping(const ParticleSystemManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_get_frame_stepping_231_comment =
    "C++ Interface:\n"
    "getFrameStepping(const ParticleSystemManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_frame_stepping\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_get_frame_stepping_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystemManager::attach_particlesystem(ParticleSystem *ps)
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_attach_particlesystem_232(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ParticleSystemManager::attach_particlesystem(ParticleSystem *ps)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ps", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachParticlesystem", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachParticlesystem", &param1));
            if(!PyErr_Occurred())
            {
                ParticleSystem *param1_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParticleSystem, 1, "ParticleSystemManager.attachParticlesystem", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_particlesystem(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystemManager.attachParticlesystem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachParticlesystem(non-const ParticleSystemManager this, non-const ParticleSystem ps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_attach_particlesystem_232_comment =
    "C++ Interface:\n"
    "attachParticlesystem(non-const ParticleSystemManager this, non-const ParticleSystem ps)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : attach_particlesystem\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_attach_particlesystem_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParticleSystemManager::remove_particlesystem(ParticleSystem *ps)
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_remove_particlesystem_233(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ParticleSystemManager::remove_particlesystem(ParticleSystem *ps)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ps", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeParticlesystem", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeParticlesystem", &param1));
            if(!PyErr_Occurred())
            {
                ParticleSystem *param1_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ParticleSystem, 1, "ParticleSystemManager.removeParticlesystem", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_particlesystem(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystemManager.removeParticlesystem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeParticlesystem(non-const ParticleSystemManager this, non-const ParticleSystem ps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_remove_particlesystem_233_comment =
    "C++ Interface:\n"
    "removeParticlesystem(non-const ParticleSystemManager this, non-const ParticleSystem ps)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : remove_particlesystem\n"
    "//      Access : public\n"
    "// Description : removes a ps from the maintenance list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_remove_particlesystem_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ParticleSystemManager::clear(void)
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_clear_234(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ParticleSystemManager::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ParticleSystemManager.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const ParticleSystemManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_clear_234_comment =
    "C++ Interface:\n"
    "clear(non-const ParticleSystemManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : clear\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_clear_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ParticleSystemManager::do_particles(float dt)
 * void ParticleSystemManager::do_particles(float dt, ParticleSystem *ps, bool do_render)
 * void ParticleSystemManager::do_particles(float dt, ParticleSystem *ps, bool do_render = (1))
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_do_particles_235(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ParticleSystemManager::do_particles(float dt)
            double param1;
            static char * key_word_list[] = {(char *)"dt", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:doParticles", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:doParticles", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->do_particles((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ParticleSystemManager.doParticles() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ParticleSystemManager::do_particles(float dt, ParticleSystem *ps, bool do_render = (1))
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"dt", (char *)"ps", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:doParticles", key_word_list, &param1, &param2))
                {
                    ParticleSystem *param2_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ParticleSystem, 2, "ParticleSystemManager.doParticles", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->do_particles((float)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParticleSystemManager.doParticles() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void ParticleSystemManager::do_particles(float dt, ParticleSystem *ps, bool do_render)
                double param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"dt", (char *)"ps", (char *)"do_render", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dOO:doParticles", key_word_list, &param1, &param2, &param3))
                {
                    ParticleSystem *param2_this = (ParticleSystem *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ParticleSystem, 2, "ParticleSystemManager.doParticles", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->do_particles((float)param1, param2_this, (PyObject_IsTrue(param3)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call ParticleSystemManager.doParticles() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "doParticles() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "doParticles(non-const ParticleSystemManager this, float dt)\n"
          "doParticles(non-const ParticleSystemManager this, float dt, non-const ParticleSystem ps)\n"
          "doParticles(non-const ParticleSystemManager this, float dt, non-const ParticleSystem ps, bool do_render)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_do_particles_235_comment =
    "C++ Interface:\n"
    "doParticles(non-const ParticleSystemManager this, float dt)\n"
    "doParticles(non-const ParticleSystemManager this, float dt, non-const ParticleSystem ps)\n"
    "doParticles(non-const ParticleSystemManager this, float dt, non-const ParticleSystem ps, bool do_render)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : do_particles\n"
    "//      Access : public\n"
    "// Description : does an update and render for each ps in the list.\n"
    "//               this is probably the one you want to use.  Rendering\n"
    "//               is the expensive operation, and particles REALLY\n"
    "//               should at least be updated every frame, so nth_frame\n"
    "//               stepping applies only to rendering.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : do_particles\n"
    "//      Access : public\n"
    "// Description : does an update and an optional render for a specific\n"
    "//               ps.  Since rendering is the expensive operation, multiple\n"
    "//               updates could be applied before calling the final render.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_do_particles_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystemManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_output_236(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void ParticleSystemManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystemManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ParticleSystemManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ParticleSystemManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_output_236_comment =
    "C++ Interface:\n"
    "output(const ParticleSystemManager this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_output_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent) const
 * virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_write_ps_list_237(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePsList", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writePsList", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystemManager.writePsList", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystemManager*)local_this)->write_ps_list(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystemManager::write_ps_list(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writePsList", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystemManager.writePsList", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystemManager*)local_this)->write_ps_list(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writePsList() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writePsList(const ParticleSystemManager this, non-const Ostream out)\n"
          "writePsList(const ParticleSystemManager this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_write_ps_list_237_comment =
    "C++ Interface:\n"
    "writePsList(const ParticleSystemManager this, non-const Ostream out)\n"
    "writePsList(const ParticleSystemManager this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_ps_list\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_write_ps_list_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ParticleSystemManager::write(ostream &out, int indent) const
 * virtual void ParticleSystemManager::write(ostream &out, int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ParticleSystemManager_write_238(PyObject *self, PyObject *args,PyObject *kwds) {
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystemManager::write(ostream &out, int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystemManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystemManager*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ParticleSystemManager::write(ostream &out, int indent) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ParticleSystemManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ParticleSystemManager*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const ParticleSystemManager this, non-const Ostream out)\n"
          "write(const ParticleSystemManager this, non-const Ostream out, int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ParticleSystemManager_write_238_comment =
    "C++ Interface:\n"
    "write(const ParticleSystemManager this, non-const Ostream out)\n"
    "write(const ParticleSystemManager this, non-const Ostream out, int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ParticleSystemManager_write_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
 * ParticleSystemManager::ParticleSystemManager(int every_nth_frame = (1))
 *******************************************************************/
int  Dtool_Init_ParticleSystemManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ParticleSystemManager::ParticleSystemManager(int every_nth_frame = (1))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ParticleSystemManager", key_word_list))
            {
                ParticleSystemManager *return_value = new ParticleSystemManager();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ParticleSystemManager,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-ParticleSystemManager::ParticleSystemManager(int every_nth_frame)
            int param0;
            static char * key_word_list[] = {(char *)"every_nth_frame", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:ParticleSystemManager", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:ParticleSystemManager", &param0));
            if(!PyErr_Occurred())
            {
                ParticleSystemManager *return_value = new ParticleSystemManager((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ParticleSystemManager,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ParticleSystemManager() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ParticleSystemManager()\n"
          "ParticleSystemManager(int every_nth_frame)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ParticleSystemManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ParticleSystemManager)
    {
        printf("ParticleSystemManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ParticleSystemManager * local_this = (ParticleSystemManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ParticleSystemManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ParticleSystemManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ParticleSystemManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PointEmitter::set_location(LPoint3f const &p)
 *******************************************************************/
static PyObject *Dtool_PointEmitter_set_location_241(PyObject *self, PyObject *args,PyObject *kwds) {
    PointEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointEmitter::set_location(LPoint3f const &p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLocation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLocation", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PointEmitter.setLocation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_location(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointEmitter.setLocation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLocation(non-const PointEmitter this, const Point3 p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointEmitter_set_location_241_comment =
    "C++ Interface:\n"
    "setLocation(non-const PointEmitter this, const Point3 p)\n"
    "\n"
    "// Filename: pointEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_point\n"
    "//      Access : public\n"
    "// Description : point setting\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointEmitter_set_location_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f PointEmitter::get_location(void) const
 *******************************************************************/
static PyObject *Dtool_PointEmitter_get_location_242(PyObject *self, PyObject *args,PyObject *kwds) {
    PointEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f PointEmitter::get_location(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocation", key_word_list));
        else
            (PyArg_Parse(args, ":getLocation"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const PointEmitter*)local_this)->get_location();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocation(const PointEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointEmitter_get_location_242_comment =
    "C++ Interface:\n"
    "getLocation(const PointEmitter this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointEmitter_get_location_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointEmitter::PointEmitter(void)
 * PointEmitter::PointEmitter(PointEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_PointEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PointEmitter::PointEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointEmitter", key_word_list))
            {
                PointEmitter *return_value = new PointEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointEmitter::PointEmitter(PointEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    PointEmitter *param0_this = (PointEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointEmitter, 0, "PointEmitter.PointEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointEmitter *return_value = new PointEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointEmitter()\n"
          "PointEmitter(const PointEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointEmitter)
    {
        printf("PointEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointEmitter * local_this = (PointEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (PointEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PointEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointParticleFactory 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointParticleFactory::PointParticleFactory(void)
 * PointParticleFactory::PointParticleFactory(PointParticleFactory const &copy)
 *******************************************************************/
int  Dtool_Init_PointParticleFactory(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PointParticleFactory::PointParticleFactory(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointParticleFactory", key_word_list))
            {
                PointParticleFactory *return_value = new PointParticleFactory();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleFactory,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointParticleFactory::PointParticleFactory(PointParticleFactory const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointParticleFactory", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointParticleFactory", &param0));
                if(!PyErr_Occurred())
                {
                    PointParticleFactory *param0_this = (PointParticleFactory *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointParticleFactory, 0, "PointParticleFactory.PointParticleFactory", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointParticleFactory *return_value = new PointParticleFactory(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleFactory,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointParticleFactory() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointParticleFactory()\n"
          "PointParticleFactory(const PointParticleFactory copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointParticleFactory)
    {
        printf("PointParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointParticleFactory * local_this = (PointParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointParticleFactory)
        return local_this;
    if(requested_type == &Dtool_BaseParticleFactory)
        return ( BaseParticleFactory *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleFactory *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointParticleFactory(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointParticleFactory)
        return from_this;
    if(from_type == &Dtool_BaseParticleFactory)
    {
          BaseParticleFactory* other_this = (BaseParticleFactory*)from_this;
          return (PointParticleFactory*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PointParticleFactory*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PointParticleRenderer::set_point_size(float point_size)
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_set_point_size_248(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PointParticleRenderer::set_point_size(float point_size)
        double param1;
        static char * key_word_list[] = {(char *)"point_size", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPointSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPointSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_point_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointParticleRenderer.setPointSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPointSize(non-const PointParticleRenderer this, float point_size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_set_point_size_248_comment =
    "C++ Interface:\n"
    "setPointSize(non-const PointParticleRenderer this, float point_size)\n"
    "\n"
    "// Filename: pointParticleRenderer.I\n"
    "// Created by:  charles (20Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_point_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_set_point_size_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointParticleRenderer::set_start_color(LVecBase4f const &sc)
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_set_start_color_249(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointParticleRenderer::set_start_color(LVecBase4f const &sc)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"sc", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PointParticleRenderer.setStartColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointParticleRenderer.setStartColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartColor(non-const PointParticleRenderer this, const VBase4 sc)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_set_start_color_249_comment =
    "C++ Interface:\n"
    "setStartColor(non-const PointParticleRenderer this, const VBase4 sc)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_start_color\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_set_start_color_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointParticleRenderer::set_end_color(LVecBase4f const &ec)
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_set_end_color_250(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointParticleRenderer::set_end_color(LVecBase4f const &ec)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"ec", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PointParticleRenderer.setEndColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointParticleRenderer.setEndColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndColor(non-const PointParticleRenderer this, const VBase4 ec)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_set_end_color_250_comment =
    "C++ Interface:\n"
    "setEndColor(non-const PointParticleRenderer this, const VBase4 ec)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_end_color\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_set_end_color_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointParticleRenderer::set_blend_type(PointParticleRenderer::PointParticleBlendType bt)
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_set_blend_type_251(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PointParticleRenderer::set_blend_type(PointParticleRenderer::PointParticleBlendType bt)
        int param1;
        static char * key_word_list[] = {(char *)"bt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBlendType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBlendType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_blend_type((PointParticleRenderer::PointParticleBlendType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointParticleRenderer.setBlendType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlendType(non-const PointParticleRenderer this, int bt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_set_blend_type_251_comment =
    "C++ Interface:\n"
    "setBlendType(non-const PointParticleRenderer this, int bt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_blend_type\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_set_blend_type_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointParticleRenderer::set_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_set_blend_method_252(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PointParticleRenderer::set_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
        int param1;
        static char * key_word_list[] = {(char *)"bm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBlendMethod", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBlendMethod", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_blend_method((BaseParticleRenderer::ParticleRendererBlendMethod)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointParticleRenderer.setBlendMethod() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlendMethod(non-const PointParticleRenderer this, int bm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_set_blend_method_252_comment =
    "C++ Interface:\n"
    "setBlendMethod(non-const PointParticleRenderer this, int bm)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_blend_method\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_set_blend_method_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PointParticleRenderer::get_point_size(void) const
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_get_point_size_253(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PointParticleRenderer::get_point_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointSize", key_word_list));
        else
            (PyArg_Parse(args, ":getPointSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PointParticleRenderer*)local_this)->get_point_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointSize(const PointParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_get_point_size_253_comment =
    "C++ Interface:\n"
    "getPointSize(const PointParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_point_size\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_get_point_size_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PointParticleRenderer::get_start_color(void) const
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_get_start_color_254(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PointParticleRenderer::get_start_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartColor", key_word_list));
        else
            (PyArg_Parse(args, ":getStartColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PointParticleRenderer*)local_this)->get_start_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartColor(const PointParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_get_start_color_254_comment =
    "C++ Interface:\n"
    "getStartColor(const PointParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_start_color\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_get_start_color_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PointParticleRenderer::get_end_color(void) const
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_get_end_color_255(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PointParticleRenderer::get_end_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndColor", key_word_list));
        else
            (PyArg_Parse(args, ":getEndColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PointParticleRenderer*)local_this)->get_end_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndColor(const PointParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_get_end_color_255_comment =
    "C++ Interface:\n"
    "getEndColor(const PointParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_end_color\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_get_end_color_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointParticleRenderer::PointParticleBlendType PointParticleRenderer::get_blend_type(void) const
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_get_blend_type_256(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointParticleRenderer::PointParticleBlendType PointParticleRenderer::get_blend_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlendType", key_word_list));
        else
            (PyArg_Parse(args, ":getBlendType"));
        if(!PyErr_Occurred())
        {
            PointParticleRenderer::PointParticleBlendType return_value = ((const PointParticleRenderer*)local_this)->get_blend_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlendType(const PointParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_get_blend_type_256_comment =
    "C++ Interface:\n"
    "getBlendType(const PointParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_blend_type\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_get_blend_type_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleRenderer::ParticleRendererBlendMethod PointParticleRenderer::get_blend_method(void) const
 *******************************************************************/
static PyObject *Dtool_PointParticleRenderer_get_blend_method_257(PyObject *self, PyObject *args,PyObject *kwds) {
    PointParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleRenderer::ParticleRendererBlendMethod PointParticleRenderer::get_blend_method(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlendMethod", key_word_list));
        else
            (PyArg_Parse(args, ":getBlendMethod"));
        if(!PyErr_Occurred())
        {
            BaseParticleRenderer::ParticleRendererBlendMethod return_value = ((const PointParticleRenderer*)local_this)->get_blend_method();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlendMethod(const PointParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointParticleRenderer_get_blend_method_257_comment =
    "C++ Interface:\n"
    "getBlendMethod(const PointParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_blend_method\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointParticleRenderer_get_blend_method_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc, LVecBase4f const &ec)
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc, LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size = (1), PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad = (PR_ALPHA_NONE), float point_size = (1), PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
 * PointParticleRenderer::PointParticleRenderer(PointParticleRenderer const &copy)
 *******************************************************************/
int  Dtool_Init_PointParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad = (PR_ALPHA_NONE), float point_size = (1), PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointParticleRenderer", key_word_list))
            {
                PointParticleRenderer *return_value = new PointParticleRenderer();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 PointParticleRenderer::PointParticleRenderer(PointParticleRenderer const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    PointParticleRenderer *param0_this = (PointParticleRenderer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointParticleRenderer, 0, "PointParticleRenderer.PointParticleRenderer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointParticleRenderer *return_value = new PointParticleRenderer(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size = (1), PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
                int param0;
                static char * key_word_list[] = {(char *)"ad", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:PointParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:PointParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt = (PP_ONE_COLOR), BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
            int param0;
            double param1;
            static char * key_word_list[] = {(char *)"ad", (char *)"point_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "id:PointParticleRenderer", key_word_list, &param0, &param1))
            {
                PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (float)param1);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm = (PP_NO_BLEND), LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
            int param0;
            double param1;
            int param2;
            static char * key_word_list[] = {(char *)"ad", (char *)"point_size", (char *)"bt", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idi:PointParticleRenderer", key_word_list, &param0, &param1, &param2))
            {
                PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (float)param1, (PointParticleRenderer::PointParticleBlendType)param2);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc = ((Colorf(1, 1, 1, 1))), LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
            int param0;
            double param1;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"ad", (char *)"point_size", (char *)"bt", (char *)"bm", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idii:PointParticleRenderer", key_word_list, &param0, &param1, &param2, &param3))
            {
                PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (float)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc, LVecBase4f const &ec = ((Colorf(1, 1, 1, 1))))
                int param0;
                double param1;
                int param2;
                int param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"ad", (char *)"point_size", (char *)"bt", (char *)"bm", (char *)"sc", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "idiiO:PointParticleRenderer", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "PointParticleRenderer.PointParticleRenderer", 1, coerced_ptr, report_errors);

                    if (!((param4_this == NULL)))
                    {
                        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (float)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointParticleRenderer::PointParticleRenderer(BaseParticleRenderer::ParticleRendererAlphaMode ad, float point_size, PointParticleRenderer::PointParticleBlendType bt, BaseParticleRenderer::ParticleRendererBlendMethod bm, LVecBase4f const &sc, LVecBase4f const &ec)
                int param0;
                double param1;
                int param2;
                int param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"ad", (char *)"point_size", (char *)"bt", (char *)"bm", (char *)"sc", (char *)"ec", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "idiiOO:PointParticleRenderer", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "PointParticleRenderer.PointParticleRenderer", 1, coerced_ptr, report_errors);
LVecBase4f *param5_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase4f, 5, "PointParticleRenderer.PointParticleRenderer", 1, coerced_ptr, report_errors);

                    if (!((param4_this == NULL)|| (param5_this == NULL)))
                    {
                        PointParticleRenderer *return_value = new PointParticleRenderer((BaseParticleRenderer::ParticleRendererAlphaMode)param0, (float)param1, (PointParticleRenderer::PointParticleBlendType)param2, (BaseParticleRenderer::ParticleRendererBlendMethod)param3, *param4_this, *param5_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointParticleRenderer() takes 0, 1, 2, 3, 4, 5, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointParticleRenderer()\n"
          "PointParticleRenderer(const PointParticleRenderer copy)\n"
          "PointParticleRenderer(int ad)\n"
          "PointParticleRenderer(int ad, float point_size)\n"
          "PointParticleRenderer(int ad, float point_size, int bt)\n"
          "PointParticleRenderer(int ad, float point_size, int bt, int bm)\n"
          "PointParticleRenderer(int ad, float point_size, int bt, int bm, const VBase4 sc)\n"
          "PointParticleRenderer(int ad, float point_size, int bt, int bm, const VBase4 sc, const VBase4 ec)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointParticleRenderer)
    {
        printf("PointParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointParticleRenderer * local_this = (PointParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return ( BaseParticleRenderer *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleRenderer *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointParticleRenderer)
        return from_this;
    if(from_type == &Dtool_BaseParticleRenderer)
    {
          BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
          return (PointParticleRenderer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PointParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. RectangleEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RectangleEmitter::set_min_bound(LPoint2f const &vmin)
 *******************************************************************/
static PyObject *Dtool_RectangleEmitter_set_min_bound_260(PyObject *self, PyObject *args,PyObject *kwds) {
    RectangleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RectangleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RectangleEmitter::set_min_bound(LPoint2f const &vmin)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vmin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMinBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMinBound", &param1));
            if(!PyErr_Occurred())
            {
                LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "RectangleEmitter.setMinBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_min_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RectangleEmitter.setMinBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinBound(non-const RectangleEmitter this, const Point2 vmin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RectangleEmitter_set_min_bound_260_comment =
    "C++ Interface:\n"
    "setMinBound(non-const RectangleEmitter this, const Point2 vmin)\n"
    "\n"
    "// Filename: rectangleEmitter.I\n"
    "// Created by:  charles (26Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_min_bound\n"
    "//      Access : public\n"
    "// Description : boundary set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RectangleEmitter_set_min_bound_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RectangleEmitter::set_max_bound(LPoint2f const &vmax)
 *******************************************************************/
static PyObject *Dtool_RectangleEmitter_set_max_bound_261(PyObject *self, PyObject *args,PyObject *kwds) {
    RectangleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RectangleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void RectangleEmitter::set_max_bound(LPoint2f const &vmax)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vmax", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMaxBound", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMaxBound", &param1));
            if(!PyErr_Occurred())
            {
                LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "RectangleEmitter.setMaxBound", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_max_bound(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call RectangleEmitter.setMaxBound() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxBound(non-const RectangleEmitter this, const Point2 vmax)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RectangleEmitter_set_max_bound_261_comment =
    "C++ Interface:\n"
    "setMaxBound(non-const RectangleEmitter this, const Point2 vmax)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_max_bound\n"
    "//      Access : public\n"
    "// Description : boundary set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RectangleEmitter_set_max_bound_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f RectangleEmitter::get_min_bound(void) const
 *******************************************************************/
static PyObject *Dtool_RectangleEmitter_get_min_bound_262(PyObject *self, PyObject *args,PyObject *kwds) {
    RectangleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RectangleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f RectangleEmitter::get_min_bound(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinBound", key_word_list));
        else
            (PyArg_Parse(args, ":getMinBound"));
        if(!PyErr_Occurred())
        {
            LPoint2f result = ((const RectangleEmitter*)local_this)->get_min_bound();
            LPoint2f *return_value = new LPoint2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinBound(const RectangleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RectangleEmitter_get_min_bound_262_comment =
    "C++ Interface:\n"
    "getMinBound(const RectangleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_min_bound\n"
    "//      Access : public\n"
    "// Description : boundary get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RectangleEmitter_get_min_bound_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f RectangleEmitter::get_max_bound(void) const
 *******************************************************************/
static PyObject *Dtool_RectangleEmitter_get_max_bound_263(PyObject *self, PyObject *args,PyObject *kwds) {
    RectangleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_RectangleEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f RectangleEmitter::get_max_bound(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxBound", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxBound"));
        if(!PyErr_Occurred())
        {
            LPoint2f result = ((const RectangleEmitter*)local_this)->get_max_bound();
            LPoint2f *return_value = new LPoint2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxBound(const RectangleEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_RectangleEmitter_get_max_bound_263_comment =
    "C++ Interface:\n"
    "getMaxBound(const RectangleEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_max_bound\n"
    "//      Access : public\n"
    "// Description : boundary get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_RectangleEmitter_get_max_bound_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * RectangleEmitter::RectangleEmitter(void)
 * RectangleEmitter::RectangleEmitter(RectangleEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_RectangleEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-RectangleEmitter::RectangleEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":RectangleEmitter", key_word_list))
            {
                RectangleEmitter *return_value = new RectangleEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_RectangleEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-RectangleEmitter::RectangleEmitter(RectangleEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:RectangleEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:RectangleEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    RectangleEmitter *param0_this = (RectangleEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_RectangleEmitter, 0, "RectangleEmitter.RectangleEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        RectangleEmitter *return_value = new RectangleEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_RectangleEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "RectangleEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "RectangleEmitter()\n"
          "RectangleEmitter(const RectangleEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_RectangleEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_RectangleEmitter)
    {
        printf("RectangleEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    RectangleEmitter * local_this = (RectangleEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_RectangleEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_RectangleEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_RectangleEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (RectangleEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (RectangleEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SparkleParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SparkleParticleRenderer::set_center_color(LVecBase4f const &c)
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_set_center_color_267(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SparkleParticleRenderer::set_center_color(LVecBase4f const &c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenterColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCenterColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "SparkleParticleRenderer.setCenterColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_center_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparkleParticleRenderer.setCenterColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCenterColor(non-const SparkleParticleRenderer this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_set_center_color_267_comment =
    "C++ Interface:\n"
    "setCenterColor(non-const SparkleParticleRenderer this, const VBase4 c)\n"
    "\n"
    "// Filename: sparkleParticleRenderer.I\n"
    "// Created by:  charles (27Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_center_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_set_center_color_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparkleParticleRenderer::set_edge_color(LVecBase4f const &c)
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_set_edge_color_268(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SparkleParticleRenderer::set_edge_color(LVecBase4f const &c)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"c", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEdgeColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEdgeColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "SparkleParticleRenderer.setEdgeColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_edge_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SparkleParticleRenderer.setEdgeColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEdgeColor(non-const SparkleParticleRenderer this, const VBase4 c)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_set_edge_color_268_comment =
    "C++ Interface:\n"
    "setEdgeColor(non-const SparkleParticleRenderer this, const VBase4 c)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_edge_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_set_edge_color_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparkleParticleRenderer::set_birth_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_set_birth_radius_269(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparkleParticleRenderer::set_birth_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBirthRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBirthRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_birth_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparkleParticleRenderer.setBirthRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBirthRadius(non-const SparkleParticleRenderer this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_set_birth_radius_269_comment =
    "C++ Interface:\n"
    "setBirthRadius(non-const SparkleParticleRenderer this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_birth_radius\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_set_birth_radius_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparkleParticleRenderer::set_death_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_set_death_radius_270(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparkleParticleRenderer::set_death_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDeathRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDeathRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_death_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparkleParticleRenderer.setDeathRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDeathRadius(non-const SparkleParticleRenderer this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_set_death_radius_270_comment =
    "C++ Interface:\n"
    "setDeathRadius(non-const SparkleParticleRenderer this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_death_radius\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_set_death_radius_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SparkleParticleRenderer::set_life_scale(SparkleParticleRenderer::SparkleParticleLifeScale )
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_set_life_scale_271(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SparkleParticleRenderer::set_life_scale(SparkleParticleRenderer::SparkleParticleLifeScale )
        int param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLifeScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLifeScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_life_scale((SparkleParticleRenderer::SparkleParticleLifeScale)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SparkleParticleRenderer.setLifeScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLifeScale(non-const SparkleParticleRenderer this, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_set_life_scale_271_comment =
    "C++ Interface:\n"
    "setLifeScale(non-const SparkleParticleRenderer this, int)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_life_scale\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_set_life_scale_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &SparkleParticleRenderer::get_center_color(void) const
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_get_center_color_272(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &SparkleParticleRenderer::get_center_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenterColor", key_word_list));
        else
            (PyArg_Parse(args, ":getCenterColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const SparkleParticleRenderer*)local_this)->get_center_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenterColor(const SparkleParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_get_center_color_272_comment =
    "C++ Interface:\n"
    "getCenterColor(const SparkleParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_center_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_get_center_color_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &SparkleParticleRenderer::get_edge_color(void) const
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_get_edge_color_273(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &SparkleParticleRenderer::get_edge_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEdgeColor", key_word_list));
        else
            (PyArg_Parse(args, ":getEdgeColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const SparkleParticleRenderer*)local_this)->get_edge_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEdgeColor(const SparkleParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_get_edge_color_273_comment =
    "C++ Interface:\n"
    "getEdgeColor(const SparkleParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_edge_color\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_get_edge_color_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SparkleParticleRenderer::get_birth_radius(void) const
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_get_birth_radius_274(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SparkleParticleRenderer::get_birth_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBirthRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getBirthRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SparkleParticleRenderer*)local_this)->get_birth_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBirthRadius(const SparkleParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_get_birth_radius_274_comment =
    "C++ Interface:\n"
    "getBirthRadius(const SparkleParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_birth_radius\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_get_birth_radius_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SparkleParticleRenderer::get_death_radius(void) const
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_get_death_radius_275(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SparkleParticleRenderer::get_death_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDeathRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getDeathRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SparkleParticleRenderer*)local_this)->get_death_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDeathRadius(const SparkleParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_get_death_radius_275_comment =
    "C++ Interface:\n"
    "getDeathRadius(const SparkleParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_death_radius\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_get_death_radius_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SparkleParticleRenderer::SparkleParticleLifeScale SparkleParticleRenderer::get_life_scale(void) const
 *******************************************************************/
static PyObject *Dtool_SparkleParticleRenderer_get_life_scale_276(PyObject *self, PyObject *args,PyObject *kwds) {
    SparkleParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SparkleParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SparkleParticleRenderer::SparkleParticleLifeScale SparkleParticleRenderer::get_life_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLifeScale", key_word_list));
        else
            (PyArg_Parse(args, ":getLifeScale"));
        if(!PyErr_Occurred())
        {
            SparkleParticleRenderer::SparkleParticleLifeScale return_value = ((const SparkleParticleRenderer*)local_this)->get_life_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLifeScale(const SparkleParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SparkleParticleRenderer_get_life_scale_276_comment =
    "C++ Interface:\n"
    "getLifeScale(const SparkleParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_life_scale\n"
    "//      Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SparkleParticleRenderer_get_life_scale_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SparkleParticleRenderer::SparkleParticleRenderer(void)
 * SparkleParticleRenderer::SparkleParticleRenderer(LVecBase4f const &center, LVecBase4f const &edge, float birth_radius, float death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
 * SparkleParticleRenderer::SparkleParticleRenderer(SparkleParticleRenderer const &copy)
 *******************************************************************/
int  Dtool_Init_SparkleParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-SparkleParticleRenderer::SparkleParticleRenderer(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SparkleParticleRenderer", key_word_list))
            {
                SparkleParticleRenderer *return_value = new SparkleParticleRenderer();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SparkleParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-SparkleParticleRenderer::SparkleParticleRenderer(SparkleParticleRenderer const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SparkleParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SparkleParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    SparkleParticleRenderer *param0_this = (SparkleParticleRenderer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SparkleParticleRenderer, 0, "SparkleParticleRenderer.SparkleParticleRenderer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SparkleParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-SparkleParticleRenderer::SparkleParticleRenderer(LVecBase4f const &center, LVecBase4f const &edge, float birth_radius, float death_radius, SparkleParticleRenderer::SparkleParticleLifeScale life_scale, BaseParticleRenderer::ParticleRendererAlphaMode alpha_mode)
                PyObject *param0;
                PyObject *param1;
                double param2;
                double param3;
                int param4;
                int param5;
                static char * key_word_list[] = {(char *)"center", (char *)"edge", (char *)"birth_radius", (char *)"death_radius", (char *)"life_scale", (char *)"alpha_mode", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOddii:SparkleParticleRenderer", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
                {
                    LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "SparkleParticleRenderer.SparkleParticleRenderer", 1, coerced_ptr, report_errors);
LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "SparkleParticleRenderer.SparkleParticleRenderer", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        SparkleParticleRenderer *return_value = new SparkleParticleRenderer(*param0_this, *param1_this, (float)param2, (float)param3, (SparkleParticleRenderer::SparkleParticleLifeScale)param4, (BaseParticleRenderer::ParticleRendererAlphaMode)param5);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SparkleParticleRenderer,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SparkleParticleRenderer() takes 0, 1, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SparkleParticleRenderer()\n"
          "SparkleParticleRenderer(const SparkleParticleRenderer copy)\n"
          "SparkleParticleRenderer(const VBase4 center, const VBase4 edge, float birth_radius, float death_radius, int life_scale, int alpha_mode)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SparkleParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SparkleParticleRenderer)
    {
        printf("SparkleParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SparkleParticleRenderer * local_this = (SparkleParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SparkleParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return ( BaseParticleRenderer *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleRenderer *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SparkleParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SparkleParticleRenderer)
        return from_this;
    if(from_type == &Dtool_BaseParticleRenderer)
    {
          BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
          return (SparkleParticleRenderer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SparkleParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SphereSurfaceEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SphereSurfaceEmitter::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_SphereSurfaceEmitter_set_radius_279(PyObject *self, PyObject *args,PyObject *kwds) {
    SphereSurfaceEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SphereSurfaceEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SphereSurfaceEmitter::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SphereSurfaceEmitter.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const SphereSurfaceEmitter this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SphereSurfaceEmitter_set_radius_279_comment =
    "C++ Interface:\n"
    "setRadius(non-const SphereSurfaceEmitter this, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius\n"
    "//      Access : public\n"
    "// Description : radius set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SphereSurfaceEmitter_set_radius_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SphereSurfaceEmitter::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_SphereSurfaceEmitter_get_radius_280(PyObject *self, PyObject *args,PyObject *kwds) {
    SphereSurfaceEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SphereSurfaceEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SphereSurfaceEmitter::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SphereSurfaceEmitter*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const SphereSurfaceEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SphereSurfaceEmitter_get_radius_280_comment =
    "C++ Interface:\n"
    "getRadius(const SphereSurfaceEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius\n"
    "//      Access : public\n"
    "// Description : radius get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SphereSurfaceEmitter_get_radius_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SphereSurfaceEmitter::SphereSurfaceEmitter(void)
 * SphereSurfaceEmitter::SphereSurfaceEmitter(SphereSurfaceEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_SphereSurfaceEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-SphereSurfaceEmitter::SphereSurfaceEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SphereSurfaceEmitter", key_word_list))
            {
                SphereSurfaceEmitter *return_value = new SphereSurfaceEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SphereSurfaceEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-SphereSurfaceEmitter::SphereSurfaceEmitter(SphereSurfaceEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SphereSurfaceEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SphereSurfaceEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    SphereSurfaceEmitter *param0_this = (SphereSurfaceEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SphereSurfaceEmitter, 0, "SphereSurfaceEmitter.SphereSurfaceEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        SphereSurfaceEmitter *return_value = new SphereSurfaceEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SphereSurfaceEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SphereSurfaceEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SphereSurfaceEmitter()\n"
          "SphereSurfaceEmitter(const SphereSurfaceEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SphereSurfaceEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SphereSurfaceEmitter)
    {
        printf("SphereSurfaceEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SphereSurfaceEmitter * local_this = (SphereSurfaceEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SphereSurfaceEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SphereSurfaceEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SphereSurfaceEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (SphereSurfaceEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SphereSurfaceEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SphereVolumeEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SphereVolumeEmitter::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_SphereVolumeEmitter_set_radius_283(PyObject *self, PyObject *args,PyObject *kwds) {
    SphereVolumeEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SphereVolumeEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SphereVolumeEmitter::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SphereVolumeEmitter.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const SphereVolumeEmitter this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SphereVolumeEmitter_set_radius_283_comment =
    "C++ Interface:\n"
    "setRadius(non-const SphereVolumeEmitter this, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius\n"
    "//      Access : public\n"
    "// Description : radius set\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SphereVolumeEmitter_set_radius_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SphereVolumeEmitter::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_SphereVolumeEmitter_get_radius_284(PyObject *self, PyObject *args,PyObject *kwds) {
    SphereVolumeEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SphereVolumeEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SphereVolumeEmitter::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SphereVolumeEmitter*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const SphereVolumeEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SphereVolumeEmitter_get_radius_284_comment =
    "C++ Interface:\n"
    "getRadius(const SphereVolumeEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius\n"
    "//      Access : public\n"
    "// Description : radius get\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SphereVolumeEmitter_get_radius_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SphereVolumeEmitter::SphereVolumeEmitter(void)
 * SphereVolumeEmitter::SphereVolumeEmitter(SphereVolumeEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_SphereVolumeEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-SphereVolumeEmitter::SphereVolumeEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SphereVolumeEmitter", key_word_list))
            {
                SphereVolumeEmitter *return_value = new SphereVolumeEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SphereVolumeEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-SphereVolumeEmitter::SphereVolumeEmitter(SphereVolumeEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SphereVolumeEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SphereVolumeEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    SphereVolumeEmitter *param0_this = (SphereVolumeEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SphereVolumeEmitter, 0, "SphereVolumeEmitter.SphereVolumeEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        SphereVolumeEmitter *return_value = new SphereVolumeEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SphereVolumeEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SphereVolumeEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SphereVolumeEmitter()\n"
          "SphereVolumeEmitter(const SphereVolumeEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SphereVolumeEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SphereVolumeEmitter)
    {
        printf("SphereVolumeEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SphereVolumeEmitter * local_this = (SphereVolumeEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SphereVolumeEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SphereVolumeEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SphereVolumeEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (SphereVolumeEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SphereVolumeEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SpriteAnim 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void SpriteAnim::set_source_info(basic_string< char > const &tex)
 * void SpriteAnim::set_source_info(basic_string< char > const &model, basic_string< char > const &node)
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_set_source_info_287(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SpriteAnim::set_source_info(basic_string< char > const &tex)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"tex", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setSourceInfo", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:setSourceInfo", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                (local_this)->set_source_info(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SpriteAnim.setSourceInfo() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SpriteAnim::set_source_info(basic_string< char > const &model, basic_string< char > const &node)
            char *param1_str; int param1_len;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"model", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:setSourceInfo", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
            {
                (local_this)->set_source_info(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SpriteAnim.setSourceInfo() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setSourceInfo() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setSourceInfo(non-const SpriteAnim this, string tex)\n"
          "setSourceInfo(non-const SpriteAnim this, string model, string node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_set_source_info_287_comment =
    "C++ Interface:\n"
    "setSourceInfo(non-const SpriteAnim this, string tex)\n"
    "setSourceInfo(non-const SpriteAnim this, string model, string node)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_set_source_info_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SpriteAnim::SourceType SpriteAnim::get_source_type(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_get_source_type_288(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-SpriteAnim::SourceType SpriteAnim::get_source_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSourceType", key_word_list));
        else
            (PyArg_Parse(args, ":getSourceType"));
        if(!PyErr_Occurred())
        {
            SpriteAnim::SourceType return_value = ((const SpriteAnim*)local_this)->get_source_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSourceType(const SpriteAnim this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_get_source_type_288_comment =
    "C++ Interface:\n"
    "getSourceType(const SpriteAnim this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_get_source_type_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > SpriteAnim::get_tex_source(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_get_tex_source_289(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > SpriteAnim::get_tex_source(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexSource", key_word_list));
        else
            (PyArg_Parse(args, ":getTexSource"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const SpriteAnim*)local_this)->get_tex_source();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexSource(const SpriteAnim this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_get_tex_source_289_comment =
    "C++ Interface:\n"
    "getTexSource(const SpriteAnim this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_get_tex_source_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > SpriteAnim::get_model_source(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_get_model_source_290(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > SpriteAnim::get_model_source(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModelSource", key_word_list));
        else
            (PyArg_Parse(args, ":getModelSource"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const SpriteAnim*)local_this)->get_model_source();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModelSource(const SpriteAnim this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_get_model_source_290_comment =
    "C++ Interface:\n"
    "getModelSource(const SpriteAnim this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_get_model_source_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > SpriteAnim::get_node_source(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_get_node_source_291(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > SpriteAnim::get_node_source(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeSource", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeSource"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const SpriteAnim*)local_this)->get_node_source();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeSource(const SpriteAnim this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_get_node_source_291_comment =
    "C++ Interface:\n"
    "getNodeSource(const SpriteAnim this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_get_node_source_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int SpriteAnim::get_num_frames(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteAnim_get_num_frames_292(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteAnim * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteAnim,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int SpriteAnim::get_num_frames(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFrames", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFrames"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SpriteAnim*)local_this)->get_num_frames();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFrames(const SpriteAnim this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteAnim_get_num_frames_292_comment =
    "C++ Interface:\n"
    "getNumFrames(const SpriteAnim this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteAnim_get_num_frames_292_comment = NULL;
#endif

int  Dtool_Init_SpriteAnim(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SpriteAnim)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SpriteAnim(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SpriteAnim)
    {
        printf("SpriteAnim ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SpriteAnim * local_this = (SpriteAnim *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SpriteAnim)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SpriteAnim(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SpriteAnim)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SpriteAnim*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SpriteParticleRenderer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels)
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels = (0))
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels)
 * void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels = (0))
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_from_node_296(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"node_path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFromNode", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFromNode", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.setFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_from_node(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, bool size_from_texels)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"node_path", (char *)"size_from_texels", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setFromNode", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.setFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_from_node(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels = (0))
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"node_path", (char *)"model", (char *)"node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#:setFromNode", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.setFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_from_node(*param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::set_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels)
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"node_path", (char *)"model", (char *)"node", (char *)"size_from_texels", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#O:setFromNode", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.setFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_from_node(*param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (PyObject_IsTrue(param4)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFromNode() takes 2, 3, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path)\n"
          "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels)\n"
          "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node)\n"
          "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_from_node_296_comment =
    "C++ Interface:\n"
    "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path)\n"
    "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels)\n"
    "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node)\n"
    "setFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_from_node\n"
    "//      Access : public\n"
    "// Description : If the source type is important, use this one.\n"
    "//\n"
    "//               model and node should lead to node_path like this:\n"
    "//               node_path = loader.loadModel(model).find(node)\n"
    "//\n"
    "//               This will remove all previously add textures and \n"
    "//               resize the renderer to match the new geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_from_node\n"
    "//      Access : public\n"
    "// Description : Sets the properties on this renderer from the geometry\n"
    "//               referenced by the indicated NodePath.  This should be\n"
    "//               a reference to a GeomNode or a SequenceNode; it\n"
    "//               extracts out the texture and UV range from the node.\n"
    "//\n"
    "//               This will remove all previously added textures and\n"
    "//               animations.  It will also resize the renderer to match\n"
    "//               this new geometry.\n"
    "//\n"
    "//               If node_path refers to a GeomNode(or has one beneath it)\n"
    "//               the texture, its size, and UV data will be extracted\n"
    "//               from that.\n"
    "//\n"
    "//               If node_path references a SequenceNode(or has one \n"
    "//               beneath it) with multiple GeomNodes beneath it, \n"
    "//               the size data will correspond only to the first \n"
    "//               GeomNode found with a valid texture, while the texture\n"
    "//               and UV information will be stored for each individual\n"
    "//               node.\n"
    "//\n"
    "//               If size_from_texels is true, the particle size is\n"
    "//               based on the number of texels in the source image;\n"
    "//               otherwise, it is based on the size of the first \n"
    "//               polygon found in the node.\n"
    "//\n"
    "//               model and node are the two items used to construct\n"
    "//               node_path.  If the source type is important, use\n"
    "//               set_from_node(NodePath,string,string,bool) instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_from_node_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels, bool resize)
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels, bool resize = (0))
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels = (0), bool resize = (0))
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize)
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize = (0))
 * void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels = (0), bool resize = (0))
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_add_from_node_297(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels = (0), bool resize = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"node_path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addFromNode", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addFromNode", &param1));
                if(!PyErr_Occurred())
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"node_path", (char *)"size_from_texels", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addFromNode", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels = (0), bool resize = (0))
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"node_path", (char *)"model", (char *)"node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#:addFromNode", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void SpriteParticleRenderer::add_from_node(NodePath const &node_path, bool size_from_texels, bool resize)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"node_path", (char *)"size_from_texels", (char *)"resize", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:addFromNode", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this, (PyObject_IsTrue(param2)!=0), (PyObject_IsTrue(param3)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels, bool resize = (0))
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"node_path", (char *)"model", (char *)"node", (char *)"size_from_texels", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#O:addFromNode", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (PyObject_IsTrue(param4)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void SpriteParticleRenderer::add_from_node(NodePath const &node_path, basic_string< char > const &model, basic_string< char > const &node, bool size_from_texels, bool resize)
                PyObject *param1;
                char *param2_str; int param2_len;
                char *param3_str; int param3_len;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"node_path", (char *)"model", (char *)"node", (char *)"size_from_texels", (char *)"resize", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#OO:addFromNode", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SpriteParticleRenderer.addFromNode", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_from_node(*param1_this, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len), (PyObject_IsTrue(param4)!=0), (PyObject_IsTrue(param5)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addFromNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addFromNode() takes 2, 3, 4, 5, or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path)\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels)\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node)\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels, bool resize)\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels)\n"
          "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels, bool resize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_add_from_node_297_comment =
    "C++ Interface:\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path)\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels)\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node)\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, bool size_from_texels, bool resize)\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels)\n"
    "addFromNode(non-const SpriteParticleRenderer this, const NodePath node_path, string model, string node, bool size_from_texels, bool resize)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::add_from_node\n"
    "//      Access : public\n"
    "// Description : This will allow the renderer to randomly choose\n"
    "//               from more than one texture or sequence at particle\n"
    "//               birth.\n"
    "//\n"
    "//               If the source type is important, use this one.\n"
    "//\n"
    "//               model and node should lead to node_path like this:\n"
    "//               node_path = loader.loadModel(model).find(node)\n"
    "//\n"
    "//               If resize is true, or if there are no textures \n"
    "//               currently on the renderer, it will force the \n"
    "//               renderer to use the size information from this \n"
    "//               node from now on. (Default is false)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::add_from_node\n"
    "//      Access : public\n"
    "// Description : This will allow the renderer to randomly choose\n"
    "//               from more than one texture or sequence at particle\n"
    "//               birth.\n"
    "//\n"
    "//               If resize is true, or if there are no textures \n"
    "//               currently on the renderer, it will force the \n"
    "//               renderer to use the size information from this \n"
    "//               node from now on. (Default is false)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_add_from_node_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_texture(Texture *tex, float texels_per_unit)
 * inline void SpriteParticleRenderer::set_texture(Texture *tex, float texels_per_unit = (1))
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_texture_298(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_texture(Texture *tex, float texels_per_unit = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"tex", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTexture", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setTexture", &param1));
                if(!PyErr_Occurred())
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "SpriteParticleRenderer.setTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_texture(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_texture(Texture *tex, float texels_per_unit)
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"tex", (char *)"texels_per_unit", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setTexture", key_word_list, &param1, &param2))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "SpriteParticleRenderer.setTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_texture(param1_this, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setTexture() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setTexture(non-const SpriteParticleRenderer this, non-const Texture tex)\n"
          "setTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_texture_298_comment =
    "C++ Interface:\n"
    "setTexture(non-const SpriteParticleRenderer this, non-const Texture tex)\n"
    "setTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit)\n"
    "\n"
    "// Filename: spriteParticleRenderer.I\n"
    "// Created by:  charles (13Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_texture\n"
    "//      Access : Published\n"
    "// Description : Sets the renderer up to render the entire texture\n"
    "//               image.  The scale of each particle is based on the\n"
    "//               size of the texture in each dimension, modified by\n"
    "//               texels_per_unit.\n"
    "//\n"
    "//               Used to set the size of the particles.  Will clear\n"
    "//               all previously loaded textures and animations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_texture_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit, bool resize)
 * inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit, bool resize = (0))
 * inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit = (1), bool resize = (0))
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_add_texture_299(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit = (1), bool resize = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"tex", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addTexture", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addTexture", &param1));
                if(!PyErr_Occurred())
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "SpriteParticleRenderer.addTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_texture(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit, bool resize = (0))
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"tex", (char *)"texels_per_unit", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:addTexture", key_word_list, &param1, &param2))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "SpriteParticleRenderer.addTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_texture(param1_this, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::add_texture(Texture *tex, float texels_per_unit, bool resize)
                PyObject *param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"tex", (char *)"texels_per_unit", (char *)"resize", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdO:addTexture", key_word_list, &param1, &param2, &param3))
                {
                    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Texture, 1, "SpriteParticleRenderer.addTexture", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_texture(param1_this, (float)param2, (PyObject_IsTrue(param3)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.addTexture() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addTexture() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex)\n"
          "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit)\n"
          "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit, bool resize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_add_texture_299_comment =
    "C++ Interface:\n"
    "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex)\n"
    "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit)\n"
    "addTexture(non-const SpriteParticleRenderer this, non-const Texture tex, float texels_per_unit, bool resize)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::add_texture\n"
    "//      Access : Published\n"
    "// Description : Adds texture to image pool, effectively creating a \n"
    "//               single frame animation that can be selected at \n"
    "//               particle birth.  This should only be called after\n"
    "//               a previous call to set_texture().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_add_texture_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::remove_animation(int const n)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_remove_animation_300(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::remove_animation(int const n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeAnimation", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeAnimation", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_animation((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.removeAnimation() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAnimation(non-const SpriteParticleRenderer this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_remove_animation_300_comment =
    "C++ Interface:\n"
    "removeAnimation(non-const SpriteParticleRenderer this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::remove_animation\n"
    "//      Access : Published\n"
    "// Description : Removes an animation texture set from the renderer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_remove_animation_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_ll_uv(LPoint2f const &ll_uv)
 * inline void SpriteParticleRenderer::set_ll_uv(LPoint2f const &ll_uv, int const anim, int const frame)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_ll_uv_301(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_ll_uv(LPoint2f const &ll_uv)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"ll_uv", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLlUv", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setLlUv", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "SpriteParticleRenderer.setLlUv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_ll_uv(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setLlUv() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_ll_uv(LPoint2f const &ll_uv, int const anim, int const frame)
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"ll_uv", (char *)"anim", (char *)"frame", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setLlUv", key_word_list, &param1, &param2, &param3))
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "SpriteParticleRenderer.setLlUv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_ll_uv(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setLlUv() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLlUv() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLlUv(non-const SpriteParticleRenderer this, const Point2 ll_uv)\n"
          "setLlUv(non-const SpriteParticleRenderer this, const Point2 ll_uv, int anim, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_ll_uv_301_comment =
    "C++ Interface:\n"
    "setLlUv(non-const SpriteParticleRenderer this, const Point2 ll_uv)\n"
    "setLlUv(non-const SpriteParticleRenderer this, const Point2 ll_uv, int anim, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_ll_uv\n"
    "//      Access : public\n"
    "// Description : Sets the UV coordinate of the lower-left corner of\n"
    "//               all the sprites generated by this renderer.  Normally\n"
    "//               this is (0, 0), but it might be set to something else\n"
    "//               to use only a portion of the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_ll_uv\n"
    "//      Access : public\n"
    "// Description : Sets the UV coordinate of the lower-left corner of\n"
    "//               all the sprites generated by this renderer.  Normally\n"
    "//               this is (0, 0), but it might be set to something else\n"
    "//               to use only a portion of the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_ll_uv_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_ur_uv(LPoint2f const &ur_uv)
 * inline void SpriteParticleRenderer::set_ur_uv(LPoint2f const &ur_uv, int const anim, int const frame)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_ur_uv_302(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_ur_uv(LPoint2f const &ur_uv)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"ur_uv", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUrUv", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setUrUv", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "SpriteParticleRenderer.setUrUv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_ur_uv(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setUrUv() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void SpriteParticleRenderer::set_ur_uv(LPoint2f const &ur_uv, int const anim, int const frame)
                PyObject *param1;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"ur_uv", (char *)"anim", (char *)"frame", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setUrUv", key_word_list, &param1, &param2, &param3))
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "SpriteParticleRenderer.setUrUv", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_ur_uv(*param1_this, (int)param2, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SpriteParticleRenderer.setUrUv() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setUrUv() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setUrUv(non-const SpriteParticleRenderer this, const Point2 ur_uv)\n"
          "setUrUv(non-const SpriteParticleRenderer this, const Point2 ur_uv, int anim, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_ur_uv_302_comment =
    "C++ Interface:\n"
    "setUrUv(non-const SpriteParticleRenderer this, const Point2 ur_uv)\n"
    "setUrUv(non-const SpriteParticleRenderer this, const Point2 ur_uv, int anim, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_ur_uv\n"
    "//      Access : public\n"
    "// Description : Sets the UV coordinate of the upper-right corner of\n"
    "//               all the sprites generated by this renderer.  Normally\n"
    "//               this is (1, 1), but it might be set to something else\n"
    "//               to use only a portion of the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_ur_uv\n"
    "//      Access : public\n"
    "// Description : Sets the UV coordinate of the upper-right corner of\n"
    "//               all the sprites generated by this renderer.  Normally\n"
    "//               this is (1, 1), but it might be set to something else\n"
    "//               to use only a portion of the texture.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_ur_uv_302_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_size(float width, float height)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_size_303(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_size(float width, float height)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setSize", key_word_list, &param1, &param2))
        {
            (local_this)->set_size((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSize(non-const SpriteParticleRenderer this, float width, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_size_303_comment =
    "C++ Interface:\n"
    "setSize(non-const SpriteParticleRenderer this, float width, float height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::set_size\n"
    "//      Access : public\n"
    "// Description : Sets the size of each particle in world units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_size_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_color_304(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SpriteParticleRenderer::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "SpriteParticleRenderer.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SpriteParticleRenderer.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const SpriteParticleRenderer this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_color_304_comment =
    "C++ Interface:\n"
    "setColor(non-const SpriteParticleRenderer this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_color\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_color_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_x_scale_flag_305(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_x_scale_flag(bool animate_x_ratio)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_x_ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setXScaleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setXScaleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_x_scale_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setXScaleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setXScaleFlag(non-const SpriteParticleRenderer this, bool animate_x_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_x_scale_flag_305_comment =
    "C++ Interface:\n"
    "setXScaleFlag(non-const SpriteParticleRenderer this, bool animate_x_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_x_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_x_scale_flag_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_y_scale_flag_306(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_y_scale_flag(bool animate_y_ratio)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_y_ratio", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setYScaleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setYScaleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_y_scale_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setYScaleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setYScaleFlag(non-const SpriteParticleRenderer this, bool animate_y_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_y_scale_flag_306_comment =
    "C++ Interface:\n"
    "setYScaleFlag(non-const SpriteParticleRenderer this, bool animate_y_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_y_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_y_scale_flag_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_anim_angle_flag(bool animate_theta)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_anim_angle_flag_307(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_anim_angle_flag(bool animate_theta)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"animate_theta", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnimAngleFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAnimAngleFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_anim_angle_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAnimAngleFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimAngleFlag(non-const SpriteParticleRenderer this, bool animate_theta)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_anim_angle_flag_307_comment =
    "C++ Interface:\n"
    "setAnimAngleFlag(non-const SpriteParticleRenderer this, bool animate_theta)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_anim_angle_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_anim_angle_flag_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_initial_x_scale(float initial_x_scale)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_initial_x_scale_308(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_initial_x_scale(float initial_x_scale)
        double param1;
        static char * key_word_list[] = {(char *)"initial_x_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialXScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialXScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_x_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setInitialXScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialXScale(non-const SpriteParticleRenderer this, float initial_x_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_initial_x_scale_308_comment =
    "C++ Interface:\n"
    "setInitialXScale(non-const SpriteParticleRenderer this, float initial_x_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_initial_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_initial_x_scale_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_final_x_scale(float final_x_scale)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_final_x_scale_309(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_final_x_scale(float final_x_scale)
        double param1;
        static char * key_word_list[] = {(char *)"final_x_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalXScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalXScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_x_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setFinalXScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalXScale(non-const SpriteParticleRenderer this, float final_x_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_final_x_scale_309_comment =
    "C++ Interface:\n"
    "setFinalXScale(non-const SpriteParticleRenderer this, float final_x_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_final_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_final_x_scale_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_initial_y_scale(float initial_y_scale)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_initial_y_scale_310(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_initial_y_scale(float initial_y_scale)
        double param1;
        static char * key_word_list[] = {(char *)"initial_y_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialYScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialYScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_y_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setInitialYScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialYScale(non-const SpriteParticleRenderer this, float initial_y_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_initial_y_scale_310_comment =
    "C++ Interface:\n"
    "setInitialYScale(non-const SpriteParticleRenderer this, float initial_y_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_initial_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_initial_y_scale_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_final_y_scale(float final_y_scale)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_final_y_scale_311(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_final_y_scale(float final_y_scale)
        double param1;
        static char * key_word_list[] = {(char *)"final_y_scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalYScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalYScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_y_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setFinalYScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalYScale(non-const SpriteParticleRenderer this, float final_y_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_final_y_scale_311_comment =
    "C++ Interface:\n"
    "setFinalYScale(non-const SpriteParticleRenderer this, float final_y_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_final_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_final_y_scale_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_nonanimated_theta(float theta)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_nonanimated_theta_312(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_nonanimated_theta(float theta)
        double param1;
        static char * key_word_list[] = {(char *)"theta", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setNonanimatedTheta", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setNonanimatedTheta", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_nonanimated_theta((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setNonanimatedTheta() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNonanimatedTheta(non-const SpriteParticleRenderer this, float theta)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_nonanimated_theta_312_comment =
    "C++ Interface:\n"
    "setNonanimatedTheta(non-const SpriteParticleRenderer this, float theta)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_nonanimated_theta\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_nonanimated_theta_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_alpha_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_alpha_blend_method_313(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_alpha_blend_method(BaseParticleRenderer::ParticleRendererBlendMethod bm)
        int param1;
        static char * key_word_list[] = {(char *)"bm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAlphaBlendMethod", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAlphaBlendMethod", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_alpha_blend_method((BaseParticleRenderer::ParticleRendererBlendMethod)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAlphaBlendMethod() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlphaBlendMethod(non-const SpriteParticleRenderer this, int bm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_alpha_blend_method_313_comment =
    "C++ Interface:\n"
    "setAlphaBlendMethod(non-const SpriteParticleRenderer this, int bm)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_alpha_blend_method\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_alpha_blend_method_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_alpha_disable(bool ad)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_alpha_disable_314(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_alpha_disable(bool ad)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"ad", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAlphaDisable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAlphaDisable", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_alpha_disable((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAlphaDisable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlphaDisable(non-const SpriteParticleRenderer this, bool ad)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_alpha_disable_314_comment =
    "C++ Interface:\n"
    "setAlphaDisable(non-const SpriteParticleRenderer this, bool ad)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_alpha_disable\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_alpha_disable_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_animate_frames_enable(bool an)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_enable_315(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_animate_frames_enable(bool an)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"an", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnimateFramesEnable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAnimateFramesEnable", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_animate_frames_enable((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAnimateFramesEnable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimateFramesEnable(non-const SpriteParticleRenderer this, bool an)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_enable_315_comment =
    "C++ Interface:\n"
    "setAnimateFramesEnable(non-const SpriteParticleRenderer this, bool an)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_animate_frames_enable\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_enable_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_animate_frames_rate(float r)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_rate_316(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_animate_frames_rate(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAnimateFramesRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAnimateFramesRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_animate_frames_rate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAnimateFramesRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimateFramesRate(non-const SpriteParticleRenderer this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_rate_316_comment =
    "C++ Interface:\n"
    "setAnimateFramesRate(non-const SpriteParticleRenderer this, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_animate_frames_rate\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_rate_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SpriteParticleRenderer::set_animate_frames_index(int i)
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_set_animate_frames_index_317(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SpriteParticleRenderer::set_animate_frames_index(int i)
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAnimateFramesIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAnimateFramesIndex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_animate_frames_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SpriteParticleRenderer.setAnimateFramesIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimateFramesIndex(non-const SpriteParticleRenderer this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_index_317_comment =
    "C++ Interface:\n"
    "setAnimateFramesIndex(non-const SpriteParticleRenderer this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::set_animate_frames_index\n"
    "//   Access : public\n"
    "//  Purpose : Sets the frame to be used when animation is disabled.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_set_animate_frames_index_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *SpriteParticleRenderer::get_texture(void) const
 * inline Texture *SpriteParticleRenderer::get_texture(int const anim, int const frame) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_texture_318(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Texture *SpriteParticleRenderer::get_texture(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexture", key_word_list));
            else
                (PyArg_Parse(args, ":getTexture"));
            if(!PyErr_Occurred())
            {
                Texture *return_value = ((const SpriteParticleRenderer*)local_this)->get_texture();
                if (return_value != (Texture *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline Texture *SpriteParticleRenderer::get_texture(int const anim, int const frame) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"anim", (char *)"frame", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getTexture", key_word_list, &param1, &param2))
            {
                Texture *return_value = ((const SpriteParticleRenderer*)local_this)->get_texture((int)param1, (int)param2);
                if (return_value != (Texture *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Texture,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getTexture() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getTexture(const SpriteParticleRenderer this)\n"
          "getTexture(const SpriteParticleRenderer this, int anim, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_texture_318_comment =
    "C++ Interface:\n"
    "getTexture(const SpriteParticleRenderer this)\n"
    "getTexture(const SpriteParticleRenderer this, int anim, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_texture\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_texture\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_texture_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SpriteParticleRenderer::get_num_anims(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_num_anims_319(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SpriteParticleRenderer::get_num_anims(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAnims", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAnims"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SpriteParticleRenderer*)local_this)->get_num_anims();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAnims(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_num_anims_319_comment =
    "C++ Interface:\n"
    "getNumAnims(const SpriteParticleRenderer this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_num_anims_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SpriteAnim *SpriteParticleRenderer::get_anim(int const n) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_anim_320(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SpriteAnim *SpriteParticleRenderer::get_anim(int const n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAnim", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAnim", &param1));
        if(!PyErr_Occurred())
        {
            SpriteAnim *return_value = ((const SpriteParticleRenderer*)local_this)->get_anim((int)param1);
            if (return_value != (SpriteAnim *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SpriteAnim,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnim(const SpriteParticleRenderer this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_anim_320_comment =
    "C++ Interface:\n"
    "getAnim(const SpriteParticleRenderer this, int n)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_anim_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SpriteAnim *SpriteParticleRenderer::get_last_anim(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_last_anim_321(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SpriteAnim *SpriteParticleRenderer::get_last_anim(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastAnim", key_word_list));
        else
            (PyArg_Parse(args, ":getLastAnim"));
        if(!PyErr_Occurred())
        {
            SpriteAnim *return_value = ((const SpriteParticleRenderer*)local_this)->get_last_anim();
            if (return_value != (SpriteAnim *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_SpriteAnim,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastAnim(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_last_anim_321_comment =
    "C++ Interface:\n"
    "getLastAnim(const SpriteParticleRenderer this)\n"
    "\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_last_anim_321_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ColorInterpolationManager *SpriteParticleRenderer::get_color_interpolation_manager(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_color_interpolation_manager_322(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ColorInterpolationManager *SpriteParticleRenderer::get_color_interpolation_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorInterpolationManager", key_word_list));
        else
            (PyArg_Parse(args, ":getColorInterpolationManager"));
        if(!PyErr_Occurred())
        {
            ColorInterpolationManager *return_value = ((const SpriteParticleRenderer*)local_this)->get_color_interpolation_manager();
            if (return_value != (ColorInterpolationManager *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ColorInterpolationManager,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorInterpolationManager(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_color_interpolation_manager_322_comment =
    "C++ Interface:\n"
    "getColorInterpolationManager(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_color_interpolation_manager\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_color_interpolation_manager_322_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f SpriteParticleRenderer::get_ll_uv(void) const
 * inline LPoint2f SpriteParticleRenderer::get_ll_uv(int const anim, int const frame) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_ll_uv_323(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline LPoint2f SpriteParticleRenderer::get_ll_uv(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getLlUv", key_word_list));
            else
                (PyArg_Parse(args, ":getLlUv"));
            if(!PyErr_Occurred())
            {
                LPoint2f result = ((const SpriteParticleRenderer*)local_this)->get_ll_uv();
                LPoint2f *return_value = new LPoint2f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline LPoint2f SpriteParticleRenderer::get_ll_uv(int const anim, int const frame) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"anim", (char *)"frame", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getLlUv", key_word_list, &param1, &param2))
            {
                LPoint2f result = ((const SpriteParticleRenderer*)local_this)->get_ll_uv((int)param1, (int)param2);
                LPoint2f *return_value = new LPoint2f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getLlUv() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getLlUv(const SpriteParticleRenderer this)\n"
          "getLlUv(const SpriteParticleRenderer this, int anim, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_ll_uv_323_comment =
    "C++ Interface:\n"
    "getLlUv(const SpriteParticleRenderer this)\n"
    "getLlUv(const SpriteParticleRenderer this, int anim, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_ll_uv\n"
    "//      Access : public\n"
    "// Description : Returns the UV coordinate of the lower-left corner;\n"
    "//               see set_ll_uv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_ll_uv\n"
    "//      Access : public\n"
    "// Description : Returns the UV coordinate of the lower-left corner;\n"
    "//               see set_ll_uv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_ll_uv_323_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f SpriteParticleRenderer::get_ur_uv(void) const
 * inline LPoint2f SpriteParticleRenderer::get_ur_uv(int const anim, int const frame) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_ur_uv_324(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline LPoint2f SpriteParticleRenderer::get_ur_uv(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getUrUv", key_word_list));
            else
                (PyArg_Parse(args, ":getUrUv"));
            if(!PyErr_Occurred())
            {
                LPoint2f result = ((const SpriteParticleRenderer*)local_this)->get_ur_uv();
                LPoint2f *return_value = new LPoint2f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-inline LPoint2f SpriteParticleRenderer::get_ur_uv(int const anim, int const frame) const
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"anim", (char *)"frame", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getUrUv", key_word_list, &param1, &param2))
            {
                LPoint2f result = ((const SpriteParticleRenderer*)local_this)->get_ur_uv((int)param1, (int)param2);
                LPoint2f *return_value = new LPoint2f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getUrUv() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getUrUv(const SpriteParticleRenderer this)\n"
          "getUrUv(const SpriteParticleRenderer this, int anim, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_ur_uv_324_comment =
    "C++ Interface:\n"
    "getUrUv(const SpriteParticleRenderer this)\n"
    "getUrUv(const SpriteParticleRenderer this, int anim, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_ur_uv\n"
    "//      Access : public\n"
    "// Description : Returns the UV coordinate of the lower-left corner;\n"
    "//               see set_ur_uv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_ur_uv\n"
    "//      Access : public\n"
    "// Description : Returns the UV coordinate of the upper-right corner;\n"
    "//               see set_ur_uv().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_ur_uv_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_width_325(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_width_325_comment =
    "C++ Interface:\n"
    "getWidth(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_width\n"
    "//      Access : public\n"
    "// Description : Returns the width of each particle in world units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_width_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_height_326(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_height_326_comment =
    "C++ Interface:\n"
    "getHeight(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : SpriteParticleRenderer::get_height\n"
    "//      Access : public\n"
    "// Description : Returns the height of each particle in world units.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_height_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f SpriteParticleRenderer::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_color_327(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f SpriteParticleRenderer::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const SpriteParticleRenderer*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_color_327_comment =
    "C++ Interface:\n"
    "getColor(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_color\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_color_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SpriteParticleRenderer::get_x_scale_flag(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_x_scale_flag_328(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SpriteParticleRenderer::get_x_scale_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getXScaleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getXScaleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SpriteParticleRenderer*)local_this)->get_x_scale_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXScaleFlag(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_x_scale_flag_328_comment =
    "C++ Interface:\n"
    "getXScaleFlag(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_x_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_x_scale_flag_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SpriteParticleRenderer::get_y_scale_flag(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_y_scale_flag_329(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SpriteParticleRenderer::get_y_scale_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getYScaleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getYScaleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SpriteParticleRenderer*)local_this)->get_y_scale_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYScaleFlag(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_y_scale_flag_329_comment =
    "C++ Interface:\n"
    "getYScaleFlag(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_y_scale_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_y_scale_flag_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SpriteParticleRenderer::get_anim_angle_flag(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_anim_angle_flag_330(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SpriteParticleRenderer::get_anim_angle_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimAngleFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimAngleFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SpriteParticleRenderer*)local_this)->get_anim_angle_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimAngleFlag(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_anim_angle_flag_330_comment =
    "C++ Interface:\n"
    "getAnimAngleFlag(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_anim_angle_flag\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_anim_angle_flag_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_initial_x_scale(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_initial_x_scale_331(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_initial_x_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialXScale", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialXScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_initial_x_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialXScale(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_initial_x_scale_331_comment =
    "C++ Interface:\n"
    "getInitialXScale(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_initial_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_initial_x_scale_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_final_x_scale(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_final_x_scale_332(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_final_x_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalXScale", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalXScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_final_x_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalXScale(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_final_x_scale_332_comment =
    "C++ Interface:\n"
    "getFinalXScale(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_final_x_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_final_x_scale_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_initial_y_scale(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_initial_y_scale_333(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_initial_y_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialYScale", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialYScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_initial_y_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialYScale(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_initial_y_scale_333_comment =
    "C++ Interface:\n"
    "getInitialYScale(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_initial_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_initial_y_scale_333_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_final_y_scale(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_final_y_scale_334(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_final_y_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalYScale", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalYScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_final_y_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalYScale(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_final_y_scale_334_comment =
    "C++ Interface:\n"
    "getFinalYScale(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_final_y_scale\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_final_y_scale_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_nonanimated_theta(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_nonanimated_theta_335(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_nonanimated_theta(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNonanimatedTheta", key_word_list));
        else
            (PyArg_Parse(args, ":getNonanimatedTheta"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_nonanimated_theta();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNonanimatedTheta(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_nonanimated_theta_335_comment =
    "C++ Interface:\n"
    "getNonanimatedTheta(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_nonanimated_theta\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_nonanimated_theta_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseParticleRenderer::ParticleRendererBlendMethod SpriteParticleRenderer::get_alpha_blend_method(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_alpha_blend_method_336(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseParticleRenderer::ParticleRendererBlendMethod SpriteParticleRenderer::get_alpha_blend_method(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaBlendMethod", key_word_list));
        else
            (PyArg_Parse(args, ":getAlphaBlendMethod"));
        if(!PyErr_Occurred())
        {
            BaseParticleRenderer::ParticleRendererBlendMethod return_value = ((const SpriteParticleRenderer*)local_this)->get_alpha_blend_method();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaBlendMethod(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_alpha_blend_method_336_comment =
    "C++ Interface:\n"
    "getAlphaBlendMethod(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_alpha_blend_method\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_alpha_blend_method_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SpriteParticleRenderer::get_alpha_disable(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_alpha_disable_337(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SpriteParticleRenderer::get_alpha_disable(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlphaDisable", key_word_list));
        else
            (PyArg_Parse(args, ":getAlphaDisable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SpriteParticleRenderer*)local_this)->get_alpha_disable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlphaDisable(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_alpha_disable_337_comment =
    "C++ Interface:\n"
    "getAlphaDisable(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_alpha_disable\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_alpha_disable_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SpriteParticleRenderer::get_animate_frames_enable(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_enable_338(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SpriteParticleRenderer::get_animate_frames_enable(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimateFramesEnable", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimateFramesEnable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SpriteParticleRenderer*)local_this)->get_animate_frames_enable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimateFramesEnable(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_enable_338_comment =
    "C++ Interface:\n"
    "getAnimateFramesEnable(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_animate_frames_enable\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_enable_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SpriteParticleRenderer::get_animate_frames_rate(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_rate_339(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SpriteParticleRenderer::get_animate_frames_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimateFramesRate", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimateFramesRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SpriteParticleRenderer*)local_this)->get_animate_frames_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimateFramesRate(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_rate_339_comment =
    "C++ Interface:\n"
    "getAnimateFramesRate(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_animate_frames_rate\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_rate_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SpriteParticleRenderer::get_animate_frames_index(void) const
 *******************************************************************/
static PyObject *Dtool_SpriteParticleRenderer_get_animate_frames_index_340(PyObject *self, PyObject *args,PyObject *kwds) {
    SpriteParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SpriteParticleRenderer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SpriteParticleRenderer::get_animate_frames_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimateFramesIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimateFramesIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SpriteParticleRenderer*)local_this)->get_animate_frames_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimateFramesIndex(const SpriteParticleRenderer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_index_340_comment =
    "C++ Interface:\n"
    "getAnimateFramesIndex(const SpriteParticleRenderer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : SpriteParticleRenderer::get_animate_frames_index\n"
    "//   Access : public\n"
    "//  Purpose : Gets the frame to be used when animation is disabled.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SpriteParticleRenderer_get_animate_frames_index_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SpriteParticleRenderer::SpriteParticleRenderer(SpriteParticleRenderer const &copy)
 * SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
 * SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex = ((Texture *)((void *)(0))))
 *******************************************************************/
int  Dtool_Init_SpriteParticleRenderer(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex = ((Texture *)((void *)(0))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":SpriteParticleRenderer", key_word_list))
            {
                SpriteParticleRenderer *return_value = new SpriteParticleRenderer();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_SpriteParticleRenderer,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 SpriteParticleRenderer::SpriteParticleRenderer(SpriteParticleRenderer const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SpriteParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SpriteParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    SpriteParticleRenderer *param0_this = (SpriteParticleRenderer *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_SpriteParticleRenderer, 0, "SpriteParticleRenderer.SpriteParticleRenderer", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        SpriteParticleRenderer *return_value = new SpriteParticleRenderer(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SpriteParticleRenderer,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 SpriteParticleRenderer::SpriteParticleRenderer(Texture *tex)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"tex", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:SpriteParticleRenderer", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:SpriteParticleRenderer", &param0));
                if(!PyErr_Occurred())
                {
                    Texture *param0_this = (Texture *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Texture, 0, "SpriteParticleRenderer.SpriteParticleRenderer", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        SpriteParticleRenderer *return_value = new SpriteParticleRenderer(param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_SpriteParticleRenderer,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "SpriteParticleRenderer() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "SpriteParticleRenderer()\n"
          "SpriteParticleRenderer(const SpriteParticleRenderer copy)\n"
          "SpriteParticleRenderer(non-const Texture tex)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_SpriteParticleRenderer_get_anims(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAnims", "getAnim");
}
inline void  * Dtool_UpcastInterface_SpriteParticleRenderer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SpriteParticleRenderer)
    {
        printf("SpriteParticleRenderer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SpriteParticleRenderer * local_this = (SpriteParticleRenderer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SpriteParticleRenderer)
        return local_this;
    if(requested_type == &Dtool_BaseParticleRenderer)
        return ( BaseParticleRenderer *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleRenderer *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SpriteParticleRenderer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SpriteParticleRenderer)
        return from_this;
    if(from_type == &Dtool_BaseParticleRenderer)
    {
          BaseParticleRenderer* other_this = (BaseParticleRenderer*)from_this;
          return (SpriteParticleRenderer*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SpriteParticleRenderer*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TangentRingEmitter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void TangentRingEmitter::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_TangentRingEmitter_set_radius_343(PyObject *self, PyObject *args,PyObject *kwds) {
    TangentRingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TangentRingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TangentRingEmitter::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TangentRingEmitter.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const TangentRingEmitter this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TangentRingEmitter_set_radius_343_comment =
    "C++ Interface:\n"
    "setRadius(non-const TangentRingEmitter this, float r)\n"
    "\n"
    "// Filename: tangentRingEmitter.I\n"
    "// Created by:  charles (25Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : set_radius\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TangentRingEmitter_set_radius_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TangentRingEmitter::set_radius_spread(float spread)
 *******************************************************************/
static PyObject *Dtool_TangentRingEmitter_set_radius_spread_344(PyObject *self, PyObject *args,PyObject *kwds) {
    TangentRingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TangentRingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TangentRingEmitter::set_radius_spread(float spread)
        double param1;
        static char * key_word_list[] = {(char *)"spread", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadiusSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadiusSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TangentRingEmitter.setRadiusSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadiusSpread(non-const TangentRingEmitter this, float spread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TangentRingEmitter_set_radius_spread_344_comment =
    "C++ Interface:\n"
    "setRadiusSpread(non-const TangentRingEmitter this, float spread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : set_radius_spread\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TangentRingEmitter_set_radius_spread_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TangentRingEmitter::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_TangentRingEmitter_get_radius_345(PyObject *self, PyObject *args,PyObject *kwds) {
    TangentRingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TangentRingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TangentRingEmitter::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TangentRingEmitter*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const TangentRingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TangentRingEmitter_get_radius_345_comment =
    "C++ Interface:\n"
    "getRadius(const TangentRingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_radius\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TangentRingEmitter_get_radius_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float TangentRingEmitter::get_radius_spread(void) const
 *******************************************************************/
static PyObject *Dtool_TangentRingEmitter_get_radius_spread_346(PyObject *self, PyObject *args,PyObject *kwds) {
    TangentRingEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TangentRingEmitter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float TangentRingEmitter::get_radius_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadiusSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getRadiusSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const TangentRingEmitter*)local_this)->get_radius_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadiusSpread(const TangentRingEmitter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TangentRingEmitter_get_radius_spread_346_comment =
    "C++ Interface:\n"
    "getRadiusSpread(const TangentRingEmitter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_radius_spread\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TangentRingEmitter_get_radius_spread_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TangentRingEmitter::TangentRingEmitter(void)
 * TangentRingEmitter::TangentRingEmitter(TangentRingEmitter const &copy)
 *******************************************************************/
int  Dtool_Init_TangentRingEmitter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-TangentRingEmitter::TangentRingEmitter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":TangentRingEmitter", key_word_list))
            {
                TangentRingEmitter *return_value = new TangentRingEmitter();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_TangentRingEmitter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-TangentRingEmitter::TangentRingEmitter(TangentRingEmitter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:TangentRingEmitter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:TangentRingEmitter", &param0));
                if(!PyErr_Occurred())
                {
                    TangentRingEmitter *param0_this = (TangentRingEmitter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TangentRingEmitter, 0, "TangentRingEmitter.TangentRingEmitter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        TangentRingEmitter *return_value = new TangentRingEmitter(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_TangentRingEmitter,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "TangentRingEmitter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "TangentRingEmitter()\n"
          "TangentRingEmitter(const TangentRingEmitter copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TangentRingEmitter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TangentRingEmitter)
    {
        printf("TangentRingEmitter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TangentRingEmitter * local_this = (TangentRingEmitter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TangentRingEmitter)
        return local_this;
    if(requested_type == &Dtool_BaseParticleEmitter)
        return ( BaseParticleEmitter *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleEmitter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TangentRingEmitter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TangentRingEmitter)
        return from_this;
    if(from_type == &Dtool_BaseParticleEmitter)
    {
          BaseParticleEmitter* other_this = (BaseParticleEmitter*)from_this;
          return (TangentRingEmitter*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (TangentRingEmitter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ZSpinParticleFactory 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_initial_angle(float angle)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_initial_angle_349(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_initial_angle(float angle)
        double param1;
        static char * key_word_list[] = {(char *)"angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setInitialAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialAngle(non-const ZSpinParticleFactory this, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_initial_angle_349_comment =
    "C++ Interface:\n"
    "setInitialAngle(non-const ZSpinParticleFactory this, float angle)\n"
    "\n"
    "// Filename: zSpinParticleFactory.I\n"
    "// Created by:  charles (16Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_initial_angle\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_initial_angle_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_final_angle(float angle)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_final_angle_350(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_final_angle(float angle)
        double param1;
        static char * key_word_list[] = {(char *)"angle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalAngle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_angle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setFinalAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalAngle(non-const ZSpinParticleFactory this, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_final_angle_350_comment =
    "C++ Interface:\n"
    "setFinalAngle(non-const ZSpinParticleFactory this, float angle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_final_angle\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_final_angle_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_initial_angle_spread(float spread)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_initial_angle_spread_351(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_initial_angle_spread(float spread)
        double param1;
        static char * key_word_list[] = {(char *)"spread", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInitialAngleSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInitialAngleSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_initial_angle_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setInitialAngleSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInitialAngleSpread(non-const ZSpinParticleFactory this, float spread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_initial_angle_spread_351_comment =
    "C++ Interface:\n"
    "setInitialAngleSpread(non-const ZSpinParticleFactory this, float spread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_initial_angle_spread\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_initial_angle_spread_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_final_angle_spread(float spread)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_final_angle_spread_352(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_final_angle_spread(float spread)
        double param1;
        static char * key_word_list[] = {(char *)"spread", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFinalAngleSpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFinalAngleSpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_final_angle_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setFinalAngleSpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFinalAngleSpread(non-const ZSpinParticleFactory this, float spread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_final_angle_spread_352_comment =
    "C++ Interface:\n"
    "setFinalAngleSpread(non-const ZSpinParticleFactory this, float spread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_final_angle_spread\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_final_angle_spread_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_initial_angle(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_initial_angle_353(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_initial_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_initial_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialAngle(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_initial_angle_353_comment =
    "C++ Interface:\n"
    "getInitialAngle(const ZSpinParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_initial_angle\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_initial_angle_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_final_angle(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_final_angle_354(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_final_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_final_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalAngle(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_final_angle_354_comment =
    "C++ Interface:\n"
    "getFinalAngle(const ZSpinParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_final_angle\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_final_angle_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_initial_angle_spread(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_initial_angle_spread_355(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_initial_angle_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInitialAngleSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getInitialAngleSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_initial_angle_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInitialAngleSpread(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_initial_angle_spread_355_comment =
    "C++ Interface:\n"
    "getInitialAngleSpread(const ZSpinParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_initial_angle_spread\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_initial_angle_spread_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_final_angle_spread(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_final_angle_spread_356(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_final_angle_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFinalAngleSpread", key_word_list));
        else
            (PyArg_Parse(args, ":getFinalAngleSpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_final_angle_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFinalAngleSpread(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_final_angle_spread_356_comment =
    "C++ Interface:\n"
    "getFinalAngleSpread(const ZSpinParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_final_angle_spread\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_final_angle_spread_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_angular_velocity(float v)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_angular_velocity_357(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_angular_velocity(float v)
        double param1;
        static char * key_word_list[] = {(char *)"v", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAngularVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAngularVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_angular_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setAngularVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAngularVelocity(non-const ZSpinParticleFactory this, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_angular_velocity_357_comment =
    "C++ Interface:\n"
    "setAngularVelocity(non-const ZSpinParticleFactory this, float v)\n"
    "\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_angular_velocity_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_angular_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_358(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_angular_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngularVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getAngularVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_angular_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngularVelocity(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_358_comment =
    "C++ Interface:\n"
    "getAngularVelocity(const ZSpinParticleFactory this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_angular_velocity\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::set_angular_velocity_spread(float spread)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_set_angular_velocity_spread_359(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::set_angular_velocity_spread(float spread)
        double param1;
        static char * key_word_list[] = {(char *)"spread", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAngularVelocitySpread", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAngularVelocitySpread", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_angular_velocity_spread((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.setAngularVelocitySpread() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAngularVelocitySpread(non-const ZSpinParticleFactory this, float spread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_set_angular_velocity_spread_359_comment =
    "C++ Interface:\n"
    "setAngularVelocitySpread(non-const ZSpinParticleFactory this, float spread)\n"
    "\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_set_angular_velocity_spread_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ZSpinParticleFactory::get_angular_velocity_spread(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_spread_360(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ZSpinParticleFactory::get_angular_velocity_spread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngularVelocitySpread", key_word_list));
        else
            (PyArg_Parse(args, ":getAngularVelocitySpread"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const ZSpinParticleFactory*)local_this)->get_angular_velocity_spread();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngularVelocitySpread(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_spread_360_comment =
    "C++ Interface:\n"
    "getAngularVelocitySpread(const ZSpinParticleFactory this)\n"
    "\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_spread_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ZSpinParticleFactory::enable_angular_velocity(bool bEnabled)
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_enable_angular_velocity_361(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ZSpinParticleFactory::enable_angular_velocity(bool bEnabled)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"bEnabled", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:enableAngularVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:enableAngularVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->enable_angular_velocity((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ZSpinParticleFactory.enableAngularVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enableAngularVelocity(non-const ZSpinParticleFactory this, bool bEnabled)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_enable_angular_velocity_361_comment =
    "C++ Interface:\n"
    "enableAngularVelocity(non-const ZSpinParticleFactory this, bool bEnabled)\n"
    "\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_enable_angular_velocity_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ZSpinParticleFactory::get_angular_velocity_enabled(void) const
 *******************************************************************/
static PyObject *Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_362(PyObject *self, PyObject *args,PyObject *kwds) {
    ZSpinParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ZSpinParticleFactory,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ZSpinParticleFactory::get_angular_velocity_enabled(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngularVelocityEnabled", key_word_list));
        else
            (PyArg_Parse(args, ":getAngularVelocityEnabled"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ZSpinParticleFactory*)local_this)->get_angular_velocity_enabled();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngularVelocityEnabled(const ZSpinParticleFactory this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_362_comment =
    "C++ Interface:\n"
    "getAngularVelocityEnabled(const ZSpinParticleFactory this)\n"
    "\n"
    "";
#else
static const char * Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ZSpinParticleFactory::ZSpinParticleFactory(void)
 * ZSpinParticleFactory::ZSpinParticleFactory(ZSpinParticleFactory const &copy)
 *******************************************************************/
int  Dtool_Init_ZSpinParticleFactory(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ZSpinParticleFactory::ZSpinParticleFactory(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ZSpinParticleFactory", key_word_list))
            {
                ZSpinParticleFactory *return_value = new ZSpinParticleFactory();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ZSpinParticleFactory,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ZSpinParticleFactory::ZSpinParticleFactory(ZSpinParticleFactory const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ZSpinParticleFactory", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ZSpinParticleFactory", &param0));
                if(!PyErr_Occurred())
                {
                    ZSpinParticleFactory *param0_this = (ZSpinParticleFactory *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ZSpinParticleFactory, 0, "ZSpinParticleFactory.ZSpinParticleFactory", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ZSpinParticleFactory *return_value = new ZSpinParticleFactory(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ZSpinParticleFactory,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ZSpinParticleFactory() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ZSpinParticleFactory()\n"
          "ZSpinParticleFactory(const ZSpinParticleFactory copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ZSpinParticleFactory(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ZSpinParticleFactory)
    {
        printf("ZSpinParticleFactory ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ZSpinParticleFactory * local_this = (ZSpinParticleFactory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ZSpinParticleFactory)
        return local_this;
    if(requested_type == &Dtool_BaseParticleFactory)
        return ( BaseParticleFactory *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseParticleFactory *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ZSpinParticleFactory(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ZSpinParticleFactory)
        return from_this;
    if(from_type == &Dtool_BaseParticleFactory)
    {
          BaseParticleFactory* other_this = (BaseParticleFactory*)from_this;
          return (ZSpinParticleFactory*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ZSpinParticleFactory*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. BaseParticleEmitter | BaseParticleEmitter
//********************************************************************
PyMethodDef Dtool_Methods_BaseParticleEmitter[]= {
  { "makeCopy",(PyCFunction ) &Dtool_BaseParticleEmitter_make_copy_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_make_copy_4_comment},
  { "generate",(PyCFunction ) &Dtool_BaseParticleEmitter_generate_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_generate_5_comment},
  { "setEmissionType",(PyCFunction ) &Dtool_BaseParticleEmitter_set_emission_type_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_emission_type_6_comment},
  { "setAmplitude",(PyCFunction ) &Dtool_BaseParticleEmitter_set_amplitude_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_amplitude_7_comment},
  { "setAmplitudeSpread",(PyCFunction ) &Dtool_BaseParticleEmitter_set_amplitude_spread_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_amplitude_spread_8_comment},
  { "setOffsetForce",(PyCFunction ) &Dtool_BaseParticleEmitter_set_offset_force_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_offset_force_9_comment},
  { "setExplicitLaunchVector",(PyCFunction ) &Dtool_BaseParticleEmitter_set_explicit_launch_vector_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_explicit_launch_vector_10_comment},
  { "setRadiateOrigin",(PyCFunction ) &Dtool_BaseParticleEmitter_set_radiate_origin_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_set_radiate_origin_11_comment},
  { "getEmissionType",(PyCFunction ) &Dtool_BaseParticleEmitter_get_emission_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_emission_type_12_comment},
  { "getAmplitude",(PyCFunction ) &Dtool_BaseParticleEmitter_get_amplitude_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_amplitude_13_comment},
  { "getAmplitudeSpread",(PyCFunction ) &Dtool_BaseParticleEmitter_get_amplitude_spread_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_amplitude_spread_14_comment},
  { "getOffsetForce",(PyCFunction ) &Dtool_BaseParticleEmitter_get_offset_force_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_offset_force_15_comment},
  { "getExplicitLaunchVector",(PyCFunction ) &Dtool_BaseParticleEmitter_get_explicit_launch_vector_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_explicit_launch_vector_16_comment},
  { "getRadiateOrigin",(PyCFunction ) &Dtool_BaseParticleEmitter_get_radiate_origin_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_get_radiate_origin_17_comment},
  { "output",(PyCFunction ) &Dtool_BaseParticleEmitter_output_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_output_18_comment},
  { "write",(PyCFunction ) &Dtool_BaseParticleEmitter_write_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleEmitter_write_19_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BaseParticleEmitter
//////////////////
static PyObject *  Dtool_Repr_BaseParticleEmitter(PyObject * self)
{
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BaseParticleEmitter
//////////////////
static PyObject *  Dtool_Str_BaseParticleEmitter(PyObject * self)
{
    BaseParticleEmitter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleEmitter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BaseParticleEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BaseParticleEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////// //////\n"
          "//       Class : BaseParticleEmitter\n"
          "// Description : Describes a physical region in space in which\n"
          "//               particles are randomly generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BaseParticleEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BaseParticleEmitter.As_PyTypeObject().tp_repr = & Dtool_Repr_BaseParticleEmitter;
        // __str__
        Dtool_BaseParticleEmitter.As_PyTypeObject().tp_str = & Dtool_Str_BaseParticleEmitter;
        // Enum  BaseParticleEmitter::emissionType;
        PyDict_SetItemString(Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict,"ETEXPLICIT",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict,"ETRADIATE",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict,"ETCUSTOM",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_BaseParticleEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BaseParticleEmitter)");
             printf(" Error In PyType_ReadyBaseParticleEmitter");
             return;
        }
        Py_INCREF(&Dtool_BaseParticleEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BaseParticleEmitter.As_PyTypeObject().tp_dict,"BaseParticleEmitter",&Dtool_BaseParticleEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_BaseParticleEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BaseParticleEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "BaseParticleEmitter",(PyObject *)&Dtool_BaseParticleEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RingEmitter | RingEmitter
//********************************************************************
PyMethodDef Dtool_Methods_RingEmitter[]= {
  { "setRadius",(PyCFunction ) &Dtool_RingEmitter_set_radius_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_set_radius_22_comment},
  { "setAngle",(PyCFunction ) &Dtool_RingEmitter_set_angle_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_set_angle_23_comment},
  { "setRadiusSpread",(PyCFunction ) &Dtool_RingEmitter_set_radius_spread_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_set_radius_spread_24_comment},
  { "setUniformEmission",(PyCFunction ) &Dtool_RingEmitter_set_uniform_emission_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_set_uniform_emission_25_comment},
  { "getRadius",(PyCFunction ) &Dtool_RingEmitter_get_radius_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_get_radius_26_comment},
  { "getAngle",(PyCFunction ) &Dtool_RingEmitter_get_angle_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_get_angle_27_comment},
  { "getRadiusSpread",(PyCFunction ) &Dtool_RingEmitter_get_radius_spread_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_get_radius_spread_28_comment},
  { "getUniformEmission",(PyCFunction ) &Dtool_RingEmitter_get_uniform_emission_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RingEmitter_get_uniform_emission_29_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RingEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_RingEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_RingEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RingEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RingEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RingEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RingEmitter)");
             printf(" Error In PyType_ReadyRingEmitter");
             return;
        }
        Py_INCREF(&Dtool_RingEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RingEmitter.As_PyTypeObject().tp_dict,"RingEmitter",&Dtool_RingEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_RingEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RingEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "RingEmitter",(PyObject *)&Dtool_RingEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ArcEmitter | ArcEmitter
//********************************************************************
PyMethodDef Dtool_Methods_ArcEmitter[]= {
  { "setStartAngle",(PyCFunction ) &Dtool_ArcEmitter_set_start_angle_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ArcEmitter_set_start_angle_32_comment},
  { "setEndAngle",(PyCFunction ) &Dtool_ArcEmitter_set_end_angle_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ArcEmitter_set_end_angle_33_comment},
  { "setArc",(PyCFunction ) &Dtool_ArcEmitter_set_arc_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ArcEmitter_set_arc_34_comment},
  { "getStartAngle",(PyCFunction ) &Dtool_ArcEmitter_get_start_angle_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ArcEmitter_get_start_angle_35_comment},
  { "getEndAngle",(PyCFunction ) &Dtool_ArcEmitter_get_end_angle_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ArcEmitter_get_end_angle_36_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ArcEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_RingEmitter._Dtool_ClassInit(NULL);
        Dtool_ArcEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_RingEmitter.As_PyTypeObject());
        Dtool_ArcEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ArcEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ArcEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ArcEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ArcEmitter)");
             printf(" Error In PyType_ReadyArcEmitter");
             return;
        }
        Py_INCREF(&Dtool_ArcEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ArcEmitter.As_PyTypeObject().tp_dict,"ArcEmitter",&Dtool_ArcEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_ArcEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ArcEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "ArcEmitter",(PyObject *)&Dtool_ArcEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BaseParticleFactory | BaseParticleFactory
//********************************************************************
PyMethodDef Dtool_Methods_BaseParticleFactory[]= {
  { "setLifespanBase",(PyCFunction ) &Dtool_BaseParticleFactory_set_lifespan_base_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_lifespan_base_38_comment},
  { "setLifespanSpread",(PyCFunction ) &Dtool_BaseParticleFactory_set_lifespan_spread_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_lifespan_spread_39_comment},
  { "setMassBase",(PyCFunction ) &Dtool_BaseParticleFactory_set_mass_base_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_mass_base_40_comment},
  { "setMassSpread",(PyCFunction ) &Dtool_BaseParticleFactory_set_mass_spread_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_mass_spread_41_comment},
  { "setTerminalVelocityBase",(PyCFunction ) &Dtool_BaseParticleFactory_set_terminal_velocity_base_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_terminal_velocity_base_42_comment},
  { "setTerminalVelocitySpread",(PyCFunction ) &Dtool_BaseParticleFactory_set_terminal_velocity_spread_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_set_terminal_velocity_spread_43_comment},
  { "getLifespanBase",(PyCFunction ) &Dtool_BaseParticleFactory_get_lifespan_base_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_lifespan_base_44_comment},
  { "getLifespanSpread",(PyCFunction ) &Dtool_BaseParticleFactory_get_lifespan_spread_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_lifespan_spread_45_comment},
  { "getMassBase",(PyCFunction ) &Dtool_BaseParticleFactory_get_mass_base_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_mass_base_46_comment},
  { "getMassSpread",(PyCFunction ) &Dtool_BaseParticleFactory_get_mass_spread_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_mass_spread_47_comment},
  { "getTerminalVelocityBase",(PyCFunction ) &Dtool_BaseParticleFactory_get_terminal_velocity_base_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_terminal_velocity_base_48_comment},
  { "getTerminalVelocitySpread",(PyCFunction ) &Dtool_BaseParticleFactory_get_terminal_velocity_spread_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_get_terminal_velocity_spread_49_comment},
  { "output",(PyCFunction ) &Dtool_BaseParticleFactory_output_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_output_52_comment},
  { "write",(PyCFunction ) &Dtool_BaseParticleFactory_write_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleFactory_write_53_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BaseParticleFactory
//////////////////
static PyObject *  Dtool_Repr_BaseParticleFactory(PyObject * self)
{
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BaseParticleFactory
//////////////////
static PyObject *  Dtool_Str_BaseParticleFactory(PyObject * self)
{
    BaseParticleFactory * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleFactory,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BaseParticleFactory(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BaseParticleFactory.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BaseParticleFactory\n"
          "// Description : Pure Virtual base class for creating particles\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BaseParticleFactory.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_BaseParticleFactory.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BaseParticleFactory.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BaseParticleFactory.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BaseParticleFactory.As_PyTypeObject().tp_repr = & Dtool_Repr_BaseParticleFactory;
        // __str__
        Dtool_BaseParticleFactory.As_PyTypeObject().tp_str = & Dtool_Str_BaseParticleFactory;
        if(PyType_Ready(&Dtool_BaseParticleFactory.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BaseParticleFactory)");
             printf(" Error In PyType_ReadyBaseParticleFactory");
             return;
        }
        Py_INCREF(&Dtool_BaseParticleFactory.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BaseParticleFactory.As_PyTypeObject().tp_dict,"BaseParticleFactory",&Dtool_BaseParticleFactory.As_PyObject());
        RegisterRuntimeClass(&Dtool_BaseParticleFactory,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BaseParticleFactory.As_PyTypeObject());
        PyModule_AddObject(module, "BaseParticleFactory",(PyObject *)&Dtool_BaseParticleFactory.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BaseParticleRenderer | BaseParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_BaseParticleRenderer[]= {
  { "getRenderNode",(PyCFunction ) &Dtool_BaseParticleRenderer_get_render_node_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_get_render_node_57_comment},
  { "getRenderNodePath",(PyCFunction ) &Dtool_BaseParticleRenderer_get_render_node_path_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_get_render_node_path_58_comment},
  { "setAlphaMode",(PyCFunction ) &Dtool_BaseParticleRenderer_set_alpha_mode_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_set_alpha_mode_59_comment},
  { "getAlphaMode",(PyCFunction ) &Dtool_BaseParticleRenderer_get_alpha_mode_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_get_alpha_mode_60_comment},
  { "setUserAlpha",(PyCFunction ) &Dtool_BaseParticleRenderer_set_user_alpha_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_set_user_alpha_61_comment},
  { "getUserAlpha",(PyCFunction ) &Dtool_BaseParticleRenderer_get_user_alpha_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_get_user_alpha_62_comment},
  { "setColorBlendMode",(PyCFunction ) &Dtool_BaseParticleRenderer_set_color_blend_mode_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_set_color_blend_mode_63_comment},
  { "setIgnoreScale",(PyCFunction ) &Dtool_BaseParticleRenderer_set_ignore_scale_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_set_ignore_scale_64_comment},
  { "getIgnoreScale",(PyCFunction ) &Dtool_BaseParticleRenderer_get_ignore_scale_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_get_ignore_scale_65_comment},
  { "output",(PyCFunction ) &Dtool_BaseParticleRenderer_output_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_output_66_comment},
  { "write",(PyCFunction ) &Dtool_BaseParticleRenderer_write_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseParticleRenderer_write_67_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BaseParticleRenderer
//////////////////
static PyObject *  Dtool_Repr_BaseParticleRenderer(PyObject * self)
{
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BaseParticleRenderer
//////////////////
static PyObject *  Dtool_Str_BaseParticleRenderer(PyObject * self)
{
    BaseParticleRenderer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseParticleRenderer,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BaseParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BaseParticleRenderer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BaseParticleRenderer\n"
          "// Description : Pure virtual particle renderer base class\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BaseParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BaseParticleRenderer.As_PyTypeObject().tp_repr = & Dtool_Repr_BaseParticleRenderer;
        // __str__
        Dtool_BaseParticleRenderer.As_PyTypeObject().tp_str = & Dtool_Str_BaseParticleRenderer;
        // Enum  BaseParticleRenderer::ParticleRendererAlphaMode;
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRALPHANONE",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRALPHAOUT",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRALPHAIN",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRALPHAINOUT",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRALPHAUSER",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PRNOTINITIALIZEDYET",PyInt_FromLong(5));
        // Enum  BaseParticleRenderer::ParticleRendererBlendMethod;
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PPNOBLEND",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PPBLENDLINEAR",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"PPBLENDCUBIC",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_BaseParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BaseParticleRenderer)");
             printf(" Error In PyType_ReadyBaseParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_BaseParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BaseParticleRenderer.As_PyTypeObject().tp_dict,"BaseParticleRenderer",&Dtool_BaseParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_BaseParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BaseParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "BaseParticleRenderer",(PyObject *)&Dtool_BaseParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoxEmitter | BoxEmitter
//********************************************************************
PyMethodDef Dtool_Methods_BoxEmitter[]= {
  { "setMinBound",(PyCFunction ) &Dtool_BoxEmitter_set_min_bound_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoxEmitter_set_min_bound_70_comment},
  { "setMaxBound",(PyCFunction ) &Dtool_BoxEmitter_set_max_bound_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoxEmitter_set_max_bound_71_comment},
  { "getMinBound",(PyCFunction ) &Dtool_BoxEmitter_get_min_bound_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoxEmitter_get_min_bound_72_comment},
  { "getMaxBound",(PyCFunction ) &Dtool_BoxEmitter_get_max_bound_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoxEmitter_get_max_bound_73_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoxEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoxEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoxEmitter\n"
          "// Description : Describes a voluminous box region in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_BoxEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_BoxEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoxEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoxEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoxEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoxEmitter)");
             printf(" Error In PyType_ReadyBoxEmitter");
             return;
        }
        Py_INCREF(&Dtool_BoxEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoxEmitter.As_PyTypeObject().tp_dict,"BoxEmitter",&Dtool_BoxEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_BoxEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoxEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "BoxEmitter",(PyObject *)&Dtool_BoxEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationFunctionConstant | ColorInterpolationFunctionConstant
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationFunctionConstant[]= {
  { "getColorA",(PyCFunction ) &Dtool_ColorInterpolationFunctionConstant_get_color_a_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionConstant_get_color_a_76_comment},
  { "setColorA",(PyCFunction ) &Dtool_ColorInterpolationFunctionConstant_set_color_a_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionConstant_set_color_a_77_comment},
  { "getClassType",(PyCFunction ) &Dtool_ColorInterpolationFunctionConstant_get_class_type_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionConstant_get_class_type_78_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationFunctionConstant\n"
          "// Description : Defines a constant color over the lifetime of\n"
          "//               the segment.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationFunctionConstant)");
             printf(" Error In PyType_ReadyColorInterpolationFunctionConstant");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_dict,"ColorInterpolationFunctionConstant",&Dtool_ColorInterpolationFunctionConstant.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ColorInterpolationFunctionConstant[2],&Dtool_ColorInterpolationFunctionConstant.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ColorInterpolationFunctionConstant,ColorInterpolationFunctionConstant::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationFunctionConstant",(PyObject *)&Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationFunctionLinear | ColorInterpolationFunctionLinear
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationFunctionLinear[]= {
  { "getColorB",(PyCFunction ) &Dtool_ColorInterpolationFunctionLinear_get_color_b_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionLinear_get_color_b_81_comment},
  { "setColorB",(PyCFunction ) &Dtool_ColorInterpolationFunctionLinear_set_color_b_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionLinear_set_color_b_82_comment},
  { "getClassType",(PyCFunction ) &Dtool_ColorInterpolationFunctionLinear_get_class_type_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionLinear_get_class_type_83_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationFunctionLinear\n"
          "// Description : Defines a linear interpolation over the lifetime of\n"
          "//               the segment.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ColorInterpolationFunctionConstant._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ColorInterpolationFunctionConstant.As_PyTypeObject());
        Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationFunctionLinear)");
             printf(" Error In PyType_ReadyColorInterpolationFunctionLinear");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_dict,"ColorInterpolationFunctionLinear",&Dtool_ColorInterpolationFunctionLinear.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ColorInterpolationFunctionLinear[2],&Dtool_ColorInterpolationFunctionLinear.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ColorInterpolationFunctionLinear,ColorInterpolationFunctionLinear::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationFunctionLinear",(PyObject *)&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationFunctionStepwave | ColorInterpolationFunctionStepwave
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationFunctionStepwave[]= {
  { "getWidthA",(PyCFunction ) &Dtool_ColorInterpolationFunctionStepwave_get_width_a_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionStepwave_get_width_a_86_comment},
  { "getWidthB",(PyCFunction ) &Dtool_ColorInterpolationFunctionStepwave_get_width_b_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionStepwave_get_width_b_87_comment},
  { "setWidthA",(PyCFunction ) &Dtool_ColorInterpolationFunctionStepwave_set_width_a_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionStepwave_set_width_a_88_comment},
  { "setWidthB",(PyCFunction ) &Dtool_ColorInterpolationFunctionStepwave_set_width_b_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionStepwave_set_width_b_89_comment},
  { "getClassType",(PyCFunction ) &Dtool_ColorInterpolationFunctionStepwave_get_class_type_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionStepwave_get_class_type_90_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationFunctionStepwave\n"
          "// Description : Defines a discrete cyclical transition between two colors.\n"
          "//               The widths describe a portion of the segment's lifetime\n"
          "//               for which the corresponding color should be selected. If\n"
          "//               their sum is less than 1, the function repeats until\n"
          "//               the end of the segment.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ColorInterpolationFunctionLinear._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject());
        Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationFunctionStepwave)");
             printf(" Error In PyType_ReadyColorInterpolationFunctionStepwave");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_dict,"ColorInterpolationFunctionStepwave",&Dtool_ColorInterpolationFunctionStepwave.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ColorInterpolationFunctionStepwave[4],&Dtool_ColorInterpolationFunctionStepwave.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ColorInterpolationFunctionStepwave,ColorInterpolationFunctionStepwave::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationFunctionStepwave",(PyObject *)&Dtool_ColorInterpolationFunctionStepwave.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationFunctionSinusoid | ColorInterpolationFunctionSinusoid
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationFunctionSinusoid[]= {
  { "getPeriod",(PyCFunction ) &Dtool_ColorInterpolationFunctionSinusoid_get_period_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionSinusoid_get_period_93_comment},
  { "setPeriod",(PyCFunction ) &Dtool_ColorInterpolationFunctionSinusoid_set_period_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionSinusoid_set_period_94_comment},
  { "getClassType",(PyCFunction ) &Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationFunctionSinusoid_get_class_type_95_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationFunctionSinusoid\n"
          "// Description : Defines a sinusoidal blending between two colors.\n"
          "//               A period of \"1\" corresponds to a single transition \n"
          "//               from color_a to color_b and then back to color_a \n"
          "//               over the course of the segment's lifetime. A \n"
          "//               shorter period will result in a higher frequency\n"
          "//               cycle.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ColorInterpolationFunctionLinear._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ColorInterpolationFunctionLinear.As_PyTypeObject());
        Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationFunctionSinusoid)");
             printf(" Error In PyType_ReadyColorInterpolationFunctionSinusoid");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_dict,"ColorInterpolationFunctionSinusoid",&Dtool_ColorInterpolationFunctionSinusoid.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ColorInterpolationFunctionSinusoid[2],&Dtool_ColorInterpolationFunctionSinusoid.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ColorInterpolationFunctionSinusoid,ColorInterpolationFunctionSinusoid::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationFunctionSinusoid",(PyObject *)&Dtool_ColorInterpolationFunctionSinusoid.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationSegment | ColorInterpolationSegment
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationSegment[]= {
  { "getFunction",(PyCFunction ) &Dtool_ColorInterpolationSegment_get_function_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_get_function_99_comment},
  { "getTimeBegin",(PyCFunction ) &Dtool_ColorInterpolationSegment_get_time_begin_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_get_time_begin_100_comment},
  { "getTimeEnd",(PyCFunction ) &Dtool_ColorInterpolationSegment_get_time_end_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_get_time_end_101_comment},
  { "isModulated",(PyCFunction ) &Dtool_ColorInterpolationSegment_is_modulated_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_is_modulated_102_comment},
  { "getId",(PyCFunction ) &Dtool_ColorInterpolationSegment_get_id_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_get_id_103_comment},
  { "isEnabled",(PyCFunction ) &Dtool_ColorInterpolationSegment_is_enabled_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_is_enabled_104_comment},
  { "setTimeBegin",(PyCFunction ) &Dtool_ColorInterpolationSegment_set_time_begin_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_set_time_begin_106_comment},
  { "setTimeEnd",(PyCFunction ) &Dtool_ColorInterpolationSegment_set_time_end_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_set_time_end_107_comment},
  { "setIsModulated",(PyCFunction ) &Dtool_ColorInterpolationSegment_set_is_modulated_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_set_is_modulated_108_comment},
  { "setEnabled",(PyCFunction ) &Dtool_ColorInterpolationSegment_set_enabled_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationSegment_set_enabled_109_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationSegment(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationSegment\n"
          "// Description : A single unit of interpolation. The begin and end\n"
          "//               times are interpolated over the lifetime of the \n"
          "//               particle, thus have the range of [0,1]. Each segment\n"
          "//               also has a function associated with it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationSegment.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationSegment)");
             printf(" Error In PyType_ReadyColorInterpolationSegment");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationSegment.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationSegment.As_PyTypeObject().tp_dict,"ColorInterpolationSegment",&Dtool_ColorInterpolationSegment.As_PyObject());
        RegisterRuntimeClass(&Dtool_ColorInterpolationSegment,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationSegment.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationSegment",(PyObject *)&Dtool_ColorInterpolationSegment.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ColorInterpolationManager | ColorInterpolationManager
//********************************************************************
PyMethodDef Dtool_Methods_ColorInterpolationManager[]= {
  { "addConstant",(PyCFunction ) &Dtool_ColorInterpolationManager_add_constant_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_add_constant_112_comment},
  { "addLinear",(PyCFunction ) &Dtool_ColorInterpolationManager_add_linear_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_add_linear_113_comment},
  { "addStepwave",(PyCFunction ) &Dtool_ColorInterpolationManager_add_stepwave_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_add_stepwave_114_comment},
  { "addSinusoid",(PyCFunction ) &Dtool_ColorInterpolationManager_add_sinusoid_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_add_sinusoid_115_comment},
  { "setDefaultColor",(PyCFunction ) &Dtool_ColorInterpolationManager_set_default_color_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_set_default_color_116_comment},
  { "getSegment",(PyCFunction ) &Dtool_ColorInterpolationManager_get_segment_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_get_segment_117_comment},
  { "getSegmentIdList",(PyCFunction ) &Dtool_ColorInterpolationManager_get_segment_id_list_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_get_segment_id_list_118_comment},
  { "clearSegment",(PyCFunction ) &Dtool_ColorInterpolationManager_clear_segment_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_clear_segment_119_comment},
  { "clearToInitial",(PyCFunction ) &Dtool_ColorInterpolationManager_clear_to_initial_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ColorInterpolationManager_clear_to_initial_120_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ColorInterpolationManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ColorInterpolationManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ColorInterpolationManager\n"
          "// Description : High level class for color interpolation.  Segments\n"
          "//               must be added to the manager in order to achieve\n"
          "//               results using the \"add_*****()\" functions.  Access\n"
          "//               to these segments is provided but not necessary\n"
          "//               general use.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ColorInterpolationManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_ColorInterpolationManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ColorInterpolationManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ColorInterpolationManager.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ColorInterpolationManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ColorInterpolationManager)");
             printf(" Error In PyType_ReadyColorInterpolationManager");
             return;
        }
        Py_INCREF(&Dtool_ColorInterpolationManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ColorInterpolationManager.As_PyTypeObject().tp_dict,"ColorInterpolationManager",&Dtool_ColorInterpolationManager.As_PyObject());
        RegisterRuntimeClass(&Dtool_ColorInterpolationManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ColorInterpolationManager.As_PyTypeObject());
        PyModule_AddObject(module, "ColorInterpolationManager",(PyObject *)&Dtool_ColorInterpolationManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DiscEmitter | DiscEmitter
//********************************************************************
PyMethodDef Dtool_Methods_DiscEmitter[]= {
  { "setRadius",(PyCFunction ) &Dtool_DiscEmitter_set_radius_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_radius_123_comment},
  { "setOuterAngle",(PyCFunction ) &Dtool_DiscEmitter_set_outer_angle_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_outer_angle_124_comment},
  { "setInnerAngle",(PyCFunction ) &Dtool_DiscEmitter_set_inner_angle_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_inner_angle_125_comment},
  { "setOuterMagnitude",(PyCFunction ) &Dtool_DiscEmitter_set_outer_magnitude_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_outer_magnitude_126_comment},
  { "setInnerMagnitude",(PyCFunction ) &Dtool_DiscEmitter_set_inner_magnitude_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_inner_magnitude_127_comment},
  { "setCubicLerping",(PyCFunction ) &Dtool_DiscEmitter_set_cubic_lerping_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_set_cubic_lerping_128_comment},
  { "getRadius",(PyCFunction ) &Dtool_DiscEmitter_get_radius_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_radius_129_comment},
  { "getOuterAngle",(PyCFunction ) &Dtool_DiscEmitter_get_outer_angle_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_outer_angle_130_comment},
  { "getInnerAngle",(PyCFunction ) &Dtool_DiscEmitter_get_inner_angle_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_inner_angle_131_comment},
  { "getOuterMagnitude",(PyCFunction ) &Dtool_DiscEmitter_get_outer_magnitude_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_outer_magnitude_132_comment},
  { "getInnerMagnitude",(PyCFunction ) &Dtool_DiscEmitter_get_inner_magnitude_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_inner_magnitude_133_comment},
  { "getCubicLerping",(PyCFunction ) &Dtool_DiscEmitter_get_cubic_lerping_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DiscEmitter_get_cubic_lerping_134_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DiscEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DiscEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DiscEmitter\n"
          "// Description : Describes a planar disc region from which particles\n"
          "//               are generated\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_DiscEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_DiscEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DiscEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DiscEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DiscEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DiscEmitter)");
             printf(" Error In PyType_ReadyDiscEmitter");
             return;
        }
        Py_INCREF(&Dtool_DiscEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DiscEmitter.As_PyTypeObject().tp_dict,"DiscEmitter",&Dtool_DiscEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DiscEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DiscEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "DiscEmitter",(PyObject *)&Dtool_DiscEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GeomParticleRenderer | GeomParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_GeomParticleRenderer[]= {
  { "setGeomNode",(PyCFunction ) &Dtool_GeomParticleRenderer_set_geom_node_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_geom_node_137_comment},
  { "getGeomNode",(PyCFunction ) &Dtool_GeomParticleRenderer_get_geom_node_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_geom_node_138_comment},
  { "getColorInterpolationManager",(PyCFunction ) &Dtool_GeomParticleRenderer_get_color_interpolation_manager_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_color_interpolation_manager_139_comment},
  { "setXScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_set_x_scale_flag_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_x_scale_flag_140_comment},
  { "setYScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_set_y_scale_flag_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_y_scale_flag_141_comment},
  { "setZScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_set_z_scale_flag_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_z_scale_flag_142_comment},
  { "setInitialXScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_initial_x_scale_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_initial_x_scale_143_comment},
  { "setFinalXScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_final_x_scale_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_final_x_scale_144_comment},
  { "setInitialYScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_initial_y_scale_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_initial_y_scale_145_comment},
  { "setFinalYScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_final_y_scale_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_final_y_scale_146_comment},
  { "setInitialZScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_initial_z_scale_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_initial_z_scale_147_comment},
  { "setFinalZScale",(PyCFunction ) &Dtool_GeomParticleRenderer_set_final_z_scale_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_set_final_z_scale_148_comment},
  { "getXScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_get_x_scale_flag_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_x_scale_flag_149_comment},
  { "getYScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_get_y_scale_flag_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_y_scale_flag_150_comment},
  { "getZScaleFlag",(PyCFunction ) &Dtool_GeomParticleRenderer_get_z_scale_flag_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_z_scale_flag_151_comment},
  { "getInitialXScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_initial_x_scale_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_initial_x_scale_152_comment},
  { "getFinalXScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_final_x_scale_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_final_x_scale_153_comment},
  { "getInitialYScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_initial_y_scale_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_initial_y_scale_154_comment},
  { "getFinalYScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_final_y_scale_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_final_y_scale_155_comment},
  { "getInitialZScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_initial_z_scale_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_initial_z_scale_156_comment},
  { "getFinalZScale",(PyCFunction ) &Dtool_GeomParticleRenderer_get_final_z_scale_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeomParticleRenderer_get_final_z_scale_157_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GeomParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_BaseParticleRenderer._Dtool_ClassInit(NULL);
        Dtool_GeomParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleRenderer.As_PyTypeObject());
        Dtool_GeomParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GeomParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GeomParticleRenderer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GeomParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GeomParticleRenderer)");
             printf(" Error In PyType_ReadyGeomParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_GeomParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GeomParticleRenderer.As_PyTypeObject().tp_dict,"GeomParticleRenderer",&Dtool_GeomParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_GeomParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GeomParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "GeomParticleRenderer",(PyObject *)&Dtool_GeomParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LineEmitter | LineEmitter
//********************************************************************
PyMethodDef Dtool_Methods_LineEmitter[]= {
  { "setEndpoint1",(PyCFunction ) &Dtool_LineEmitter_set_endpoint1_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineEmitter_set_endpoint1_160_comment},
  { "setEndpoint2",(PyCFunction ) &Dtool_LineEmitter_set_endpoint2_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineEmitter_set_endpoint2_161_comment},
  { "getEndpoint1",(PyCFunction ) &Dtool_LineEmitter_get_endpoint1_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineEmitter_get_endpoint1_162_comment},
  { "getEndpoint2",(PyCFunction ) &Dtool_LineEmitter_get_endpoint2_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineEmitter_get_endpoint2_163_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LineEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LineEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LineEmitter\n"
          "// Description : Describes a linear region in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_LineEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_LineEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LineEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LineEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LineEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LineEmitter)");
             printf(" Error In PyType_ReadyLineEmitter");
             return;
        }
        Py_INCREF(&Dtool_LineEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LineEmitter.As_PyTypeObject().tp_dict,"LineEmitter",&Dtool_LineEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_LineEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LineEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "LineEmitter",(PyObject *)&Dtool_LineEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LineParticleRenderer | LineParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_LineParticleRenderer[]= {
  { "setHeadColor",(PyCFunction ) &Dtool_LineParticleRenderer_set_head_color_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_set_head_color_166_comment},
  { "setTailColor",(PyCFunction ) &Dtool_LineParticleRenderer_set_tail_color_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_set_tail_color_167_comment},
  { "getHeadColor",(PyCFunction ) &Dtool_LineParticleRenderer_get_head_color_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_get_head_color_168_comment},
  { "getTailColor",(PyCFunction ) &Dtool_LineParticleRenderer_get_tail_color_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_get_tail_color_169_comment},
  { "setLineScaleFactor",(PyCFunction ) &Dtool_LineParticleRenderer_set_line_scale_factor_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_set_line_scale_factor_170_comment},
  { "getLineScaleFactor",(PyCFunction ) &Dtool_LineParticleRenderer_get_line_scale_factor_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LineParticleRenderer_get_line_scale_factor_171_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LineParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LineParticleRenderer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LineParticleRenderer\n"
          "// Description : renders a line from last position to current\n"
          "//               position -- good for rain, sparks, etc.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleRenderer._Dtool_ClassInit(NULL);
        Dtool_LineParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleRenderer.As_PyTypeObject());
        Dtool_LineParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LineParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LineParticleRenderer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LineParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LineParticleRenderer)");
             printf(" Error In PyType_ReadyLineParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_LineParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LineParticleRenderer.As_PyTypeObject().tp_dict,"LineParticleRenderer",&Dtool_LineParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_LineParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LineParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "LineParticleRenderer",(PyObject *)&Dtool_LineParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ParticleSystem | ParticleSystem
//********************************************************************
PyMethodDef Dtool_Methods_ParticleSystem[]= {
  { "setPoolSize",(PyCFunction ) &Dtool_ParticleSystem_set_pool_size_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_pool_size_175_comment},
  { "setBirthRate",(PyCFunction ) &Dtool_ParticleSystem_set_birth_rate_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_birth_rate_176_comment},
  { "setSoftBirthRate",(PyCFunction ) &Dtool_ParticleSystem_set_soft_birth_rate_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_soft_birth_rate_177_comment},
  { "setLitterSize",(PyCFunction ) &Dtool_ParticleSystem_set_litter_size_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_litter_size_178_comment},
  { "setLitterSpread",(PyCFunction ) &Dtool_ParticleSystem_set_litter_spread_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_litter_spread_179_comment},
  { "setLocalVelocityFlag",(PyCFunction ) &Dtool_ParticleSystem_set_local_velocity_flag_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_local_velocity_flag_180_comment},
  { "setSystemGrowsOlderFlag",(PyCFunction ) &Dtool_ParticleSystem_set_system_grows_older_flag_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_system_grows_older_flag_181_comment},
  { "setSystemLifespan",(PyCFunction ) &Dtool_ParticleSystem_set_system_lifespan_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_system_lifespan_182_comment},
  { "setSystemAge",(PyCFunction ) &Dtool_ParticleSystem_set_system_age_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_system_age_183_comment},
  { "setActiveSystemFlag",(PyCFunction ) &Dtool_ParticleSystem_set_active_system_flag_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_active_system_flag_184_comment},
  { "setSpawnOnDeathFlag",(PyCFunction ) &Dtool_ParticleSystem_set_spawn_on_death_flag_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_spawn_on_death_flag_185_comment},
  { "setSpawnRenderNode",(PyCFunction ) &Dtool_ParticleSystem_set_spawn_render_node_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_spawn_render_node_186_comment},
  { "setSpawnRenderNodePath",(PyCFunction ) &Dtool_ParticleSystem_set_spawn_render_node_path_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_spawn_render_node_path_187_comment},
  { "setTemplateSystemFlag",(PyCFunction ) &Dtool_ParticleSystem_set_template_system_flag_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_template_system_flag_188_comment},
  { "setRenderParent",(PyCFunction ) &Dtool_ParticleSystem_set_render_parent_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_render_parent_189_comment},
  { "setRenderer",(PyCFunction ) &Dtool_ParticleSystem_set_renderer_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_renderer_190_comment},
  { "setEmitter",(PyCFunction ) &Dtool_ParticleSystem_set_emitter_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_emitter_191_comment},
  { "setFactory",(PyCFunction ) &Dtool_ParticleSystem_set_factory_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_factory_192_comment},
  { "setFloorZ",(PyCFunction ) &Dtool_ParticleSystem_set_floor_z_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_set_floor_z_193_comment},
  { "clearFloorZ",(PyCFunction ) &Dtool_ParticleSystem_clear_floor_z_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_clear_floor_z_194_comment},
  { "getPoolSize",(PyCFunction ) &Dtool_ParticleSystem_get_pool_size_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_pool_size_195_comment},
  { "getBirthRate",(PyCFunction ) &Dtool_ParticleSystem_get_birth_rate_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_birth_rate_196_comment},
  { "getSoftBirthRate",(PyCFunction ) &Dtool_ParticleSystem_get_soft_birth_rate_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_soft_birth_rate_197_comment},
  { "getLitterSize",(PyCFunction ) &Dtool_ParticleSystem_get_litter_size_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_litter_size_198_comment},
  { "getLitterSpread",(PyCFunction ) &Dtool_ParticleSystem_get_litter_spread_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_litter_spread_199_comment},
  { "getLocalVelocityFlag",(PyCFunction ) &Dtool_ParticleSystem_get_local_velocity_flag_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_local_velocity_flag_200_comment},
  { "getSystemGrowsOlderFlag",(PyCFunction ) &Dtool_ParticleSystem_get_system_grows_older_flag_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_system_grows_older_flag_201_comment},
  { "getSystemLifespan",(PyCFunction ) &Dtool_ParticleSystem_get_system_lifespan_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_system_lifespan_202_comment},
  { "getSystemAge",(PyCFunction ) &Dtool_ParticleSystem_get_system_age_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_system_age_203_comment},
  { "getActiveSystemFlag",(PyCFunction ) &Dtool_ParticleSystem_get_active_system_flag_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_active_system_flag_204_comment},
  { "getSpawnOnDeathFlag",(PyCFunction ) &Dtool_ParticleSystem_get_spawn_on_death_flag_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_spawn_on_death_flag_205_comment},
  { "getSpawnRenderNode",(PyCFunction ) &Dtool_ParticleSystem_get_spawn_render_node_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_spawn_render_node_206_comment},
  { "getSpawnRenderNodePath",(PyCFunction ) &Dtool_ParticleSystem_get_spawn_render_node_path_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_spawn_render_node_path_207_comment},
  { "getIWasSpawnedFlag",(PyCFunction ) &Dtool_ParticleSystem_get_i_was_spawned_flag_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_i_was_spawned_flag_208_comment},
  { "getLivingParticles",(PyCFunction ) &Dtool_ParticleSystem_get_living_particles_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_living_particles_209_comment},
  { "getRenderParent",(PyCFunction ) &Dtool_ParticleSystem_get_render_parent_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_render_parent_210_comment},
  { "getRenderer",(PyCFunction ) &Dtool_ParticleSystem_get_renderer_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_renderer_211_comment},
  { "getEmitter",(PyCFunction ) &Dtool_ParticleSystem_get_emitter_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_emitter_212_comment},
  { "getFactory",(PyCFunction ) &Dtool_ParticleSystem_get_factory_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_factory_213_comment},
  { "getFloorZ",(PyCFunction ) &Dtool_ParticleSystem_get_floor_z_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_floor_z_214_comment},
  { "addSpawnTemplate",(PyCFunction ) &Dtool_ParticleSystem_add_spawn_template_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_add_spawn_template_215_comment},
  { "clearSpawnTemplates",(PyCFunction ) &Dtool_ParticleSystem_clear_spawn_templates_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_clear_spawn_templates_216_comment},
  { "render",(PyCFunction ) &Dtool_ParticleSystem_render_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_render_217_comment},
  { "induceLabor",(PyCFunction ) &Dtool_ParticleSystem_induce_labor_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_induce_labor_218_comment},
  { "clearToInitial",(PyCFunction ) &Dtool_ParticleSystem_clear_to_initial_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_clear_to_initial_219_comment},
  { "softStop",(PyCFunction ) &Dtool_ParticleSystem_soft_stop_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_soft_stop_220_comment},
  { "softStart",(PyCFunction ) &Dtool_ParticleSystem_soft_start_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_soft_start_221_comment},
  { "update",(PyCFunction ) &Dtool_ParticleSystem_update_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_update_222_comment},
  { "writeFreeParticleFifo",(PyCFunction ) &Dtool_ParticleSystem_write_free_particle_fifo_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_write_free_particle_fifo_223_comment},
  { "writeSpawnTemplates",(PyCFunction ) &Dtool_ParticleSystem_write_spawn_templates_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_write_spawn_templates_224_comment},
  { "write",(PyCFunction ) &Dtool_ParticleSystem_write_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_write_225_comment},
  { "getClassType",(PyCFunction ) &Dtool_ParticleSystem_get_class_type_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystem_get_class_type_226_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     ParticleSystem
//////////////////
static PyObject *  Dtool_Str_ParticleSystem(PyObject * self)
{
    ParticleSystem * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystem,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ParticleSystem(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ParticleSystem.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ParticleSystem\n"
          "// Description : Contains and manages a particle system.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Physical._Dtool_ClassInit(NULL);
        Dtool_ParticleSystem.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Physical.As_PyTypeObject());
        Dtool_ParticleSystem.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ParticleSystem.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ParticleSystem.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_ParticleSystem.As_PyTypeObject().tp_str = & Dtool_Str_ParticleSystem;
        if(PyType_Ready(&Dtool_ParticleSystem.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ParticleSystem)");
             printf(" Error In PyType_ReadyParticleSystem");
             return;
        }
        Py_INCREF(&Dtool_ParticleSystem.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ParticleSystem.As_PyTypeObject().tp_dict,"ParticleSystem",&Dtool_ParticleSystem.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ParticleSystem.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ParticleSystem[51],&Dtool_ParticleSystem.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ParticleSystem,ParticleSystem::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ParticleSystem.As_PyTypeObject());
        PyModule_AddObject(module, "ParticleSystem",(PyObject *)&Dtool_ParticleSystem.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ParticleSystemManager | ParticleSystemManager
//********************************************************************
PyMethodDef Dtool_Methods_ParticleSystemManager[]= {
  { "setFrameStepping",(PyCFunction ) &Dtool_ParticleSystemManager_set_frame_stepping_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_set_frame_stepping_230_comment},
  { "getFrameStepping",(PyCFunction ) &Dtool_ParticleSystemManager_get_frame_stepping_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_get_frame_stepping_231_comment},
  { "attachParticlesystem",(PyCFunction ) &Dtool_ParticleSystemManager_attach_particlesystem_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_attach_particlesystem_232_comment},
  { "removeParticlesystem",(PyCFunction ) &Dtool_ParticleSystemManager_remove_particlesystem_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_remove_particlesystem_233_comment},
  { "clear",(PyCFunction ) &Dtool_ParticleSystemManager_clear_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_clear_234_comment},
  { "doParticles",(PyCFunction ) &Dtool_ParticleSystemManager_do_particles_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_do_particles_235_comment},
  { "output",(PyCFunction ) &Dtool_ParticleSystemManager_output_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_output_236_comment},
  { "writePsList",(PyCFunction ) &Dtool_ParticleSystemManager_write_ps_list_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_write_ps_list_237_comment},
  { "write",(PyCFunction ) &Dtool_ParticleSystemManager_write_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ParticleSystemManager_write_238_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ParticleSystemManager
//////////////////
static PyObject *  Dtool_Repr_ParticleSystemManager(PyObject * self)
{
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     ParticleSystemManager
//////////////////
static PyObject *  Dtool_Str_ParticleSystemManager(PyObject * self)
{
    ParticleSystemManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ParticleSystemManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ParticleSystemManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ParticleSystemManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ParticleSystemManager\n"
          "// Description : Manages a set of individual ParticleSystem objects,\n"
          "//               so that each individual one doesn't have to be\n"
          "//               updated and rendered every frame\n"
          "//    See Also : particleSystemManager.cxx\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ParticleSystemManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ParticleSystemManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ParticleSystemManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ParticleSystemManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ParticleSystemManager.As_PyTypeObject().tp_repr = & Dtool_Repr_ParticleSystemManager;
        // __str__
        Dtool_ParticleSystemManager.As_PyTypeObject().tp_str = & Dtool_Str_ParticleSystemManager;
        if(PyType_Ready(&Dtool_ParticleSystemManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ParticleSystemManager)");
             printf(" Error In PyType_ReadyParticleSystemManager");
             return;
        }
        Py_INCREF(&Dtool_ParticleSystemManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ParticleSystemManager.As_PyTypeObject().tp_dict,"ParticleSystemManager",&Dtool_ParticleSystemManager.As_PyObject());
        RegisterRuntimeClass(&Dtool_ParticleSystemManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ParticleSystemManager.As_PyTypeObject());
        PyModule_AddObject(module, "ParticleSystemManager",(PyObject *)&Dtool_ParticleSystemManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointEmitter | PointEmitter
//********************************************************************
PyMethodDef Dtool_Methods_PointEmitter[]= {
  { "setLocation",(PyCFunction ) &Dtool_PointEmitter_set_location_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointEmitter_set_location_241_comment},
  { "getLocation",(PyCFunction ) &Dtool_PointEmitter_get_location_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointEmitter_get_location_242_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointEmitter\n"
          "// Description : Describes a planar ring region in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_PointEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_PointEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointEmitter)");
             printf(" Error In PyType_ReadyPointEmitter");
             return;
        }
        Py_INCREF(&Dtool_PointEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointEmitter.As_PyTypeObject().tp_dict,"PointEmitter",&Dtool_PointEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "PointEmitter",(PyObject *)&Dtool_PointEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointParticleFactory | PointParticleFactory
//********************************************************************
PyMethodDef Dtool_Methods_PointParticleFactory[]= {
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointParticleFactory(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointParticleFactory.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointParticleFactory\n"
          "// Description : Creates point particles to user specs\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleFactory._Dtool_ClassInit(NULL);
        Dtool_PointParticleFactory.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleFactory.As_PyTypeObject());
        Dtool_PointParticleFactory.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointParticleFactory.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointParticleFactory.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointParticleFactory.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointParticleFactory)");
             printf(" Error In PyType_ReadyPointParticleFactory");
             return;
        }
        Py_INCREF(&Dtool_PointParticleFactory.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointParticleFactory.As_PyTypeObject().tp_dict,"PointParticleFactory",&Dtool_PointParticleFactory.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointParticleFactory,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointParticleFactory.As_PyTypeObject());
        PyModule_AddObject(module, "PointParticleFactory",(PyObject *)&Dtool_PointParticleFactory.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointParticleRenderer | PointParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_PointParticleRenderer[]= {
  { "setPointSize",(PyCFunction ) &Dtool_PointParticleRenderer_set_point_size_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_set_point_size_248_comment},
  { "setStartColor",(PyCFunction ) &Dtool_PointParticleRenderer_set_start_color_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_set_start_color_249_comment},
  { "setEndColor",(PyCFunction ) &Dtool_PointParticleRenderer_set_end_color_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_set_end_color_250_comment},
  { "setBlendType",(PyCFunction ) &Dtool_PointParticleRenderer_set_blend_type_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_set_blend_type_251_comment},
  { "setBlendMethod",(PyCFunction ) &Dtool_PointParticleRenderer_set_blend_method_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_set_blend_method_252_comment},
  { "getPointSize",(PyCFunction ) &Dtool_PointParticleRenderer_get_point_size_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_get_point_size_253_comment},
  { "getStartColor",(PyCFunction ) &Dtool_PointParticleRenderer_get_start_color_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_get_start_color_254_comment},
  { "getEndColor",(PyCFunction ) &Dtool_PointParticleRenderer_get_end_color_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_get_end_color_255_comment},
  { "getBlendType",(PyCFunction ) &Dtool_PointParticleRenderer_get_blend_type_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_get_blend_type_256_comment},
  { "getBlendMethod",(PyCFunction ) &Dtool_PointParticleRenderer_get_blend_method_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointParticleRenderer_get_blend_method_257_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointParticleRenderer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointParticleRenderer\n"
          "// Description : Simple point/point particle renderer.  Does NOT\n"
          "//               handle billboards- use BillboardParticleRenderer\n"
          "//               for that.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleRenderer._Dtool_ClassInit(NULL);
        Dtool_PointParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleRenderer.As_PyTypeObject());
        Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict);
        // Enum  PointParticleRenderer::PointParticleBlendType;
        PyDict_SetItemString(Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict,"PPONECOLOR",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict,"PPBLENDLIFE",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict,"PPBLENDVEL",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_PointParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointParticleRenderer)");
             printf(" Error In PyType_ReadyPointParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_PointParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointParticleRenderer.As_PyTypeObject().tp_dict,"PointParticleRenderer",&Dtool_PointParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "PointParticleRenderer",(PyObject *)&Dtool_PointParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. RectangleEmitter | RectangleEmitter
//********************************************************************
PyMethodDef Dtool_Methods_RectangleEmitter[]= {
  { "setMinBound",(PyCFunction ) &Dtool_RectangleEmitter_set_min_bound_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RectangleEmitter_set_min_bound_260_comment},
  { "setMaxBound",(PyCFunction ) &Dtool_RectangleEmitter_set_max_bound_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RectangleEmitter_set_max_bound_261_comment},
  { "getMinBound",(PyCFunction ) &Dtool_RectangleEmitter_get_min_bound_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RectangleEmitter_get_min_bound_262_comment},
  { "getMaxBound",(PyCFunction ) &Dtool_RectangleEmitter_get_max_bound_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_RectangleEmitter_get_max_bound_263_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_RectangleEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_RectangleEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : RectangleEmitter\n"
          "// Description : Describes a planar square region in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_RectangleEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_RectangleEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_RectangleEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_RectangleEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_RectangleEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(RectangleEmitter)");
             printf(" Error In PyType_ReadyRectangleEmitter");
             return;
        }
        Py_INCREF(&Dtool_RectangleEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_RectangleEmitter.As_PyTypeObject().tp_dict,"RectangleEmitter",&Dtool_RectangleEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_RectangleEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_RectangleEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "RectangleEmitter",(PyObject *)&Dtool_RectangleEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SparkleParticleRenderer | SparkleParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_SparkleParticleRenderer[]= {
  { "setCenterColor",(PyCFunction ) &Dtool_SparkleParticleRenderer_set_center_color_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_set_center_color_267_comment},
  { "setEdgeColor",(PyCFunction ) &Dtool_SparkleParticleRenderer_set_edge_color_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_set_edge_color_268_comment},
  { "setBirthRadius",(PyCFunction ) &Dtool_SparkleParticleRenderer_set_birth_radius_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_set_birth_radius_269_comment},
  { "setDeathRadius",(PyCFunction ) &Dtool_SparkleParticleRenderer_set_death_radius_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_set_death_radius_270_comment},
  { "setLifeScale",(PyCFunction ) &Dtool_SparkleParticleRenderer_set_life_scale_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_set_life_scale_271_comment},
  { "getCenterColor",(PyCFunction ) &Dtool_SparkleParticleRenderer_get_center_color_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_get_center_color_272_comment},
  { "getEdgeColor",(PyCFunction ) &Dtool_SparkleParticleRenderer_get_edge_color_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_get_edge_color_273_comment},
  { "getBirthRadius",(PyCFunction ) &Dtool_SparkleParticleRenderer_get_birth_radius_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_get_birth_radius_274_comment},
  { "getDeathRadius",(PyCFunction ) &Dtool_SparkleParticleRenderer_get_death_radius_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_get_death_radius_275_comment},
  { "getLifeScale",(PyCFunction ) &Dtool_SparkleParticleRenderer_get_life_scale_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SparkleParticleRenderer_get_life_scale_276_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SparkleParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SparkleParticleRenderer\n"
          "// Description : pretty sparkly things.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleRenderer._Dtool_ClassInit(NULL);
        Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleRenderer.As_PyTypeObject());
        Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict);
        // Enum  SparkleParticleRenderer::SparkleParticleLifeScale;
        PyDict_SetItemString(Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict,"SPNOSCALE",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict,"SPSCALE",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_SparkleParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SparkleParticleRenderer)");
             printf(" Error In PyType_ReadySparkleParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_SparkleParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SparkleParticleRenderer.As_PyTypeObject().tp_dict,"SparkleParticleRenderer",&Dtool_SparkleParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_SparkleParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SparkleParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "SparkleParticleRenderer",(PyObject *)&Dtool_SparkleParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SphereSurfaceEmitter | SphereSurfaceEmitter
//********************************************************************
PyMethodDef Dtool_Methods_SphereSurfaceEmitter[]= {
  { "setRadius",(PyCFunction ) &Dtool_SphereSurfaceEmitter_set_radius_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SphereSurfaceEmitter_set_radius_279_comment},
  { "getRadius",(PyCFunction ) &Dtool_SphereSurfaceEmitter_get_radius_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SphereSurfaceEmitter_get_radius_280_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SphereSurfaceEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SphereSurfaceEmitter\n"
          "// Description : Describes a curved space in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SphereSurfaceEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SphereSurfaceEmitter)");
             printf(" Error In PyType_ReadySphereSurfaceEmitter");
             return;
        }
        Py_INCREF(&Dtool_SphereSurfaceEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SphereSurfaceEmitter.As_PyTypeObject().tp_dict,"SphereSurfaceEmitter",&Dtool_SphereSurfaceEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_SphereSurfaceEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SphereSurfaceEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "SphereSurfaceEmitter",(PyObject *)&Dtool_SphereSurfaceEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SphereVolumeEmitter | SphereVolumeEmitter
//********************************************************************
PyMethodDef Dtool_Methods_SphereVolumeEmitter[]= {
  { "setRadius",(PyCFunction ) &Dtool_SphereVolumeEmitter_set_radius_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SphereVolumeEmitter_set_radius_283_comment},
  { "getRadius",(PyCFunction ) &Dtool_SphereVolumeEmitter_get_radius_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SphereVolumeEmitter_get_radius_284_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SphereVolumeEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SphereVolumeEmitter\n"
          "// Description : Describes a voluminous spherical region in which\n"
          "//               particles are generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SphereVolumeEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SphereVolumeEmitter)");
             printf(" Error In PyType_ReadySphereVolumeEmitter");
             return;
        }
        Py_INCREF(&Dtool_SphereVolumeEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SphereVolumeEmitter.As_PyTypeObject().tp_dict,"SphereVolumeEmitter",&Dtool_SphereVolumeEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_SphereVolumeEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SphereVolumeEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "SphereVolumeEmitter",(PyObject *)&Dtool_SphereVolumeEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SpriteAnim | SpriteAnim
//********************************************************************
PyMethodDef Dtool_Methods_SpriteAnim[]= {
  { "setSourceInfo",(PyCFunction ) &Dtool_SpriteAnim_set_source_info_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_set_source_info_287_comment},
  { "getSourceType",(PyCFunction ) &Dtool_SpriteAnim_get_source_type_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_get_source_type_288_comment},
  { "getTexSource",(PyCFunction ) &Dtool_SpriteAnim_get_tex_source_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_get_tex_source_289_comment},
  { "getModelSource",(PyCFunction ) &Dtool_SpriteAnim_get_model_source_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_get_model_source_290_comment},
  { "getNodeSource",(PyCFunction ) &Dtool_SpriteAnim_get_node_source_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_get_node_source_291_comment},
  { "getNumFrames",(PyCFunction ) &Dtool_SpriteAnim_get_num_frames_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteAnim_get_num_frames_292_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SpriteAnim(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SpriteAnim.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SpriteAnim\n"
          "// Description : Helper class used by SpriteParticleRenderer to\n"
          "//               keep track of its textures and their respective UVs\n"
          "//               and source types.  \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_SpriteAnim.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_SpriteAnim.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SpriteAnim.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SpriteAnim.As_PyTypeObject().tp_dict);
        // Enum  SpriteAnim::SourceType;
        PyDict_SetItemString(Dtool_SpriteAnim.As_PyTypeObject().tp_dict,"STTexture",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SpriteAnim.As_PyTypeObject().tp_dict,"STFromNode",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_SpriteAnim.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SpriteAnim)");
             printf(" Error In PyType_ReadySpriteAnim");
             return;
        }
        Py_INCREF(&Dtool_SpriteAnim.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SpriteAnim.As_PyTypeObject().tp_dict,"SpriteAnim",&Dtool_SpriteAnim.As_PyObject());
        RegisterRuntimeClass(&Dtool_SpriteAnim,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SpriteAnim.As_PyTypeObject());
        PyModule_AddObject(module, "SpriteAnim",(PyObject *)&Dtool_SpriteAnim.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SpriteParticleRenderer | SpriteParticleRenderer
//********************************************************************
PyMethodDef Dtool_Methods_SpriteParticleRenderer[]= {
  { "setFromNode",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_from_node_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_from_node_296_comment},
  { "addFromNode",(PyCFunction ) &Dtool_SpriteParticleRenderer_add_from_node_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_add_from_node_297_comment},
  { "setTexture",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_texture_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_texture_298_comment},
  { "addTexture",(PyCFunction ) &Dtool_SpriteParticleRenderer_add_texture_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_add_texture_299_comment},
  { "removeAnimation",(PyCFunction ) &Dtool_SpriteParticleRenderer_remove_animation_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_remove_animation_300_comment},
  { "setLlUv",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_ll_uv_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_ll_uv_301_comment},
  { "setUrUv",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_ur_uv_302, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_ur_uv_302_comment},
  { "setSize",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_size_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_size_303_comment},
  { "setColor",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_color_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_color_304_comment},
  { "setXScaleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_x_scale_flag_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_x_scale_flag_305_comment},
  { "setYScaleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_y_scale_flag_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_y_scale_flag_306_comment},
  { "setAnimAngleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_anim_angle_flag_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_anim_angle_flag_307_comment},
  { "setInitialXScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_initial_x_scale_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_initial_x_scale_308_comment},
  { "setFinalXScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_final_x_scale_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_final_x_scale_309_comment},
  { "setInitialYScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_initial_y_scale_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_initial_y_scale_310_comment},
  { "setFinalYScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_final_y_scale_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_final_y_scale_311_comment},
  { "setNonanimatedTheta",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_nonanimated_theta_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_nonanimated_theta_312_comment},
  { "setAlphaBlendMethod",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_alpha_blend_method_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_alpha_blend_method_313_comment},
  { "setAlphaDisable",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_alpha_disable_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_alpha_disable_314_comment},
  { "setAnimateFramesEnable",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_animate_frames_enable_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_animate_frames_enable_315_comment},
  { "setAnimateFramesRate",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_animate_frames_rate_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_animate_frames_rate_316_comment},
  { "setAnimateFramesIndex",(PyCFunction ) &Dtool_SpriteParticleRenderer_set_animate_frames_index_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_set_animate_frames_index_317_comment},
  { "getTexture",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_texture_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_texture_318_comment},
  { "getNumAnims",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_num_anims_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_num_anims_319_comment},
  { "getAnim",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_anim_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_anim_320_comment},
  { "getLastAnim",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_last_anim_321, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_last_anim_321_comment},
  { "getColorInterpolationManager",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_color_interpolation_manager_322, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_color_interpolation_manager_322_comment},
  { "getLlUv",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_ll_uv_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_ll_uv_323_comment},
  { "getUrUv",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_ur_uv_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_ur_uv_324_comment},
  { "getWidth",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_width_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_width_325_comment},
  { "getHeight",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_height_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_height_326_comment},
  { "getColor",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_color_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_color_327_comment},
  { "getXScaleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_x_scale_flag_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_x_scale_flag_328_comment},
  { "getYScaleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_y_scale_flag_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_y_scale_flag_329_comment},
  { "getAnimAngleFlag",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_anim_angle_flag_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_anim_angle_flag_330_comment},
  { "getInitialXScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_initial_x_scale_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_initial_x_scale_331_comment},
  { "getFinalXScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_final_x_scale_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_final_x_scale_332_comment},
  { "getInitialYScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_initial_y_scale_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_initial_y_scale_333_comment},
  { "getFinalYScale",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_final_y_scale_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_final_y_scale_334_comment},
  { "getNonanimatedTheta",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_nonanimated_theta_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_nonanimated_theta_335_comment},
  { "getAlphaBlendMethod",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_alpha_blend_method_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_alpha_blend_method_336_comment},
  { "getAlphaDisable",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_alpha_disable_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_alpha_disable_337_comment},
  { "getAnimateFramesEnable",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_animate_frames_enable_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_animate_frames_enable_338_comment},
  { "getAnimateFramesRate",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_animate_frames_rate_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_animate_frames_rate_339_comment},
  { "getAnimateFramesIndex",(PyCFunction ) &Dtool_SpriteParticleRenderer_get_animate_frames_index_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SpriteParticleRenderer_get_animate_frames_index_340_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getAnims",(PyCFunction) &MakeSeq_SpriteParticleRenderer_get_anims, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SpriteParticleRenderer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SpriteParticleRenderer\n"
          "// Description : Renders a particle system with high-speed nasty\n"
          "//               trick sprites.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleRenderer._Dtool_ClassInit(NULL);
        Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleRenderer.As_PyTypeObject());
        Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SpriteParticleRenderer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SpriteParticleRenderer)");
             printf(" Error In PyType_ReadySpriteParticleRenderer");
             return;
        }
        Py_INCREF(&Dtool_SpriteParticleRenderer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SpriteParticleRenderer.As_PyTypeObject().tp_dict,"SpriteParticleRenderer",&Dtool_SpriteParticleRenderer.As_PyObject());
        RegisterRuntimeClass(&Dtool_SpriteParticleRenderer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SpriteParticleRenderer.As_PyTypeObject());
        PyModule_AddObject(module, "SpriteParticleRenderer",(PyObject *)&Dtool_SpriteParticleRenderer.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TangentRingEmitter | TangentRingEmitter
//********************************************************************
PyMethodDef Dtool_Methods_TangentRingEmitter[]= {
  { "setRadius",(PyCFunction ) &Dtool_TangentRingEmitter_set_radius_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TangentRingEmitter_set_radius_343_comment},
  { "setRadiusSpread",(PyCFunction ) &Dtool_TangentRingEmitter_set_radius_spread_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TangentRingEmitter_set_radius_spread_344_comment},
  { "getRadius",(PyCFunction ) &Dtool_TangentRingEmitter_get_radius_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TangentRingEmitter_get_radius_345_comment},
  { "getRadiusSpread",(PyCFunction ) &Dtool_TangentRingEmitter_get_radius_spread_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TangentRingEmitter_get_radius_spread_346_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TangentRingEmitter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TangentRingEmitter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TangentRingEmitter\n"
          "// Description : Describes a planar ring region in which\n"
          "//               tangent particles are generated, and particles\n"
          "//               fly off tangential to the ring.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleEmitter._Dtool_ClassInit(NULL);
        Dtool_TangentRingEmitter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleEmitter.As_PyTypeObject());
        Dtool_TangentRingEmitter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TangentRingEmitter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TangentRingEmitter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TangentRingEmitter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TangentRingEmitter)");
             printf(" Error In PyType_ReadyTangentRingEmitter");
             return;
        }
        Py_INCREF(&Dtool_TangentRingEmitter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TangentRingEmitter.As_PyTypeObject().tp_dict,"TangentRingEmitter",&Dtool_TangentRingEmitter.As_PyObject());
        RegisterRuntimeClass(&Dtool_TangentRingEmitter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TangentRingEmitter.As_PyTypeObject());
        PyModule_AddObject(module, "TangentRingEmitter",(PyObject *)&Dtool_TangentRingEmitter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ZSpinParticleFactory | ZSpinParticleFactory
//********************************************************************
PyMethodDef Dtool_Methods_ZSpinParticleFactory[]= {
  { "setInitialAngle",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_initial_angle_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_initial_angle_349_comment},
  { "setFinalAngle",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_final_angle_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_final_angle_350_comment},
  { "setInitialAngleSpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_initial_angle_spread_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_initial_angle_spread_351_comment},
  { "setFinalAngleSpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_final_angle_spread_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_final_angle_spread_352_comment},
  { "getInitialAngle",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_initial_angle_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_initial_angle_353_comment},
  { "getFinalAngle",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_final_angle_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_final_angle_354_comment},
  { "getInitialAngleSpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_initial_angle_spread_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_initial_angle_spread_355_comment},
  { "getFinalAngleSpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_final_angle_spread_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_final_angle_spread_356_comment},
  { "setAngularVelocity",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_angular_velocity_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_angular_velocity_357_comment},
  { "getAngularVelocity",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_angular_velocity_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_angular_velocity_358_comment},
  { "setAngularVelocitySpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_set_angular_velocity_spread_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_set_angular_velocity_spread_359_comment},
  { "getAngularVelocitySpread",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_angular_velocity_spread_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_angular_velocity_spread_360_comment},
  { "enableAngularVelocity",(PyCFunction ) &Dtool_ZSpinParticleFactory_enable_angular_velocity_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_enable_angular_velocity_361_comment},
  { "getAngularVelocityEnabled",(PyCFunction ) &Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ZSpinParticleFactory_get_angular_velocity_enabled_362_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ZSpinParticleFactory(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ZSpinParticleFactory\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseParticleFactory._Dtool_ClassInit(NULL);
        Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseParticleFactory.As_PyTypeObject());
        Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ZSpinParticleFactory.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ZSpinParticleFactory)");
             printf(" Error In PyType_ReadyZSpinParticleFactory");
             return;
        }
        Py_INCREF(&Dtool_ZSpinParticleFactory.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ZSpinParticleFactory.As_PyTypeObject().tp_dict,"ZSpinParticleFactory",&Dtool_ZSpinParticleFactory.As_PyObject());
        RegisterRuntimeClass(&Dtool_ZSpinParticleFactory,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ZSpinParticleFactory.As_PyTypeObject());
        PyModule_AddObject(module, "ZSpinParticleFactory",(PyObject *)&Dtool_ZSpinParticleFactory.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..BaseParticleEmitter
//********************************************************************
   Dtool_PyModuleClassInit_BaseParticleEmitter(module);
//********************************************************************
//*** Module Init Updcall ..RingEmitter
//********************************************************************
   Dtool_PyModuleClassInit_RingEmitter(module);
//********************************************************************
//*** Module Init Updcall ..ArcEmitter
//********************************************************************
   Dtool_PyModuleClassInit_ArcEmitter(module);
//********************************************************************
//*** Module Init Updcall ..BaseParticleFactory
//********************************************************************
   Dtool_PyModuleClassInit_BaseParticleFactory(module);
//********************************************************************
//*** Module Init Updcall ..BaseParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_BaseParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..BoxEmitter
//********************************************************************
   Dtool_PyModuleClassInit_BoxEmitter(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationFunctionConstant
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationFunctionConstant(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationFunctionLinear
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationFunctionLinear(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationFunctionStepwave
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationFunctionStepwave(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationFunctionSinusoid
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationFunctionSinusoid(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationSegment
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationSegment(module);
//********************************************************************
//*** Module Init Updcall ..ColorInterpolationManager
//********************************************************************
   Dtool_PyModuleClassInit_ColorInterpolationManager(module);
//********************************************************************
//*** Module Init Updcall ..DiscEmitter
//********************************************************************
   Dtool_PyModuleClassInit_DiscEmitter(module);
//********************************************************************
//*** Module Init Updcall ..GeomParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_GeomParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..LineEmitter
//********************************************************************
   Dtool_PyModuleClassInit_LineEmitter(module);
//********************************************************************
//*** Module Init Updcall ..LineParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_LineParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..ParticleSystem
//********************************************************************
   Dtool_PyModuleClassInit_ParticleSystem(module);
//********************************************************************
//*** Module Init Updcall ..ParticleSystemManager
//********************************************************************
   Dtool_PyModuleClassInit_ParticleSystemManager(module);
//********************************************************************
//*** Module Init Updcall ..PointEmitter
//********************************************************************
   Dtool_PyModuleClassInit_PointEmitter(module);
//********************************************************************
//*** Module Init Updcall ..PointParticleFactory
//********************************************************************
   Dtool_PyModuleClassInit_PointParticleFactory(module);
//********************************************************************
//*** Module Init Updcall ..PointParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_PointParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..RectangleEmitter
//********************************************************************
   Dtool_PyModuleClassInit_RectangleEmitter(module);
//********************************************************************
//*** Module Init Updcall ..SparkleParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_SparkleParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..SphereSurfaceEmitter
//********************************************************************
   Dtool_PyModuleClassInit_SphereSurfaceEmitter(module);
//********************************************************************
//*** Module Init Updcall ..SphereVolumeEmitter
//********************************************************************
   Dtool_PyModuleClassInit_SphereVolumeEmitter(module);
//********************************************************************
//*** Module Init Updcall ..SpriteAnim
//********************************************************************
   Dtool_PyModuleClassInit_SpriteAnim(module);
//********************************************************************
//*** Module Init Updcall ..SpriteParticleRenderer
//********************************************************************
   Dtool_PyModuleClassInit_SpriteParticleRenderer(module);
//********************************************************************
//*** Module Init Updcall ..TangentRingEmitter
//********************************************************************
   Dtool_PyModuleClassInit_TangentRingEmitter(module);
//********************************************************************
//*** Module Init Updcall ..ZSpinParticleFactory
//********************************************************************
   Dtool_PyModuleClassInit_ZSpinParticleFactory(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libparticlesystem_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213624,  /* file_identifier */
  "libparticlesystem",  /* library_name */
  "KBUA",  /* library_hash_name */
  "pandaphysics",  /* module_name */
  "libparticlesystem.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  907  /* next_index */
};

Configure(_in_configure_libparticlesystem);
ConfigureFn(_in_configure_libparticlesystem) {
  interrogate_request_module(&_in_module_def);
}

