/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pgraphnodes -Ipanda/src/pgraphnodes -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpgraphnodes_igate.cxx -od built_Rocket/pandac/input/libpgraphnodes.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pgraphnodes -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpgraphnodes ambientLight.h callbackNode.h config_pgraphnodes.h directionalLight.h fadeLodNode.h fadeLodNodeData.h lightLensNode.h lightNode.h lodNode.h lodNodeType.h nodeCullCallbackData.h pgraphnodes_composite.cxx pointLight.h sceneGraphAnalyzer.h selectiveChildNode.h sequenceNode.h shaderGenerator.h spotlight.h switchNode.h uvScrollNode.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpgraphnodes
#include "py_panda.h"  

#include "ambientLight.h"
#include "auxSceneData.h"
#include "callbackData.h"
#include "callbackNode.h"
#include "callbackObject.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "config_pgraphnodes.h"
#include "cullTraverser.h"
#include "cullTraverserData.h"
#include "directionalLight.h"
#include "fadeLodNode.h"
#include "fadeLodNodeData.h"
#include "lightLensNode.h"
#include "lightNode.h"
#include "lodNode.h"
#include "lodNodeType.h"
#include "nodeCullCallbackData.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pointLight.h"
#include "pointerTo.h"
#include "sceneGraphAnalyzer.h"
#include "selectiveChildNode.h"
#include "sequenceNode.h"
#include "shaderGenerator.h"
#include "spotlight.h"
#include "switchNode.h"
#include "uvScrollNode.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. LightNode
//********************************************************************
typedef  LightNode  LightNode_localtype;
Define_Module_ClassRef(panda,LightNode,LightNode_localtype,LightNode);
//********************************************************************
//*** prototypes for .. AmbientLight
//********************************************************************
typedef  AmbientLight  AmbientLight_localtype;
Define_Module_ClassRef(panda,AmbientLight,AmbientLight_localtype,AmbientLight);
//********************************************************************
//*** prototypes for .. CallbackNode
//********************************************************************
typedef  CallbackNode  CallbackNode_localtype;
Define_Module_ClassRef(panda,CallbackNode,CallbackNode_localtype,CallbackNode);
//********************************************************************
//*** prototypes for .. LightLensNode
//********************************************************************
typedef  LightLensNode  LightLensNode_localtype;
Define_Module_ClassRef(panda,LightLensNode,LightLensNode_localtype,LightLensNode);
//********************************************************************
//*** prototypes for .. DirectionalLight
//********************************************************************
typedef  DirectionalLight  DirectionalLight_localtype;
Define_Module_ClassRef(panda,DirectionalLight,DirectionalLight_localtype,DirectionalLight);
//********************************************************************
//*** prototypes for .. LODNode
//********************************************************************
typedef  LODNode  LODNode_localtype;
Define_Module_ClassRef(panda,LODNode,LODNode_localtype,LODNode);
//********************************************************************
//*** prototypes for .. FadeLODNode
//********************************************************************
typedef  FadeLODNode  FadeLODNode_localtype;
Define_Module_ClassRef(panda,FadeLODNode,FadeLODNode_localtype,FadeLODNode);
//********************************************************************
//*** prototypes for .. NodeCullCallbackData
//********************************************************************
typedef  NodeCullCallbackData  NodeCullCallbackData_localtype;
Define_Module_Class(panda,NodeCullCallbackData,NodeCullCallbackData_localtype,NodeCullCallbackData);
//********************************************************************
//*** prototypes for .. PointLight
//********************************************************************
typedef  PointLight  PointLight_localtype;
Define_Module_ClassRef(panda,PointLight,PointLight_localtype,PointLight);
//********************************************************************
//*** prototypes for .. SelectiveChildNode
//********************************************************************
typedef  SelectiveChildNode  SelectiveChildNode_localtype;
Define_Module_ClassRef(panda,SelectiveChildNode,SelectiveChildNode_localtype,SelectiveChildNode);
//********************************************************************
//*** prototypes for .. SequenceNode
//********************************************************************
typedef  SequenceNode  SequenceNode_localtype;
Define_Module_ClassRef(panda,SequenceNode,SequenceNode_localtype,SequenceNode);
//********************************************************************
//*** prototypes for .. ShaderGenerator
//********************************************************************
typedef  ShaderGenerator  ShaderGenerator_localtype;
Define_Module_Class(panda,ShaderGenerator,ShaderGenerator_localtype,ShaderGenerator);
//********************************************************************
//*** prototypes for .. Spotlight
//********************************************************************
typedef  Spotlight  Spotlight_localtype;
Define_Module_ClassRef(panda,Spotlight,Spotlight_localtype,Spotlight);
//********************************************************************
//*** prototypes for .. SwitchNode
//********************************************************************
typedef  SwitchNode  SwitchNode_localtype;
Define_Module_ClassRef(panda,SwitchNode,SwitchNode_localtype,SwitchNode);
//********************************************************************
//*** prototypes for .. UvScrollNode
//********************************************************************
typedef  UvScrollNode  UvScrollNode_localtype;
Define_Module_ClassRef(panda,UvScrollNode,UvScrollNode_localtype,UvScrollNode);
//********************************************************************
//*** prototypes for .. SceneGraphAnalyzer
//********************************************************************
typedef  SceneGraphAnalyzer  SceneGraphAnalyzer_localtype;
Define_Module_Class(panda,SceneGraphAnalyzer,SceneGraphAnalyzer_localtype,SceneGraphAnalyzer);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AnimInterface;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CallbackData;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CallbackObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Camera;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CullTraverser;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CullTraverserData;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsOutputBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LensNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Light;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_RenderAttrib;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_RenderState;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. LightNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void LightNode::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_LightNode_output_8(PyObject *self, PyObject *args,PyObject *kwds) {
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void LightNode::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightNode.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const LightNode*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const LightNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightNode_output_8_comment =
    "C++ Interface:\n"
    "output(const LightNode this, non-const Ostream out)\n"
    "\n"
    "// We have to explicitly publish these because they resolve the\n"
    "// multiple inheritance.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightNode::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightNode_output_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void LightNode::write(ostream &out, int indent_level) const
 * virtual void LightNode::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_LightNode_write_9(PyObject *self, PyObject *args,PyObject *kwds) {
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LightNode::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const LightNode*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LightNode::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const LightNode*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const LightNode this, non-const Ostream out)\n"
          "write(const LightNode this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightNode_write_9_comment =
    "C++ Interface:\n"
    "write(const LightNode this, non-const Ostream out)\n"
    "write(const LightNode this, non-const Ostream out, int indent_level)\n"
    "\n"
    "// We have to explicitly publish these because they resolve the\n"
    "// multiple inheritance.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightNode::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightNode_write_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LightNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LightNode_get_class_type_10(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LightNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LightNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightNode_get_class_type_10_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LightNode_get_class_type_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Light *LightNode::upcast_to_Light(void)
 *******************************************************************/
static PyObject *Dtool_LightNode_upcast_to_Light_3(PyObject *self, PyObject *args,PyObject *kwds) {
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Light *LightNode::upcast_to_Light(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToLight", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToLight"));
        if(!PyErr_Occurred())
        {
            Light *return_value = (Light *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Light,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightNode.upcastToLight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToLight(non-const LightNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightNode_upcast_to_Light_3_comment =
    "C++ Interface:\n"
    "upcastToLight(non-const LightNode this)\n"
    "\n"
    "upcast from LightNode to Light\n"
    "";
#else
static const char * Dtool_LightNode_upcast_to_Light_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PandaNode *LightNode::upcast_to_PandaNode(void)
 *******************************************************************/
static PyObject *Dtool_LightNode_upcast_to_PandaNode_6(PyObject *self, PyObject *args,PyObject *kwds) {
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PandaNode *LightNode::upcast_to_PandaNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPandaNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPandaNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = (PandaNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightNode.upcastToPandaNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPandaNode(non-const LightNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightNode_upcast_to_PandaNode_6_comment =
    "C++ Interface:\n"
    "upcastToPandaNode(non-const LightNode this)\n"
    "\n"
    "upcast from LightNode to PandaNode\n"
    "";
#else
static const char * Dtool_LightNode_upcast_to_PandaNode_6_comment = NULL;
#endif

int  Dtool_Init_LightNode(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LightNode)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LightNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightNode)
    {
        printf("LightNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightNode * local_this = (LightNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightNode)
        return local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightNode)
        return from_this;
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (LightNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (LightNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (LightNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LightNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (LightNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AmbientLight 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AmbientLight::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AmbientLight_get_class_type_14(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AmbientLight::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AmbientLight::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AmbientLight_get_class_type_14_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AmbientLight_get_class_type_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AmbientLight::AmbientLight(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_AmbientLight(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AmbientLight::AmbientLight(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:AmbientLight", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:AmbientLight", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            AmbientLight *return_value = new AmbientLight(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AmbientLight,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AmbientLight(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AmbientLight(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AmbientLight)
    {
        printf("AmbientLight ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AmbientLight * local_this = (AmbientLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AmbientLight)
        return local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *)( LightNode *) local_this;
    if(requested_type == &Dtool_LightNode)
        return ( LightNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LightNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LightNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *)( LightNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LightNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LightNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AmbientLight(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AmbientLight)
        return from_this;
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (AmbientLight*)other_this;
    }
    if(from_type == &Dtool_LightNode)
    {
          LightNode* other_this = (LightNode*)from_this;
          return (AmbientLight*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AmbientLight*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (AmbientLight*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AmbientLight*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AmbientLight*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CallbackNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CallbackNode::set_cull_callback(CallbackObject *object)
 *******************************************************************/
static PyObject *Dtool_CallbackNode_set_cull_callback_18(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CallbackNode::set_cull_callback(CallbackObject *object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCullCallback", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCullCallback", &param1));
            if(!PyErr_Occurred())
            {
                CallbackObject *param1_this = (CallbackObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CallbackObject, 1, "CallbackNode.setCullCallback", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_cull_callback(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CallbackNode.setCullCallback() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCullCallback(non-const CallbackNode this, non-const CallbackObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_set_cull_callback_18_comment =
    "C++ Interface:\n"
    "setCullCallback(non-const CallbackNode this, non-const CallbackObject object)\n"
    "\n"
    "// Filename: callbackNode.I\n"
    "// Created by:  drose (13Mar09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::set_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Sets the CallbackObject that will be notified when\n"
    "//               this node is visited during the cull traversal.  This\n"
    "//               callback will be made during the cull thread.\n"
    "//\n"
    "//               The cull traversal is responsible for determining\n"
    "//               which nodes are visible and within the view frustum,\n"
    "//               and for accumulating state and transform, and\n"
    "//               generally building up the list of CullableObjects\n"
    "//               that are to be eventually passed to the draw\n"
    "//               traversal for rendering.\n"
    "//\n"
    "//               At the time the cull traversal callback is made, the\n"
    "//               node has been determined to be visible and it has\n"
    "//               passed the bounding-volume test, so it lies within\n"
    "//               the view frustum.\n"
    "//\n"
    "//               The callback is passed an instance of a\n"
    "//               NodeCullCallbackData, which contains pointers to the\n"
    "//               CullTraverser and CullTraverserData--enough data to\n"
    "//               examine the current node and its place within the\n"
    "//               scene graph.  The callback *replaces* the normal cull\n"
    "//               behavior, so if your callback does nothing, the cull\n"
    "//               traversal will not continue below this node.  If you\n"
    "//               wish the cull traversal to continue to visit this\n"
    "//               node and below, you must call cbdata->upcall()\n"
    "//               from your callback.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_set_cull_callback_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CallbackNode::clear_cull_callback(void)
 *******************************************************************/
static PyObject *Dtool_CallbackNode_clear_cull_callback_19(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CallbackNode::clear_cull_callback(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCullCallback", key_word_list));
        else
            (PyArg_Parse(args, ":clearCullCallback"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_cull_callback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CallbackNode.clearCullCallback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCullCallback(non-const CallbackNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_clear_cull_callback_19_comment =
    "C++ Interface:\n"
    "clearCullCallback(non-const CallbackNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::clear_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Removes the callback set by an earlier call to\n"
    "//               set_cull_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_clear_cull_callback_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CallbackObject *CallbackNode::get_cull_callback(void) const
 *******************************************************************/
static PyObject *Dtool_CallbackNode_get_cull_callback_20(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CallbackObject *CallbackNode::get_cull_callback(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCullCallback", key_word_list));
        else
            (PyArg_Parse(args, ":getCullCallback"));
        if(!PyErr_Occurred())
        {
            CallbackObject *return_value = ((const CallbackNode*)local_this)->get_cull_callback();
            if (return_value != (CallbackObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CallbackObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCullCallback(const CallbackNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_get_cull_callback_20_comment =
    "C++ Interface:\n"
    "getCullCallback(const CallbackNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::get_cull_callback\n"
    "//       Access: Published\n"
    "//  Description: Returns the CallbackObject set by set_cull_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_get_cull_callback_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CallbackNode::set_draw_callback(CallbackObject *object)
 *******************************************************************/
static PyObject *Dtool_CallbackNode_set_draw_callback_21(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CallbackNode::set_draw_callback(CallbackObject *object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDrawCallback", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDrawCallback", &param1));
            if(!PyErr_Occurred())
            {
                CallbackObject *param1_this = (CallbackObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CallbackObject, 1, "CallbackNode.setDrawCallback", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_draw_callback(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CallbackNode.setDrawCallback() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawCallback(non-const CallbackNode this, non-const CallbackObject object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_set_draw_callback_21_comment =
    "C++ Interface:\n"
    "setDrawCallback(non-const CallbackNode this, non-const CallbackObject object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::set_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Sets the CallbackObject that will be notified when\n"
    "//               this node is visited during the draw traversal.  This\n"
    "//               callback will be made during the draw thread.\n"
    "//\n"
    "//               The draw traversal is responsible for actually\n"
    "//               issuing the commands to the graphics engine to draw\n"
    "//               primitives.  Its job is to walk through the list of\n"
    "//               CullableObjects build up by the cull traversal, as\n"
    "//               quickly as possible, issuing the appropriate commands\n"
    "//               to draw each one.\n"
    "//\n"
    "//               At the time the draw traversal callback is made, the\n"
    "//               graphics state has been loaded with the correct\n"
    "//               modelview transform and render state, and the\n"
    "//               primitives (if any) in this node are ready to be\n"
    "//               drawn.\n"
    "//\n"
    "//               The callback is passed an instance of a\n"
    "//               GeomDrawCallbackData, which contains pointers to the\n"
    "//               current state and transform, as well as the current\n"
    "//               GSG.  There is a Geom pointer as well, but it will\n"
    "//               always be NULL to this callback, since the\n"
    "//               CallbackNode does not itself contain any Geoms.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_set_draw_callback_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CallbackNode::clear_draw_callback(void)
 *******************************************************************/
static PyObject *Dtool_CallbackNode_clear_draw_callback_22(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CallbackNode::clear_draw_callback(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDrawCallback", key_word_list));
        else
            (PyArg_Parse(args, ":clearDrawCallback"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_draw_callback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CallbackNode.clearDrawCallback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDrawCallback(non-const CallbackNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_clear_draw_callback_22_comment =
    "C++ Interface:\n"
    "clearDrawCallback(non-const CallbackNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::clear_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Removes the callback set by an earlier call to\n"
    "//               set_draw_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_clear_draw_callback_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CallbackObject *CallbackNode::get_draw_callback(void) const
 *******************************************************************/
static PyObject *Dtool_CallbackNode_get_draw_callback_23(PyObject *self, PyObject *args,PyObject *kwds) {
    CallbackNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CallbackNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CallbackObject *CallbackNode::get_draw_callback(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDrawCallback", key_word_list));
        else
            (PyArg_Parse(args, ":getDrawCallback"));
        if(!PyErr_Occurred())
        {
            CallbackObject *return_value = ((const CallbackNode*)local_this)->get_draw_callback();
            if (return_value != (CallbackObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CallbackObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDrawCallback(const CallbackNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_get_draw_callback_23_comment =
    "C++ Interface:\n"
    "getDrawCallback(const CallbackNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CallbackNode::get_draw_callback\n"
    "//       Access: Published\n"
    "//  Description: Returns the CallbackObject set by set_draw_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CallbackNode_get_draw_callback_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CallbackNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CallbackNode_get_class_type_24(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CallbackNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CallbackNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CallbackNode_get_class_type_24_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CallbackNode_get_class_type_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CallbackNode::CallbackNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_CallbackNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CallbackNode::CallbackNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CallbackNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:CallbackNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            CallbackNode *return_value = new CallbackNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CallbackNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CallbackNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CallbackNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CallbackNode)
    {
        printf("CallbackNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CallbackNode * local_this = (CallbackNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CallbackNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CallbackNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CallbackNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CallbackNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (CallbackNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CallbackNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CallbackNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LightLensNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool LightLensNode::is_shadow_caster(void)
 *******************************************************************/
static PyObject *Dtool_LightLensNode_is_shadow_caster_34(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool LightLensNode::is_shadow_caster(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isShadowCaster", key_word_list));
        else
            (PyArg_Parse(args, ":isShadowCaster"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_shadow_caster();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightLensNode.isShadowCaster() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isShadowCaster(non-const LightLensNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_is_shadow_caster_34_comment =
    "C++ Interface:\n"
    "isShadowCaster(non-const LightLensNode this)\n"
    "\n"
    "// Filename: lightLensNode.I\n"
    "// Created by:  drose (26Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightLensNode::is_shadow_caster\n"
    "//       Access: Published\n"
    "//  Description: Returns whether this light is configured to cast\n"
    "//               shadows or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightLensNode_is_shadow_caster_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightLensNode::set_shadow_caster(bool caster)
 * inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort)
 * inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = (-10))
 *******************************************************************/
static PyObject *Dtool_LightLensNode_set_shadow_caster_35(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LightLensNode::set_shadow_caster(bool caster)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"caster", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setShadowCaster", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setShadowCaster", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_shadow_caster((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LightLensNode.setShadowCaster() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort = (-10))
            PyObject *param1;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"caster", (char *)"buffer_xsize", (char *)"buffer_ysize", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:setShadowCaster", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_shadow_caster((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LightLensNode.setShadowCaster() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LightLensNode::set_shadow_caster(bool caster, int buffer_xsize, int buffer_ysize, int sort)
            PyObject *param1;
            int param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"caster", (char *)"buffer_xsize", (char *)"buffer_ysize", (char *)"sort", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiii:setShadowCaster", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_shadow_caster((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3, (int)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LightLensNode.setShadowCaster() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setShadowCaster() takes 2, 4, or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setShadowCaster(non-const LightLensNode this, bool caster)\n"
          "setShadowCaster(non-const LightLensNode this, bool caster, int buffer_xsize, int buffer_ysize)\n"
          "setShadowCaster(non-const LightLensNode this, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_set_shadow_caster_35_comment =
    "C++ Interface:\n"
    "setShadowCaster(non-const LightLensNode this, bool caster)\n"
    "setShadowCaster(non-const LightLensNode this, bool caster, int buffer_xsize, int buffer_ysize)\n"
    "setShadowCaster(non-const LightLensNode this, bool caster, int buffer_xsize, int buffer_ysize, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightLensNode::set_shadow_caster\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating whether this light should\n"
    "//               cast shadows or not. This is the variant without\n"
    "//               buffer size, meaning that the current buffer size\n"
    "//               will be kept (512x512 is the default).\n"
    "//               Note that enabling shadows will require the shader\n"
    "//               generator to be enabled on the scene.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightLensNode::set_shadow_caster\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag indicating whether this light should\n"
    "//               cast shadows or not. The xsize and ysize parameters\n"
    "//               specify the size of the shadow buffer that will be\n"
    "//               set up, the sort parameter specifies the sort.\n"
    "//               Note that enabling shadows will require the shader\n"
    "//               generator to be enabled on the scene.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightLensNode_set_shadow_caster_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void LightLensNode::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_LightLensNode_output_36(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void LightLensNode::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightLensNode.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const LightLensNode*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const LightLensNode this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_output_36_comment =
    "C++ Interface:\n"
    "output(const LightLensNode this, non-const Ostream out)\n"
    "\n"
    "// We have to explicitly publish these because they resolve the\n"
    "// multiple inheritance.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightLensNode::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightLensNode_output_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void LightLensNode::write(ostream &out, int indent_level) const
 * virtual void LightLensNode::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_LightLensNode_write_37(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LightLensNode::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightLensNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const LightLensNode*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LightLensNode::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightLensNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const LightLensNode*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const LightLensNode this, non-const Ostream out)\n"
          "write(const LightLensNode this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_write_37_comment =
    "C++ Interface:\n"
    "write(const LightLensNode this, non-const Ostream out)\n"
    "write(const LightLensNode this, non-const Ostream out, int indent_level)\n"
    "\n"
    "// We have to explicitly publish these because they resolve the\n"
    "// multiple inheritance.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightLensNode::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightLensNode_write_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LightLensNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LightLensNode_get_class_type_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LightLensNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LightLensNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_get_class_type_38_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LightLensNode_get_class_type_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Light *LightLensNode::upcast_to_Light(void)
 *******************************************************************/
static PyObject *Dtool_LightLensNode_upcast_to_Light_28(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Light *LightLensNode::upcast_to_Light(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToLight", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToLight"));
        if(!PyErr_Occurred())
        {
            Light *return_value = (Light *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Light,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightLensNode.upcastToLight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToLight(non-const LightLensNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_upcast_to_Light_28_comment =
    "C++ Interface:\n"
    "upcastToLight(non-const LightLensNode this)\n"
    "\n"
    "upcast from LightLensNode to Light\n"
    "";
#else
static const char * Dtool_LightLensNode_upcast_to_Light_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Camera *LightLensNode::upcast_to_Camera(void)
 *******************************************************************/
static PyObject *Dtool_LightLensNode_upcast_to_Camera_31(PyObject *self, PyObject *args,PyObject *kwds) {
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Camera *LightLensNode::upcast_to_Camera(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToCamera", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToCamera"));
        if(!PyErr_Occurred())
        {
            Camera *return_value = (Camera *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Camera,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightLensNode.upcastToCamera() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToCamera(non-const LightLensNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightLensNode_upcast_to_Camera_31_comment =
    "C++ Interface:\n"
    "upcastToCamera(non-const LightLensNode this)\n"
    "\n"
    "upcast from LightLensNode to Camera\n"
    "";
#else
static const char * Dtool_LightLensNode_upcast_to_Camera_31_comment = NULL;
#endif

int  Dtool_Init_LightLensNode(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LightLensNode)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LightLensNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightLensNode)
    {
        printf("LightLensNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightLensNode * local_this = (LightLensNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightLensNode)
        return local_this;
    if(requested_type == &Dtool_Camera)
        return ( Camera *) local_this;
    if(requested_type == &Dtool_LensNode)
        return ( LensNode *)( Camera *) local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LensNode *)( Camera *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LensNode *)( Camera *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LensNode *)( Camera *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LensNode *)( Camera *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightLensNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightLensNode)
        return from_this;
    if(from_type == &Dtool_Camera)
    {
          Camera* other_this = (Camera*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_LensNode)
    {
          LensNode* other_this = (LensNode*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LightLensNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (LightLensNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DirectionalLight 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &DirectionalLight::get_specular_color(void) const
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_get_specular_color_41(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &DirectionalLight::get_specular_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpecularColor", key_word_list));
        else
            (PyArg_Parse(args, ":getSpecularColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const DirectionalLight*)local_this)->get_specular_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpecularColor(const DirectionalLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_get_specular_color_41_comment =
    "C++ Interface:\n"
    "getSpecularColor(const DirectionalLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::get_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Returns the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_get_specular_color_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DirectionalLight::set_specular_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_set_specular_color_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DirectionalLight::set_specular_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpecularColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSpecularColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DirectionalLight.setSpecularColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_specular_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DirectionalLight.setSpecularColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpecularColor(non-const DirectionalLight this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_set_specular_color_42_comment =
    "C++ Interface:\n"
    "setSpecularColor(non-const DirectionalLight this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::set_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_set_specular_color_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &DirectionalLight::get_point(void) const
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_get_point_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &DirectionalLight::get_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getPoint"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const DirectionalLight*)local_this)->get_point());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const DirectionalLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_get_point_43_comment =
    "C++ Interface:\n"
    "getPoint(const DirectionalLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::get_point\n"
    "//       Access: Public\n"
    "//  Description: Returns the point in space at which the light is\n"
    "//               located.  This is local to the coordinate space in\n"
    "//               which the light is assigned.\n"
    "//\n"
    "//               This actually has no bearing on the visual effect of\n"
    "//               the light, since the light is rendered as if it were\n"
    "//               infinitely far away.  This is only used to create a\n"
    "//               visible representation of the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_get_point_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DirectionalLight::set_point(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_set_point_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DirectionalLight::set_point(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPoint", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "DirectionalLight.setPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_point(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DirectionalLight.setPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPoint(non-const DirectionalLight this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_set_point_44_comment =
    "C++ Interface:\n"
    "setPoint(non-const DirectionalLight this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::set_point\n"
    "//       Access: Public\n"
    "//  Description: Sets the point in space at which the light is located.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_set_point_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &DirectionalLight::get_direction(void) const
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_get_direction_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &DirectionalLight::get_direction(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirection", key_word_list));
        else
            (PyArg_Parse(args, ":getDirection"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const DirectionalLight*)local_this)->get_direction());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirection(const DirectionalLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_get_direction_45_comment =
    "C++ Interface:\n"
    "getDirection(const DirectionalLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::get_direction\n"
    "//       Access: Public\n"
    "//  Description: Returns the direction in which the light is aimed.\n"
    "//               This is local to the coordinate space in which the\n"
    "//               light is assigned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_get_direction_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DirectionalLight::set_direction(LVector3f const &direction)
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_set_direction_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DirectionalLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DirectionalLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DirectionalLight::set_direction(LVector3f const &direction)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"direction", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDirection", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDirection", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "DirectionalLight.setDirection", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_direction(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DirectionalLight.setDirection() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDirection(non-const DirectionalLight this, const Vec3 direction)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_set_direction_46_comment =
    "C++ Interface:\n"
    "setDirection(non-const DirectionalLight this, const Vec3 direction)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DirectionalLight::set_direction\n"
    "//       Access: Public\n"
    "//  Description: Sets the direction in which the light is aimed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DirectionalLight_set_direction_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DirectionalLight::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DirectionalLight_get_class_type_47(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DirectionalLight::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DirectionalLight::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DirectionalLight_get_class_type_47_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DirectionalLight_get_class_type_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DirectionalLight::DirectionalLight(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_DirectionalLight(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DirectionalLight::DirectionalLight(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DirectionalLight", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:DirectionalLight", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            DirectionalLight *return_value = new DirectionalLight(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DirectionalLight,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DirectionalLight(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DirectionalLight(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DirectionalLight)
    {
        printf("DirectionalLight ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DirectionalLight * local_this = (DirectionalLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DirectionalLight)
        return local_this;
    if(requested_type == &Dtool_Camera)
        return ( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LensNode)
        return ( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LightLensNode)
        return ( LightLensNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DirectionalLight(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DirectionalLight)
        return from_this;
    if(from_type == &Dtool_Camera)
    {
          Camera* other_this = (Camera*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_LensNode)
    {
          LensNode* other_this = (LensNode*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_LightLensNode)
    {
          LightLensNode* other_this = (LightLensNode*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DirectionalLight*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (DirectionalLight*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LODNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PointerTo< LODNode > LODNode::make_default_lod(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_LODNode_make_default_lod_51(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< LODNode > LODNode::make_default_lod(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeDefaultLod", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:makeDefaultLod", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PointerTo< LODNode > return_value = LODNode::make_default_lod(basic_string<char>(param0_str, param0_len));
            if (return_value != (LODNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_LODNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeDefaultLod(string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_make_default_lod_51_comment =
    "C++ Interface:\n"
    "makeDefaultLod(string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::make_default_lod\n"
    "//       Access: Published, Static\n"
    "//  Description: Creates a new LODNode of the type specified by the\n"
    "//               default-lod-type config variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_make_default_lod_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::add_switch(float in, float out)
 *******************************************************************/
static PyObject *Dtool_LODNode_add_switch_52(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LODNode::add_switch(float in, float out)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"in", (char *)"out", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addSwitch", key_word_list, &param1, &param2))
        {
            (local_this)->add_switch((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.addSwitch() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSwitch(non-const LODNode this, float in, float out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_add_switch_52_comment =
    "C++ Interface:\n"
    "addSwitch(non-const LODNode this, float in, float out)\n"
    "\n"
    "// The sense of in vs. out distances is as if the object were coming\n"
    "// towards you from far away: it switches \"in\" at the far distance,\n"
    "// and switches \"out\" at the close distance.  Thus, \"in\" should be\n"
    "// larger than \"out\".\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::add_switch\n"
    "//       Access: Published\n"
    "//  Description: Adds a switch range to the LODNode.  This implies\n"
    "//               that the corresponding child node has been parented\n"
    "//               to the node.\n"
    "//\n"
    "//               The sense of in vs. out distances is as if the object\n"
    "//               were coming towards you from far away: it switches\n"
    "//               \"in\" at the far distance, and switches \"out\" at the\n"
    "//               close distance.  Thus, \"in\" should be larger than\n"
    "//               \"out\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_add_switch_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LODNode::set_switch(int index, float in, float out)
 *******************************************************************/
static PyObject *Dtool_LODNode_set_switch_53(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool LODNode::set_switch(int index, float in, float out)
        int param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"index", (char *)"in", (char *)"out", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "idd:setSwitch", key_word_list, &param1, &param2, &param3))
        {
            bool return_value = (local_this)->set_switch((int)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.setSwitch() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSwitch(non-const LODNode this, int index, float in, float out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_set_switch_53_comment =
    "C++ Interface:\n"
    "setSwitch(non-const LODNode this, int index, float in, float out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::set_switch\n"
    "//       Access: Published\n"
    "//  Description: Changes the switching range of a particular child of\n"
    "//               the LODNode.  See add_switch().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_set_switch_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::clear_switches(void)
 *******************************************************************/
static PyObject *Dtool_LODNode_clear_switches_54(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LODNode::clear_switches(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSwitches", key_word_list));
        else
            (PyArg_Parse(args, ":clearSwitches"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_switches();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.clearSwitches() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSwitches(non-const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_clear_switches_54_comment =
    "C++ Interface:\n"
    "clearSwitches(non-const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::clear_switches\n"
    "//       Access: Published\n"
    "//  Description: Removes the set of switching ranges for the LODNode,\n"
    "//               presumably in conjunction with removing all of its\n"
    "//               children.  See add_switch().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_clear_switches_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LODNode::get_num_switches(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_num_switches_55(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LODNode::get_num_switches(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSwitches", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSwitches"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LODNode*)local_this)->get_num_switches();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSwitches(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_num_switches_55_comment =
    "C++ Interface:\n"
    "getNumSwitches(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_num_switches\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of switch ranges added to the\n"
    "//               LODNode.  This should correspond to the number of\n"
    "//               children of the node in order for the LODNode to\n"
    "//               function correctly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_num_switches_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LODNode::get_in(int index) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_in_56(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LODNode::get_in(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getIn", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getIn", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LODNode*)local_this)->get_in((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIn(const LODNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_in_56_comment =
    "C++ Interface:\n"
    "getIn(const LODNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_in\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"in\" distance of the indicated switch\n"
    "//               range.  This should be larger than the \"out\" distance\n"
    "//               of the same range.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_in_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LODNode::get_out(int index) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_out_57(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LODNode::get_out(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getOut", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getOut", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LODNode*)local_this)->get_out((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOut(const LODNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_out_57_comment =
    "C++ Interface:\n"
    "getOut(const LODNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_out\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"out\" distance of the indicated switch\n"
    "//               range.  This should be smaller than the \"in\" distance\n"
    "//               of the same range.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_out_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LODNode::get_lowest_switch(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_lowest_switch_58(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LODNode::get_lowest_switch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLowestSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":getLowestSwitch"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LODNode*)local_this)->get_lowest_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLowestSwitch(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_lowest_switch_58_comment =
    "C++ Interface:\n"
    "getLowestSwitch(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_lowest_switch\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of the child with the lowest\n"
    "//               level of detail; that is, the one that is designed to\n"
    "//               be seen from the farthest away.  This is usually the\n"
    "//               first child, but it is not necessarily so.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_lowest_switch_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LODNode::get_highest_switch(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_highest_switch_59(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int LODNode::get_highest_switch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestSwitch"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const LODNode*)local_this)->get_highest_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestSwitch(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_highest_switch_59_comment =
    "C++ Interface:\n"
    "getHighestSwitch(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_highest_switch\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of the child with the highest\n"
    "//               level of detail; that is, the one that is designed to\n"
    "//               be seen from the closest to the camera.  This is\n"
    "//               usually the last child, but it is not necessarily so.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_highest_switch_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::force_switch(int index)
 *******************************************************************/
static PyObject *Dtool_LODNode_force_switch_60(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LODNode::force_switch(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:forceSwitch", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:forceSwitch", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->force_switch((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.forceSwitch() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceSwitch(non-const LODNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_force_switch_60_comment =
    "C++ Interface:\n"
    "forceSwitch(non-const LODNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::force_switch\n"
    "//       Access: Published\n"
    "//  Description: Forces the LODNode to show the indicated level\n"
    "//               instead of the level that would normally be shown\n"
    "//               based on the distance from the camera.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_force_switch_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::clear_force_switch(void)
 *******************************************************************/
static PyObject *Dtool_LODNode_clear_force_switch_61(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LODNode::clear_force_switch(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearForceSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":clearForceSwitch"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_force_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.clearForceSwitch() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearForceSwitch(non-const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_clear_force_switch_61_comment =
    "C++ Interface:\n"
    "clearForceSwitch(non-const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::clear_force_switch\n"
    "//       Access: Published\n"
    "//  Description: Undoes the effect of a previous call to\n"
    "//               force_switch() and releases the LODNode to once again\n"
    "//               display the normal level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_clear_force_switch_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::set_lod_scale(float value)
 *******************************************************************/
static PyObject *Dtool_LODNode_set_lod_scale_62(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LODNode::set_lod_scale(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLodScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLodScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_lod_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.setLodScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLodScale(non-const LODNode this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_set_lod_scale_62_comment =
    "C++ Interface:\n"
    "setLodScale(non-const LODNode this, float value)\n"
    "\n"
    "//for performance tuning, increasing this value should improve performance\n"
    "//at the cost of model quality\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::set_lod_scale\n"
    "//       Access: Published\n"
    "//  Description: Sets the multiplier for lod distances. A higher \n"
    "//               value means you'll see farther switchs than normal\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_set_lod_scale_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LODNode::get_lod_scale(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_lod_scale_63(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LODNode::get_lod_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLodScale", key_word_list));
        else
            (PyArg_Parse(args, ":getLodScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LODNode*)local_this)->get_lod_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLodScale(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_lod_scale_63_comment =
    "C++ Interface:\n"
    "getLodScale(const LODNode this)\n"
    "\n"
    "//for performance tuning, increasing this value should improve performance\n"
    "//at the cost of model quality\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_lod_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the multiplier for lod distances\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_lod_scale_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LODNode::set_center(LPoint3f const &center)
 *******************************************************************/
static PyObject *Dtool_LODNode_set_center_64(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LODNode::set_center(LPoint3f const &center)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"center", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCenter", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "LODNode.setCenter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_center(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LODNode.setCenter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCenter(non-const LODNode this, const Point3 center)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_set_center_64_comment =
    "C++ Interface:\n"
    "setCenter(non-const LODNode this, const Point3 center)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::set_center\n"
    "//       Access: Published\n"
    "//  Description: Specifies the center of the LOD.  This is the point\n"
    "//               that is compared to the camera (in camera space) to\n"
    "//               determine the particular LOD that should be chosen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_set_center_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &LODNode::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_get_center_65(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &LODNode::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const LODNode*)local_this)->get_center());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_center_65_comment =
    "C++ Interface:\n"
    "getCenter(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::get_center\n"
    "//       Access: Published\n"
    "//  Description: Returns the center of the LOD.  This is the point\n"
    "//               that is compared to the camera (in camera space) to\n"
    "//               determine the particular LOD that should be chosen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_get_center_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LODNode::show_switch(int index)
 * void LODNode::show_switch(int index, LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_LODNode_show_switch_66(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void LODNode::show_switch(int index)
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:showSwitch", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:showSwitch", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->show_switch((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LODNode.showSwitch() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void LODNode::show_switch(int index, LVecBase4f const &color)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"index", (char *)"color", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:showSwitch", key_word_list, &param1, &param2))
                {
                    LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "LODNode.showSwitch", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->show_switch((int)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LODNode.showSwitch() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "showSwitch() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "showSwitch(non-const LODNode this, int index)\n"
          "showSwitch(non-const LODNode this, int index, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_show_switch_66_comment =
    "C++ Interface:\n"
    "showSwitch(non-const LODNode this, int index)\n"
    "showSwitch(non-const LODNode this, int index, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::show_switch\n"
    "//       Access: Published\n"
    "//  Description: This is provided as a debugging aid.  show_switch()\n"
    "//               will put the LODNode into a special mode where rather\n"
    "//               than computing and drawing the appropriate level of\n"
    "//               the LOD, a ring is drawn around the LODNode center\n"
    "//               indicating the switch distances from the camera for\n"
    "//               the indicated level, and the geometry of the\n"
    "//               indicated level is drawn in wireframe.\n"
    "//\n"
    "//               Multiple different levels can be visualized this way\n"
    "//               at once.  Call hide_switch() or hide_all_switches() to\n"
    "//               undo this mode and restore the LODNode to its normal\n"
    "//               behavior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::show_switch\n"
    "//       Access: Published\n"
    "//  Description: This is provided as a debugging aid.  show_switch()\n"
    "//               will put the LODNode into a special mode where rather\n"
    "//               than computing and drawing the appropriate level of\n"
    "//               the LOD, a ring is drawn around the LODNode center\n"
    "//               indicating the switch distances from the camera for\n"
    "//               the indicated level, and the geometry of the\n"
    "//               indicated level is drawn in wireframe.\n"
    "//\n"
    "//               Multiple different levels can be visualized this way\n"
    "//               at once.  Call hide_switch() or hide_all_switches() to\n"
    "//               undo this mode and restore the LODNode to its normal\n"
    "//               behavior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_show_switch_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LODNode::hide_switch(int index)
 *******************************************************************/
static PyObject *Dtool_LODNode_hide_switch_67(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void LODNode::hide_switch(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hideSwitch", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hideSwitch", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->hide_switch((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.hideSwitch() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hideSwitch(non-const LODNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_hide_switch_67_comment =
    "C++ Interface:\n"
    "hideSwitch(non-const LODNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::hide_switch\n"
    "//       Access: Published\n"
    "//  Description: Disables a previous call to show_switch().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_hide_switch_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LODNode::show_all_switches(void)
 *******************************************************************/
static PyObject *Dtool_LODNode_show_all_switches_68(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void LODNode::show_all_switches(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":showAllSwitches", key_word_list));
        else
            (PyArg_Parse(args, ":showAllSwitches"));
        if(!PyErr_Occurred())
        {
            (local_this)->show_all_switches();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.showAllSwitches() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "showAllSwitches(non-const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_show_all_switches_68_comment =
    "C++ Interface:\n"
    "showAllSwitches(non-const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::show_all_switches\n"
    "//       Access: Published\n"
    "//  Description: Shows all levels in their default colors.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_show_all_switches_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LODNode::hide_all_switches(void)
 *******************************************************************/
static PyObject *Dtool_LODNode_hide_all_switches_69(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void LODNode::hide_all_switches(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hideAllSwitches", key_word_list));
        else
            (PyArg_Parse(args, ":hideAllSwitches"));
        if(!PyErr_Occurred())
        {
            (local_this)->hide_all_switches();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LODNode.hideAllSwitches() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hideAllSwitches(non-const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_hide_all_switches_69_comment =
    "C++ Interface:\n"
    "hideAllSwitches(non-const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::hide_all_switches\n"
    "//       Access: Published\n"
    "//  Description: Hides all levels, restoring the LODNode to normal\n"
    "//               operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_hide_all_switches_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LODNode::is_any_shown(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_is_any_shown_70(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LODNode::is_any_shown(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAnyShown", key_word_list));
        else
            (PyArg_Parse(args, ":isAnyShown"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LODNode*)local_this)->is_any_shown();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAnyShown(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_is_any_shown_70_comment =
    "C++ Interface:\n"
    "isAnyShown(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::is_any_shown\n"
    "//       Access: Published\n"
    "//  Description: Returns true if any switch has been shown with\n"
    "//               show_switch(), indicating the LODNode is in debug\n"
    "//               show mode; or false if it is in the normal mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_is_any_shown_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool LODNode::verify_child_bounds(void) const
 *******************************************************************/
static PyObject *Dtool_LODNode_verify_child_bounds_71(PyObject *self, PyObject *args,PyObject *kwds) {
    LODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool LODNode::verify_child_bounds(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":verifyChildBounds", key_word_list));
        else
            (PyArg_Parse(args, ":verifyChildBounds"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LODNode*)local_this)->verify_child_bounds();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "verifyChildBounds(const LODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_verify_child_bounds_71_comment =
    "C++ Interface:\n"
    "verifyChildBounds(const LODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LODNode::verify_child_bounds\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the bounding volumes for the geometry\n"
    "//               of each fhild node entirely fits within the\n"
    "//               switch_in radius for that child, or false otherwise.\n"
    "//               It is almost always a mistake for the geometry of an\n"
    "//               LOD level to be larger than its switch_in radius.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LODNode_verify_child_bounds_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LODNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LODNode_get_class_type_72(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LODNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LODNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LODNode_get_class_type_72_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LODNode_get_class_type_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LODNode::LODNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_LODNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline LODNode::LODNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LODNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:LODNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            LODNode *return_value = new LODNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_LODNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "LODNode(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_LODNode_get_ins(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSwitches", "getIn");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_LODNode_get_outs(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSwitches", "getOut");
}
inline void  * Dtool_UpcastInterface_LODNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LODNode)
    {
        printf("LODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LODNode * local_this = (LODNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LODNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LODNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LODNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (LODNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (LODNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LODNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (LODNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FadeLODNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void FadeLODNode::set_fade_time(float t)
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_set_fade_time_76(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void FadeLODNode::set_fade_time(float t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFadeTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFadeTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fade_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FadeLODNode.setFadeTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFadeTime(non-const FadeLODNode this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_set_fade_time_76_comment =
    "C++ Interface:\n"
    "setFadeTime(non-const FadeLODNode this, float t)\n"
    "\n"
    "// Filename: fadelodNode.I\n"
    "// Created by:  sshodhan (14Jun04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::set_fade_time\n"
    "//       Access: Published\n"
    "//  Description: set the time taken to complete an LOD switch\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_set_fade_time_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float FadeLODNode::get_fade_time(void) const
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_get_fade_time_77(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float FadeLODNode::get_fade_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFadeTime", key_word_list));
        else
            (PyArg_Parse(args, ":getFadeTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FadeLODNode*)local_this)->get_fade_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFadeTime(const FadeLODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_get_fade_time_77_comment =
    "C++ Interface:\n"
    "getFadeTime(const FadeLODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::get_fade_time\n"
    "//       Access: Published\n"
    "//  Description: get the time taken to complete an LOD switch\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_get_fade_time_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FadeLODNode::set_fade_bin(basic_string< char > const &name, int draw_order)
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_set_fade_bin_78(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FadeLODNode::set_fade_bin(basic_string< char > const &name, int draw_order)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"name", (char *)"draw_order", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setFadeBin", key_word_list, &param1_str, &param1_len, &param2))
        {
            (local_this)->set_fade_bin(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FadeLODNode.setFadeBin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFadeBin(non-const FadeLODNode this, string name, int draw_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_set_fade_bin_78_comment =
    "C++ Interface:\n"
    "setFadeBin(non-const FadeLODNode this, string name, int draw_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::set_fade_bin\n"
    "//       Access: Published\n"
    "//  Description: Specifies the cull bin and draw order that is\n"
    "//               assigned to the fading part of the geometry during a\n"
    "//               transition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_set_fade_bin_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &FadeLODNode::get_fade_bin_name(void) const
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_get_fade_bin_name_79(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &FadeLODNode::get_fade_bin_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFadeBinName", key_word_list));
        else
            (PyArg_Parse(args, ":getFadeBinName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const FadeLODNode*)local_this)->get_fade_bin_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFadeBinName(const FadeLODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_get_fade_bin_name_79_comment =
    "C++ Interface:\n"
    "getFadeBinName(const FadeLODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::get_fade_bin_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the cull bin that is assigned to the fading\n"
    "//               part of the geometry during a transition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_get_fade_bin_name_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FadeLODNode::get_fade_bin_draw_order(void) const
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_get_fade_bin_draw_order_80(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FadeLODNode::get_fade_bin_draw_order(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFadeBinDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":getFadeBinDrawOrder"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FadeLODNode*)local_this)->get_fade_bin_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFadeBinDrawOrder(const FadeLODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_get_fade_bin_draw_order_80_comment =
    "C++ Interface:\n"
    "getFadeBinDrawOrder(const FadeLODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::get_fade_bin_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Returns the draw order that is assigned (along with\n"
    "//               the bin name) to the fading part of the geometry\n"
    "//               during a transition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_get_fade_bin_draw_order_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void FadeLODNode::set_fade_state_override(int override)
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_set_fade_state_override_81(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void FadeLODNode::set_fade_state_override(int override)
        int param1;
        static char * key_word_list[] = {(char *)"override", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFadeStateOverride", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFadeStateOverride", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fade_state_override((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FadeLODNode.setFadeStateOverride() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFadeStateOverride(non-const FadeLODNode this, int override)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_set_fade_state_override_81_comment =
    "C++ Interface:\n"
    "setFadeStateOverride(non-const FadeLODNode this, int override)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::set_fade_state_override\n"
    "//       Access: Published\n"
    "//  Description: Specifies the override value that is applied to the\n"
    "//               state changes necessary to apply the fade effect.\n"
    "//               This should be larger than any attrib overrides on\n"
    "//               the fading geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_set_fade_state_override_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int FadeLODNode::get_fade_state_override(void) const
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_get_fade_state_override_82(PyObject *self, PyObject *args,PyObject *kwds) {
    FadeLODNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FadeLODNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int FadeLODNode::get_fade_state_override(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFadeStateOverride", key_word_list));
        else
            (PyArg_Parse(args, ":getFadeStateOverride"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const FadeLODNode*)local_this)->get_fade_state_override();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFadeStateOverride(const FadeLODNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_get_fade_state_override_82_comment =
    "C++ Interface:\n"
    "getFadeStateOverride(const FadeLODNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FadeLODNode::get_fade_state_override\n"
    "//       Access: Published\n"
    "//  Description: Returns the override value that is applied to the\n"
    "//               state changes necessary to apply the fade effect.\n"
    "//               This should be larger than any attrib overrides on\n"
    "//               the fading geometry.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FadeLODNode_get_fade_state_override_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FadeLODNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FadeLODNode_get_class_type_83(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FadeLODNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FadeLODNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FadeLODNode_get_class_type_83_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FadeLODNode_get_class_type_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * FadeLODNode::FadeLODNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_FadeLODNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-FadeLODNode::FadeLODNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:FadeLODNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:FadeLODNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            FadeLODNode *return_value = new FadeLODNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_FadeLODNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FadeLODNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FadeLODNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FadeLODNode)
    {
        printf("FadeLODNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FadeLODNode * local_this = (FadeLODNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FadeLODNode)
        return local_this;
    if(requested_type == &Dtool_LODNode)
        return ( LODNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LODNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LODNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( LODNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LODNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LODNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FadeLODNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FadeLODNode)
        return from_this;
    if(from_type == &Dtool_LODNode)
    {
          LODNode* other_this = (LODNode*)from_this;
          return (FadeLODNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (FadeLODNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (FadeLODNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FadeLODNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FadeLODNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NodeCullCallbackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CullTraverser *NodeCullCallbackData::get_trav(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCullCallbackData_get_trav_87(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCullCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCullCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CullTraverser *NodeCullCallbackData::get_trav(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrav", key_word_list));
        else
            (PyArg_Parse(args, ":getTrav"));
        if(!PyErr_Occurred())
        {
            CullTraverser *return_value = ((const NodeCullCallbackData*)local_this)->get_trav();
            if (return_value != (CullTraverser *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CullTraverser,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrav(const NodeCullCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCullCallbackData_get_trav_87_comment =
    "C++ Interface:\n"
    "getTrav(const NodeCullCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCullCallbackData::get_trav\n"
    "//       Access: Published\n"
    "//  Description: Returns the CullTraverser in use at the time of the\n"
    "//               callback.  This object contains data that does not\n"
    "//               change during the traversal, such as the\n"
    "//               DisplayRegion and Camera in use.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCullCallbackData_get_trav_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CullTraverserData &NodeCullCallbackData::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_NodeCullCallbackData_get_data_88(PyObject *self, PyObject *args,PyObject *kwds) {
    NodeCullCallbackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NodeCullCallbackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CullTraverserData &NodeCullCallbackData::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            CullTraverserData *return_value = &(((const NodeCullCallbackData*)local_this)->get_data());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_CullTraverserData,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const NodeCullCallbackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCullCallbackData_get_data_88_comment =
    "C++ Interface:\n"
    "getData(const NodeCullCallbackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NodeCullCallbackData::get_data\n"
    "//       Access: Published\n"
    "//  Description: Returns the CullTraverserData in use at the time of the\n"
    "//               callback.  This object contains data that changes at\n"
    "//               each node of the traversal, such as the current node\n"
    "//               and the current net transform to that node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NodeCullCallbackData_get_data_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NodeCullCallbackData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NodeCullCallbackData_get_class_type_89(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NodeCullCallbackData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NodeCullCallbackData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NodeCullCallbackData_get_class_type_89_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NodeCullCallbackData_get_class_type_89_comment = NULL;
#endif

int  Dtool_Init_NodeCullCallbackData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NodeCullCallbackData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NodeCullCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NodeCullCallbackData)
    {
        printf("NodeCullCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NodeCullCallbackData * local_this = (NodeCullCallbackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NodeCullCallbackData)
        return local_this;
    if(requested_type == &Dtool_CallbackData)
        return ( CallbackData *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( CallbackData *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NodeCullCallbackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NodeCullCallbackData)
        return from_this;
    if(from_type == &Dtool_CallbackData)
    {
          CallbackData* other_this = (CallbackData*)from_this;
          return (NodeCullCallbackData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NodeCullCallbackData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointLight 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &PointLight::get_specular_color(void) const
 *******************************************************************/
static PyObject *Dtool_PointLight_get_specular_color_93(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &PointLight::get_specular_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpecularColor", key_word_list));
        else
            (PyArg_Parse(args, ":getSpecularColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const PointLight*)local_this)->get_specular_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpecularColor(const PointLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_get_specular_color_93_comment =
    "C++ Interface:\n"
    "getSpecularColor(const PointLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::get_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Returns the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_get_specular_color_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointLight::set_specular_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_PointLight_set_specular_color_94(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointLight::set_specular_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpecularColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSpecularColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PointLight.setSpecularColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_specular_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointLight.setSpecularColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpecularColor(non-const PointLight this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_set_specular_color_94_comment =
    "C++ Interface:\n"
    "setSpecularColor(non-const PointLight this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::set_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_set_specular_color_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &PointLight::get_attenuation(void) const
 *******************************************************************/
static PyObject *Dtool_PointLight_get_attenuation_95(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &PointLight::get_attenuation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAttenuation", key_word_list));
        else
            (PyArg_Parse(args, ":getAttenuation"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const PointLight*)local_this)->get_attenuation());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAttenuation(const PointLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_get_attenuation_95_comment =
    "C++ Interface:\n"
    "getAttenuation(const PointLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::get_attenuation\n"
    "//       Access: Public\n"
    "//  Description: Returns the terms of the attenuation equation for the\n"
    "//               light.  These are, in order, the constant, linear,\n"
    "//               and quadratic terms based on the distance from the\n"
    "//               point to the vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_get_attenuation_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointLight::set_attenuation(LVecBase3f const &attenuation)
 *******************************************************************/
static PyObject *Dtool_PointLight_set_attenuation_96(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointLight::set_attenuation(LVecBase3f const &attenuation)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"attenuation", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAttenuation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAttenuation", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PointLight.setAttenuation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_attenuation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointLight.setAttenuation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAttenuation(non-const PointLight this, const VBase3 attenuation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_set_attenuation_96_comment =
    "C++ Interface:\n"
    "setAttenuation(non-const PointLight this, const VBase3 attenuation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::set_attenuation\n"
    "//       Access: Public\n"
    "//  Description: Sets the terms of the attenuation equation for the\n"
    "//               light.  These are, in order, the constant, linear,\n"
    "//               and quadratic terms based on the distance from the\n"
    "//               point to the vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_set_attenuation_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &PointLight::get_point(void) const
 *******************************************************************/
static PyObject *Dtool_PointLight_get_point_97(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &PointLight::get_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getPoint"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const PointLight*)local_this)->get_point());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const PointLight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_get_point_97_comment =
    "C++ Interface:\n"
    "getPoint(const PointLight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::get_point\n"
    "//       Access: Public\n"
    "//  Description: Returns the point in space at which the light is\n"
    "//               located.  This is local to the coordinate space in\n"
    "//               which the light is assigned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_get_point_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointLight::set_point(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_PointLight_set_point_98(PyObject *self, PyObject *args,PyObject *kwds) {
    PointLight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointLight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PointLight::set_point(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPoint", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PointLight.setPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_point(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointLight.setPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPoint(non-const PointLight this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_set_point_98_comment =
    "C++ Interface:\n"
    "setPoint(non-const PointLight this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointLight::set_point\n"
    "//       Access: Public\n"
    "//  Description: Sets the point in space at which the light is located.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointLight_set_point_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PointLight::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PointLight_get_class_type_99(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PointLight::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PointLight::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointLight_get_class_type_99_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PointLight_get_class_type_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointLight::PointLight(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PointLight(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PointLight::PointLight(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PointLight", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PointLight", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PointLight *return_value = new PointLight(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PointLight,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PointLight(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointLight(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointLight)
    {
        printf("PointLight ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointLight * local_this = (PointLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointLight)
        return local_this;
    if(requested_type == &Dtool_Camera)
        return ( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LensNode)
        return ( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LightLensNode)
        return ( LightLensNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointLight(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointLight)
        return from_this;
    if(from_type == &Dtool_Camera)
    {
          Camera* other_this = (Camera*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_LensNode)
    {
          LensNode* other_this = (LensNode*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_LightLensNode)
    {
          LightLensNode* other_this = (LightLensNode*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PointLight*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PointLight*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SelectiveChildNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SelectiveChildNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SelectiveChildNode_get_class_type_103(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SelectiveChildNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SelectiveChildNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SelectiveChildNode_get_class_type_103_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SelectiveChildNode_get_class_type_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void)
 *******************************************************************/
static PyObject *Dtool_SelectiveChildNode_downcast_to_SequenceNode_107(PyObject *self, PyObject *args,PyObject *kwds) {
    SelectiveChildNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SelectiveChildNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SequenceNode *SelectiveChildNode::downcast_to_SequenceNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToSequenceNode", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToSequenceNode"));
        if(!PyErr_Occurred())
        {
            SequenceNode *return_value = (SequenceNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_SequenceNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SelectiveChildNode.downcastToSequenceNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToSequenceNode(non-const SelectiveChildNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SelectiveChildNode_downcast_to_SequenceNode_107_comment =
    "C++ Interface:\n"
    "downcastToSequenceNode(non-const SelectiveChildNode this)\n"
    "\n"
    "downcast from SelectiveChildNode to SequenceNode\n"
    "";
#else
static const char * Dtool_SelectiveChildNode_downcast_to_SequenceNode_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SelectiveChildNode::SelectiveChildNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_SelectiveChildNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline SelectiveChildNode::SelectiveChildNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SelectiveChildNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:SelectiveChildNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            SelectiveChildNode *return_value = new SelectiveChildNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SelectiveChildNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SelectiveChildNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SelectiveChildNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SelectiveChildNode)
    {
        printf("SelectiveChildNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SelectiveChildNode * local_this = (SelectiveChildNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SelectiveChildNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SelectiveChildNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SelectiveChildNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (SelectiveChildNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (SelectiveChildNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SelectiveChildNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (SelectiveChildNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SequenceNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual int SequenceNode::get_num_frames(void) const
 *******************************************************************/
static PyObject *Dtool_SequenceNode_get_num_frames_112(PyObject *self, PyObject *args,PyObject *kwds) {
    SequenceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SequenceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int SequenceNode::get_num_frames(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFrames", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFrames"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SequenceNode*)local_this)->get_num_frames();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFrames(const SequenceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SequenceNode_get_num_frames_112_comment =
    "C++ Interface:\n"
    "getNumFrames(const SequenceNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SequenceNode::get_num_frames\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the number of frames in the animation.  This\n"
    "//               is a property of the animation and may not be\n"
    "//               directly adjusted by the user (although it may change\n"
    "//               without warning with certain kinds of animations,\n"
    "//               since this is a virtual method that may be\n"
    "//               overridden).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SequenceNode_get_num_frames_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SequenceNode::set_frame_rate(double frame_rate)
 *******************************************************************/
static PyObject *Dtool_SequenceNode_set_frame_rate_113(PyObject *self, PyObject *args,PyObject *kwds) {
    SequenceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SequenceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SequenceNode::set_frame_rate(double frame_rate)
        double param1;
        static char * key_word_list[] = {(char *)"frame_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFrameRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFrameRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_rate((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SequenceNode.setFrameRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameRate(non-const SequenceNode this, float frame_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SequenceNode_set_frame_rate_113_comment =
    "C++ Interface:\n"
    "setFrameRate(non-const SequenceNode this, float frame_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SequenceNode::set_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: Changes the advertised frame rate of the\n"
    "//               SequenceNode.  This can be used in conjunction with\n"
    "//               get_play_rate() to change the effective frame rate of\n"
    "//               the node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SequenceNode_set_frame_rate_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SequenceNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SequenceNode_get_class_type_114(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SequenceNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SequenceNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SequenceNode_get_class_type_114_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SequenceNode_get_class_type_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
 *******************************************************************/
static PyObject *Dtool_SequenceNode_upcast_to_SelectiveChildNode_106(PyObject *self, PyObject *args,PyObject *kwds) {
    SequenceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SequenceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-SelectiveChildNode *SequenceNode::upcast_to_SelectiveChildNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToSelectiveChildNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToSelectiveChildNode"));
        if(!PyErr_Occurred())
        {
            SelectiveChildNode *return_value = (SelectiveChildNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_SelectiveChildNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SequenceNode.upcastToSelectiveChildNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToSelectiveChildNode(non-const SequenceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SequenceNode_upcast_to_SelectiveChildNode_106_comment =
    "C++ Interface:\n"
    "upcastToSelectiveChildNode(non-const SequenceNode this)\n"
    "\n"
    "upcast from SequenceNode to SelectiveChildNode\n"
    "";
#else
static const char * Dtool_SequenceNode_upcast_to_SelectiveChildNode_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
 *******************************************************************/
static PyObject *Dtool_SequenceNode_upcast_to_AnimInterface_109(PyObject *self, PyObject *args,PyObject *kwds) {
    SequenceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SequenceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AnimInterface *SequenceNode::upcast_to_AnimInterface(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToAnimInterface", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToAnimInterface"));
        if(!PyErr_Occurred())
        {
            AnimInterface *return_value = (AnimInterface *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AnimInterface,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SequenceNode.upcastToAnimInterface() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToAnimInterface(non-const SequenceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SequenceNode_upcast_to_AnimInterface_109_comment =
    "C++ Interface:\n"
    "upcastToAnimInterface(non-const SequenceNode this)\n"
    "\n"
    "upcast from SequenceNode to AnimInterface\n"
    "";
#else
static const char * Dtool_SequenceNode_upcast_to_AnimInterface_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SequenceNode::SequenceNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_SequenceNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline SequenceNode::SequenceNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SequenceNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:SequenceNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            SequenceNode *return_value = new SequenceNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SequenceNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SequenceNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SequenceNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SequenceNode)
    {
        printf("SequenceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SequenceNode * local_this = (SequenceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SequenceNode)
        return local_this;
    if(requested_type == &Dtool_AnimInterface)
        return ( AnimInterface *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_SelectiveChildNode)
        return ( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( SelectiveChildNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SequenceNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SequenceNode)
        return from_this;
    if(from_type == &Dtool_AnimInterface)
    {
          AnimInterface* other_this = (AnimInterface*)from_this;
          return (SequenceNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (SequenceNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (SequenceNode*)other_this;
    }
    if(from_type == &Dtool_SelectiveChildNode)
    {
          SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
          return (SequenceNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SequenceNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (SequenceNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ShaderGenerator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual ConstPointerTo< RenderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs)
 *******************************************************************/
static PyObject *Dtool_ShaderGenerator_synthesize_shader_119(PyObject *self, PyObject *args,PyObject *kwds) {
    ShaderGenerator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ShaderGenerator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual ConstPointerTo< RenderAttrib > ShaderGenerator::synthesize_shader(RenderState const *rs)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rs", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:synthesizeShader", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:synthesizeShader", &param1));
            if(!PyErr_Occurred())
            {
                RenderState *param1_this = (RenderState *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_RenderState, 1, "ShaderGenerator.synthesizeShader", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ConstPointerTo< RenderAttrib > return_value = (local_this)->synthesize_shader(param1_this);
                    if (return_value != (RenderAttrib const *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_RenderAttrib,true, true, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ShaderGenerator.synthesizeShader() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "synthesizeShader(non-const ShaderGenerator this, const RenderState rs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ShaderGenerator_synthesize_shader_119_comment =
    "C++ Interface:\n"
    "synthesizeShader(non-const ShaderGenerator this, const RenderState rs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ShaderGenerator::synthesize_shader\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is the routine that implements the next-gen\n"
    "//               fixed function pipeline by synthesizing a shader.\n"
    "//               It also takes care of setting up any buffers\n"
    "//               needed to produce the requested effects.\n"
    "//\n"
    "//               Currently supports:\n"
    "//               - flat colors\n"
    "//               - vertex colors\n"
    "//               - lighting\n"
    "//               - normal maps, but not multiple\n"
    "//               - gloss maps, but not multiple\n"
    "//               - glow maps, but not multiple\n"
    "//               - materials, but not updates to materials\n"
    "//               - 2D textures\n"
    "//               - all texture stage modes, including combine modes\n"
    "//               - color scale attrib\n"
    "//               - light ramps (for cartoon shading)\n"
    "//               - shadow mapping\n"
    "//               - most texgen modes\n"
    "//               - texmatrix\n"
    "//               - 1D/2D/3D textures, cube textures\n"
    "//\n"
    "//               Not yet supported:\n"
    "//               - dot3_rgb and dot3_rgba combine modes\n"
    "//               - fog\n"
    "//\n"
    "//               Potential optimizations\n"
    "//               - omit attenuation calculations if attenuation off\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ShaderGenerator_synthesize_shader_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ShaderGenerator::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ShaderGenerator_get_class_type_120(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ShaderGenerator::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ShaderGenerator::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ShaderGenerator_get_class_type_120_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ShaderGenerator_get_class_type_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ShaderGenerator::ShaderGenerator(PointerTo< GraphicsStateGuardianBase > gsg, PointerTo< GraphicsOutputBase > host)
 *******************************************************************/
int  Dtool_Init_ShaderGenerator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-ShaderGenerator::ShaderGenerator(PointerTo< GraphicsStateGuardianBase > gsg, PointerTo< GraphicsOutputBase > host)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"gsg", (char *)"host", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:ShaderGenerator", key_word_list, &param0, &param1))
            {
                GraphicsStateGuardianBase *param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsStateGuardianBase, 0, "ShaderGenerator.ShaderGenerator", 1, coerced_ptr, report_errors);
GraphicsOutputBase *param1_this = (GraphicsOutputBase *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GraphicsOutputBase, 1, "ShaderGenerator.ShaderGenerator", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    ShaderGenerator *return_value = new ShaderGenerator(param0_this, param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ShaderGenerator,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ShaderGenerator(const GraphicsStateGuardianBase gsg, const GraphicsOutputBase host)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ShaderGenerator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ShaderGenerator)
    {
        printf("ShaderGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ShaderGenerator * local_this = (ShaderGenerator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ShaderGenerator)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ShaderGenerator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ShaderGenerator)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ShaderGenerator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Spotlight 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float Spotlight::get_exponent(void) const
 *******************************************************************/
static PyObject *Dtool_Spotlight_get_exponent_123(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Spotlight::get_exponent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExponent", key_word_list));
        else
            (PyArg_Parse(args, ":getExponent"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Spotlight*)local_this)->get_exponent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExponent(const Spotlight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_get_exponent_123_comment =
    "C++ Interface:\n"
    "getExponent(const Spotlight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::get_exponent\n"
    "//       Access: Public\n"
    "//  Description: Returns the exponent that controls the amount of\n"
    "//               light falloff from the center of the spotlight.  See\n"
    "//               set_exponent().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_get_exponent_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Spotlight::set_exponent(float exponent)
 *******************************************************************/
static PyObject *Dtool_Spotlight_set_exponent_124(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Spotlight::set_exponent(float exponent)
        double param1;
        static char * key_word_list[] = {(char *)"exponent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setExponent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setExponent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_exponent((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Spotlight.setExponent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExponent(non-const Spotlight this, float exponent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_set_exponent_124_comment =
    "C++ Interface:\n"
    "setExponent(non-const Spotlight this, float exponent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::set_exponent\n"
    "//       Access: Public\n"
    "//  Description: Sets the exponent that controls the amount of light\n"
    "//               falloff from the center of the spotlight.  The light\n"
    "//               is attenuated by the cosine of the angle between the\n"
    "//               direction of the light and the direction of the point\n"
    "//               being lighted, raised to the power of this exponent.\n"
    "//               Thus, higher exponents result in a more focused light\n"
    "//               source, regardless of the field-of-view of the lens.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_set_exponent_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &Spotlight::get_specular_color(void) const
 *******************************************************************/
static PyObject *Dtool_Spotlight_get_specular_color_125(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &Spotlight::get_specular_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpecularColor", key_word_list));
        else
            (PyArg_Parse(args, ":getSpecularColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const Spotlight*)local_this)->get_specular_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpecularColor(const Spotlight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_get_specular_color_125_comment =
    "C++ Interface:\n"
    "getSpecularColor(const Spotlight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::get_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Returns the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_get_specular_color_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Spotlight::set_specular_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_Spotlight_set_specular_color_126(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Spotlight::set_specular_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpecularColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSpecularColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "Spotlight.setSpecularColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_specular_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Spotlight.setSpecularColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpecularColor(non-const Spotlight this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_set_specular_color_126_comment =
    "C++ Interface:\n"
    "setSpecularColor(non-const Spotlight this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::set_specular_color\n"
    "//       Access: Public\n"
    "//  Description: Sets the color of specular highlights generated by\n"
    "//               the light.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_set_specular_color_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &Spotlight::get_attenuation(void) const
 *******************************************************************/
static PyObject *Dtool_Spotlight_get_attenuation_127(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &Spotlight::get_attenuation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAttenuation", key_word_list));
        else
            (PyArg_Parse(args, ":getAttenuation"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const Spotlight*)local_this)->get_attenuation());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAttenuation(const Spotlight this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_get_attenuation_127_comment =
    "C++ Interface:\n"
    "getAttenuation(const Spotlight this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::get_attenuation\n"
    "//       Access: Public\n"
    "//  Description: Returns the terms of the attenuation equation for the\n"
    "//               light.  These are, in order, the constant, linear,\n"
    "//               and quadratic terms based on the distance from the\n"
    "//               point to the vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_get_attenuation_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Spotlight::set_attenuation(LVecBase3f const &attenuation)
 *******************************************************************/
static PyObject *Dtool_Spotlight_set_attenuation_128(PyObject *self, PyObject *args,PyObject *kwds) {
    Spotlight * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Spotlight,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Spotlight::set_attenuation(LVecBase3f const &attenuation)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"attenuation", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAttenuation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAttenuation", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "Spotlight.setAttenuation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_attenuation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Spotlight.setAttenuation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAttenuation(non-const Spotlight this, const VBase3 attenuation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_set_attenuation_128_comment =
    "C++ Interface:\n"
    "setAttenuation(non-const Spotlight this, const VBase3 attenuation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::set_attenuation\n"
    "//       Access: Public\n"
    "//  Description: Sets the terms of the attenuation equation for the\n"
    "//               light.  These are, in order, the constant, linear,\n"
    "//               and quadratic terms based on the distance from the\n"
    "//               point to the vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_set_attenuation_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< Texture > Spotlight::make_spot(int pixel_width, float full_radius, LVecBase4f &fg, LVecBase4f &bg)
 *******************************************************************/
static PyObject *Dtool_Spotlight_make_spot_129(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static PointerTo< Texture > Spotlight::make_spot(int pixel_width, float full_radius, LVecBase4f &fg, LVecBase4f &bg)
            int param0;
            double param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"pixel_width", (char *)"full_radius", (char *)"fg", (char *)"bg", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "idOO:makeSpot", key_word_list, &param0, &param1, &param2, &param3))
            {
                LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "Spotlight.makeSpot", 0, coerced_ptr, report_errors);
LVecBase4f *param3_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase4f, 3, "Spotlight.makeSpot", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)))
                {
                    PointerTo< Texture > return_value = Spotlight::make_spot((int)param0, (float)param1, *param2_this, *param3_this);
                    if (return_value != (Texture *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_Texture,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeSpot(int pixel_width, float full_radius, non-const VBase4 fg, non-const VBase4 bg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_make_spot_129_comment =
    "C++ Interface:\n"
    "makeSpot(int pixel_width, float full_radius, non-const VBase4 fg, non-const VBase4 bg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Spotlight::make_spot\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a newly-generated Texture that renders a\n"
    "//               circular spot image as might be cast from the\n"
    "//               spotlight.  This may be projected onto target\n"
    "//               geometry (for instance, via\n"
    "//               NodePath::project_texture()) instead of actually\n"
    "//               enabling the light itself, as a cheesy way to make a\n"
    "//               high-resolution spot appear on the geometry.\n"
    "//\n"
    "//               pixel_width specifies the height and width of the new\n"
    "//               texture in pixels, full_radius is a value in the\n"
    "//               range 0..1 that indicates the relative size of the\n"
    "//               fully bright center spot, and fg and bg are the\n"
    "//               colors of the interior and exterior of the spot,\n"
    "//               respectively.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Spotlight_make_spot_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Spotlight::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Spotlight_get_class_type_130(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Spotlight::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Spotlight::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Spotlight_get_class_type_130_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Spotlight_get_class_type_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Spotlight::Spotlight(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_Spotlight(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Spotlight::Spotlight(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Spotlight", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:Spotlight", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Spotlight *return_value = new Spotlight(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Spotlight,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Spotlight(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Spotlight(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Spotlight)
    {
        printf("Spotlight ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Spotlight * local_this = (Spotlight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Spotlight)
        return local_this;
    if(requested_type == &Dtool_Camera)
        return ( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LensNode)
        return ( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_Light)
        return ( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_LightLensNode)
        return ( LightLensNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Light *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( LensNode *)( Camera *)( LightLensNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Spotlight(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Spotlight)
        return from_this;
    if(from_type == &Dtool_Camera)
    {
          Camera* other_this = (Camera*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_LensNode)
    {
          LensNode* other_this = (LensNode*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_Light)
    {
          Light* other_this = (Light*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_LightLensNode)
    {
          LightLensNode* other_this = (LightLensNode*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Spotlight*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Spotlight*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SwitchNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SwitchNode::set_visible_child(int index)
 *******************************************************************/
static PyObject *Dtool_SwitchNode_set_visible_child_134(PyObject *self, PyObject *args,PyObject *kwds) {
    SwitchNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SwitchNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SwitchNode::set_visible_child(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setVisibleChild", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setVisibleChild", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_visible_child((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SwitchNode.setVisibleChild() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVisibleChild(non-const SwitchNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SwitchNode_set_visible_child_134_comment =
    "C++ Interface:\n"
    "setVisibleChild(non-const SwitchNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SwitchNode::set_visible_child\n"
    "//       Access: Published\n"
    "//  Description: Specifies the particular child of this node, by\n"
    "//               index, that will be visible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SwitchNode_set_visible_child_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int SwitchNode::get_visible_child(void) const
 *******************************************************************/
static PyObject *Dtool_SwitchNode_get_visible_child_135(PyObject *self, PyObject *args,PyObject *kwds) {
    SwitchNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SwitchNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int SwitchNode::get_visible_child(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVisibleChild", key_word_list));
        else
            (PyArg_Parse(args, ":getVisibleChild"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SwitchNode*)local_this)->get_visible_child();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVisibleChild(const SwitchNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SwitchNode_get_visible_child_135_comment =
    "C++ Interface:\n"
    "getVisibleChild(const SwitchNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SwitchNode::get_visible_child\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the index of the child that should be visible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SwitchNode_get_visible_child_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SwitchNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SwitchNode_get_class_type_136(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle SwitchNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = SwitchNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SwitchNode_get_class_type_136_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SwitchNode_get_class_type_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SwitchNode::SwitchNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_SwitchNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline SwitchNode::SwitchNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SwitchNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:SwitchNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            SwitchNode *return_value = new SwitchNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SwitchNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SwitchNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SwitchNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SwitchNode)
    {
        printf("SwitchNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SwitchNode * local_this = (SwitchNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SwitchNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_SelectiveChildNode)
        return ( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( SelectiveChildNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( SelectiveChildNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SwitchNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SwitchNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (SwitchNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (SwitchNode*)other_this;
    }
    if(from_type == &Dtool_SelectiveChildNode)
    {
          SelectiveChildNode* other_this = (SelectiveChildNode*)from_this;
          return (SwitchNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SwitchNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (SwitchNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. UvScrollNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void UvScrollNode::set_u_speed(float u_speed)
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_set_u_speed_140(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void UvScrollNode::set_u_speed(float u_speed)
        double param1;
        static char * key_word_list[] = {(char *)"u_speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setUSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setUSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_u_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UvScrollNode.setUSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUSpeed(non-const UvScrollNode this, float u_speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_set_u_speed_140_comment =
    "C++ Interface:\n"
    "setUSpeed(non-const UvScrollNode this, float u_speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::set_u_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_set_u_speed_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void UvScrollNode::set_v_speed(float v_speed)
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_set_v_speed_141(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void UvScrollNode::set_v_speed(float v_speed)
        double param1;
        static char * key_word_list[] = {(char *)"v_speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_v_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UvScrollNode.setVSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVSpeed(non-const UvScrollNode this, float v_speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_set_v_speed_141_comment =
    "C++ Interface:\n"
    "setVSpeed(non-const UvScrollNode this, float v_speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::set_v_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_set_v_speed_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void UvScrollNode::set_r_speed(float r_speed)
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_set_r_speed_142(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void UvScrollNode::set_r_speed(float r_speed)
        double param1;
        static char * key_word_list[] = {(char *)"r_speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_r_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call UvScrollNode.setRSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRSpeed(non-const UvScrollNode this, float r_speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_set_r_speed_142_comment =
    "C++ Interface:\n"
    "setRSpeed(non-const UvScrollNode this, float r_speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::set_r_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_set_r_speed_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float UvScrollNode::get_u_speed(void) const
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_get_u_speed_143(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float UvScrollNode::get_u_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getUSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const UvScrollNode*)local_this)->get_u_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUSpeed(const UvScrollNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_get_u_speed_143_comment =
    "C++ Interface:\n"
    "getUSpeed(const UvScrollNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::get_u_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_get_u_speed_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float UvScrollNode::get_v_speed(void) const
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_get_v_speed_144(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float UvScrollNode::get_v_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getVSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const UvScrollNode*)local_this)->get_v_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVSpeed(const UvScrollNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_get_v_speed_144_comment =
    "C++ Interface:\n"
    "getVSpeed(const UvScrollNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::get_v_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_get_v_speed_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float UvScrollNode::get_r_speed(void) const
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_get_r_speed_145(PyObject *self, PyObject *args,PyObject *kwds) {
    UvScrollNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_UvScrollNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float UvScrollNode::get_r_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getRSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const UvScrollNode*)local_this)->get_r_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRSpeed(const UvScrollNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_get_r_speed_145_comment =
    "C++ Interface:\n"
    "getRSpeed(const UvScrollNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: UvSctrollNode::get_r_speed\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_UvScrollNode_get_r_speed_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle UvScrollNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_UvScrollNode_get_class_type_146(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle UvScrollNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = UvScrollNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_UvScrollNode_get_class_type_146_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_UvScrollNode_get_class_type_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline UvScrollNode::UvScrollNode(basic_string< char > const &name)
 * inline UvScrollNode::UvScrollNode(basic_string< char > const &name, float u_speed, float v_speed, float r_speed)
 *******************************************************************/
int  Dtool_Init_UvScrollNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline UvScrollNode::UvScrollNode(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:UvScrollNode", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:UvScrollNode", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                UvScrollNode *return_value = new UvScrollNode(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_UvScrollNode,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline UvScrollNode::UvScrollNode(basic_string< char > const &name, float u_speed, float v_speed, float r_speed)
            char *param0_str; int param0_len;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"name", (char *)"u_speed", (char *)"v_speed", (char *)"r_speed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ddd:UvScrollNode", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3))
            {
                UvScrollNode *return_value = new UvScrollNode(basic_string<char>(param0_str, param0_len), (float)param1, (float)param2, (float)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_UvScrollNode,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "UvScrollNode() takes 1 or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "UvScrollNode(string name)\n"
          "UvScrollNode(string name, float u_speed, float v_speed, float r_speed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_UvScrollNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_UvScrollNode)
    {
        printf("UvScrollNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    UvScrollNode * local_this = (UvScrollNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_UvScrollNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_UvScrollNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_UvScrollNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (UvScrollNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (UvScrollNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (UvScrollNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (UvScrollNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SceneGraphAnalyzer 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_set_lod_mode_152(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SceneGraphAnalyzer::set_lod_mode(SceneGraphAnalyzer::LodMode lod_mode)
        int param1;
        static char * key_word_list[] = {(char *)"lod_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLodMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLodMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_lod_mode((SceneGraphAnalyzer::LodMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SceneGraphAnalyzer.setLodMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLodMode(non-const SceneGraphAnalyzer this, int lod_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_set_lod_mode_152_comment =
    "C++ Interface:\n"
    "setLodMode(non-const SceneGraphAnalyzer this, int lod_mode)\n"
    "\n"
    "// Filename: sceneGraphAnalyzer.I\n"
    "// Created by:  drose (15Oct06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::set_lod_mode\n"
    "//       Access: Published\n"
    "//  Description: Specifies the mode in which LODNodes are analyzed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_set_lod_mode_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_lod_mode_153(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline SceneGraphAnalyzer::LodMode SceneGraphAnalyzer::get_lod_mode(SceneGraphAnalyzer::LodMode lod_mode) const
        int param1;
        static char * key_word_list[] = {(char *)"lod_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getLodMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getLodMode", &param1));
        if(!PyErr_Occurred())
        {
            SceneGraphAnalyzer::LodMode return_value = ((const SceneGraphAnalyzer*)local_this)->get_lod_mode((SceneGraphAnalyzer::LodMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLodMode(const SceneGraphAnalyzer this, int lod_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_lod_mode_153_comment =
    "C++ Interface:\n"
    "getLodMode(const SceneGraphAnalyzer this, int lod_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_lod_mode\n"
    "//       Access: Published\n"
    "//  Description: Returns the mode in which LODNodes are analyzed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_lod_mode_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SceneGraphAnalyzer::clear(void)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_clear_154(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void SceneGraphAnalyzer::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SceneGraphAnalyzer.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_clear_154_comment =
    "C++ Interface:\n"
    "clear(non-const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::clear\n"
    "//       Access: Published\n"
    "//  Description: Resets all of the data in the analyzer in preparation\n"
    "//               for a new run.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_clear_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SceneGraphAnalyzer::add_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_add_node_155(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SceneGraphAnalyzer::add_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "SceneGraphAnalyzer.addNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SceneGraphAnalyzer.addNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addNode(non-const SceneGraphAnalyzer this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_add_node_155_comment =
    "C++ Interface:\n"
    "addNode(non-const SceneGraphAnalyzer this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::add_node\n"
    "//       Access: Published\n"
    "//  Description: Adds a new node to the set of data for analysis.\n"
    "//               Normally, this would only be called once, and passed\n"
    "//               the top of the scene graph, but it's possible to\n"
    "//               repeatedly pass in subgraphs to get an analysis of\n"
    "//               all the graphs together.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_add_node_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SceneGraphAnalyzer::write(ostream &out, int indent_level) const
 * void SceneGraphAnalyzer::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_write_156(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void SceneGraphAnalyzer::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SceneGraphAnalyzer.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const SceneGraphAnalyzer*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void SceneGraphAnalyzer::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SceneGraphAnalyzer.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const SceneGraphAnalyzer*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const SceneGraphAnalyzer this, non-const Ostream out)\n"
          "write(const SceneGraphAnalyzer this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_write_156_comment =
    "C++ Interface:\n"
    "write(const SceneGraphAnalyzer this, non-const Ostream out)\n"
    "write(const SceneGraphAnalyzer this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::write\n"
    "//       Access: Published\n"
    "//  Description: Describes all the data collected.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_write_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_nodes(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_157(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_nodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNodes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNodes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNodes(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_nodes_157_comment =
    "C++ Interface:\n"
    "getNumNodes(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_nodes\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_nodes_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_instances(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_instances_158(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_instances(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumInstances", key_word_list));
        else
            (PyArg_Parse(args, ":getNumInstances"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_instances();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumInstances(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_instances_158_comment =
    "C++ Interface:\n"
    "getNumInstances(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_instances\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_instances_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_transforms(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_transforms_159(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_transforms(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTransforms"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTransforms(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_transforms_159_comment =
    "C++ Interface:\n"
    "getNumTransforms(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_transforms\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_transforms_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_160(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_nodes_with_attribs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNodesWithAttribs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNodesWithAttribs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_nodes_with_attribs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNodesWithAttribs(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_160_comment =
    "C++ Interface:\n"
    "getNumNodesWithAttribs(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_nodes_with_attribs\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lod_nodes_161(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_lod_nodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLodNodes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLodNodes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_lod_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLodNodes(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_lod_nodes_161_comment =
    "C++ Interface:\n"
    "getNumLodNodes(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_lod_nodes\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_lod_nodes_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_nodes_162(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_geom_nodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGeomNodes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGeomNodes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_geom_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGeomNodes(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_nodes_162_comment =
    "C++ Interface:\n"
    "getNumGeomNodes(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_geom_nodes\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_nodes_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_geoms(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geoms_163(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_geoms(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGeoms", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGeoms"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_geoms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGeoms(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_geoms_163_comment =
    "C++ Interface:\n"
    "getNumGeoms(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_geoms\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_geoms_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_164(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_datas(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGeomVertexDatas", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGeomVertexDatas"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_geom_vertex_datas();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGeomVertexDatas(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_164_comment =
    "C++ Interface:\n"
    "getNumGeomVertexDatas(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_geom_vertex_datas\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_165(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_geom_vertex_formats(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGeomVertexFormats", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGeomVertexFormats"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_geom_vertex_formats();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGeomVertexFormats(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_165_comment =
    "C++ Interface:\n"
    "getNumGeomVertexFormats(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_geom_vertex_formats\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_vertex_data_size(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_vertex_data_size_166(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_vertex_data_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVertexDataSize", key_word_list));
        else
            (PyArg_Parse(args, ":getVertexDataSize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_vertex_data_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertexDataSize(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_vertex_data_size_166_comment =
    "C++ Interface:\n"
    "getVertexDataSize(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_vertex_data_size\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_vertex_data_size_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_vertices_167(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVertices(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_vertices_167_comment =
    "C++ Interface:\n"
    "getNumVertices(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_vertices\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_vertices_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_normals(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_normals_168(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_normals(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNormals", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNormals"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_normals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNormals(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_normals_168_comment =
    "C++ Interface:\n"
    "getNumNormals(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_normals\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_normals_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_colors(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_colors_169(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_colors(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumColors", key_word_list));
        else
            (PyArg_Parse(args, ":getNumColors"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_colors();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumColors(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_colors_169_comment =
    "C++ Interface:\n"
    "getNumColors(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_colors\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_colors_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_texcoords(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_texcoords_170(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_texcoords(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTexcoords", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTexcoords"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_texcoords();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTexcoords(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_texcoords_170_comment =
    "C++ Interface:\n"
    "getNumTexcoords(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_texcoords\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_texcoords_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_tris(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tris_171(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_tris(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTris", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTris"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_tris();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTris(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_tris_171_comment =
    "C++ Interface:\n"
    "getNumTris(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_tris\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_tris_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_lines(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_lines_172(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_lines(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLines", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLines"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_lines();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLines(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_lines_172_comment =
    "C++ Interface:\n"
    "getNumLines(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_lines\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_lines_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_points_173(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_points_173_comment =
    "C++ Interface:\n"
    "getNumPoints(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_points\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_points_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_individual_tris_174(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_individual_tris(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumIndividualTris", key_word_list));
        else
            (PyArg_Parse(args, ":getNumIndividualTris"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_individual_tris();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumIndividualTris(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_individual_tris_174_comment =
    "C++ Interface:\n"
    "getNumIndividualTris(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_individual_tris\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_individual_tris_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_tristrips(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_tristrips_175(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_tristrips(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTristrips", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTristrips"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_tristrips();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTristrips(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_tristrips_175_comment =
    "C++ Interface:\n"
    "getNumTristrips(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_tristrips\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_tristrips_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_176(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_strips(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTrianglesInStrips", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTrianglesInStrips"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_triangles_in_strips();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTrianglesInStrips(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_176_comment =
    "C++ Interface:\n"
    "getNumTrianglesInStrips(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_triangles_in_strips\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_trifans(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_trifans_177(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_trifans(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTrifans", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTrifans"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_trifans();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTrifans(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_trifans_177_comment =
    "C++ Interface:\n"
    "getNumTrifans(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_trifans\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_trifans_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_178(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_triangles_in_fans(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTrianglesInFans", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTrianglesInFans"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_triangles_in_fans();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTrianglesInFans(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_178_comment =
    "C++ Interface:\n"
    "getNumTrianglesInFans(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_triangles_in_fans\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_texture_bytes(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_texture_bytes_179(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_texture_bytes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTextureBytes", key_word_list));
        else
            (PyArg_Parse(args, ":getTextureBytes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_texture_bytes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTextureBytes(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_texture_bytes_179_comment =
    "C++ Interface:\n"
    "getTextureBytes(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_texture_bytes\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_texture_bytes_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_long_normals(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_long_normals_180(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_long_normals(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLongNormals", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLongNormals"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_long_normals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLongNormals(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_long_normals_180_comment =
    "C++ Interface:\n"
    "getNumLongNormals(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_long_normals\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_long_normals_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int SceneGraphAnalyzer::get_num_short_normals(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_num_short_normals_181(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int SceneGraphAnalyzer::get_num_short_normals(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumShortNormals", key_word_list));
        else
            (PyArg_Parse(args, ":getNumShortNormals"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SceneGraphAnalyzer*)local_this)->get_num_short_normals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumShortNormals(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_num_short_normals_181_comment =
    "C++ Interface:\n"
    "getNumShortNormals(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_num_short_normals\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_num_short_normals_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SceneGraphAnalyzer::get_total_normal_length(void) const
 *******************************************************************/
static PyObject *Dtool_SceneGraphAnalyzer_get_total_normal_length_182(PyObject *self, PyObject *args,PyObject *kwds) {
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SceneGraphAnalyzer::get_total_normal_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTotalNormalLength", key_word_list));
        else
            (PyArg_Parse(args, ":getTotalNormalLength"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SceneGraphAnalyzer*)local_this)->get_total_normal_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTotalNormalLength(const SceneGraphAnalyzer this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SceneGraphAnalyzer_get_total_normal_length_182_comment =
    "C++ Interface:\n"
    "getTotalNormalLength(const SceneGraphAnalyzer this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SceneGraphAnalyzer::get_total_normal_length\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SceneGraphAnalyzer_get_total_normal_length_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SceneGraphAnalyzer::SceneGraphAnalyzer(void)
 *******************************************************************/
int  Dtool_Init_SceneGraphAnalyzer(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-SceneGraphAnalyzer::SceneGraphAnalyzer(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SceneGraphAnalyzer", key_word_list))
        {
            SceneGraphAnalyzer *return_value = new SceneGraphAnalyzer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SceneGraphAnalyzer,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SceneGraphAnalyzer()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SceneGraphAnalyzer(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SceneGraphAnalyzer)
    {
        printf("SceneGraphAnalyzer ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SceneGraphAnalyzer * local_this = (SceneGraphAnalyzer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SceneGraphAnalyzer)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SceneGraphAnalyzer(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SceneGraphAnalyzer)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. LightNode | LightNode
//********************************************************************
PyMethodDef Dtool_Methods_LightNode[]= {
  { "output",(PyCFunction ) &Dtool_LightNode_output_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightNode_output_8_comment},
  { "write",(PyCFunction ) &Dtool_LightNode_write_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightNode_write_9_comment},
  { "getClassType",(PyCFunction ) &Dtool_LightNode_get_class_type_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightNode_get_class_type_10_comment},
  { "upcastToLight",(PyCFunction ) &Dtool_LightNode_upcast_to_Light_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightNode_upcast_to_Light_3_comment},
  { "upcastToPandaNode",(PyCFunction ) &Dtool_LightNode_upcast_to_PandaNode_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightNode_upcast_to_PandaNode_6_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     LightNode
//////////////////
static PyObject *  Dtool_Repr_LightNode(PyObject * self)
{
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     LightNode
//////////////////
static PyObject *  Dtool_Str_LightNode(PyObject * self)
{
    LightNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LightNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LightNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LightNode\n"
          "// Description : A derivative of Light and of PandaNode.  All kinds of\n"
          "//               Light except Spotlight (which must inherit from\n"
          "//               LensNode instead) inherit from this class.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Light._Dtool_ClassInit(NULL);
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_LightNode.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_Light.As_PyTypeObject(),&Dtool_PandaNode.As_PyTypeObject());
        Dtool_LightNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightNode.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_LightNode.As_PyTypeObject().tp_repr = & Dtool_Repr_LightNode;
        // __str__
        Dtool_LightNode.As_PyTypeObject().tp_str = & Dtool_Str_LightNode;
        if(PyType_Ready(&Dtool_LightNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightNode)");
             printf(" Error In PyType_ReadyLightNode");
             return;
        }
        Py_INCREF(&Dtool_LightNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightNode.As_PyTypeObject().tp_dict,"LightNode",&Dtool_LightNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LightNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LightNode[2],&Dtool_LightNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LightNode,LightNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightNode.As_PyTypeObject());
        PyModule_AddObject(module, "LightNode",(PyObject *)&Dtool_LightNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AmbientLight | AmbientLight
//********************************************************************
PyMethodDef Dtool_Methods_AmbientLight[]= {
  { "getClassType",(PyCFunction ) &Dtool_AmbientLight_get_class_type_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AmbientLight_get_class_type_14_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AmbientLight(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AmbientLight.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AmbientLight\n"
          "// Description : A light source that seems to illuminate all points in\n"
          "//               space at once.  This kind of light need not actually\n"
          "//               be part of the scene graph, since it has no meaningful\n"
          "//               position.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LightNode._Dtool_ClassInit(NULL);
        Dtool_AmbientLight.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightNode.As_PyTypeObject());
        Dtool_AmbientLight.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AmbientLight.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AmbientLight.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AmbientLight.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AmbientLight)");
             printf(" Error In PyType_ReadyAmbientLight");
             return;
        }
        Py_INCREF(&Dtool_AmbientLight.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AmbientLight.As_PyTypeObject().tp_dict,"AmbientLight",&Dtool_AmbientLight.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AmbientLight.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AmbientLight[0],&Dtool_AmbientLight.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AmbientLight,AmbientLight::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AmbientLight.As_PyTypeObject());
        PyModule_AddObject(module, "AmbientLight",(PyObject *)&Dtool_AmbientLight.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CallbackNode | CallbackNode
//********************************************************************
PyMethodDef Dtool_Methods_CallbackNode[]= {
  { "setCullCallback",(PyCFunction ) &Dtool_CallbackNode_set_cull_callback_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_set_cull_callback_18_comment},
  { "clearCullCallback",(PyCFunction ) &Dtool_CallbackNode_clear_cull_callback_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_clear_cull_callback_19_comment},
  { "getCullCallback",(PyCFunction ) &Dtool_CallbackNode_get_cull_callback_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_get_cull_callback_20_comment},
  { "setDrawCallback",(PyCFunction ) &Dtool_CallbackNode_set_draw_callback_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_set_draw_callback_21_comment},
  { "clearDrawCallback",(PyCFunction ) &Dtool_CallbackNode_clear_draw_callback_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_clear_draw_callback_22_comment},
  { "getDrawCallback",(PyCFunction ) &Dtool_CallbackNode_get_draw_callback_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_get_draw_callback_23_comment},
  { "getClassType",(PyCFunction ) &Dtool_CallbackNode_get_class_type_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CallbackNode_get_class_type_24_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CallbackNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CallbackNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CallbackNode\n"
          "// Description : A special node that can issue arbitrary callbacks to\n"
          "//               user code, either during the cull or draw traversals.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_CallbackNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_CallbackNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CallbackNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CallbackNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CallbackNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CallbackNode)");
             printf(" Error In PyType_ReadyCallbackNode");
             return;
        }
        Py_INCREF(&Dtool_CallbackNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CallbackNode.As_PyTypeObject().tp_dict,"CallbackNode",&Dtool_CallbackNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CallbackNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CallbackNode[6],&Dtool_CallbackNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CallbackNode,CallbackNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CallbackNode.As_PyTypeObject());
        PyModule_AddObject(module, "CallbackNode",(PyObject *)&Dtool_CallbackNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LightLensNode | LightLensNode
//********************************************************************
PyMethodDef Dtool_Methods_LightLensNode[]= {
  { "isShadowCaster",(PyCFunction ) &Dtool_LightLensNode_is_shadow_caster_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_is_shadow_caster_34_comment},
  { "setShadowCaster",(PyCFunction ) &Dtool_LightLensNode_set_shadow_caster_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_set_shadow_caster_35_comment},
  { "output",(PyCFunction ) &Dtool_LightLensNode_output_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_output_36_comment},
  { "write",(PyCFunction ) &Dtool_LightLensNode_write_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_write_37_comment},
  { "getClassType",(PyCFunction ) &Dtool_LightLensNode_get_class_type_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_get_class_type_38_comment},
  { "upcastToLight",(PyCFunction ) &Dtool_LightLensNode_upcast_to_Light_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_upcast_to_Light_28_comment},
  { "upcastToCamera",(PyCFunction ) &Dtool_LightLensNode_upcast_to_Camera_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightLensNode_upcast_to_Camera_31_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     LightLensNode
//////////////////
static PyObject *  Dtool_Repr_LightLensNode(PyObject * self)
{
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     LightLensNode
//////////////////
static PyObject *  Dtool_Str_LightLensNode(PyObject * self)
{
    LightLensNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightLensNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LightLensNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LightLensNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LightLensNode\n"
          "// Description : A derivative of Light and of Camera. The name might\n"
          "//               be misleading: it does not directly derive from\n"
          "//               LensNode, but through the Camera class. The Camera\n"
          "//               serves no purpose unless shadows are enabled.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Light._Dtool_ClassInit(NULL);
        Dtool_Camera._Dtool_ClassInit(NULL);
        Dtool_LightLensNode.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_Light.As_PyTypeObject(),&Dtool_Camera.As_PyTypeObject());
        Dtool_LightLensNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightLensNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightLensNode.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_LightLensNode.As_PyTypeObject().tp_repr = & Dtool_Repr_LightLensNode;
        // __str__
        Dtool_LightLensNode.As_PyTypeObject().tp_str = & Dtool_Str_LightLensNode;
        if(PyType_Ready(&Dtool_LightLensNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightLensNode)");
             printf(" Error In PyType_ReadyLightLensNode");
             return;
        }
        Py_INCREF(&Dtool_LightLensNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightLensNode.As_PyTypeObject().tp_dict,"LightLensNode",&Dtool_LightLensNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LightLensNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LightLensNode[4],&Dtool_LightLensNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LightLensNode,LightLensNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightLensNode.As_PyTypeObject());
        PyModule_AddObject(module, "LightLensNode",(PyObject *)&Dtool_LightLensNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DirectionalLight | DirectionalLight
//********************************************************************
PyMethodDef Dtool_Methods_DirectionalLight[]= {
  { "getSpecularColor",(PyCFunction ) &Dtool_DirectionalLight_get_specular_color_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_get_specular_color_41_comment},
  { "setSpecularColor",(PyCFunction ) &Dtool_DirectionalLight_set_specular_color_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_set_specular_color_42_comment},
  { "getPoint",(PyCFunction ) &Dtool_DirectionalLight_get_point_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_get_point_43_comment},
  { "setPoint",(PyCFunction ) &Dtool_DirectionalLight_set_point_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_set_point_44_comment},
  { "getDirection",(PyCFunction ) &Dtool_DirectionalLight_get_direction_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_get_direction_45_comment},
  { "setDirection",(PyCFunction ) &Dtool_DirectionalLight_set_direction_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_set_direction_46_comment},
  { "getClassType",(PyCFunction ) &Dtool_DirectionalLight_get_class_type_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DirectionalLight_get_class_type_47_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DirectionalLight(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DirectionalLight.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DirectionalLight\n"
          "// Description : A light shining from infinitely far away in a\n"
          "//               particular direction, like sunlight.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LightLensNode._Dtool_ClassInit(NULL);
        Dtool_DirectionalLight.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightLensNode.As_PyTypeObject());
        Dtool_DirectionalLight.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DirectionalLight.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DirectionalLight.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DirectionalLight.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DirectionalLight)");
             printf(" Error In PyType_ReadyDirectionalLight");
             return;
        }
        Py_INCREF(&Dtool_DirectionalLight.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DirectionalLight.As_PyTypeObject().tp_dict,"DirectionalLight",&Dtool_DirectionalLight.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DirectionalLight.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DirectionalLight[6],&Dtool_DirectionalLight.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DirectionalLight,DirectionalLight::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DirectionalLight.As_PyTypeObject());
        PyModule_AddObject(module, "DirectionalLight",(PyObject *)&Dtool_DirectionalLight.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LODNode | LODNode
//********************************************************************
PyMethodDef Dtool_Methods_LODNode[]= {
  { "makeDefaultLod",(PyCFunction ) &Dtool_LODNode_make_default_lod_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_make_default_lod_51_comment},
  { "addSwitch",(PyCFunction ) &Dtool_LODNode_add_switch_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_add_switch_52_comment},
  { "setSwitch",(PyCFunction ) &Dtool_LODNode_set_switch_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_set_switch_53_comment},
  { "clearSwitches",(PyCFunction ) &Dtool_LODNode_clear_switches_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_clear_switches_54_comment},
  { "getNumSwitches",(PyCFunction ) &Dtool_LODNode_get_num_switches_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_num_switches_55_comment},
  { "getIn",(PyCFunction ) &Dtool_LODNode_get_in_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_in_56_comment},
  { "getOut",(PyCFunction ) &Dtool_LODNode_get_out_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_out_57_comment},
  { "getLowestSwitch",(PyCFunction ) &Dtool_LODNode_get_lowest_switch_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_lowest_switch_58_comment},
  { "getHighestSwitch",(PyCFunction ) &Dtool_LODNode_get_highest_switch_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_highest_switch_59_comment},
  { "forceSwitch",(PyCFunction ) &Dtool_LODNode_force_switch_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_force_switch_60_comment},
  { "clearForceSwitch",(PyCFunction ) &Dtool_LODNode_clear_force_switch_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_clear_force_switch_61_comment},
  { "setLodScale",(PyCFunction ) &Dtool_LODNode_set_lod_scale_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_set_lod_scale_62_comment},
  { "getLodScale",(PyCFunction ) &Dtool_LODNode_get_lod_scale_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_lod_scale_63_comment},
  { "setCenter",(PyCFunction ) &Dtool_LODNode_set_center_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_set_center_64_comment},
  { "getCenter",(PyCFunction ) &Dtool_LODNode_get_center_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_center_65_comment},
  { "showSwitch",(PyCFunction ) &Dtool_LODNode_show_switch_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_show_switch_66_comment},
  { "hideSwitch",(PyCFunction ) &Dtool_LODNode_hide_switch_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_hide_switch_67_comment},
  { "showAllSwitches",(PyCFunction ) &Dtool_LODNode_show_all_switches_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_show_all_switches_68_comment},
  { "hideAllSwitches",(PyCFunction ) &Dtool_LODNode_hide_all_switches_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_hide_all_switches_69_comment},
  { "isAnyShown",(PyCFunction ) &Dtool_LODNode_is_any_shown_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_is_any_shown_70_comment},
  { "verifyChildBounds",(PyCFunction ) &Dtool_LODNode_verify_child_bounds_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_verify_child_bounds_71_comment},
  { "getClassType",(PyCFunction ) &Dtool_LODNode_get_class_type_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LODNode_get_class_type_72_comment},
  { "getIns",(PyCFunction) &MakeSeq_LODNode_get_ins, METH_NOARGS, NULL},
  { "getOuts",(PyCFunction) &MakeSeq_LODNode_get_outs, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LODNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LODNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LODNode\n"
          "// Description : A Level-of-Detail node.  This selects only one of its\n"
          "//               children for rendering, according to the distance\n"
          "//               from the camera and the table indicated in the\n"
          "//               associated LOD object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_LODNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_LODNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LODNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LODNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LODNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LODNode)");
             printf(" Error In PyType_ReadyLODNode");
             return;
        }
        Py_INCREF(&Dtool_LODNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LODNode.As_PyTypeObject().tp_dict,"LODNode",&Dtool_LODNode.As_PyObject());
        //  Static Method makeDefaultLod
        PyDict_SetItemString(Dtool_LODNode.As_PyTypeObject().tp_dict,"makeDefaultLod",PyCFunction_New(&Dtool_Methods_LODNode[0],&Dtool_LODNode.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LODNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LODNode[21],&Dtool_LODNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LODNode,LODNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LODNode.As_PyTypeObject());
        PyModule_AddObject(module, "LODNode",(PyObject *)&Dtool_LODNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FadeLODNode | FadeLODNode
//********************************************************************
PyMethodDef Dtool_Methods_FadeLODNode[]= {
  { "setFadeTime",(PyCFunction ) &Dtool_FadeLODNode_set_fade_time_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_set_fade_time_76_comment},
  { "getFadeTime",(PyCFunction ) &Dtool_FadeLODNode_get_fade_time_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_get_fade_time_77_comment},
  { "setFadeBin",(PyCFunction ) &Dtool_FadeLODNode_set_fade_bin_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_set_fade_bin_78_comment},
  { "getFadeBinName",(PyCFunction ) &Dtool_FadeLODNode_get_fade_bin_name_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_get_fade_bin_name_79_comment},
  { "getFadeBinDrawOrder",(PyCFunction ) &Dtool_FadeLODNode_get_fade_bin_draw_order_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_get_fade_bin_draw_order_80_comment},
  { "setFadeStateOverride",(PyCFunction ) &Dtool_FadeLODNode_set_fade_state_override_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_set_fade_state_override_81_comment},
  { "getFadeStateOverride",(PyCFunction ) &Dtool_FadeLODNode_get_fade_state_override_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_get_fade_state_override_82_comment},
  { "getClassType",(PyCFunction ) &Dtool_FadeLODNode_get_class_type_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FadeLODNode_get_class_type_83_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FadeLODNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FadeLODNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FadeLODNode\n"
          "// Description : A Level-of-Detail node with alpha based switching.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LODNode._Dtool_ClassInit(NULL);
        Dtool_FadeLODNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LODNode.As_PyTypeObject());
        Dtool_FadeLODNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FadeLODNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FadeLODNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FadeLODNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FadeLODNode)");
             printf(" Error In PyType_ReadyFadeLODNode");
             return;
        }
        Py_INCREF(&Dtool_FadeLODNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FadeLODNode.As_PyTypeObject().tp_dict,"FadeLODNode",&Dtool_FadeLODNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FadeLODNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FadeLODNode[7],&Dtool_FadeLODNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FadeLODNode,FadeLODNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FadeLODNode.As_PyTypeObject());
        PyModule_AddObject(module, "FadeLODNode",(PyObject *)&Dtool_FadeLODNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NodeCullCallbackData | NodeCullCallbackData
//********************************************************************
PyMethodDef Dtool_Methods_NodeCullCallbackData[]= {
  { "getTrav",(PyCFunction ) &Dtool_NodeCullCallbackData_get_trav_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCullCallbackData_get_trav_87_comment},
  { "getData",(PyCFunction ) &Dtool_NodeCullCallbackData_get_data_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCullCallbackData_get_data_88_comment},
  { "getClassType",(PyCFunction ) &Dtool_NodeCullCallbackData_get_class_type_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NodeCullCallbackData_get_class_type_89_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NodeCullCallbackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NodeCullCallbackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NodeCullCallbackData\n"
          "// Description : This kind of CallbackData is passed to the\n"
          "//               CallbackObject added to\n"
          "//               CallbackNode:set_cull_callback().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CallbackData._Dtool_ClassInit(NULL);
        Dtool_NodeCullCallbackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CallbackData.As_PyTypeObject());
        Dtool_NodeCullCallbackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NodeCullCallbackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NodeCullCallbackData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NodeCullCallbackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NodeCullCallbackData)");
             printf(" Error In PyType_ReadyNodeCullCallbackData");
             return;
        }
        Py_INCREF(&Dtool_NodeCullCallbackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NodeCullCallbackData.As_PyTypeObject().tp_dict,"NodeCullCallbackData",&Dtool_NodeCullCallbackData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NodeCullCallbackData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NodeCullCallbackData[2],&Dtool_NodeCullCallbackData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NodeCullCallbackData,NodeCullCallbackData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NodeCullCallbackData.As_PyTypeObject());
        PyModule_AddObject(module, "NodeCullCallbackData",(PyObject *)&Dtool_NodeCullCallbackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointLight | PointLight
//********************************************************************
PyMethodDef Dtool_Methods_PointLight[]= {
  { "getSpecularColor",(PyCFunction ) &Dtool_PointLight_get_specular_color_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_get_specular_color_93_comment},
  { "setSpecularColor",(PyCFunction ) &Dtool_PointLight_set_specular_color_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_set_specular_color_94_comment},
  { "getAttenuation",(PyCFunction ) &Dtool_PointLight_get_attenuation_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_get_attenuation_95_comment},
  { "setAttenuation",(PyCFunction ) &Dtool_PointLight_set_attenuation_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_set_attenuation_96_comment},
  { "getPoint",(PyCFunction ) &Dtool_PointLight_get_point_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_get_point_97_comment},
  { "setPoint",(PyCFunction ) &Dtool_PointLight_set_point_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_set_point_98_comment},
  { "getClassType",(PyCFunction ) &Dtool_PointLight_get_class_type_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointLight_get_class_type_99_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointLight(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointLight.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointLight\n"
          "// Description : A light originating from a single point in space, and\n"
          "//               shining in all directions.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LightLensNode._Dtool_ClassInit(NULL);
        Dtool_PointLight.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightLensNode.As_PyTypeObject());
        Dtool_PointLight.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointLight.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointLight.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointLight.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointLight)");
             printf(" Error In PyType_ReadyPointLight");
             return;
        }
        Py_INCREF(&Dtool_PointLight.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointLight.As_PyTypeObject().tp_dict,"PointLight",&Dtool_PointLight.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PointLight.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PointLight[6],&Dtool_PointLight.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointLight,PointLight::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointLight.As_PyTypeObject());
        PyModule_AddObject(module, "PointLight",(PyObject *)&Dtool_PointLight.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SelectiveChildNode | SelectiveChildNode
//********************************************************************
PyMethodDef Dtool_Methods_SelectiveChildNode[]= {
  { "getClassType",(PyCFunction ) &Dtool_SelectiveChildNode_get_class_type_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SelectiveChildNode_get_class_type_103_comment},
  { "downcastToSequenceNode",(PyCFunction ) &Dtool_SelectiveChildNode_downcast_to_SequenceNode_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SelectiveChildNode_downcast_to_SequenceNode_107_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SelectiveChildNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SelectiveChildNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SelectiveChildNode\n"
          "// Description : A base class for nodes like LODNode and SequenceNode\n"
          "//               that select only one visible child at a time.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_SelectiveChildNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_SelectiveChildNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SelectiveChildNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SelectiveChildNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SelectiveChildNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SelectiveChildNode)");
             printf(" Error In PyType_ReadySelectiveChildNode");
             return;
        }
        Py_INCREF(&Dtool_SelectiveChildNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SelectiveChildNode.As_PyTypeObject().tp_dict,"SelectiveChildNode",&Dtool_SelectiveChildNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SelectiveChildNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SelectiveChildNode[0],&Dtool_SelectiveChildNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SelectiveChildNode,SelectiveChildNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SelectiveChildNode.As_PyTypeObject());
        PyModule_AddObject(module, "SelectiveChildNode",(PyObject *)&Dtool_SelectiveChildNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SequenceNode | SequenceNode
//********************************************************************
PyMethodDef Dtool_Methods_SequenceNode[]= {
  { "getNumFrames",(PyCFunction ) &Dtool_SequenceNode_get_num_frames_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SequenceNode_get_num_frames_112_comment},
  { "setFrameRate",(PyCFunction ) &Dtool_SequenceNode_set_frame_rate_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SequenceNode_set_frame_rate_113_comment},
  { "getClassType",(PyCFunction ) &Dtool_SequenceNode_get_class_type_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SequenceNode_get_class_type_114_comment},
  { "upcastToSelectiveChildNode",(PyCFunction ) &Dtool_SequenceNode_upcast_to_SelectiveChildNode_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SequenceNode_upcast_to_SelectiveChildNode_106_comment},
  { "upcastToAnimInterface",(PyCFunction ) &Dtool_SequenceNode_upcast_to_AnimInterface_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SequenceNode_upcast_to_AnimInterface_109_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SequenceNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SequenceNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SequenceNode\n"
          "// Description : A node that automatically cycles through rendering\n"
          "//               each one of its children according to its frame rate.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_SelectiveChildNode._Dtool_ClassInit(NULL);
        Dtool_AnimInterface._Dtool_ClassInit(NULL);
        Dtool_SequenceNode.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_SelectiveChildNode.As_PyTypeObject(),&Dtool_AnimInterface.As_PyTypeObject());
        Dtool_SequenceNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SequenceNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SequenceNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SequenceNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SequenceNode)");
             printf(" Error In PyType_ReadySequenceNode");
             return;
        }
        Py_INCREF(&Dtool_SequenceNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SequenceNode.As_PyTypeObject().tp_dict,"SequenceNode",&Dtool_SequenceNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SequenceNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SequenceNode[2],&Dtool_SequenceNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SequenceNode,SequenceNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SequenceNode.As_PyTypeObject());
        PyModule_AddObject(module, "SequenceNode",(PyObject *)&Dtool_SequenceNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ShaderGenerator | ShaderGenerator
//********************************************************************
PyMethodDef Dtool_Methods_ShaderGenerator[]= {
  { "synthesizeShader",(PyCFunction ) &Dtool_ShaderGenerator_synthesize_shader_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ShaderGenerator_synthesize_shader_119_comment},
  { "getClassType",(PyCFunction ) &Dtool_ShaderGenerator_get_class_type_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ShaderGenerator_get_class_type_120_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ShaderGenerator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ShaderGenerator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ShaderGenerator\n"
          "// Description : The ShaderGenerator is a device that effectively\n"
          "//               replaces the classic fixed function pipeline with\n"
          "//               a 'next-gen' fixed function pipeline.  The next-gen\n"
          "//               fixed function pipeline supports features like\n"
          "//               normal mapping, gloss mapping, cartoon lighting,\n"
          "//               and so forth.  It works by automatically generating\n"
          "//               a shader from a given RenderState.\n"
          "//\n"
          "//               Currently, there is one ShaderGenerator object per\n"
          "//               GraphicsStateGuardian.  It is our intent that in\n"
          "//               time, people will write classes that derive from\n"
          "//               ShaderGenerator but which yield slightly different\n"
          "//               results.\n"
          "//\n"
          "//               The ShaderGenerator owes its existence to the\n"
          "//               'Bamboo Team' at Carnegie Mellon's Entertainment\n"
          "//               Technology Center.  This is a group of students\n"
          "//               who, as a semester project, decided that next-gen\n"
          "//               graphics should be accessible to everyone, even if\n"
          "//               they don't know shader programming.  The group\n"
          "//               consisted of:\n"
          "//\n"
          "//               Aaron Lo, Programmer\n"
          "//               Heegun Lee, Programmer\n"
          "//               Erin Fernandez, Artist/Tester\n"
          "//               Joe Grubb, Artist/Tester\n"
          "//               Ivan Ortega, Technical Artist/Tester\n"
          "//\n"
          "//               Thanks to them!\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_ShaderGenerator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_ShaderGenerator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ShaderGenerator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ShaderGenerator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ShaderGenerator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ShaderGenerator)");
             printf(" Error In PyType_ReadyShaderGenerator");
             return;
        }
        Py_INCREF(&Dtool_ShaderGenerator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ShaderGenerator.As_PyTypeObject().tp_dict,"ShaderGenerator",&Dtool_ShaderGenerator.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ShaderGenerator.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ShaderGenerator[1],&Dtool_ShaderGenerator.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ShaderGenerator,ShaderGenerator::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ShaderGenerator.As_PyTypeObject());
        PyModule_AddObject(module, "ShaderGenerator",(PyObject *)&Dtool_ShaderGenerator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Spotlight | Spotlight
//********************************************************************
PyMethodDef Dtool_Methods_Spotlight[]= {
  { "getExponent",(PyCFunction ) &Dtool_Spotlight_get_exponent_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_get_exponent_123_comment},
  { "setExponent",(PyCFunction ) &Dtool_Spotlight_set_exponent_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_set_exponent_124_comment},
  { "getSpecularColor",(PyCFunction ) &Dtool_Spotlight_get_specular_color_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_get_specular_color_125_comment},
  { "setSpecularColor",(PyCFunction ) &Dtool_Spotlight_set_specular_color_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_set_specular_color_126_comment},
  { "getAttenuation",(PyCFunction ) &Dtool_Spotlight_get_attenuation_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_get_attenuation_127_comment},
  { "setAttenuation",(PyCFunction ) &Dtool_Spotlight_set_attenuation_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_set_attenuation_128_comment},
  { "makeSpot",(PyCFunction ) &Dtool_Spotlight_make_spot_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_make_spot_129_comment},
  { "getClassType",(PyCFunction ) &Dtool_Spotlight_get_class_type_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Spotlight_get_class_type_130_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Spotlight(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Spotlight.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Spotlight\n"
          "// Description : A light originating from a single point in space, and\n"
          "//               shining in a particular direction, with a cone-shaped\n"
          "//               falloff.\n"
          "//\n"
          "//               The Spotlight frustum is defined using a Lens, so it\n"
          "//               can have any of the properties that a camera lens can\n"
          "//               have.\n"
          "//\n"
          "//               Note that the class is named Spotlight instead of\n"
          "//               SpotLight, because \"spotlight\" is a single English\n"
          "//               word, instead of two words.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LightLensNode._Dtool_ClassInit(NULL);
        Dtool_Spotlight.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightLensNode.As_PyTypeObject());
        Dtool_Spotlight.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Spotlight.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Spotlight.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Spotlight.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Spotlight)");
             printf(" Error In PyType_ReadySpotlight");
             return;
        }
        Py_INCREF(&Dtool_Spotlight.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Spotlight.As_PyTypeObject().tp_dict,"Spotlight",&Dtool_Spotlight.As_PyObject());
        //  Static Method makeSpot
        PyDict_SetItemString(Dtool_Spotlight.As_PyTypeObject().tp_dict,"makeSpot",PyCFunction_New(&Dtool_Methods_Spotlight[6],&Dtool_Spotlight.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Spotlight.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Spotlight[7],&Dtool_Spotlight.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Spotlight,Spotlight::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Spotlight.As_PyTypeObject());
        PyModule_AddObject(module, "Spotlight",(PyObject *)&Dtool_Spotlight.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SwitchNode | SwitchNode
//********************************************************************
PyMethodDef Dtool_Methods_SwitchNode[]= {
  { "setVisibleChild",(PyCFunction ) &Dtool_SwitchNode_set_visible_child_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SwitchNode_set_visible_child_134_comment},
  { "getVisibleChild",(PyCFunction ) &Dtool_SwitchNode_get_visible_child_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SwitchNode_get_visible_child_135_comment},
  { "getClassType",(PyCFunction ) &Dtool_SwitchNode_get_class_type_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SwitchNode_get_class_type_136_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SwitchNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SwitchNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SwitchNode\n"
          "// Description : A node that renders only one of its children,\n"
          "//               according to the user's indication.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_SelectiveChildNode._Dtool_ClassInit(NULL);
        Dtool_SwitchNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SelectiveChildNode.As_PyTypeObject());
        Dtool_SwitchNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SwitchNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SwitchNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SwitchNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SwitchNode)");
             printf(" Error In PyType_ReadySwitchNode");
             return;
        }
        Py_INCREF(&Dtool_SwitchNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SwitchNode.As_PyTypeObject().tp_dict,"SwitchNode",&Dtool_SwitchNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SwitchNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SwitchNode[2],&Dtool_SwitchNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SwitchNode,SwitchNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SwitchNode.As_PyTypeObject());
        PyModule_AddObject(module, "SwitchNode",(PyObject *)&Dtool_SwitchNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. UvScrollNode | UvScrollNode
//********************************************************************
PyMethodDef Dtool_Methods_UvScrollNode[]= {
  { "setUSpeed",(PyCFunction ) &Dtool_UvScrollNode_set_u_speed_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_set_u_speed_140_comment},
  { "setVSpeed",(PyCFunction ) &Dtool_UvScrollNode_set_v_speed_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_set_v_speed_141_comment},
  { "setRSpeed",(PyCFunction ) &Dtool_UvScrollNode_set_r_speed_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_set_r_speed_142_comment},
  { "getUSpeed",(PyCFunction ) &Dtool_UvScrollNode_get_u_speed_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_get_u_speed_143_comment},
  { "getVSpeed",(PyCFunction ) &Dtool_UvScrollNode_get_v_speed_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_get_v_speed_144_comment},
  { "getRSpeed",(PyCFunction ) &Dtool_UvScrollNode_get_r_speed_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_get_r_speed_145_comment},
  { "getClassType",(PyCFunction ) &Dtool_UvScrollNode_get_class_type_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_UvScrollNode_get_class_type_146_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_UvScrollNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_UvScrollNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : UvScrollNode\n"
          "// Description : This node is placed at key points within the scene\n"
          "//               graph to animate uvs. \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_UvScrollNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_UvScrollNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_UvScrollNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_UvScrollNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_UvScrollNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(UvScrollNode)");
             printf(" Error In PyType_ReadyUvScrollNode");
             return;
        }
        Py_INCREF(&Dtool_UvScrollNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_UvScrollNode.As_PyTypeObject().tp_dict,"UvScrollNode",&Dtool_UvScrollNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_UvScrollNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_UvScrollNode[6],&Dtool_UvScrollNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_UvScrollNode,UvScrollNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_UvScrollNode.As_PyTypeObject());
        PyModule_AddObject(module, "UvScrollNode",(PyObject *)&Dtool_UvScrollNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SceneGraphAnalyzer | SceneGraphAnalyzer
//********************************************************************
PyMethodDef Dtool_Methods_SceneGraphAnalyzer[]= {
  { "setLodMode",(PyCFunction ) &Dtool_SceneGraphAnalyzer_set_lod_mode_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_set_lod_mode_152_comment},
  { "getLodMode",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_lod_mode_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_lod_mode_153_comment},
  { "clear",(PyCFunction ) &Dtool_SceneGraphAnalyzer_clear_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_clear_154_comment},
  { "addNode",(PyCFunction ) &Dtool_SceneGraphAnalyzer_add_node_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_add_node_155_comment},
  { "write",(PyCFunction ) &Dtool_SceneGraphAnalyzer_write_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_write_156_comment},
  { "getNumNodes",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_nodes_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_nodes_157_comment},
  { "getNumInstances",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_instances_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_instances_158_comment},
  { "getNumTransforms",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_transforms_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_transforms_159_comment},
  { "getNumNodesWithAttribs",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_nodes_with_attribs_160_comment},
  { "getNumLodNodes",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_lod_nodes_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_lod_nodes_161_comment},
  { "getNumGeomNodes",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_geom_nodes_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_geom_nodes_162_comment},
  { "getNumGeoms",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_geoms_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_geoms_163_comment},
  { "getNumGeomVertexDatas",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_datas_164_comment},
  { "getNumGeomVertexFormats",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_geom_vertex_formats_165_comment},
  { "getVertexDataSize",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_vertex_data_size_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_vertex_data_size_166_comment},
  { "getNumVertices",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_vertices_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_vertices_167_comment},
  { "getNumNormals",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_normals_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_normals_168_comment},
  { "getNumColors",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_colors_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_colors_169_comment},
  { "getNumTexcoords",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_texcoords_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_texcoords_170_comment},
  { "getNumTris",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_tris_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_tris_171_comment},
  { "getNumLines",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_lines_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_lines_172_comment},
  { "getNumPoints",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_points_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_points_173_comment},
  { "getNumIndividualTris",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_individual_tris_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_individual_tris_174_comment},
  { "getNumTristrips",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_tristrips_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_tristrips_175_comment},
  { "getNumTrianglesInStrips",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_strips_176_comment},
  { "getNumTrifans",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_trifans_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_trifans_177_comment},
  { "getNumTrianglesInFans",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_triangles_in_fans_178_comment},
  { "getTextureBytes",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_texture_bytes_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_texture_bytes_179_comment},
  { "getNumLongNormals",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_long_normals_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_long_normals_180_comment},
  { "getNumShortNormals",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_num_short_normals_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_num_short_normals_181_comment},
  { "getTotalNormalLength",(PyCFunction ) &Dtool_SceneGraphAnalyzer_get_total_normal_length_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SceneGraphAnalyzer_get_total_normal_length_182_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     SceneGraphAnalyzer
//////////////////
static PyObject *  Dtool_Str_SceneGraphAnalyzer(PyObject * self)
{
    SceneGraphAnalyzer * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SceneGraphAnalyzer,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_SceneGraphAnalyzer(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SceneGraphAnalyzer\n"
          "// Description : A handy class that can scrub over a scene graph and\n"
          "//               collect interesting statistics on it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_str = & Dtool_Str_SceneGraphAnalyzer;
        // Enum  SceneGraphAnalyzer::LodMode;
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"LMLowest",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"LMHighest",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"LMAll",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"LMNone",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_SceneGraphAnalyzer.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SceneGraphAnalyzer)");
             printf(" Error In PyType_ReadySceneGraphAnalyzer");
             return;
        }
        Py_INCREF(&Dtool_SceneGraphAnalyzer.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SceneGraphAnalyzer.As_PyTypeObject().tp_dict,"SceneGraphAnalyzer",&Dtool_SceneGraphAnalyzer.As_PyObject());
        RegisterRuntimeClass(&Dtool_SceneGraphAnalyzer,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SceneGraphAnalyzer.As_PyTypeObject());
        PyModule_AddObject(module, "SceneGraphAnalyzer",(PyObject *)&Dtool_SceneGraphAnalyzer.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..LODNodeType
//********************************************************************
   PyModule_AddIntConstant(module,"LNTPop",0);
   PyModule_AddIntConstant(module,"LNTFade",1);
//********************************************************************
//*** Module Init Updcall ..LightNode
//********************************************************************
   Dtool_PyModuleClassInit_LightNode(module);
//********************************************************************
//*** Module Init Updcall ..AmbientLight
//********************************************************************
   Dtool_PyModuleClassInit_AmbientLight(module);
//********************************************************************
//*** Module Init Updcall ..CallbackNode
//********************************************************************
   Dtool_PyModuleClassInit_CallbackNode(module);
//********************************************************************
//*** Module Init Updcall ..LightLensNode
//********************************************************************
   Dtool_PyModuleClassInit_LightLensNode(module);
//********************************************************************
//*** Module Init Updcall ..DirectionalLight
//********************************************************************
   Dtool_PyModuleClassInit_DirectionalLight(module);
//********************************************************************
//*** Module Init Updcall ..LODNode
//********************************************************************
   Dtool_PyModuleClassInit_LODNode(module);
//********************************************************************
//*** Module Init Updcall ..FadeLODNode
//********************************************************************
   Dtool_PyModuleClassInit_FadeLODNode(module);
//********************************************************************
//*** Module Init Updcall ..NodeCullCallbackData
//********************************************************************
   Dtool_PyModuleClassInit_NodeCullCallbackData(module);
//********************************************************************
//*** Module Init Updcall ..PointLight
//********************************************************************
   Dtool_PyModuleClassInit_PointLight(module);
//********************************************************************
//*** Module Init Updcall ..SelectiveChildNode
//********************************************************************
   Dtool_PyModuleClassInit_SelectiveChildNode(module);
//********************************************************************
//*** Module Init Updcall ..SequenceNode
//********************************************************************
   Dtool_PyModuleClassInit_SequenceNode(module);
//********************************************************************
//*** Module Init Updcall ..ShaderGenerator
//********************************************************************
   Dtool_PyModuleClassInit_ShaderGenerator(module);
//********************************************************************
//*** Module Init Updcall ..Spotlight
//********************************************************************
   Dtool_PyModuleClassInit_Spotlight(module);
//********************************************************************
//*** Module Init Updcall ..SwitchNode
//********************************************************************
   Dtool_PyModuleClassInit_SwitchNode(module);
//********************************************************************
//*** Module Init Updcall ..UvScrollNode
//********************************************************************
   Dtool_PyModuleClassInit_UvScrollNode(module);
//********************************************************************
//*** Module Init Updcall ..SceneGraphAnalyzer
//********************************************************************
   Dtool_PyModuleClassInit_SceneGraphAnalyzer(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpgraphnodes_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212840,  /* file_identifier */
  "libpgraphnodes",  /* library_name */
  "_MIZ",  /* library_hash_name */
  "panda",  /* module_name */
  "libpgraphnodes.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  423  /* next_index */
};

Configure(_in_configure_libpgraphnodes);
ConfigureFn(_in_configure_libpgraphnodes) {
  interrogate_request_module(&_in_module_def);
}

