/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/http -Idirect/src/http -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libhttp_igate.cxx -od built_Rocket/pandac/input/libhttp.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/http -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libhttp application_log.h baseincomingset.h bufferedwriter_growable.h config_http.h http_bufferedreader.h http_composite1.cxx http_connection.h http_request.h parsedhttprequest.h ringbuffer_slide.h strtargetbuffer.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libhttp
#include "py_panda.h"  

#include "application_log.h"
#include "baseincomingset.h"
#include "bufferedwriter_growable.h"
#include "config_http.h"
#include "directbase.h"
#include "http_bufferedreader.h"
#include "http_connection.h"
#include "http_request.h"
#include <list>
#include "notifyCategoryProxy.h"
#include "parsedhttprequest.h"
#include "ringbuffer_slide.h"
#include "socket_base.h"
#include <string>
#include "strtargetbuffer.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. Http_Request
//********************************************************************
typedef  Http_Request  Http_Request_localtype;
Define_Module_Class(p3direct,Http_Request,Http_Request_localtype,HttpRequest);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Socket_IP;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Socket_TCP;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. Http_Request 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Http_Request::GetRequestType(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetRequestType_3(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Http_Request::GetRequestType(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetRequestType", key_word_list));
        else
            (PyArg_Parse(args, ":GetRequestType"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->GetRequestType();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetRequestType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetRequestType(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetRequestType_3_comment =
    "C++ Interface:\n"
    "GetRequestType(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetRequestType_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Http_Request::GetRawRequest(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetRawRequest_4(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Http_Request::GetRawRequest(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetRawRequest", key_word_list));
        else
            (PyArg_Parse(args, ":GetRawRequest"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->GetRawRequest();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetRawRequest() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetRawRequest(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetRawRequest_4_comment =
    "C++ Interface:\n"
    "GetRawRequest(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetRawRequest_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Http_Request::GetRequestURL(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetRequestURL_5(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Http_Request::GetRequestURL(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetRequestURL", key_word_list));
        else
            (PyArg_Parse(args, ":GetRequestURL"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->GetRequestURL();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetRequestURL() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetRequestURL(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetRequestURL_5_comment =
    "C++ Interface:\n"
    "GetRequestURL(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetRequestURL_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Http_Request::GetSourceAddress(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetSourceAddress_6(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Http_Request::GetSourceAddress(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetSourceAddress", key_word_list));
        else
            (PyArg_Parse(args, ":GetSourceAddress"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->GetSourceAddress();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetSourceAddress() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetSourceAddress(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetSourceAddress_6_comment =
    "C++ Interface:\n"
    "GetSourceAddress(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetSourceAddress_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Http_Request::AppendToResponse(basic_string< char > const &in)
 *******************************************************************/
static PyObject *Dtool_Http_Request_AppendToResponse_7(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Http_Request::AppendToResponse(basic_string< char > const &in)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:AppendToResponse", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:AppendToResponse", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->AppendToResponse(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.AppendToResponse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AppendToResponse(non-const HttpRequest this, string in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_AppendToResponse_7_comment =
    "C++ Interface:\n"
    "AppendToResponse(non-const HttpRequest this, string in)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_AppendToResponse_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Http_Request::SendThisResponse(basic_string< char > const &in)
 *******************************************************************/
static PyObject *Dtool_Http_Request_SendThisResponse_8(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Http_Request::SendThisResponse(basic_string< char > const &in)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:SendThisResponse", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:SendThisResponse", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->SendThisResponse(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.SendThisResponse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SendThisResponse(non-const HttpRequest this, string in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_SendThisResponse_8_comment =
    "C++ Interface:\n"
    "SendThisResponse(non-const HttpRequest this, string in)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_SendThisResponse_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Http_Request::Finish(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_Finish_9(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Http_Request::Finish(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Finish", key_word_list));
        else
            (PyArg_Parse(args, ":Finish"));
        if(!PyErr_Occurred())
        {
            (local_this)->Finish();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.Finish() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Finish(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_Finish_9_comment =
    "C++ Interface:\n"
    "Finish(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_Finish_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Http_Request::Abort(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_Abort_10(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Http_Request::Abort(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":Abort", key_word_list));
        else
            (PyArg_Parse(args, ":Abort"));
        if(!PyErr_Occurred())
        {
            (local_this)->Abort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.Abort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Abort(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_Abort_10_comment =
    "C++ Interface:\n"
    "Abort(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_Abort_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Http_Request::HasOption(basic_string< char > in)
 *******************************************************************/
static PyObject *Dtool_Http_Request_HasOption_11(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Http_Request::HasOption(basic_string< char > in)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:HasOption", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:HasOption", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->HasOption(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.HasOption() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "HasOption(non-const HttpRequest this, string in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_HasOption_11_comment =
    "C++ Interface:\n"
    "HasOption(non-const HttpRequest this, string in)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_HasOption_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * char const *Http_Request::GetOption(basic_string< char > in)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetOption_12(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-char const *Http_Request::GetOption(basic_string< char > in)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:GetOption", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:GetOption", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            char const *return_value = (local_this)->GetOption(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return PyString_FromString(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetOption() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetOption(non-const HttpRequest this, string in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetOption_12_comment =
    "C++ Interface:\n"
    "GetOption(non-const HttpRequest this, string in)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetOption_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Http_Request::GetRequestOptionString(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_GetRequestOptionString_13(PyObject *self, PyObject *args,PyObject *kwds) {
    Http_Request * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Http_Request,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > Http_Request::GetRequestOptionString(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":GetRequestOptionString", key_word_list));
        else
            (PyArg_Parse(args, ":GetRequestOptionString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->GetRequestOptionString();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call HttpRequest.GetRequestOptionString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "GetRequestOptionString(non-const HttpRequest this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_GetRequestOptionString_13_comment =
    "C++ Interface:\n"
    "GetRequestOptionString(non-const HttpRequest this)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_GetRequestOptionString_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool Http_Request::HttpManager_Initialize(unsigned short int port)
 *******************************************************************/
static PyObject *Dtool_Http_Request_HttpManager_Initialize_14(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static bool Http_Request::HttpManager_Initialize(unsigned short int port)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"port", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:HttpManagerInitialize", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:HttpManagerInitialize", &param0));
        if(!PyErr_Occurred())
        {
             PyObject *param0_uint = PyNumber_Long(param0);
            if (!((param0_uint == NULL)))
            {
                bool return_value = Http_Request::HttpManager_Initialize(PyLong_AsUnsignedLong(param0_uint));
                 Py_XDECREF(param0_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "HttpManagerInitialize(unsigned int port)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_HttpManager_Initialize_14_comment =
    "C++ Interface:\n"
    "HttpManagerInitialize(unsigned int port)\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_HttpManager_Initialize_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static Http_Request *Http_Request::HttpManager_GetARequest(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_HttpManager_GetARequest_15(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static Http_Request *Http_Request::HttpManager_GetARequest(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":HttpManagerGetARequest", key_word_list))
        {
            Http_Request *return_value = Http_Request::HttpManager_GetARequest();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Http_Request,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "HttpManagerGetARequest()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_HttpManager_GetARequest_15_comment =
    "C++ Interface:\n"
    "HttpManagerGetARequest()\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_HttpManager_GetARequest_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Http_Request::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Http_Request_get_class_type_16(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Http_Request::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Http_Request::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Http_Request_get_class_type_16_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Http_Request_get_class_type_16_comment = NULL;
#endif

int  Dtool_Init_Http_Request(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Http_Request)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Http_Request(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Http_Request)
    {
        printf("Http_Request ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Http_Request * local_this = (Http_Request *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Http_Request)
        return local_this;
    if(requested_type == &Dtool_Socket_IP)
        return ( Socket_IP *)( Socket_TCP *)( HttpConnection *) local_this;
    if(requested_type == &Dtool_Socket_TCP)
        return ( Socket_TCP *)( HttpConnection *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( Socket_IP *)( Socket_TCP *)( HttpConnection *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Http_Request(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Http_Request)
        return from_this;
    if(from_type == &Dtool_Socket_IP)
    {
          Socket_IP* other_this = (Socket_IP*)from_this;
          return (Http_Request*)other_this;
    }
    if(from_type == &Dtool_Socket_TCP)
    {
          Socket_TCP* other_this = (Socket_TCP*)from_this;
          return (Http_Request*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Http_Request*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. Http_Request | HttpRequest
//********************************************************************
PyMethodDef Dtool_Methods_Http_Request[]= {
  { "GetRequestType",(PyCFunction ) &Dtool_Http_Request_GetRequestType_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetRequestType_3_comment},
  { "GetRawRequest",(PyCFunction ) &Dtool_Http_Request_GetRawRequest_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetRawRequest_4_comment},
  { "GetRequestURL",(PyCFunction ) &Dtool_Http_Request_GetRequestURL_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetRequestURL_5_comment},
  { "GetSourceAddress",(PyCFunction ) &Dtool_Http_Request_GetSourceAddress_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetSourceAddress_6_comment},
  { "AppendToResponse",(PyCFunction ) &Dtool_Http_Request_AppendToResponse_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_AppendToResponse_7_comment},
  { "SendThisResponse",(PyCFunction ) &Dtool_Http_Request_SendThisResponse_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_SendThisResponse_8_comment},
  { "Finish",(PyCFunction ) &Dtool_Http_Request_Finish_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_Finish_9_comment},
  { "Abort",(PyCFunction ) &Dtool_Http_Request_Abort_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_Abort_10_comment},
  { "HasOption",(PyCFunction ) &Dtool_Http_Request_HasOption_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_HasOption_11_comment},
  { "GetOption",(PyCFunction ) &Dtool_Http_Request_GetOption_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetOption_12_comment},
  { "GetRequestOptionString",(PyCFunction ) &Dtool_Http_Request_GetRequestOptionString_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_GetRequestOptionString_13_comment},
  { "HttpManagerInitialize",(PyCFunction ) &Dtool_Http_Request_HttpManager_Initialize_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_HttpManager_Initialize_14_comment},
  { "HttpManagerGetARequest",(PyCFunction ) &Dtool_Http_Request_HttpManager_GetARequest_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_HttpManager_GetARequest_15_comment},
  { "getClassType",(PyCFunction ) &Dtool_Http_Request_get_class_type_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Http_Request_get_class_type_16_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Http_Request(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Http_Request.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Http_Request.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Http_Request.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Http_Request.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Http_Request.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Http_Request)");
             printf(" Error In PyType_ReadyHttp_Request");
             return;
        }
        Py_INCREF(&Dtool_Http_Request.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Http_Request.As_PyTypeObject().tp_dict,"HttpRequest",&Dtool_Http_Request.As_PyObject());
        //  Static Method HttpManagerInitialize
        PyDict_SetItemString(Dtool_Http_Request.As_PyTypeObject().tp_dict,"HttpManagerInitialize",PyCFunction_New(&Dtool_Methods_Http_Request[11],&Dtool_Http_Request.As_PyObject()));
        //  Static Method HttpManagerGetARequest
        PyDict_SetItemString(Dtool_Http_Request.As_PyTypeObject().tp_dict,"HttpManagerGetARequest",PyCFunction_New(&Dtool_Methods_Http_Request[12],&Dtool_Http_Request.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Http_Request.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Http_Request[13],&Dtool_Http_Request.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Http_Request,Http_Request::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Http_Request.As_PyTypeObject());
        PyModule_AddObject(module, "HttpRequest",(PyObject *)&Dtool_Http_Request.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..Http_Request
//********************************************************************
   Dtool_PyModuleClassInit_Http_Request(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libhttp_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213772,  /* file_identifier */
  "libhttp",  /* library_name */
  "ncDU",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libhttp.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  38  /* next_index */
};

Configure(_in_configure_libhttp);
ConfigureFn(_in_configure_libhttp) {
  interrogate_request_module(&_in_module_def);
}

