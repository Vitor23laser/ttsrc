/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/showbase -Idirect/src/showbase -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libshowbase_igate.cxx -od built_Rocket/pandac/input/libshowbase.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/showbase -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libshowbase showBase.cxx showBase.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libshowbase
#include "py_panda.h"  

#include "camera.h"
#include "graphicsPipeSelection.h"
#include "graphicsWindow.h"
#include "renderBuffer.h"
#include "showBase.h"
#include "throw_event.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConfigVariableSearchPath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DConfig;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsWindow;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * ConfigVariableSearchPath &get_particle_path(void)
 *******************************************************************/
static PyObject *Dtool_get_particle_path_1(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-ConfigVariableSearchPath &get_particle_path(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getParticlePath", key_word_list))
        {
            ConfigVariableSearchPath *return_value = &(get_particle_path());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableSearchPath,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParticlePath()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_particle_path_1_comment =
    "C++ Interface:\n"
    "getParticlePath()\n"
    "\n"
    "";
#else
static const char * Dtool_get_particle_path_1_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void throw_new_frame(void)
 *******************************************************************/
static PyObject *Dtool_throw_new_frame_2(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-void throw_new_frame(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":throwNewFrame", key_word_list))
        {
            throw_new_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "throwNewFrame()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_throw_new_frame_2_comment =
    "C++ Interface:\n"
    "throwNewFrame()\n"
    "\n"
    "// Throw the \"NewFrame\" event in the C++ world.  Some of the lerp code\n"
    "// depends on receiving this.\n"
    "";
#else
static const char * Dtool_throw_new_frame_2_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DConfig &get_config_showbase(void)
 *******************************************************************/
static PyObject *Dtool_get_config_showbase_3(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-DConfig &get_config_showbase(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getConfigShowbase", key_word_list))
        {
            DConfig *return_value = &(get_config_showbase());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DConfig,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConfigShowbase()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_config_showbase_3_comment =
    "C++ Interface:\n"
    "getConfigShowbase()\n"
    "\n"
    "// Returns the configure object for accessing config variables from a\n"
    "// scripting language.\n"
    "";
#else
static const char * Dtool_get_config_showbase_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void init_app_for_gui(void)
 *******************************************************************/
static PyObject *Dtool_init_app_for_gui_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-void init_app_for_gui(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":initAppForGui", key_word_list))
        {
            init_app_for_gui();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initAppForGui()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_init_app_for_gui_4_comment =
    "C++ Interface:\n"
    "initAppForGui()\n"
    "\n"
    "// Initialize the application for making a Gui-based app, such as wx.\n"
    "// At the moment, this is a no-op except on Mac.\n"
    "";
#else
static const char * Dtool_init_app_for_gui_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void add_fullscreen_testsize(int xsize, int ysize)
 *******************************************************************/
static PyObject *Dtool_add_fullscreen_testsize_5(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-void add_fullscreen_testsize(int xsize, int ysize)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"xsize", (char *)"ysize", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:addFullscreenTestsize", key_word_list, &param0, &param1))
        {
            add_fullscreen_testsize((int)param0, (int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addFullscreenTestsize(int xsize, int ysize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_add_fullscreen_testsize_5_comment =
    "C++ Interface:\n"
    "addFullscreenTestsize(int xsize, int ysize)\n"
    "\n"
    "// klunky interface since we cant pass array from python->C++\n"
    "";
#else
static const char * Dtool_add_fullscreen_testsize_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void runtest_fullscreen_sizes(GraphicsWindow *win)
 *******************************************************************/
static PyObject *Dtool_runtest_fullscreen_sizes_6(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void runtest_fullscreen_sizes(GraphicsWindow *win)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"win", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:runtestFullscreenSizes", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:runtestFullscreenSizes", &param0));
            if(!PyErr_Occurred())
            {
                GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsWindow, 0, "runtestFullscreenSizes", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    runtest_fullscreen_sizes(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "runtestFullscreenSizes(non-const GraphicsWindow win)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_runtest_fullscreen_sizes_6_comment =
    "C++ Interface:\n"
    "runtestFullscreenSizes(non-const GraphicsWindow win)\n"
    "\n"
    "// klunky interface since we cant pass array from python->C++\n"
    "";
#else
static const char * Dtool_runtest_fullscreen_sizes_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool query_fullscreen_testresult(int xsize, int ysize)
 *******************************************************************/
static PyObject *Dtool_query_fullscreen_testresult_7(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-bool query_fullscreen_testresult(int xsize, int ysize)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"xsize", (char *)"ysize", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:queryFullscreenTestresult", key_word_list, &param0, &param1))
        {
            bool return_value = query_fullscreen_testresult((int)param0, (int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "queryFullscreenTestresult(int xsize, int ysize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_query_fullscreen_testresult_7_comment =
    "C++ Interface:\n"
    "queryFullscreenTestresult(int xsize, int ysize)\n"
    "\n"
    "";
#else
static const char * Dtool_query_fullscreen_testresult_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void store_accessibility_shortcut_keys(void)
 *******************************************************************/
static PyObject *Dtool_store_accessibility_shortcut_keys_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-void store_accessibility_shortcut_keys(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":storeAccessibilityShortcutKeys", key_word_list))
        {
            store_accessibility_shortcut_keys();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeAccessibilityShortcutKeys()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_store_accessibility_shortcut_keys_8_comment =
    "C++ Interface:\n"
    "storeAccessibilityShortcutKeys()\n"
    "\n"
    "// to handle windows stickykeys\n"
    "";
#else
static const char * Dtool_store_accessibility_shortcut_keys_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void allow_accessibility_shortcut_keys(bool allowKeys)
 *******************************************************************/
static PyObject *Dtool_allow_accessibility_shortcut_keys_9(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-void allow_accessibility_shortcut_keys(bool allowKeys)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"allowKeys", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:allowAccessibilityShortcutKeys", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:allowAccessibilityShortcutKeys", &param0));
        if(!PyErr_Occurred())
        {
            allow_accessibility_shortcut_keys((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allowAccessibilityShortcutKeys(bool allowKeys)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_allow_accessibility_shortcut_keys_9_comment =
    "C++ Interface:\n"
    "allowAccessibilityShortcutKeys(bool allowKeys)\n"
    "\n"
    "// to handle windows stickykeys\n"
    "";
#else
static const char * Dtool_allow_accessibility_shortcut_keys_9_comment = NULL;
#endif


//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "getParticlePath", (PyCFunction) &Dtool_get_particle_path_1, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_particle_path_1_comment},
  { "throwNewFrame", (PyCFunction) &Dtool_throw_new_frame_2, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_throw_new_frame_2_comment},
  { "getConfigShowbase", (PyCFunction) &Dtool_get_config_showbase_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_config_showbase_3_comment},
  { "initAppForGui", (PyCFunction) &Dtool_init_app_for_gui_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_init_app_for_gui_4_comment},
  { "addFullscreenTestsize", (PyCFunction) &Dtool_add_fullscreen_testsize_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_add_fullscreen_testsize_5_comment},
  { "runtestFullscreenSizes", (PyCFunction) &Dtool_runtest_fullscreen_sizes_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_runtest_fullscreen_sizes_6_comment},
  { "queryFullscreenTestresult", (PyCFunction) &Dtool_query_fullscreen_testresult_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_query_fullscreen_testresult_7_comment},
  { "storeAccessibilityShortcutKeys", (PyCFunction) &Dtool_store_accessibility_shortcut_keys_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_store_accessibility_shortcut_keys_8_comment},
  { "allowAccessibilityShortcutKeys", (PyCFunction) &Dtool_allow_accessibility_shortcut_keys_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_allow_accessibility_shortcut_keys_9_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libshowbase_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213805,  /* file_identifier */
  "libshowbase",  /* library_name */
  "L4GT",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libshowbase.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  28  /* next_index */
};

Configure(_in_configure_libshowbase);
ConfigureFn(_in_configure_libshowbase) {
  interrogate_request_module(&_in_module_def);
}

