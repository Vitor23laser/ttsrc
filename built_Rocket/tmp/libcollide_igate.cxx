/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/collide -Ipanda/src/collide -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libcollide_igate.cxx -od built_Rocket/pandac/input/libcollide.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/collide -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libcollide collide_composite.cxx collisionBox.h collisionDSSolid.h collisionEntry.h collisionFloorMesh.h collisionGeom.h collisionHandler.h collisionHandlerEvent.h collisionHandlerFloor.h collisionHandlerFluidPusher.h collisionHandlerGravity.h collisionHandlerHighestEvent.h collisionHandlerPhysical.h collisionHandlerPusher.h collisionHandlerQueue.h collisionInvSphere.h collisionLevelState.h collisionLevelStateBase.h collisionLine.h collisionNode.h collisionParabola.h collisionPlane.h collisionPolygon.h collisionRay.h collisionRecorder.h collisionSegment.h collisionSolid.h collisionSphere.h collisionTraverser.h collisionTube.h collisionVisualizer.h config_collide.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libcollide
#include "py_panda.h"  

#include "collisionBox.h"
#include "collisionDSSolid.h"
#include "collisionEntry.h"
#include "collisionFloorMesh.h"
#include "collisionGeom.h"
#include "collisionHandler.h"
#include "collisionHandlerEvent.h"
#include "collisionHandlerFloor.h"
#include "collisionHandlerFluidPusher.h"
#include "collisionHandlerGravity.h"
#include "collisionHandlerHighestEvent.h"
#include "collisionHandlerPhysical.h"
#include "collisionHandlerPusher.h"
#include "collisionHandlerQueue.h"
#include "collisionInvSphere.h"
#include "collisionLevelState.h"
#include "collisionLevelStateBase.h"
#include "collisionLine.h"
#include "collisionNode.h"
#include "collisionParabola.h"
#include "collisionPlane.h"
#include "collisionPolygon.h"
#include "collisionRay.h"
#include "collisionRecorder.h"
#include "collisionSegment.h"
#include "collisionSolid.h"
#include "collisionSphere.h"
#include "collisionTraverser.h"
#include "collisionTube.h"
#include "collisionVisualizer.h"
#include "config_collide.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CollisionHandler
//********************************************************************
typedef  CollisionHandler  CollisionHandler_localtype;
Define_Module_ClassRef(panda,CollisionHandler,CollisionHandler_localtype,CollisionHandler);
//********************************************************************
//*** prototypes for .. CollisionSolid
//********************************************************************
typedef  CollisionSolid  CollisionSolid_localtype;
Define_Module_ClassRef(panda,CollisionSolid,CollisionSolid_localtype,CollisionSolid);
//********************************************************************
//*** prototypes for .. CollisionNode
//********************************************************************
typedef  CollisionNode  CollisionNode_localtype;
Define_Module_ClassRef(panda,CollisionNode,CollisionNode_localtype,CollisionNode);
//********************************************************************
//*** prototypes for .. CollisionTraverser
//********************************************************************
typedef  CollisionTraverser  CollisionTraverser_localtype;
Define_Module_Class(panda,CollisionTraverser,CollisionTraverser_localtype,CollisionTraverser);
//********************************************************************
//*** prototypes for .. CollisionEntry
//********************************************************************
typedef  CollisionEntry  CollisionEntry_localtype;
Define_Module_ClassRef(panda,CollisionEntry,CollisionEntry_localtype,CollisionEntry);
//********************************************************************
//*** prototypes for .. CollisionHandlerEvent
//********************************************************************
typedef  CollisionHandlerEvent  CollisionHandlerEvent_localtype;
Define_Module_ClassRef(panda,CollisionHandlerEvent,CollisionHandlerEvent_localtype,CollisionHandlerEvent);
//********************************************************************
//*** prototypes for .. CollisionHandlerHighestEvent
//********************************************************************
typedef  CollisionHandlerHighestEvent  CollisionHandlerHighestEvent_localtype;
Define_Module_ClassRef(panda,CollisionHandlerHighestEvent,CollisionHandlerHighestEvent_localtype,CollisionHandlerHighestEvent);
//********************************************************************
//*** prototypes for .. CollisionHandlerPhysical
//********************************************************************
typedef  CollisionHandlerPhysical  CollisionHandlerPhysical_localtype;
Define_Module_ClassRef(panda,CollisionHandlerPhysical,CollisionHandlerPhysical_localtype,CollisionHandlerPhysical);
//********************************************************************
//*** prototypes for .. CollisionHandlerFloor
//********************************************************************
typedef  CollisionHandlerFloor  CollisionHandlerFloor_localtype;
Define_Module_ClassRef(panda,CollisionHandlerFloor,CollisionHandlerFloor_localtype,CollisionHandlerFloor);
//********************************************************************
//*** prototypes for .. CollisionHandlerGravity
//********************************************************************
typedef  CollisionHandlerGravity  CollisionHandlerGravity_localtype;
Define_Module_ClassRef(panda,CollisionHandlerGravity,CollisionHandlerGravity_localtype,CollisionHandlerGravity);
//********************************************************************
//*** prototypes for .. CollisionHandlerPusher
//********************************************************************
typedef  CollisionHandlerPusher  CollisionHandlerPusher_localtype;
Define_Module_ClassRef(panda,CollisionHandlerPusher,CollisionHandlerPusher_localtype,CollisionHandlerPusher);
//********************************************************************
//*** prototypes for .. CollisionHandlerFluidPusher
//********************************************************************
typedef  CollisionHandlerFluidPusher  CollisionHandlerFluidPusher_localtype;
Define_Module_ClassRef(panda,CollisionHandlerFluidPusher,CollisionHandlerFluidPusher_localtype,CollisionHandlerFluidPusher);
//********************************************************************
//*** prototypes for .. CollisionHandlerQueue
//********************************************************************
typedef  CollisionHandlerQueue  CollisionHandlerQueue_localtype;
Define_Module_ClassRef(panda,CollisionHandlerQueue,CollisionHandlerQueue_localtype,CollisionHandlerQueue);
//********************************************************************
//*** prototypes for .. CollisionDSSolid
//********************************************************************
typedef  CollisionDSSolid  CollisionDSSolid_localtype;
Define_Module_ClassRef(panda,CollisionDSSolid,CollisionDSSolid_localtype,CollisionDSSolid);
//********************************************************************
//*** prototypes for .. CollisionBox
//********************************************************************
typedef  CollisionBox  CollisionBox_localtype;
Define_Module_ClassRef(panda,CollisionBox,CollisionBox_localtype,CollisionBox);
//********************************************************************
//*** prototypes for .. CollisionSphere
//********************************************************************
typedef  CollisionSphere  CollisionSphere_localtype;
Define_Module_ClassRef(panda,CollisionSphere,CollisionSphere_localtype,CollisionSphere);
//********************************************************************
//*** prototypes for .. CollisionInvSphere
//********************************************************************
typedef  CollisionInvSphere  CollisionInvSphere_localtype;
Define_Module_ClassRef(panda,CollisionInvSphere,CollisionInvSphere_localtype,CollisionInvSphere);
//********************************************************************
//*** prototypes for .. CollisionRay
//********************************************************************
typedef  CollisionRay  CollisionRay_localtype;
Define_Module_ClassRef(panda,CollisionRay,CollisionRay_localtype,CollisionRay);
//********************************************************************
//*** prototypes for .. CollisionLine
//********************************************************************
typedef  CollisionLine  CollisionLine_localtype;
Define_Module_ClassRef(panda,CollisionLine,CollisionLine_localtype,CollisionLine);
//********************************************************************
//*** prototypes for .. CollisionPlane
//********************************************************************
typedef  CollisionPlane  CollisionPlane_localtype;
Define_Module_ClassRef(panda,CollisionPlane,CollisionPlane_localtype,CollisionPlane);
//********************************************************************
//*** prototypes for .. CollisionPolygon
//********************************************************************
typedef  CollisionPolygon  CollisionPolygon_localtype;
Define_Module_ClassRef(panda,CollisionPolygon,CollisionPolygon_localtype,CollisionPolygon);
//********************************************************************
//*** prototypes for .. CollisionParabola
//********************************************************************
typedef  CollisionParabola  CollisionParabola_localtype;
Define_Module_ClassRef(panda,CollisionParabola,CollisionParabola_localtype,CollisionParabola);
//********************************************************************
//*** prototypes for .. CollisionFloorMesh
//********************************************************************
typedef  CollisionFloorMesh  CollisionFloorMesh_localtype;
Define_Module_ClassRef(panda,CollisionFloorMesh,CollisionFloorMesh_localtype,CollisionFloorMesh);
//********************************************************************
//*** prototypes for .. CollisionSegment
//********************************************************************
typedef  CollisionSegment  CollisionSegment_localtype;
Define_Module_ClassRef(panda,CollisionSegment,CollisionSegment_localtype,CollisionSegment);
//********************************************************************
//*** prototypes for .. CollisionTube
//********************************************************************
typedef  CollisionTube  CollisionTube_localtype;
Define_Module_ClassRef(panda,CollisionTube,CollisionTube_localtype,CollisionTube);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BitMask_unsigned_int_32;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BoundingVolume;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CopyOnWriteObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DriveInterface;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LensNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Parabolaf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Planef;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CollisionHandler 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandler::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandler_get_class_type_3(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandler::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandler::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandler_get_class_type_3_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandler_get_class_type_3_comment = NULL;
#endif

int  Dtool_Init_CollisionHandler(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CollisionHandler)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandler)
    {
        printf("CollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandler * local_this = (CollisionHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandler)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandler(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandler)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandler*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandler*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandler*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionSolid 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual LPoint3f CollisionSolid::get_collision_origin(void) const = 0
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_get_collision_origin_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LPoint3f CollisionSolid::get_collision_origin(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollisionOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getCollisionOrigin"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const CollisionSolid*)local_this)->get_collision_origin();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollisionOrigin(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_get_collision_origin_7_comment =
    "C++ Interface:\n"
    "getCollisionOrigin(const CollisionSolid this)\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionSolid_get_collision_origin_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSolid::set_tangible(bool tangible)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_set_tangible_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionSolid::set_tangible(bool tangible)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"tangible", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTangible", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTangible", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tangible((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionSolid.setTangible() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTangible(non-const CollisionSolid this, bool tangible)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_set_tangible_8_comment =
    "C++ Interface:\n"
    "setTangible(non-const CollisionSolid this, bool tangible)\n"
    "\n"
    "// Filename: collisionSolid.I\n"
    "// Created by:  drose (27Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::set_tangible\n"
    "//       Access: Published\n"
    "//  Description: Sets the current state of the 'tangible' flag.  Set\n"
    "//               this true to make the solid tangible, so that a\n"
    "//               CollisionHandlerPusher will not allow another object\n"
    "//               to intersect it, or false to make it intangible, so\n"
    "//               that a CollisionHandlerPusher will ignore it except\n"
    "//               to throw an event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_set_tangible_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionSolid::is_tangible(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_is_tangible_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionSolid::is_tangible(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isTangible", key_word_list));
        else
            (PyArg_Parse(args, ":isTangible"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionSolid*)local_this)->is_tangible();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTangible(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_is_tangible_9_comment =
    "C++ Interface:\n"
    "isTangible(const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::is_tangible\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the solid is considered 'tangible' or\n"
    "//               not.  An intangible solid has no effect in a\n"
    "//               CollisionHandlerPusher (except to throw an event);\n"
    "//               it's useful for defining 'trigger' planes and\n"
    "//               spheres, that cause an effect when passed through.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_is_tangible_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSolid::set_effective_normal(LVector3f const &effective_normal)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_set_effective_normal_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionSolid::set_effective_normal(LVector3f const &effective_normal)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"effective_normal", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEffectiveNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEffectiveNormal", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionSolid.setEffectiveNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_effective_normal(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionSolid.setEffectiveNormal() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEffectiveNormal(non-const CollisionSolid this, const Vec3 effective_normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_set_effective_normal_10_comment =
    "C++ Interface:\n"
    "setEffectiveNormal(non-const CollisionSolid this, const Vec3 effective_normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::set_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: Records a false normal for this CollisionSolid that\n"
    "//               will be reported by the collision system with all\n"
    "//               collisions into it, instead of its actual normal.\n"
    "//               This is useful as a workaround for the problem of an\n"
    "//               avatar wanting to stand on a sloping ground; by\n"
    "//               storing a false normal, the ground appears to be\n"
    "//               perfectly level, and the avatar does not tend to\n"
    "//               slide down it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_set_effective_normal_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSolid::clear_effective_normal(void)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_clear_effective_normal_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionSolid::clear_effective_normal(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearEffectiveNormal", key_word_list));
        else
            (PyArg_Parse(args, ":clearEffectiveNormal"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_effective_normal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionSolid.clearEffectiveNormal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearEffectiveNormal(non-const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_clear_effective_normal_11_comment =
    "C++ Interface:\n"
    "clearEffectiveNormal(non-const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::clear_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: Removes the normal previously set by\n"
    "//               set_effective_normal().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_clear_effective_normal_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionSolid::has_effective_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_has_effective_normal_12(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionSolid::has_effective_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasEffectiveNormal", key_word_list));
        else
            (PyArg_Parse(args, ":hasEffectiveNormal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionSolid*)local_this)->has_effective_normal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasEffectiveNormal(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_has_effective_normal_12_comment =
    "C++ Interface:\n"
    "hasEffectiveNormal(const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::has_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a special normal was set by\n"
    "//               set_effective_normal(), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_has_effective_normal_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &CollisionSolid::get_effective_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_get_effective_normal_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &CollisionSolid::get_effective_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEffectiveNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getEffectiveNormal"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const CollisionSolid*)local_this)->get_effective_normal());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEffectiveNormal(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_get_effective_normal_13_comment =
    "C++ Interface:\n"
    "getEffectiveNormal(const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::get_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the normal that was set by\n"
    "//               set_effective_normal().  It is an error to call this\n"
    "//               unless has_effective_normal() returns true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_get_effective_normal_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_set_respect_effective_normal_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"respect_effective_normal", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRespectEffectiveNormal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRespectEffectiveNormal", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_respect_effective_normal((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionSolid.setRespectEffectiveNormal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRespectEffectiveNormal(non-const CollisionSolid this, bool respect_effective_normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_set_respect_effective_normal_14_comment =
    "C++ Interface:\n"
    "setRespectEffectiveNormal(non-const CollisionSolid this, bool respect_effective_normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::set_respect_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: This is only meaningful for CollisionSolids that will\n"
    "//               be added to a traverser as colliders.  It is normally\n"
    "//               true, but if set false, it means that this particular\n"
    "//               solid does not care about the \"effective\" normal of\n"
    "//               other solids it meets, but rather always uses the\n"
    "//               true normal.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_set_respect_effective_normal_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionSolid::get_respect_effective_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_get_respect_effective_normal_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionSolid::get_respect_effective_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRespectEffectiveNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getRespectEffectiveNormal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionSolid*)local_this)->get_respect_effective_normal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRespectEffectiveNormal(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_get_respect_effective_normal_15_comment =
    "C++ Interface:\n"
    "getRespectEffectiveNormal(const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::get_respect_effective_normal\n"
    "//       Access: Published\n"
    "//  Description: See set_respect_effective_normal().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_get_respect_effective_normal_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_get_bounds_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBounds", key_word_list));
        else
            (PyArg_Parse(args, ":getBounds"));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< BoundingVolume > return_value = ((const CollisionSolid*)local_this)->get_bounds();
            if (return_value != (BoundingVolume const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_BoundingVolume,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBounds(const CollisionSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_get_bounds_16_comment =
    "C++ Interface:\n"
    "getBounds(const CollisionSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::get_bounds\n"
    "//       Access: Protected\n"
    "//  Description: Returns the solid's bounding volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_get_bounds_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_set_bounds_17(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bounding_volume", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBounds", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setBounds", &param1));
            if(!PyErr_Occurred())
            {
                BoundingVolume *param1_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BoundingVolume, 1, "CollisionSolid.setBounds", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_bounds(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionSolid.setBounds() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBounds(non-const CollisionSolid this, const BoundingVolume bounding_volume)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_set_bounds_17_comment =
    "C++ Interface:\n"
    "setBounds(non-const CollisionSolid this, const BoundingVolume bounding_volume)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::set_bounds\n"
    "//       Access: Protected\n"
    "//  Description: Returns the solid's bounding volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_set_bounds_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CollisionSolid::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_output_18(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void CollisionSolid::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionSolid.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CollisionSolid*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CollisionSolid this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_output_18_comment =
    "C++ Interface:\n"
    "output(const CollisionSolid this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_output_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CollisionSolid::write(ostream &out, int indent_level) const
 * virtual void CollisionSolid::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_write_19(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void CollisionSolid::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionSolid.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionSolid*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void CollisionSolid::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionSolid.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionSolid*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const CollisionSolid this, non-const Ostream out)\n"
          "write(const CollisionSolid this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_write_19_comment =
    "C++ Interface:\n"
    "write(const CollisionSolid this, non-const Ostream out)\n"
    "write(const CollisionSolid this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSolid::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSolid_write_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionSolid::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionSolid_get_class_type_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionSolid::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionSolid::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSolid_get_class_type_20_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionSolid_get_class_type_20_comment = NULL;
#endif

int  Dtool_Init_CollisionSolid(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CollisionSolid)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CollisionSolid(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionSolid)
    {
        printf("CollisionSolid ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionSolid * local_this = (CollisionSolid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionSolid)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionSolid(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionSolid)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionSolid*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionSolid*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionSolid*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionSolid*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionSolid*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionSolid*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::set_collide_mask(BitMask< unsigned int, 32 > mask)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_set_collide_mask_24(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionNode::set_collide_mask(BitMask< unsigned int, 32 > mask)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mask", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollideMask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCollideMask", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "CollisionNode.setCollideMask", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_collide_mask(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionNode.setCollideMask() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollideMask(non-const CollisionNode this, const BitMask mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_set_collide_mask_24_comment =
    "C++ Interface:\n"
    "setCollideMask(non-const CollisionNode this, const BitMask mask)\n"
    "\n"
    "// Filename: collisionNode.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::set_collide_mask\n"
    "//       Access: Published\n"
    "//  Description: Simultaneously sets both the \"from\" and \"into\"\n"
    "//               CollideMask values to the same thing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_set_collide_mask_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionNode::set_from_collide_mask(BitMask< unsigned int, 32 > mask)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_set_from_collide_mask_25(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CollisionNode::set_from_collide_mask(BitMask< unsigned int, 32 > mask)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mask", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFromCollideMask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFromCollideMask", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "CollisionNode.setFromCollideMask", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_from_collide_mask(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionNode.setFromCollideMask() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFromCollideMask(non-const CollisionNode this, const BitMask mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_set_from_collide_mask_25_comment =
    "C++ Interface:\n"
    "setFromCollideMask(non-const CollisionNode this, const BitMask mask)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::set_from_collide_mask\n"
    "//       Access: Published\n"
    "//  Description: Sets the \"from\" CollideMask.  In order for a\n"
    "//               collision to be detected from this object into\n"
    "//               another object, the intersection of this object's\n"
    "//               \"from\" mask and the other object's \"into\" mask must\n"
    "//               be nonzero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_set_from_collide_mask_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::set_into_collide_mask(BitMask< unsigned int, 32 > mask)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_set_into_collide_mask_26(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionNode::set_into_collide_mask(BitMask< unsigned int, 32 > mask)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mask", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIntoCollideMask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setIntoCollideMask", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "CollisionNode.setIntoCollideMask", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_into_collide_mask(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionNode.setIntoCollideMask() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIntoCollideMask(non-const CollisionNode this, const BitMask mask)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_set_into_collide_mask_26_comment =
    "C++ Interface:\n"
    "setIntoCollideMask(non-const CollisionNode this, const BitMask mask)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::set_into_collide_mask\n"
    "//       Access: Published\n"
    "//  Description: Sets the \"into\" CollideMask.  In order for a\n"
    "//               collision to be detected from another object into\n"
    "//               this object, the intersection of the other object's\n"
    "//               \"from\" mask and this object's \"into\" mask must be\n"
    "//               nonzero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_set_into_collide_mask_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > CollisionNode::get_from_collide_mask(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_from_collide_mask_27(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > CollisionNode::get_from_collide_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFromCollideMask", key_word_list));
        else
            (PyArg_Parse(args, ":getFromCollideMask"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const CollisionNode*)local_this)->get_from_collide_mask();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFromCollideMask(const CollisionNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_from_collide_mask_27_comment =
    "C++ Interface:\n"
    "getFromCollideMask(const CollisionNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_from_collide_mask\n"
    "//       Access: Published\n"
    "//  Description: Returns the current \"from\" CollideMask.  In order for\n"
    "//               a collision to be detected from this object into\n"
    "//               another object, the intersection of this object's\n"
    "//               \"from\" mask and the other object's \"into\" mask must\n"
    "//               be nonzero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_from_collide_mask_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > CollisionNode::get_into_collide_mask(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_into_collide_mask_28(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitMask< unsigned int, 32 > CollisionNode::get_into_collide_mask(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntoCollideMask", key_word_list));
        else
            (PyArg_Parse(args, ":getIntoCollideMask"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = ((const CollisionNode*)local_this)->get_into_collide_mask();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntoCollideMask(const CollisionNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_into_collide_mask_28_comment =
    "C++ Interface:\n"
    "getIntoCollideMask(const CollisionNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_into_collide_mask\n"
    "//       Access: Published\n"
    "//  Description: Returns the current \"into\" CollideMask.  In order for\n"
    "//               a collision to be detected from another object into\n"
    "//               this object, the intersection of the other object's\n"
    "//               \"from\" mask and this object's \"into\" mask must be\n"
    "//               nonzero.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_into_collide_mask_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::clear_solids(void)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_clear_solids_29(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionNode::clear_solids(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearSolids", key_word_list));
        else
            (PyArg_Parse(args, ":clearSolids"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_solids();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionNode.clearSolids() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearSolids(non-const CollisionNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_clear_solids_29_comment =
    "C++ Interface:\n"
    "clearSolids(non-const CollisionNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::clear_solids\n"
    "//       Access: Published\n"
    "//  Description: Removes all solids from the node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_clear_solids_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionNode::get_num_solids(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_num_solids_30(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionNode::get_num_solids(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSolids", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSolids"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionNode*)local_this)->get_num_solids();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSolids(const CollisionNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_num_solids_30_comment =
    "C++ Interface:\n"
    "getNumSolids(const CollisionNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_num_solids\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_num_solids_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_solid_31(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSolid", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSolid", &param1));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< CollisionSolid > return_value = ((const CollisionNode*)local_this)->get_solid((int)param1);
            if (return_value != (CollisionSolid const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_CollisionSolid,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSolid(const CollisionNode this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_solid_31_comment =
    "C++ Interface:\n"
    "getSolid(const CollisionNode this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_solid\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_solid_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< CollisionSolid > CollisionNode::modify_solid(int n)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_modify_solid_32(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< CollisionSolid > CollisionNode::modify_solid(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:modifySolid", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:modifySolid", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< CollisionSolid > return_value = (local_this)->modify_solid((int)param1);
            if (return_value != (CollisionSolid *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_CollisionSolid,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionNode.modifySolid() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "modifySolid(non-const CollisionNode this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_modify_solid_32_comment =
    "C++ Interface:\n"
    "modifySolid(non-const CollisionNode this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::modify_solid\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_modify_solid_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::set_solid(int n, CollisionSolid *solid)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_set_solid_33(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionNode::set_solid(int n, CollisionSolid *solid)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"solid", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setSolid", key_word_list, &param1, &param2))
            {
                CollisionSolid *param2_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_CollisionSolid, 2, "CollisionNode.setSolid", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_solid((int)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionNode.setSolid() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSolid(non-const CollisionNode this, int n, non-const CollisionSolid solid)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_set_solid_33_comment =
    "C++ Interface:\n"
    "setSolid(non-const CollisionNode this, int n, non-const CollisionSolid solid)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::set_solid\n"
    "//       Access: Published\n"
    "//  Description: Replaces the solid with the indicated index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_set_solid_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::remove_solid(int n)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_remove_solid_34(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionNode::remove_solid(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeSolid", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeSolid", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_solid((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionNode.removeSolid() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSolid(non-const CollisionNode this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_remove_solid_34_comment =
    "C++ Interface:\n"
    "removeSolid(non-const CollisionNode this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::remove_solid\n"
    "//       Access: Published\n"
    "//  Description: Removes the solid with the indicated index.  This\n"
    "//               will shift all subsequent indices down by one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_remove_solid_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionNode::add_solid(CollisionSolid const *solid)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_add_solid_35(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int CollisionNode::add_solid(CollisionSolid const *solid)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"solid", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addSolid", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addSolid", &param1));
            if(!PyErr_Occurred())
            {
                CollisionSolid *param1_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CollisionSolid, 1, "CollisionNode.addSolid", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->add_solid(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionNode.addSolid() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSolid(non-const CollisionNode this, const CollisionSolid solid)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_add_solid_35_comment =
    "C++ Interface:\n"
    "addSolid(non-const CollisionNode this, const CollisionSolid solid)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::add_solid\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated solid to the node.  Returns the\n"
    "//               index of the new solid within the node's list of\n"
    "//               solids.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_add_solid_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionNode::get_collider_sort(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_collider_sort_36(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionNode::get_collider_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColliderSort", key_word_list));
        else
            (PyArg_Parse(args, ":getColliderSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionNode*)local_this)->get_collider_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColliderSort(const CollisionNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_collider_sort_36_comment =
    "C++ Interface:\n"
    "getColliderSort(const CollisionNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_collider_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the collider_sort value that has been set for\n"
    "//               this particular node.  See set_collider_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_collider_sort_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionNode::set_collider_sort(int sort)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_set_collider_sort_37(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionNode::set_collider_sort(int sort)
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setColliderSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setColliderSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collider_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionNode.setColliderSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColliderSort(non-const CollisionNode this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_set_collider_sort_37_comment =
    "C++ Interface:\n"
    "setColliderSort(non-const CollisionNode this, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::set_collider_sort\n"
    "//       Access: Published\n"
    "//  Description: Sets a particular collider_sort value on this node.\n"
    "//               This controls the order in which colliders (that is,\n"
    "//               \"from nodes\") are grouped together for the collision\n"
    "//               traversal.\n"
    "//\n"
    "//               If there are 32 or fewer colliders added to any\n"
    "//               particular CollisionTraverser, then this value has no\n"
    "//               meaning.  It is only useful if there are many\n"
    "//               colliders, which may force the CollisionTraverser to\n"
    "//               make multiple passes through the data; in that case,\n"
    "//               it may be a useful optimization to group colliders\n"
    "//               that have similar bounding volumes together (by\n"
    "//               giving them similar sort values).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_set_collider_sort_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask< unsigned int, 32 > CollisionNode::get_default_collide_mask(void)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_default_collide_mask_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline BitMask< unsigned int, 32 > CollisionNode::get_default_collide_mask(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultCollideMask", key_word_list))
        {
            BitMask< unsigned int, 32 > result = CollisionNode::get_default_collide_mask();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultCollideMask()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_default_collide_mask_38_comment =
    "C++ Interface:\n"
    "getDefaultCollideMask()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionNode::get_default_collide_mask\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the default into_collide_mask assigned to new\n"
    "//               CollisionNodes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionNode_get_default_collide_mask_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionNode_get_class_type_39(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionNode_get_class_type_39_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionNode_get_class_type_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionNode::CollisionNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_CollisionNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionNode::CollisionNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CollisionNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:CollisionNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            CollisionNode *return_value = new CollisionNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionNode(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionNode_get_solids(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumSolids", "getSolid");
}
inline void  * Dtool_UpcastInterface_CollisionNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionNode)
    {
        printf("CollisionNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionNode * local_this = (CollisionNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CollisionNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (CollisionNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionTraverser 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionTraverser::set_respect_prev_transform(bool flag)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_set_respect_prev_transform_44(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionTraverser::set_respect_prev_transform(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRespectPrevTransform", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setRespectPrevTransform", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_respect_prev_transform((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionTraverser.setRespectPrevTransform() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRespectPrevTransform(non-const CollisionTraverser this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_set_respect_prev_transform_44_comment =
    "C++ Interface:\n"
    "setRespectPrevTransform(non-const CollisionTraverser this, bool flag)\n"
    "\n"
    "// Filename: collisionTraverser.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::set_respect_prev_transform\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag that indicates whether the\n"
    "//               prev_transform stored on a node (as updated via\n"
    "//               set_fluid_pos(), etc.) is respected to calculate\n"
    "//               collisions.  If this is true, certain types of\n"
    "//               collision tests will be enhanced by the information\n"
    "//               about objects in motion.  If this is false, objects\n"
    "//               are always considered to be static.  The default is\n"
    "//               false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_set_respect_prev_transform_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionTraverser::get_respect_prev_transform(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_get_respect_prev_transform_45(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionTraverser::get_respect_prev_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRespectPrevTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getRespectPrevTransform"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionTraverser*)local_this)->get_respect_prev_transform();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRespectPrevTransform(const CollisionTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_get_respect_prev_transform_45_comment =
    "C++ Interface:\n"
    "getRespectPrevTransform(const CollisionTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::get_respect_prev_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag that indicates whether the\n"
    "//               prev_transform stored on a node is respected to\n"
    "//               calculate collisions.  See\n"
    "//               set_respect_prev_transform().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_get_respect_prev_transform_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_add_collider_46(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"collider", (char *)"handler", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addCollider", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionTraverser.addCollider", 1, coerced_ptr, report_errors);
CollisionHandler *param2_this = (CollisionHandler *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_CollisionHandler, 2, "CollisionTraverser.addCollider", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->add_collider(*param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionTraverser.addCollider() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCollider(non-const CollisionTraverser this, const NodePath collider, non-const CollisionHandler handler)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_add_collider_46_comment =
    "C++ Interface:\n"
    "addCollider(non-const CollisionTraverser this, const NodePath collider, non-const CollisionHandler handler)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::add_collider\n"
    "//       Access: Published\n"
    "//  Description: Adds a new CollisionNode, representing an object that\n"
    "//               will be tested for collisions into other objects,\n"
    "//               along with the handler that will serve each detected\n"
    "//               collision.  Each CollisionNode may be served by only\n"
    "//               one handler at a time, but a given handler may serve\n"
    "//               many CollisionNodes.\n"
    "//\n"
    "//               The handler that serves a particular node may be\n"
    "//               changed from time to time by calling add_collider()\n"
    "//               again on the same node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_add_collider_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionTraverser::remove_collider(NodePath const &collider)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_remove_collider_47(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CollisionTraverser::remove_collider(NodePath const &collider)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"collider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeCollider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeCollider", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionTraverser.removeCollider", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_collider(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionTraverser.removeCollider() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCollider(non-const CollisionTraverser this, const NodePath collider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_remove_collider_47_comment =
    "C++ Interface:\n"
    "removeCollider(non-const CollisionTraverser this, const NodePath collider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::remove_collider\n"
    "//       Access: Published\n"
    "//  Description: Removes the collider (and its associated handler)\n"
    "//               from the set of CollisionNodes that will be tested\n"
    "//               each frame for collisions into other objects.\n"
    "//               Returns true if the definition was found and removed,\n"
    "//               false if it wasn't present to begin with.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_remove_collider_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionTraverser::has_collider(NodePath const &collider) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_has_collider_48(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CollisionTraverser::has_collider(NodePath const &collider) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"collider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasCollider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasCollider", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionTraverser.hasCollider", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const CollisionTraverser*)local_this)->has_collider(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCollider(const CollisionTraverser this, const NodePath collider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_has_collider_48_comment =
    "C++ Interface:\n"
    "hasCollider(const CollisionTraverser this, const NodePath collider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::has_collider\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated node is current in the\n"
    "//               set of nodes that will be tested each frame for\n"
    "//               collisions into other objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_has_collider_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CollisionTraverser::get_num_colliders(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_get_num_colliders_49(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CollisionTraverser::get_num_colliders(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumColliders", key_word_list));
        else
            (PyArg_Parse(args, ":getNumColliders"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionTraverser*)local_this)->get_num_colliders();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumColliders(const CollisionTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_get_num_colliders_49_comment =
    "C++ Interface:\n"
    "getNumColliders(const CollisionTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::get_num_colliders\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of CollisionNodes that have been\n"
    "//               added to the traverser via add_collider().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_get_num_colliders_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath CollisionTraverser::get_collider(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_get_collider_50(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath CollisionTraverser::get_collider(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCollider", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCollider", &param1));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CollisionTraverser*)local_this)->get_collider((int)param1);
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollider(const CollisionTraverser this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_get_collider_50_comment =
    "C++ Interface:\n"
    "getCollider(const CollisionTraverser this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::get_collider\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth CollisionNode that has been\n"
    "//               added to the traverser via add_collider().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_get_collider_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_get_handler_51(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"collider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getHandler", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getHandler", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionTraverser.getHandler", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    CollisionHandler *return_value = ((const CollisionTraverser*)local_this)->get_handler(*param1_this);
                    if (return_value != (CollisionHandler *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CollisionHandler,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHandler(const CollisionTraverser this, const NodePath collider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_get_handler_51_comment =
    "C++ Interface:\n"
    "getHandler(const CollisionTraverser this, const NodePath collider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::get_handler\n"
    "//       Access: Published\n"
    "//  Description: Returns the handler that is currently assigned to\n"
    "//               serve the indicated collision node, or NULL if the\n"
    "//               node is not on the traverser's set of active nodes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_get_handler_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionTraverser::clear_colliders(void)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_clear_colliders_52(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionTraverser::clear_colliders(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearColliders", key_word_list));
        else
            (PyArg_Parse(args, ":clearColliders"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_colliders();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionTraverser.clearColliders() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearColliders(non-const CollisionTraverser this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_clear_colliders_52_comment =
    "C++ Interface:\n"
    "clearColliders(non-const CollisionTraverser this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::clear_colliders\n"
    "//       Access: Published\n"
    "//  Description: Completely empties the set of collision nodes and\n"
    "//               their associated handlers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_clear_colliders_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionTraverser::traverse(NodePath const &root)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_traverse_53(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CollisionTraverser::traverse(NodePath const &root)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:traverse", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:traverse", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionTraverser.traverse", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->traverse(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionTraverser.traverse() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "traverse(non-const CollisionTraverser this, const NodePath root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_traverse_53_comment =
    "C++ Interface:\n"
    "traverse(non-const CollisionTraverser this, const NodePath root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::traverse\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_traverse_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionTraverser::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_output_54(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CollisionTraverser::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionTraverser.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CollisionTraverser*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CollisionTraverser this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_output_54_comment =
    "C++ Interface:\n"
    "output(const CollisionTraverser this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_output_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionTraverser::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_write_55(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CollisionTraverser::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionTraverser.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CollisionTraverser*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const CollisionTraverser this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_write_55_comment =
    "C++ Interface:\n"
    "write(const CollisionTraverser this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTraverser::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTraverser_write_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionTraverser::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionTraverser_get_class_type_56(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionTraverser::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionTraverser::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTraverser_get_class_type_56_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionTraverser_get_class_type_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionTraverser::CollisionTraverser(basic_string< char > const &name)
 * CollisionTraverser::CollisionTraverser(basic_string< char > const &name = ("ctrav"))
 *******************************************************************/
int  Dtool_Init_CollisionTraverser(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-CollisionTraverser::CollisionTraverser(basic_string< char > const &name = ("ctrav"))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionTraverser", key_word_list))
            {
                CollisionTraverser *return_value = new CollisionTraverser();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionTraverser,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-CollisionTraverser::CollisionTraverser(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CollisionTraverser", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:CollisionTraverser", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                CollisionTraverser *return_value = new CollisionTraverser(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionTraverser,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionTraverser() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionTraverser()\n"
          "CollisionTraverser(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionTraverser_get_colliders(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumColliders", "getCollider");
}
inline void  * Dtool_UpcastInterface_CollisionTraverser(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionTraverser)
    {
        printf("CollisionTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionTraverser * local_this = (CollisionTraverser *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionTraverser)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionTraverser(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionTraverser)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (CollisionTraverser*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionEntry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CollisionSolid const *CollisionEntry::get_from(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_from_59(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CollisionSolid const *CollisionEntry::get_from(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrom", key_word_list));
        else
            (PyArg_Parse(args, ":getFrom"));
        if(!PyErr_Occurred())
        {
            CollisionSolid const *return_value = ((const CollisionEntry*)local_this)->get_from();
            if (return_value != (CollisionSolid const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CollisionSolid,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrom(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_from_59_comment =
    "C++ Interface:\n"
    "getFrom(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_from\n"
    "//       Access: Published\n"
    "//  Description: Returns the CollisionSolid pointer for the particular\n"
    "//               solid that triggered this collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_from_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_into(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_into_60(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_into(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasInto", key_word_list));
        else
            (PyArg_Parse(args, ":hasInto"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_into();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasInto(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_into_60_comment =
    "C++ Interface:\n"
    "hasInto(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_into\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"into\" solid is, in fact, a\n"
    "//               CollisionSolid, and its pointer is known (in which\n"
    "//               case get_into() may be called to retrieve it).  If\n"
    "//               this returns false, the collision was detected into a\n"
    "//               GeomNode, and there is no CollisionSolid pointer to\n"
    "//               be retrieved.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_into_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionSolid const *CollisionEntry::get_into(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_into_61(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CollisionSolid const *CollisionEntry::get_into(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInto", key_word_list));
        else
            (PyArg_Parse(args, ":getInto"));
        if(!PyErr_Occurred())
        {
            CollisionSolid const *return_value = ((const CollisionEntry*)local_this)->get_into();
            if (return_value != (CollisionSolid const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CollisionSolid,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInto(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_into_61_comment =
    "C++ Interface:\n"
    "getInto(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_into\n"
    "//       Access: Published\n"
    "//  Description: Returns the CollisionSolid pointer for the particular\n"
    "//               solid was collided into.  This pointer might be NULL\n"
    "//               if the collision was into a piece of visible\n"
    "//               geometry, instead of a normal CollisionSolid\n"
    "//               collision; see has_into().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_into_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionNode *CollisionEntry::get_from_node(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_from_node_62(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CollisionNode *CollisionEntry::get_from_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFromNode", key_word_list));
        else
            (PyArg_Parse(args, ":getFromNode"));
        if(!PyErr_Occurred())
        {
            CollisionNode *return_value = ((const CollisionEntry*)local_this)->get_from_node();
            if (return_value != (CollisionNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CollisionNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFromNode(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_from_node_62_comment =
    "C++ Interface:\n"
    "getFromNode(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_from_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that contains the CollisionSolid\n"
    "//               that triggered this collision.  This will be a node\n"
    "//               that has been added to a CollisionTraverser via\n"
    "//               add_collider().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_from_node_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *CollisionEntry::get_into_node(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_into_node_63(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *CollisionEntry::get_into_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntoNode", key_word_list));
        else
            (PyArg_Parse(args, ":getIntoNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const CollisionEntry*)local_this)->get_into_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntoNode(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_into_node_63_comment =
    "C++ Interface:\n"
    "getIntoNode(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_into_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that contains the CollisionSolid\n"
    "//               that was collided into.  This returns a PandaNode\n"
    "//               pointer instead of something more specific, because\n"
    "//               it might be either a CollisionNode or a GeomNode.\n"
    "//\n"
    "//               Also see get_into_node_path().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_into_node_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath CollisionEntry::get_from_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_from_node_path_64(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath CollisionEntry::get_from_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFromNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getFromNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CollisionEntry*)local_this)->get_from_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFromNodePath(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_from_node_path_64_comment =
    "C++ Interface:\n"
    "getFromNodePath(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_from_node_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath that represents the\n"
    "//               CollisionNode that contains the CollisionSolid that\n"
    "//               triggered this collision.  This will be a NodePath\n"
    "//               that has been added to a CollisionTraverser via\n"
    "//               add_collider().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_from_node_path_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath CollisionEntry::get_into_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_into_node_path_65(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath CollisionEntry::get_into_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntoNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getIntoNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CollisionEntry*)local_this)->get_into_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntoNodePath(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_into_node_path_65_comment =
    "C++ Interface:\n"
    "getIntoNodePath(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_into_node_path\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath that represents the specific\n"
    "//               CollisionNode or GeomNode instance that was collided\n"
    "//               into.  This is the same node returned by\n"
    "//               get_into_node(), represented as a NodePath; however,\n"
    "//               it may be more useful because the NodePath can\n"
    "//               resolve the particular instance of the node, if there\n"
    "//               is more than one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_into_node_path_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_t(float t)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_t_66(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionEntry::set_t(float t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionEntry.setT() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT(non-const CollisionEntry this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_t_66_comment =
    "C++ Interface:\n"
    "setT(non-const CollisionEntry this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_t\n"
    "//       Access: Published\n"
    "//  Description: Sets a time value for this collision relative to\n"
    "//               other CollisionEntries\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_t_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionEntry::get_t(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_t_67(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionEntry::get_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT", key_word_list));
        else
            (PyArg_Parse(args, ":getT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionEntry*)local_this)->get_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_t_67_comment =
    "C++ Interface:\n"
    "getT(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_t\n"
    "//       Access: Published\n"
    "//  Description: returns time value for this collision relative to\n"
    "//               other CollisionEntries\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_t_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::collided(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_collided_68(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::collided(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":collided", key_word_list));
        else
            (PyArg_Parse(args, ":collided"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->collided();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "collided(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_collided_68_comment =
    "C++ Interface:\n"
    "collided(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::collided\n"
    "//       Access: Published\n"
    "//  Description: returns true if this represents an actual collision\n"
    "//               as opposed to a potential collision, needed for\n"
    "//               iterative collision resolution where path of\n"
    "//               collider changes mid-frame\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_collided_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::reset_collided(void)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_reset_collided_69(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionEntry::reset_collided(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetCollided", key_word_list));
        else
            (PyArg_Parse(args, ":resetCollided"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_collided();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionEntry.resetCollided() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetCollided(non-const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_reset_collided_69_comment =
    "C++ Interface:\n"
    "resetCollided(non-const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::reset_collided\n"
    "//       Access: Published\n"
    "//  Description: prepare for another collision test\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_reset_collided_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::get_respect_prev_transform(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_respect_prev_transform_70(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::get_respect_prev_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRespectPrevTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getRespectPrevTransform"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->get_respect_prev_transform();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRespectPrevTransform(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_respect_prev_transform_70_comment =
    "C++ Interface:\n"
    "getRespectPrevTransform(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_respect_prev_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the collision was detected by a\n"
    "//               CollisionTraverser whose respect_prev_transform\n"
    "//               flag was set true, meaning we should consider motion\n"
    "//               significant in evaluating collisions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_respect_prev_transform_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_surface_point(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_surface_point_71(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionEntry::set_surface_point(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSurfacePoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSurfacePoint", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionEntry.setSurfacePoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_surface_point(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionEntry.setSurfacePoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurfacePoint(non-const CollisionEntry this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_surface_point_71_comment =
    "C++ Interface:\n"
    "setSurfacePoint(non-const CollisionEntry this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_surface_point\n"
    "//       Access: Published\n"
    "//  Description: Stores the point, on the surface of the \"into\"\n"
    "//               object, at which a collision is detected.\n"
    "//\n"
    "//               This point is specified in the coordinate space of\n"
    "//               the \"into\" object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_surface_point_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_surface_normal(LVector3f const &normal)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_surface_normal_72(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionEntry::set_surface_normal(LVector3f const &normal)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"normal", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSurfaceNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSurfaceNormal", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionEntry.setSurfaceNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_surface_normal(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionEntry.setSurfaceNormal() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurfaceNormal(non-const CollisionEntry this, const Vec3 normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_surface_normal_72_comment =
    "C++ Interface:\n"
    "setSurfaceNormal(non-const CollisionEntry this, const Vec3 normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_surface_normal\n"
    "//       Access: Published\n"
    "//  Description: Stores the surface normal of the \"into\" object at the\n"
    "//               point of the intersection.\n"
    "//\n"
    "//               This normal is specified in the coordinate space of\n"
    "//               the \"into\" object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_surface_normal_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_interior_point(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_interior_point_73(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionEntry::set_interior_point(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInteriorPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setInteriorPoint", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionEntry.setInteriorPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_interior_point(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionEntry.setInteriorPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInteriorPoint(non-const CollisionEntry this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_interior_point_73_comment =
    "C++ Interface:\n"
    "setInteriorPoint(non-const CollisionEntry this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_interior_point\n"
    "//       Access: Published\n"
    "//  Description: Stores the point, within the interior of the \"into\"\n"
    "//               object, which represents the depth to which the\n"
    "//               \"from\" object has penetrated.  This can also be\n"
    "//               described as the intersection point on the surface of\n"
    "//               the \"from\" object (which is inside the \"into\"\n"
    "//               object).\n"
    "//\n"
    "//               This point is specified in the coordinate space of\n"
    "//               the \"into\" object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_interior_point_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_surface_point(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_surface_point_74(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_surface_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSurfacePoint", key_word_list));
        else
            (PyArg_Parse(args, ":hasSurfacePoint"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_surface_point();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSurfacePoint(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_surface_point_74_comment =
    "C++ Interface:\n"
    "hasSurfacePoint(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_surface_point\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the surface point has been specified,\n"
    "//               false otherwise.  See get_surface_point().  Some\n"
    "//               types of collisions may not compute the surface\n"
    "//               point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_surface_point_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_surface_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_surface_normal_75(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_surface_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasSurfaceNormal", key_word_list));
        else
            (PyArg_Parse(args, ":hasSurfaceNormal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_surface_normal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasSurfaceNormal(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_surface_normal_75_comment =
    "C++ Interface:\n"
    "hasSurfaceNormal(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_surface_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the surface normal has been specified,\n"
    "//               false otherwise.  See get_surface_normal().  Some\n"
    "//               types of collisions may not compute the surface\n"
    "//               normal.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_surface_normal_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_interior_point(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_interior_point_76(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_interior_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasInteriorPoint", key_word_list));
        else
            (PyArg_Parse(args, ":hasInteriorPoint"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_interior_point();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasInteriorPoint(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_interior_point_76_comment =
    "C++ Interface:\n"
    "hasInteriorPoint(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_interior_point\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the interior point has been specified,\n"
    "//               false otherwise.  See get_interior_point().  Some\n"
    "//               types of collisions may not compute the interior\n"
    "//               point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_interior_point_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_contact_pos(LPoint3f const &pos)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_contact_pos_77(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionEntry::set_contact_pos(LPoint3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setContactPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setContactPos", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionEntry.setContactPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_contact_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionEntry.setContactPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContactPos(non-const CollisionEntry this, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_contact_pos_77_comment =
    "C++ Interface:\n"
    "setContactPos(non-const CollisionEntry this, const Point3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_contact_pos\n"
    "//       Access: Published\n"
    "//  Description: Stores the position of the \"from\" object at the\n"
    "//               instant at which the collision is first detected.\n"
    "//\n"
    "//               This position is specified in the coordinate space of\n"
    "//               the \"into\" object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_contact_pos_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionEntry::set_contact_normal(LVector3f const &normal)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_set_contact_normal_78(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionEntry::set_contact_normal(LVector3f const &normal)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"normal", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setContactNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setContactNormal", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionEntry.setContactNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_contact_normal(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionEntry.setContactNormal() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContactNormal(non-const CollisionEntry this, const Vec3 normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_set_contact_normal_78_comment =
    "C++ Interface:\n"
    "setContactNormal(non-const CollisionEntry this, const Vec3 normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::set_contact_normal\n"
    "//       Access: Published\n"
    "//  Description: Stores the surface normal of the \"into\" object at the\n"
    "//               contact pos.\n"
    "//\n"
    "//               This normal is specified in the coordinate space of\n"
    "//               the \"into\" object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_set_contact_normal_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_contact_pos(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_contact_pos_79(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_contact_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasContactPos", key_word_list));
        else
            (PyArg_Parse(args, ":hasContactPos"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_contact_pos();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasContactPos(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_contact_pos_79_comment =
    "C++ Interface:\n"
    "hasContactPos(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_contact_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the contact position has been specified,\n"
    "//               false otherwise.  See get_contact_pos().  Some\n"
    "//               types of collisions may not compute the contact\n"
    "//               pos.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_contact_pos_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionEntry::has_contact_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_has_contact_normal_80(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionEntry::has_contact_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasContactNormal", key_word_list));
        else
            (PyArg_Parse(args, ":hasContactNormal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionEntry*)local_this)->has_contact_normal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasContactNormal(const CollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_has_contact_normal_80_comment =
    "C++ Interface:\n"
    "hasContactNormal(const CollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::has_contact_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the contact normal has been specified,\n"
    "//               false otherwise.  See get_contact_normal().  Some\n"
    "//               types of collisions may not compute the contact\n"
    "//               normal.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_has_contact_normal_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f CollisionEntry::get_surface_point(NodePath const &space) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_surface_point_81(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LPoint3f CollisionEntry::get_surface_point(NodePath const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSurfacePoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getSurfacePoint", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getSurfacePoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LPoint3f result = ((const CollisionEntry*)local_this)->get_surface_point(*param1_this);
                    LPoint3f *return_value = new LPoint3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSurfacePoint(const CollisionEntry this, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_surface_point_81_comment =
    "C++ Interface:\n"
    "getSurfacePoint(const CollisionEntry this, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_surface_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the point, on the surface of the \"into\"\n"
    "//               object, at which a collision is detected.  This can\n"
    "//               be thought of as the first point of intersection.\n"
    "//               However the contact point is the actual first point of\n"
    "//               intersection.\n"
    "//\n"
    "//               The point will be converted into whichever coordinate\n"
    "//               space the caller specifies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_surface_point_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f CollisionEntry::get_surface_normal(NodePath const &space) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_surface_normal_82(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LVector3f CollisionEntry::get_surface_normal(NodePath const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSurfaceNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getSurfaceNormal", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getSurfaceNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LVector3f result = ((const CollisionEntry*)local_this)->get_surface_normal(*param1_this);
                    LVector3f *return_value = new LVector3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSurfaceNormal(const CollisionEntry this, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_surface_normal_82_comment =
    "C++ Interface:\n"
    "getSurfaceNormal(const CollisionEntry this, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_surface_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the surface normal of the \"into\" object at\n"
    "//               the point at which a collision is detected.\n"
    "//\n"
    "//               The normal will be converted into whichever coordinate\n"
    "//               space the caller specifies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_surface_normal_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f CollisionEntry::get_interior_point(NodePath const &space) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_interior_point_83(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LPoint3f CollisionEntry::get_interior_point(NodePath const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getInteriorPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getInteriorPoint", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getInteriorPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LPoint3f result = ((const CollisionEntry*)local_this)->get_interior_point(*param1_this);
                    LPoint3f *return_value = new LPoint3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInteriorPoint(const CollisionEntry this, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_interior_point_83_comment =
    "C++ Interface:\n"
    "getInteriorPoint(const CollisionEntry this, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_interior_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the point, within the interior of the \"into\"\n"
    "//               object, which represents the depth to which the\n"
    "//               \"from\" object has penetrated.  This can also be\n"
    "//               described as the intersection point on the surface of\n"
    "//               the \"from\" object (which is inside the \"into\"\n"
    "//               object).  It can be thought of as the deepest point\n"
    "//               of intersection.\n"
    "//\n"
    "//               The point will be converted into whichever coordinate\n"
    "//               space the caller specifies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_interior_point_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionEntry::get_all(NodePath const &space, LPoint3f &surface_point, LVector3f &surface_normal, LPoint3f &interior_point) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_all_84(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CollisionEntry::get_all(NodePath const &space, LPoint3f &surface_point, LVector3f &surface_normal, LPoint3f &interior_point) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"space", (char *)"surface_point", (char *)"surface_normal", (char *)"interior_point", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:getAll", key_word_list, &param1, &param2, &param3, &param4))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getAll", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CollisionEntry.getAll", 0, coerced_ptr, report_errors);
LVector3f *param3_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector3f, 3, "CollisionEntry.getAll", 0, coerced_ptr, report_errors);
LPoint3f *param4_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint3f, 4, "CollisionEntry.getAll", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                {
                    bool return_value = ((const CollisionEntry*)local_this)->get_all(*param1_this, *param2_this, *param3_this, *param4_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAll(const CollisionEntry this, const NodePath space, non-const Point3 surface_point, non-const Vec3 surface_normal, non-const Point3 interior_point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_all_84_comment =
    "C++ Interface:\n"
    "getAll(const CollisionEntry this, const NodePath space, non-const Point3 surface_point, non-const Vec3 surface_normal, non-const Point3 interior_point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_all\n"
    "//       Access: Published\n"
    "//  Description: Simultaneously transforms the surface point, surface\n"
    "//               normal, and interior point of the collision into the\n"
    "//               indicated coordinate space.\n"
    "//\n"
    "//               Returns true if all three properties are available,\n"
    "//               or false if any one of them is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_all_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f CollisionEntry::get_contact_pos(NodePath const &space) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_contact_pos_85(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LPoint3f CollisionEntry::get_contact_pos(NodePath const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getContactPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getContactPos", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getContactPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LPoint3f result = ((const CollisionEntry*)local_this)->get_contact_pos(*param1_this);
                    LPoint3f *return_value = new LPoint3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactPos(const CollisionEntry this, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_contact_pos_85_comment =
    "C++ Interface:\n"
    "getContactPos(const CollisionEntry this, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_contact_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns the position of the \"from\" object at the instant\n"
    "//               that a collision is first detected.\n"
    "//\n"
    "//               The position will be converted into whichever coordinate\n"
    "//               space the caller specifies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_contact_pos_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f CollisionEntry::get_contact_normal(NodePath const &space) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_contact_normal_86(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-LVector3f CollisionEntry::get_contact_normal(NodePath const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getContactNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getContactNormal", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getContactNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LVector3f result = ((const CollisionEntry*)local_this)->get_contact_normal(*param1_this);
                    LVector3f *return_value = new LVector3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactNormal(const CollisionEntry this, const NodePath space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_contact_normal_86_comment =
    "C++ Interface:\n"
    "getContactNormal(const CollisionEntry this, const NodePath space)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_contact_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the surface normal of the \"into\" object at\n"
    "//               the contact position.\n"
    "//\n"
    "//               The normal will be converted into whichever coordinate\n"
    "//               space the caller specifies.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_contact_normal_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3f &contact_pos, LVector3f &contact_normal) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_all_contact_info_87(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3f &contact_pos, LVector3f &contact_normal) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"space", (char *)"contact_pos", (char *)"contact_normal", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:getAllContactInfo", key_word_list, &param1, &param2, &param3))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionEntry.getAllContactInfo", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CollisionEntry.getAllContactInfo", 0, coerced_ptr, report_errors);
LVector3f *param3_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector3f, 3, "CollisionEntry.getAllContactInfo", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const CollisionEntry*)local_this)->get_all_contact_info(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAllContactInfo(const CollisionEntry this, const NodePath space, non-const Point3 contact_pos, non-const Vec3 contact_normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_all_contact_info_87_comment =
    "C++ Interface:\n"
    "getAllContactInfo(const CollisionEntry this, const NodePath space, non-const Point3 contact_pos, non-const Vec3 contact_normal)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::get_all_contact_info\n"
    "//       Access: Published\n"
    "//  Description: Simultaneously transforms the contact position and\n"
    "//               contact normal of the collision into the\n"
    "//               indicated coordinate space.\n"
    "//\n"
    "//               Returns true if all three properties are available,\n"
    "//               or false if any one of them is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_all_contact_info_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionEntry::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_output_88(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CollisionEntry::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionEntry.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CollisionEntry*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CollisionEntry this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_output_88_comment =
    "C++ Interface:\n"
    "output(const CollisionEntry this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_output_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionEntry::write(ostream &out, int indent_level) const
 * void CollisionEntry::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_write_89(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void CollisionEntry::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionEntry.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionEntry*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void CollisionEntry::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionEntry.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionEntry*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const CollisionEntry this, non-const Ostream out)\n"
          "write(const CollisionEntry this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_write_89_comment =
    "C++ Interface:\n"
    "write(const CollisionEntry this, non-const Ostream out)\n"
    "write(const CollisionEntry this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionEntry::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionEntry_write_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionEntry::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionEntry_get_class_type_90(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionEntry::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionEntry::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionEntry_get_class_type_90_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionEntry_get_class_type_90_comment = NULL;
#endif

int  Dtool_Init_CollisionEntry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CollisionEntry)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionEntry)
    {
        printf("CollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionEntry * local_this = (CollisionEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionEntry)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionEntry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionEntry)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionEntry*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionEntry*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionEntry*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionEntry*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerEvent 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::clear_in_patterns(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_clear_in_patterns_94(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::clear_in_patterns(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearInPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":clearInPatterns"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_in_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.clearInPatterns() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearInPatterns(non-const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_clear_in_patterns_94_comment =
    "C++ Interface:\n"
    "clearInPatterns(non-const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::clear_in_patterns\n"
    "//       Access: Public\n"
    "//  Description: Removes all of the previously-added in patterns.  See\n"
    "//               add_in_pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_clear_in_patterns_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::add_in_pattern(basic_string< char > const &in_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_add_in_pattern_95(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::add_in_pattern(basic_string< char > const &in_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addInPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addInPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_in_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.addInPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addInPattern(non-const CollisionHandlerEvent this, string in_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_add_in_pattern_95_comment =
    "C++ Interface:\n"
    "addInPattern(non-const CollisionHandlerEvent this, string in_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::add_in_pattern\n"
    "//       Access: Public\n"
    "//  Description: Adds a pattern string to the list of events that will\n"
    "//               be generated in response to a collision.  The pattern\n"
    "//               string describes how the event name will be composed.\n"
    "//               It is a string that may contain any of the following:\n"
    "//\n"
    "//                  %fn  - the name of the \"from\" object's node\n"
    "//                  %in  - the name of the \"into\" object's node\n"
    "//                  %fs  - 't' if \"from\" is tangible, 'i' if intangible\n"
    "//                  %is  - 't' if \"into\" is tangible, 'i' if intangible\n"
    "//                  %ig  - 'c' if the collision is into a\n"
    "//                          CollisionNode, 'g' if it is a geom.\n"
    "//\n"
    "//                  %(tag)fh - generate event only if \"from\" node has\n"
    "//                          the indicated net tag.\n"
    "//                  %(tag)fx - generate event only if \"from\" node does \n"
    "//                          not have the indicated net tag.\n"
    "//                  %(tag)ih - generate event only if \"into\" node has\n"
    "//                          the indicated net tag.\n"
    "//                  %(tag)ix - generate event only if \"into\" node does \n"
    "//                          not have the indicated net tag.\n"
    "//                  %(tag)ft - the indicated net tag value of the \"from\" node.\n"
    "//                  %(tag)it - the indicated net tag value of the \"into\" node.\n"
    "//\n"
    "//               Parentheses in the above are literal and should be\n"
    "//               included in the actual pattern.\n"
    "//\n"
    "//               The event name will be based on the in_pattern\n"
    "//               string specified here, with all occurrences of the\n"
    "//               above strings replaced with the corresponding values.\n"
    "//\n"
    "//               In general, the in_pattern event is thrown on the\n"
    "//               first detection of a collision between two particular\n"
    "//               nodes.  In subsequent passes, as long as a collision\n"
    "//               between those two nodes continues to be detected each\n"
    "//               frame, the again_pattern is thrown.  The first frame\n"
    "//               in which the collision is no longer detected, the\n"
    "//               out_pattern event is thrown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_add_in_pattern_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::set_in_pattern(basic_string< char > const &in_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_set_in_pattern_96(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::set_in_pattern(basic_string< char > const &in_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"in_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setInPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setInPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_in_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.setInPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInPattern(non-const CollisionHandlerEvent this, string in_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_set_in_pattern_96_comment =
    "C++ Interface:\n"
    "setInPattern(non-const CollisionHandlerEvent this, string in_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::set_in_pattern\n"
    "//       Access: Public\n"
    "//  Description: This method is deprecated; it completely replaces all\n"
    "//               the in patterns that have previously been set with\n"
    "//               the indicated pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_set_in_pattern_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionHandlerEvent::get_num_in_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_num_in_patterns_97(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionHandlerEvent::get_num_in_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumInPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumInPatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionHandlerEvent*)local_this)->get_num_in_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumInPatterns(const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_num_in_patterns_97_comment =
    "C++ Interface:\n"
    "getNumInPatterns(const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_num_in_patterns\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of in pattern strings that have\n"
    "//               been added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_num_in_patterns_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > CollisionHandlerEvent::get_in_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_in_pattern_98(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > CollisionHandlerEvent::get_in_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getInPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getInPattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const CollisionHandlerEvent*)local_this)->get_in_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInPattern(const CollisionHandlerEvent this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_in_pattern_98_comment =
    "C++ Interface:\n"
    "getInPattern(const CollisionHandlerEvent this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_in_pattern\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth pattern string that indicates how the\n"
    "//               event names are generated for each collision\n"
    "//               detected.  See add_in_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_in_pattern_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::clear_again_patterns(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_clear_again_patterns_99(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::clear_again_patterns(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAgainPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":clearAgainPatterns"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_again_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.clearAgainPatterns() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAgainPatterns(non-const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_clear_again_patterns_99_comment =
    "C++ Interface:\n"
    "clearAgainPatterns(non-const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::clear_again_patterns\n"
    "//       Access: Public\n"
    "//  Description: Removes all of the previously-added in patterns.  See\n"
    "//               add_again_pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_clear_again_patterns_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::add_again_pattern(basic_string< char > const &again_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_add_again_pattern_100(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::add_again_pattern(basic_string< char > const &again_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"again_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addAgainPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addAgainPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_again_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.addAgainPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAgainPattern(non-const CollisionHandlerEvent this, string again_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_add_again_pattern_100_comment =
    "C++ Interface:\n"
    "addAgainPattern(non-const CollisionHandlerEvent this, string again_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::add_again_pattern\n"
    "//       Access: Public\n"
    "//  Description: Adds the pattern string that indicates how the event\n"
    "//               names are generated when a collision between two\n"
    "//               particular nodes is *still* detected.  This event is\n"
    "//               thrown each consecutive time a collision between two\n"
    "//               particular nodes is detected, starting with the\n"
    "//               second time.\n"
    "//\n"
    "//               In general, the in_pattern event is thrown on the\n"
    "//               first detection of a collision between two particular\n"
    "//               nodes.  In subsequent passes, as long as a collision\n"
    "//               between those two nodes continues to be detected each\n"
    "//               frame, the again_pattern is thrown.  The first frame\n"
    "//               in which the collision is no longer detected, the\n"
    "//               out_pattern event is thrown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_add_again_pattern_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::set_again_pattern(basic_string< char > const &again_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_set_again_pattern_101(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::set_again_pattern(basic_string< char > const &again_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"again_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setAgainPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setAgainPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_again_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.setAgainPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAgainPattern(non-const CollisionHandlerEvent this, string again_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_set_again_pattern_101_comment =
    "C++ Interface:\n"
    "setAgainPattern(non-const CollisionHandlerEvent this, string again_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::set_again_pattern\n"
    "//       Access: Public\n"
    "//  Description: This method is deprecated; it completely replaces all\n"
    "//               the in patterns that have previously been set with\n"
    "//               the indicated pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_set_again_pattern_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionHandlerEvent::get_num_again_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_num_again_patterns_102(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionHandlerEvent::get_num_again_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAgainPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAgainPatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionHandlerEvent*)local_this)->get_num_again_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAgainPatterns(const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_num_again_patterns_102_comment =
    "C++ Interface:\n"
    "getNumAgainPatterns(const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_num_again_patterns\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of in pattern strings that have\n"
    "//               been added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_num_again_patterns_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > CollisionHandlerEvent::get_again_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_again_pattern_103(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > CollisionHandlerEvent::get_again_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAgainPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAgainPattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const CollisionHandlerEvent*)local_this)->get_again_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAgainPattern(const CollisionHandlerEvent this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_again_pattern_103_comment =
    "C++ Interface:\n"
    "getAgainPattern(const CollisionHandlerEvent this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_again_pattern\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth pattern string that indicates how the\n"
    "//               event names are generated for each collision\n"
    "//               detected.  See add_again_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_again_pattern_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::clear_out_patterns(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_clear_out_patterns_104(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::clear_out_patterns(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearOutPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":clearOutPatterns"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_out_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.clearOutPatterns() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearOutPatterns(non-const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_clear_out_patterns_104_comment =
    "C++ Interface:\n"
    "clearOutPatterns(non-const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::clear_out_patterns\n"
    "//       Access: Public\n"
    "//  Description: Removes all of the previously-added in patterns.  See\n"
    "//               add_out_pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_clear_out_patterns_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::add_out_pattern(basic_string< char > const &out_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_add_out_pattern_105(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::add_out_pattern(basic_string< char > const &out_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"out_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addOutPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addOutPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_out_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.addOutPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addOutPattern(non-const CollisionHandlerEvent this, string out_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_add_out_pattern_105_comment =
    "C++ Interface:\n"
    "addOutPattern(non-const CollisionHandlerEvent this, string out_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::add_out_pattern\n"
    "//       Access: Public\n"
    "//  Description: Adds the pattern string that indicates how the event\n"
    "//               names are generated when a collision between two\n"
    "//               particular nodes is *no longer* detected.\n"
    "//\n"
    "//               In general, the in_pattern event is thrown on the\n"
    "//               first detection of a collision between two particular\n"
    "//               nodes.  In subsequent passes, as long as a collision\n"
    "//               between those two nodes continues to be detected each\n"
    "//               frame, the again_pattern is thrown.  The first frame\n"
    "//               in which the collision is no longer detected, the\n"
    "//               out_pattern event is thrown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_add_out_pattern_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerEvent::set_out_pattern(basic_string< char > const &out_pattern)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_set_out_pattern_106(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerEvent::set_out_pattern(basic_string< char > const &out_pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"out_pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setOutPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setOutPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_out_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.setOutPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOutPattern(non-const CollisionHandlerEvent this, string out_pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_set_out_pattern_106_comment =
    "C++ Interface:\n"
    "setOutPattern(non-const CollisionHandlerEvent this, string out_pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::set_out_pattern\n"
    "//       Access: Public\n"
    "//  Description: This method is deprecated; it completely replaces all\n"
    "//               the in patterns that have previously been set with\n"
    "//               the indicated pattern.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_set_out_pattern_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionHandlerEvent::get_num_out_patterns(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_num_out_patterns_107(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionHandlerEvent::get_num_out_patterns(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumOutPatterns", key_word_list));
        else
            (PyArg_Parse(args, ":getNumOutPatterns"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionHandlerEvent*)local_this)->get_num_out_patterns();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumOutPatterns(const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_num_out_patterns_107_comment =
    "C++ Interface:\n"
    "getNumOutPatterns(const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_num_out_patterns\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of in pattern strings that have\n"
    "//               been added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_num_out_patterns_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > CollisionHandlerEvent::get_out_pattern(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_out_pattern_108(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > CollisionHandlerEvent::get_out_pattern(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getOutPattern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getOutPattern", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const CollisionHandlerEvent*)local_this)->get_out_pattern((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOutPattern(const CollisionHandlerEvent this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_out_pattern_108_comment =
    "C++ Interface:\n"
    "getOutPattern(const CollisionHandlerEvent this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::get_out_pattern\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth pattern string that indicates how the\n"
    "//               event names are generated for each collision\n"
    "//               detected.  See add_out_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_out_pattern_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerEvent::clear(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_clear_109(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionHandlerEvent::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_clear_109_comment =
    "C++ Interface:\n"
    "clear(non-const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::clear\n"
    "//       Access: Public\n"
    "//  Description: Empties the list of elements that all colliders are\n"
    "//               known to be colliding with.  No \"out\" events will be\n"
    "//               thrown; if the same collision is detected next frame,\n"
    "//               a new \"in\" event will be thrown for each collision.\n"
    "//\n"
    "//               This can be called each frame to defeat the\n"
    "//               persistent \"in\" event mechanism, which prevents the\n"
    "//               same \"in\" event from being thrown repeatedly.\n"
    "//               However, also see add_again_pattern(), which can be\n"
    "//               used to set the event that is thrown when a collision\n"
    "//               is detected for two or more consecutive frames.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_clear_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerEvent::flush(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_flush_110(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerEvent * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerEvent,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionHandlerEvent::flush(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flush", key_word_list));
        else
            (PyArg_Parse(args, ":flush"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerEvent.flush() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flush(non-const CollisionHandlerEvent this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_flush_110_comment =
    "C++ Interface:\n"
    "flush(non-const CollisionHandlerEvent this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerEvent::flush\n"
    "//       Access: Public\n"
    "//  Description: Same as clear() except \"out\" events are thrown.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_flush_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerEvent::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerEvent_get_class_type_111(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerEvent::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerEvent::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerEvent_get_class_type_111_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerEvent_get_class_type_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerEvent::CollisionHandlerEvent(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerEvent(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerEvent::CollisionHandlerEvent(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerEvent", key_word_list))
        {
            CollisionHandlerEvent *return_value = new CollisionHandlerEvent();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerEvent,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerEvent()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionHandlerEvent_get_in_patterns(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumInPatterns", "getInPattern");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionHandlerEvent_get_again_patterns(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAgainPatterns", "getAgainPattern");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionHandlerEvent_get_out_patterns(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumOutPatterns", "getOutPattern");
}
inline void  * Dtool_UpcastInterface_CollisionHandlerEvent(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerEvent)
    {
        printf("CollisionHandlerEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerEvent * local_this = (CollisionHandlerEvent *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerEvent(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerEvent)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerEvent*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerEvent*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerEvent*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerEvent*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerHighestEvent 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerHighestEvent_get_class_type_115(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerHighestEvent::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerHighestEvent_get_class_type_115_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerHighestEvent_get_class_type_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerHighestEvent(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerHighestEvent", key_word_list))
        {
            CollisionHandlerHighestEvent *return_value = new CollisionHandlerHighestEvent();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerHighestEvent,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerHighestEvent()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionHandlerHighestEvent(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerHighestEvent)
    {
        printf("CollisionHandlerHighestEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerHighestEvent * local_this = (CollisionHandlerHighestEvent *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerHighestEvent)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerHighestEvent(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerHighestEvent)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerHighestEvent*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerHighestEvent*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerHighestEvent*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerHighestEvent*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerHighestEvent*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerPhysical 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_add_collider_118(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"collider", (char *)"target", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addCollider", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionHandlerPhysical.addCollider", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CollisionHandlerPhysical.addCollider", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->add_collider(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionHandlerPhysical.addCollider() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"collider", (char *)"target", (char *)"drive_interface", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:addCollider", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionHandlerPhysical.addCollider", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CollisionHandlerPhysical.addCollider", 1, coerced_ptr, report_errors);
DriveInterface *param3_this = (DriveInterface *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DriveInterface, 3, "CollisionHandlerPhysical.addCollider", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->add_collider(*param1_this, *param2_this, param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionHandlerPhysical.addCollider() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addCollider() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addCollider(non-const CollisionHandlerPhysical this, const NodePath collider, const NodePath target)\n"
          "addCollider(non-const CollisionHandlerPhysical this, const NodePath collider, const NodePath target, non-const DriveInterface drive_interface)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_add_collider_118_comment =
    "C++ Interface:\n"
    "addCollider(non-const CollisionHandlerPhysical this, const NodePath collider, const NodePath target)\n"
    "addCollider(non-const CollisionHandlerPhysical this, const NodePath collider, const NodePath target, non-const DriveInterface drive_interface)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::add_collider\n"
    "//       Access: Published\n"
    "//  Description: Adds a new collider to the list with a NodePath\n"
    "//               that will be updated with the collider's new\n"
    "//               position, or updates the existing collider with a new\n"
    "//               NodePath object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::add_collider\n"
    "//       Access: Published\n"
    "//  Description: Adds a new collider to the list with a NodePath\n"
    "//               that will be updated with the collider's new\n"
    "//               position, or updates the existing collider with a new\n"
    "//               NodePath object.\n"
    "//\n"
    "//               The indicated DriveInterface will also be updated\n"
    "//               with the target's new transform each frame.  This\n"
    "//               method should be used when the target is directly\n"
    "//               controlled by a DriveInterface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_add_collider_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_remove_collider_119(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"collider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeCollider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeCollider", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionHandlerPhysical.removeCollider", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_collider(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionHandlerPhysical.removeCollider() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCollider(non-const CollisionHandlerPhysical this, const NodePath collider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_remove_collider_119_comment =
    "C++ Interface:\n"
    "removeCollider(non-const CollisionHandlerPhysical this, const NodePath collider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::remove_collider\n"
    "//       Access: Published\n"
    "//  Description: Removes the collider from the list of colliders that\n"
    "//               this handler knows about.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_remove_collider_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_has_collider_120(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"collider", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasCollider", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasCollider", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionHandlerPhysical.hasCollider", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const CollisionHandlerPhysical*)local_this)->has_collider(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCollider(const CollisionHandlerPhysical this, const NodePath collider)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_has_collider_120_comment =
    "C++ Interface:\n"
    "hasCollider(const CollisionHandlerPhysical this, const NodePath collider)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::has_collider\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the handler knows about the indicated\n"
    "//               collider, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_has_collider_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerPhysical::clear_colliders(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_clear_colliders_121(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionHandlerPhysical::clear_colliders(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearColliders", key_word_list));
        else
            (PyArg_Parse(args, ":clearColliders"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_colliders();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerPhysical.clearColliders() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearColliders(non-const CollisionHandlerPhysical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_clear_colliders_121_comment =
    "C++ Interface:\n"
    "clearColliders(non-const CollisionHandlerPhysical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::clear_colliders\n"
    "//       Access: Published\n"
    "//  Description: Completely empties the list of colliders this handler\n"
    "//               knows about.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_clear_colliders_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerPhysical::set_center(NodePath const &center)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_set_center_122(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionHandlerPhysical::set_center(NodePath const &center)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"center", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCenter", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "CollisionHandlerPhysical.setCenter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_center(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionHandlerPhysical.setCenter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCenter(non-const CollisionHandlerPhysical this, const NodePath center)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_set_center_122_comment =
    "C++ Interface:\n"
    "setCenter(non-const CollisionHandlerPhysical this, const NodePath center)\n"
    "\n"
    "// Filename: collisionHandlerPhysical.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::set_center\n"
    "//       Access: Published\n"
    "//  Description: Specifies an arbitrary NodePath that the handler is\n"
    "//               always considered to be facing.  It does not detect\n"
    "//               collisions with surfaces that appear to be facing\n"
    "//               away from this NodePath.  This works best when the\n"
    "//               collision surfaces in question are polygons.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_set_center_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerPhysical::clear_center(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_clear_center_123(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerPhysical::clear_center(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearCenter", key_word_list));
        else
            (PyArg_Parse(args, ":clearCenter"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_center();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerPhysical.clearCenter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearCenter(non-const CollisionHandlerPhysical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_clear_center_123_comment =
    "C++ Interface:\n"
    "clearCenter(non-const CollisionHandlerPhysical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::clear_center\n"
    "//       Access: Published\n"
    "//  Description: Clears the center NodePath specified with set_center.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_clear_center_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CollisionHandlerPhysical::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_get_center_124(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CollisionHandlerPhysical::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CollisionHandlerPhysical*)local_this)->get_center());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const CollisionHandlerPhysical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_get_center_124_comment =
    "C++ Interface:\n"
    "getCenter(const CollisionHandlerPhysical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::get_center\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath specified with set_center, or\n"
    "//               the empty NodePath if nothing has been specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_get_center_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionHandlerPhysical::has_center(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_has_center_125(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionHandlerPhysical::has_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCenter", key_word_list));
        else
            (PyArg_Parse(args, ":hasCenter"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionHandlerPhysical*)local_this)->has_center();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCenter(const CollisionHandlerPhysical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_has_center_125_comment =
    "C++ Interface:\n"
    "hasCenter(const CollisionHandlerPhysical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::has_center\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a NodePath has been specified with\n"
    "//               set_center(), false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_has_center_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionHandlerPhysical::has_contact(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_has_contact_126(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPhysical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPhysical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionHandlerPhysical::has_contact(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasContact", key_word_list));
        else
            (PyArg_Parse(args, ":hasContact"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionHandlerPhysical*)local_this)->has_contact();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasContact(const CollisionHandlerPhysical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_has_contact_126_comment =
    "C++ Interface:\n"
    "hasContact(const CollisionHandlerPhysical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPhysical::has_contact\n"
    "//       Access: Public\n"
    "//  Description: Did the handler make any contacts with anything\n"
    "//               on the last collision pass?  Depending on how your\n"
    "//               world is setup, this can be used to tell if the\n"
    "//               handler is out of the world (i.e. out of bounds).\n"
    "//               That is the original use of this call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_has_contact_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerPhysical::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPhysical_get_class_type_127(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerPhysical::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerPhysical::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPhysical_get_class_type_127_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerPhysical_get_class_type_127_comment = NULL;
#endif

int  Dtool_Init_CollisionHandlerPhysical(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CollisionHandlerPhysical)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CollisionHandlerPhysical(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerPhysical)
    {
        printf("CollisionHandlerPhysical ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerPhysical * local_this = (CollisionHandlerPhysical *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerPhysical(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerPhysical)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerPhysical*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerPhysical*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerPhysical*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerPhysical*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerPhysical*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerFloor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerFloor::set_offset(float offset)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_set_offset_130(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerFloor::set_offset(float offset)
        double param1;
        static char * key_word_list[] = {(char *)"offset", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setOffset", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setOffset", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_offset((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerFloor.setOffset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffset(non-const CollisionHandlerFloor this, float offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_set_offset_130_comment =
    "C++ Interface:\n"
    "setOffset(non-const CollisionHandlerFloor this, float offset)\n"
    "\n"
    "// Filename: collisionHandlerFloor.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::set_offset\n"
    "//       Access: Public\n"
    "//  Description: Sets the linear offset to add to (or subtract from)\n"
    "//               the highest detected collision point to determine the\n"
    "//               actual height at which to set the collider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_set_offset_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerFloor::get_offset(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_get_offset_131(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerFloor::get_offset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffset", key_word_list));
        else
            (PyArg_Parse(args, ":getOffset"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerFloor*)local_this)->get_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffset(const CollisionHandlerFloor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_get_offset_131_comment =
    "C++ Interface:\n"
    "getOffset(const CollisionHandlerFloor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::get_offset\n"
    "//       Access: Public\n"
    "//  Description: Returns the linear offset to add to (or subtract from)\n"
    "//               the highest detected collision point to determine the\n"
    "//               actual height at which to set the collider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_get_offset_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerFloor::set_reach(float reach)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_set_reach_132(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerFloor::set_reach(float reach)
        double param1;
        static char * key_word_list[] = {(char *)"reach", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setReach", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setReach", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reach((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerFloor.setReach() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReach(non-const CollisionHandlerFloor this, float reach)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_set_reach_132_comment =
    "C++ Interface:\n"
    "setReach(non-const CollisionHandlerFloor this, float reach)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::set_reach\n"
    "//       Access: Public\n"
    "//  Description: Sets the reach to add to (or subtract from)\n"
    "//               the highest collision point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_set_reach_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerFloor::get_reach(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_get_reach_133(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerFloor::get_reach(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReach", key_word_list));
        else
            (PyArg_Parse(args, ":getReach"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerFloor*)local_this)->get_reach();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReach(const CollisionHandlerFloor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_get_reach_133_comment =
    "C++ Interface:\n"
    "getReach(const CollisionHandlerFloor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::get_reach\n"
    "//       Access: Public\n"
    "//  Description: Returns the reach to add to (or subtract from)\n"
    "//               the highest collision point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_get_reach_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerFloor::set_max_velocity(float max_vel)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_set_max_velocity_134(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerFloor::set_max_velocity(float max_vel)
        double param1;
        static char * key_word_list[] = {(char *)"max_vel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerFloor.setMaxVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxVelocity(non-const CollisionHandlerFloor this, float max_vel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_set_max_velocity_134_comment =
    "C++ Interface:\n"
    "setMaxVelocity(non-const CollisionHandlerFloor this, float max_vel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::set_max_velocity\n"
    "//       Access: Public\n"
    "//  Description: Sets the maximum speed at which the object will be\n"
    "//               allowed to descend towards a floor below it, in units\n"
    "//               per second.  Set this to zero to allow it to\n"
    "//               instantly teleport any distance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_set_max_velocity_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerFloor::get_max_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_get_max_velocity_135(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerFloor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerFloor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerFloor::get_max_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerFloor*)local_this)->get_max_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVelocity(const CollisionHandlerFloor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_get_max_velocity_135_comment =
    "C++ Interface:\n"
    "getMaxVelocity(const CollisionHandlerFloor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerFloor::get_max_velocity\n"
    "//       Access: Public\n"
    "//  Description: Retrieves the maximum speed at which the object will\n"
    "//               be allowed to descend towards a floor below it, in\n"
    "//               units per second.  See set_max_velocity().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_get_max_velocity_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerFloor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFloor_get_class_type_136(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerFloor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerFloor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFloor_get_class_type_136_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerFloor_get_class_type_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerFloor::CollisionHandlerFloor(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerFloor(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerFloor::CollisionHandlerFloor(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerFloor", key_word_list))
        {
            CollisionHandlerFloor *return_value = new CollisionHandlerFloor();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerFloor,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerFloor()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionHandlerFloor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerFloor)
    {
        printf("CollisionHandlerFloor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerFloor * local_this = (CollisionHandlerFloor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerFloor)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return ( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerFloor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerFloor)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPhysical)
    {
          CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerFloor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerGravity 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_offset(float offset)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_offset_139(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_offset(float offset)
        double param1;
        static char * key_word_list[] = {(char *)"offset", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setOffset", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setOffset", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_offset((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setOffset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffset(non-const CollisionHandlerGravity this, float offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_offset_139_comment =
    "C++ Interface:\n"
    "setOffset(non-const CollisionHandlerGravity this, float offset)\n"
    "\n"
    "// Filename: CollisionHandlerGravity.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_offset\n"
    "//       Access: Public\n"
    "//  Description: Sets the linear offset to add to (or subtract from)\n"
    "//               the highest detected collision point to determine the\n"
    "//               actual height at which to set the collider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_offset_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_offset(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_offset_140(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_offset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffset", key_word_list));
        else
            (PyArg_Parse(args, ":getOffset"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffset(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_offset_140_comment =
    "C++ Interface:\n"
    "getOffset(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_offset\n"
    "//       Access: Public\n"
    "//  Description: Returns the linear offset to add to (or subtract from)\n"
    "//               the highest detected collision point to determine the\n"
    "//               actual height at which to set the collider.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_offset_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_reach(float reach)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_reach_141(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_reach(float reach)
        double param1;
        static char * key_word_list[] = {(char *)"reach", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setReach", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setReach", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reach((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setReach() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReach(non-const CollisionHandlerGravity this, float reach)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_reach_141_comment =
    "C++ Interface:\n"
    "setReach(non-const CollisionHandlerGravity this, float reach)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_reach\n"
    "//       Access: Public\n"
    "//  Description: Sets the reach to add to (or subtract from)\n"
    "//               the highest collision point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_reach_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_reach(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_reach_142(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_reach(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReach", key_word_list));
        else
            (PyArg_Parse(args, ":getReach"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_reach();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReach(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_reach_142_comment =
    "C++ Interface:\n"
    "getReach(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_reach\n"
    "//       Access: Public\n"
    "//  Description: Returns the reach to add to (or subtract from)\n"
    "//               the highest collision point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_reach_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_airborne_height(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_airborne_height_143(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_airborne_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAirborneHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getAirborneHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_airborne_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAirborneHeight(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_airborne_height_143_comment =
    "C++ Interface:\n"
    "getAirborneHeight(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_airborne_height\n"
    "//       Access: Public\n"
    "//  Description: Return the height of the object from the ground.\n"
    "//\n"
    "//               The object might not necessarily be at rest.  Use\n"
    "//               is_on_ground() if you want to know whether the\n"
    "//               object is on the ground and at rest.\n"
    "//\n"
    "//               See Also: is_in_outer_space()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_airborne_height_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionHandlerGravity::is_on_ground(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_is_on_ground_144(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionHandlerGravity::is_on_ground(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOnGround", key_word_list));
        else
            (PyArg_Parse(args, ":isOnGround"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionHandlerGravity*)local_this)->is_on_ground();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOnGround(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_is_on_ground_144_comment =
    "C++ Interface:\n"
    "isOnGround(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::is_on_ground\n"
    "//       Access: Public\n"
    "//  Description: Is the object at rest?\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_is_on_ground_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_impact_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_impact_velocity_145(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_impact_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getImpactVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getImpactVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_impact_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getImpactVelocity(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_impact_velocity_145_comment =
    "C++ Interface:\n"
    "getImpactVelocity(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_impact_velocity\n"
    "//       Access: Public\n"
    "//  Description: How hard did the object hit the ground.\n"
    "//               This value is set on impact with the ground.\n"
    "//               You may want to watch (poll) on is_on_groun() and\n"
    "//               when that is true, call get_impact_velocity().\n"
    "//               Normally I avoid polling, but we are calling\n"
    "//               is_on_ground() frequently anyway.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_impact_velocity_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &CollisionHandlerGravity::get_contact_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_contact_normal_146(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &CollisionHandlerGravity::get_contact_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContactNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getContactNormal"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const CollisionHandlerGravity*)local_this)->get_contact_normal());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactNormal(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_contact_normal_146_comment =
    "C++ Interface:\n"
    "getContactNormal(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : CollisionHandlerGravity::get_contact_normal\n"
    "//      Access : Public\n"
    "// Description : \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_contact_normal_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::add_velocity(float velocity)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_add_velocity_147(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::add_velocity(float velocity)
        double param1;
        static char * key_word_list[] = {(char *)"velocity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.addVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addVelocity(non-const CollisionHandlerGravity this, float velocity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_add_velocity_147_comment =
    "C++ Interface:\n"
    "addVelocity(non-const CollisionHandlerGravity this, float velocity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::add_velocity\n"
    "//       Access: Public\n"
    "//  Description: Adds the sepcified amount to the current velocity.\n"
    "//               This is mostly here allow this common operation to\n"
    "//               be faster for scripting, but it's also more concise\n"
    "//               even in cpp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_add_velocity_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_velocity(float velocity)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_velocity_148(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_velocity(float velocity)
        double param1;
        static char * key_word_list[] = {(char *)"velocity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVelocity(non-const CollisionHandlerGravity this, float velocity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_velocity_148_comment =
    "C++ Interface:\n"
    "setVelocity(non-const CollisionHandlerGravity this, float velocity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_velocity\n"
    "//       Access: Public\n"
    "//  Description: Sets the current vertical velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_velocity_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_velocity_149(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVelocity(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_velocity_149_comment =
    "C++ Interface:\n"
    "getVelocity(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_velocity\n"
    "//       Access: Public\n"
    "//  Description: Gets the current vertical velocity.\n"
    "//\n"
    "//               Generally, negative values mean the object is in\n"
    "//               free fall; while postive values mean the object has\n"
    "//               vertical thrust.\n"
    "//\n"
    "//               A zero value does not necessarily mean the object\n"
    "//               on the ground, it may also be weightless and/or at\n"
    "//               the apex of its jump.\n"
    "//\n"
    "//               See Also: is_on_ground() and get_gravity()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_velocity_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_gravity(float gravity)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_gravity_150(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_gravity(float gravity)
        double param1;
        static char * key_word_list[] = {(char *)"gravity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGravity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setGravity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_gravity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setGravity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGravity(non-const CollisionHandlerGravity this, float gravity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_gravity_150_comment =
    "C++ Interface:\n"
    "setGravity(non-const CollisionHandlerGravity this, float gravity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_gravity\n"
    "//       Access: Public\n"
    "//  Description: Sets the linear gravity force (always plumb).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_gravity_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_gravity(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_gravity_151(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_gravity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGravity", key_word_list));
        else
            (PyArg_Parse(args, ":getGravity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_gravity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGravity(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_gravity_151_comment =
    "C++ Interface:\n"
    "getGravity(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_gravity\n"
    "//       Access: Public\n"
    "//  Description: Gets the linear gravity force (always plumb).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_gravity_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_max_velocity(float max_vel)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_max_velocity_152(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_max_velocity(float max_vel)
        double param1;
        static char * key_word_list[] = {(char *)"max_vel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setMaxVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxVelocity(non-const CollisionHandlerGravity this, float max_vel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_max_velocity_152_comment =
    "C++ Interface:\n"
    "setMaxVelocity(non-const CollisionHandlerGravity this, float max_vel)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_max_velocity\n"
    "//       Access: Public\n"
    "//  Description: Sets the maximum speed at which the object will be\n"
    "//               allowed to descend towards a floor below it, in units\n"
    "//               per second.  Set this to zero to allow it to\n"
    "//               instantly teleport any distance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_max_velocity_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionHandlerGravity::get_max_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_max_velocity_153(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionHandlerGravity::get_max_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionHandlerGravity*)local_this)->get_max_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVelocity(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_max_velocity_153_comment =
    "C++ Interface:\n"
    "getMaxVelocity(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_max_velocity\n"
    "//       Access: Public\n"
    "//  Description: Retrieves the maximum speed at which the object will\n"
    "//               be allowed to descend towards a floor below it, in\n"
    "//               units per second.  See set_max_velocity().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_max_velocity_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_set_legacy_mode_154(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"legacy_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLegacyMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setLegacyMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_legacy_mode((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerGravity.setLegacyMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLegacyMode(non-const CollisionHandlerGravity this, bool legacy_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_set_legacy_mode_154_comment =
    "C++ Interface:\n"
    "setLegacyMode(non-const CollisionHandlerGravity this, bool legacy_mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::set_legacy_mode\n"
    "//       Access: Public\n"
    "//  Description: Enables old behavior required by Toontown\n"
    "//               (Sellbot Factory lava room is good test case,\n"
    "//               lava and conveyor belt specifically). Behavior\n"
    "//               is to throw enter/exit events only for floor\n"
    "//               that the toon is in contact with\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_set_legacy_mode_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionHandlerGravity::get_legacy_mode(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_legacy_mode_155(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerGravity * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerGravity,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionHandlerGravity::get_legacy_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLegacyMode", key_word_list));
        else
            (PyArg_Parse(args, ":getLegacyMode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionHandlerGravity*)local_this)->get_legacy_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLegacyMode(const CollisionHandlerGravity this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_legacy_mode_155_comment =
    "C++ Interface:\n"
    "getLegacyMode(const CollisionHandlerGravity this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerGravity::get_legacy_mode\n"
    "//       Access: Public\n"
    "//  Description: returns true if legacy mode is enabled\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_legacy_mode_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerGravity::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerGravity_get_class_type_156(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerGravity::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerGravity::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerGravity_get_class_type_156_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerGravity_get_class_type_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerGravity::CollisionHandlerGravity(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerGravity(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerGravity::CollisionHandlerGravity(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerGravity", key_word_list))
        {
            CollisionHandlerGravity *return_value = new CollisionHandlerGravity();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerGravity,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerGravity()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionHandlerGravity(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerGravity)
    {
        printf("CollisionHandlerGravity ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerGravity * local_this = (CollisionHandlerGravity *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerGravity)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return ( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerGravity(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerGravity)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPhysical)
    {
          CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerGravity*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerPusher 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionHandlerPusher::set_horizontal(bool flag)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPusher_set_horizontal_159(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPusher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPusher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionHandlerPusher::set_horizontal(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHorizontal", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setHorizontal", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_horizontal((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerPusher.setHorizontal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontal(non-const CollisionHandlerPusher this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPusher_set_horizontal_159_comment =
    "C++ Interface:\n"
    "setHorizontal(non-const CollisionHandlerPusher this, bool flag)\n"
    "\n"
    "// Filename: collisionHandlerPusher.I\n"
    "// Created by:  drose (16Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPusher::set_horizontal\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPusher_set_horizontal_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CollisionHandlerPusher::get_horizontal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPusher_get_horizontal_160(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerPusher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerPusher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CollisionHandlerPusher::get_horizontal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHorizontal", key_word_list));
        else
            (PyArg_Parse(args, ":getHorizontal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionHandlerPusher*)local_this)->get_horizontal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHorizontal(const CollisionHandlerPusher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPusher_get_horizontal_160_comment =
    "C++ Interface:\n"
    "getHorizontal(const CollisionHandlerPusher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerPusher::get_horizontal\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerPusher_get_horizontal_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerPusher::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerPusher_get_class_type_161(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerPusher::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerPusher::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerPusher_get_class_type_161_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerPusher_get_class_type_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerPusher::CollisionHandlerPusher(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerPusher(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerPusher::CollisionHandlerPusher(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerPusher", key_word_list))
        {
            CollisionHandlerPusher *return_value = new CollisionHandlerPusher();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerPusher,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerPusher()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionHandlerPusher(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerPusher)
    {
        printf("CollisionHandlerPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerPusher * local_this = (CollisionHandlerPusher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerPusher)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return ( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerPusher(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerPusher)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPhysical)
    {
          CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerPusher*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerFluidPusher 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerFluidPusher_get_class_type_164(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerFluidPusher::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerFluidPusher_get_class_type_164_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerFluidPusher_get_class_type_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerFluidPusher(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerFluidPusher", key_word_list))
        {
            CollisionHandlerFluidPusher *return_value = new CollisionHandlerFluidPusher();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerFluidPusher,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerFluidPusher()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionHandlerFluidPusher(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerFluidPusher)
    {
        printf("CollisionHandlerFluidPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerFluidPusher * local_this = (CollisionHandlerFluidPusher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerFluidPusher)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return ( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPusher)
        return ( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerFluidPusher(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerFluidPusher)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPhysical)
    {
          CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPusher)
    {
          CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerFluidPusher*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionHandlerQueue 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerQueue::sort_entries(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_sort_entries_168(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionHandlerQueue::sort_entries(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sortEntries", key_word_list));
        else
            (PyArg_Parse(args, ":sortEntries"));
        if(!PyErr_Occurred())
        {
            (local_this)->sort_entries();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerQueue.sortEntries() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sortEntries(non-const CollisionHandlerQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_sort_entries_168_comment =
    "C++ Interface:\n"
    "sortEntries(non-const CollisionHandlerQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::sort_entries\n"
    "//       Access: Published\n"
    "//  Description: Sorts all the detected collisions front-to-back by\n"
    "//               from_intersection_point() so that those intersection\n"
    "//               points closest to the collider's origin (e.g., the\n"
    "//               center of the CollisionSphere, or the point_a of a\n"
    "//               CollisionSegment) appear first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_sort_entries_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerQueue::clear_entries(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_clear_entries_169(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionHandlerQueue::clear_entries(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearEntries", key_word_list));
        else
            (PyArg_Parse(args, ":clearEntries"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_entries();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionHandlerQueue.clearEntries() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearEntries(non-const CollisionHandlerQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_clear_entries_169_comment =
    "C++ Interface:\n"
    "clearEntries(non-const CollisionHandlerQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::clear_entries\n"
    "//       Access: Published\n"
    "//  Description: Removes all the entries from the queue.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_clear_entries_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CollisionHandlerQueue::get_num_entries(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_get_num_entries_170(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CollisionHandlerQueue::get_num_entries(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumEntries", key_word_list));
        else
            (PyArg_Parse(args, ":getNumEntries"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionHandlerQueue*)local_this)->get_num_entries();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumEntries(const CollisionHandlerQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_get_num_entries_170_comment =
    "C++ Interface:\n"
    "getNumEntries(const CollisionHandlerQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::get_num_entries\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of CollisionEntries detected last\n"
    "//               pass.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_get_num_entries_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_get_entry_171(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getEntry", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getEntry", &param1));
        if(!PyErr_Occurred())
        {
            CollisionEntry *return_value = ((const CollisionHandlerQueue*)local_this)->get_entry((int)param1);
            if (return_value != (CollisionEntry *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CollisionEntry,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEntry(const CollisionHandlerQueue this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_get_entry_171_comment =
    "C++ Interface:\n"
    "getEntry(const CollisionHandlerQueue this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::get_entry\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth CollisionEntry detected last pass.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_get_entry_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerQueue::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_output_172(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CollisionHandlerQueue::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionHandlerQueue.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CollisionHandlerQueue*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CollisionHandlerQueue this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_output_172_comment =
    "C++ Interface:\n"
    "output(const CollisionHandlerQueue this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_output_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionHandlerQueue::write(ostream &out, int indent_level) const
 * void CollisionHandlerQueue::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_write_173(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void CollisionHandlerQueue::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionHandlerQueue.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionHandlerQueue*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void CollisionHandlerQueue::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CollisionHandlerQueue.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const CollisionHandlerQueue*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const CollisionHandlerQueue this, non-const Ostream out)\n"
          "write(const CollisionHandlerQueue this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_write_173_comment =
    "C++ Interface:\n"
    "write(const CollisionHandlerQueue this, non-const Ostream out)\n"
    "write(const CollisionHandlerQueue this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionHandlerQueue::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_write_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionHandlerQueue::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionHandlerQueue_get_class_type_174(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionHandlerQueue::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionHandlerQueue::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionHandlerQueue_get_class_type_174_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionHandlerQueue_get_class_type_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CollisionHandlerQueue::CollisionHandlerQueue(void)
 *******************************************************************/
int  Dtool_Init_CollisionHandlerQueue(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CollisionHandlerQueue::CollisionHandlerQueue(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionHandlerQueue", key_word_list))
        {
            CollisionHandlerQueue *return_value = new CollisionHandlerQueue();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionHandlerQueue,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionHandlerQueue()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionHandlerQueue_get_entries(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumEntries", "getEntry");
}
inline void  * Dtool_UpcastInterface_CollisionHandlerQueue(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionHandlerQueue)
    {
        printf("CollisionHandlerQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionHandlerQueue * local_this = (CollisionHandlerQueue *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionHandlerQueue)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionHandlerQueue(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionHandlerQueue)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (CollisionHandlerQueue*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionHandlerQueue*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionHandlerQueue*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CollisionHandlerQueue*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionDSSolid 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_center_a(LPoint3f const &center)
 * inline void CollisionDSSolid::set_center_a(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_center_a_178(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionDSSolid::set_center_a(LPoint3f const &center)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"center", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenterA", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setCenterA", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionDSSolid.setCenterA", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_center_a(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionDSSolid.setCenterA() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionDSSolid::set_center_a(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setCenterA", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_center_a((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionDSSolid.setCenterA() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCenterA() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCenterA(non-const CollisionDSSolid this, const Point3 center)\n"
          "setCenterA(non-const CollisionDSSolid this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_center_a_178_comment =
    "C++ Interface:\n"
    "setCenterA(non-const CollisionDSSolid this, const Point3 center)\n"
    "setCenterA(non-const CollisionDSSolid this, float x, float y, float z)\n"
    "\n"
    "// Sphere a\n"
    "\n"
    "// Sphere a\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_center_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_center_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_center_a_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionDSSolid::get_center_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_center_a_179(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionDSSolid::get_center_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenterA", key_word_list));
        else
            (PyArg_Parse(args, ":getCenterA"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionDSSolid*)local_this)->get_center_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenterA(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_center_a_179_comment =
    "C++ Interface:\n"
    "getCenterA(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_center_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_center_a_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_radius_a(float radius)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_radius_a_180(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionDSSolid::set_radius_a(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadiusA", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadiusA", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius_a((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionDSSolid.setRadiusA() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadiusA(non-const CollisionDSSolid this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_radius_a_180_comment =
    "C++ Interface:\n"
    "setRadiusA(non-const CollisionDSSolid this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_radius_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_radius_a_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionDSSolid::get_radius_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_radius_a_181(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionDSSolid::get_radius_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadiusA", key_word_list));
        else
            (PyArg_Parse(args, ":getRadiusA"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionDSSolid*)local_this)->get_radius_a();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadiusA(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_radius_a_181_comment =
    "C++ Interface:\n"
    "getRadiusA(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_radius_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_radius_a_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_center_b(LPoint3f const &center)
 * inline void CollisionDSSolid::set_center_b(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_center_b_182(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionDSSolid::set_center_b(LPoint3f const &center)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"center", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenterB", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setCenterB", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionDSSolid.setCenterB", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_center_b(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionDSSolid.setCenterB() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionDSSolid::set_center_b(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setCenterB", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_center_b((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionDSSolid.setCenterB() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCenterB() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCenterB(non-const CollisionDSSolid this, const Point3 center)\n"
          "setCenterB(non-const CollisionDSSolid this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_center_b_182_comment =
    "C++ Interface:\n"
    "setCenterB(non-const CollisionDSSolid this, const Point3 center)\n"
    "setCenterB(non-const CollisionDSSolid this, float x, float y, float z)\n"
    "\n"
    "// Sphere b\n"
    "\n"
    "// Sphere b\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_center_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_center_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_center_b_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionDSSolid::get_center_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_center_b_183(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionDSSolid::get_center_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenterB", key_word_list));
        else
            (PyArg_Parse(args, ":getCenterB"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionDSSolid*)local_this)->get_center_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenterB(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_center_b_183_comment =
    "C++ Interface:\n"
    "getCenterB(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_center_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_center_b_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_radius_b(float radius)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_radius_b_184(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionDSSolid::set_radius_b(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadiusB", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadiusB", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius_b((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionDSSolid.setRadiusB() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadiusB(non-const CollisionDSSolid this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_radius_b_184_comment =
    "C++ Interface:\n"
    "setRadiusB(non-const CollisionDSSolid this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_radius_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_radius_b_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionDSSolid::get_radius_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_radius_b_185(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionDSSolid::get_radius_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadiusB", key_word_list));
        else
            (PyArg_Parse(args, ":getRadiusB"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionDSSolid*)local_this)->get_radius_b();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadiusB(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_radius_b_185_comment =
    "C++ Interface:\n"
    "getRadiusB(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_radius_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_radius_b_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f CollisionDSSolid::get_normal_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_normal_a_186(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f CollisionDSSolid::get_normal_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormalA", key_word_list));
        else
            (PyArg_Parse(args, ":getNormalA"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const CollisionDSSolid*)local_this)->get_normal_a();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormalA(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_normal_a_186_comment =
    "C++ Interface:\n"
    "getNormalA(const CollisionDSSolid this)\n"
    "\n"
    "// Plane a\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_normal_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_normal_a_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionDSSolid::dist_to_plane_a(LPoint3f const &point) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_dist_to_plane_a_187(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline float CollisionDSSolid::dist_to_plane_a(LPoint3f const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:distToPlaneA", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:distToPlaneA", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionDSSolid.distToPlaneA", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = ((const CollisionDSSolid*)local_this)->dist_to_plane_a(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "distToPlaneA(const CollisionDSSolid this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_dist_to_plane_a_187_comment =
    "C++ Interface:\n"
    "distToPlaneA(const CollisionDSSolid this, const Point3 point)\n"
    "\n"
    "// Plane a\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::dist_to_plane_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_dist_to_plane_a_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_plane_a(Planef const &plane)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_plane_a_188(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionDSSolid::set_plane_a(Planef const &plane)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"plane", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPlaneA", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPlaneA", &param1));
            if(!PyErr_Occurred())
            {
                Planef *param1_this = (Planef *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Planef, 1, "CollisionDSSolid.setPlaneA", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_plane_a(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionDSSolid.setPlaneA() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlaneA(non-const CollisionDSSolid this, const Plane plane)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_plane_a_188_comment =
    "C++ Interface:\n"
    "setPlaneA(non-const CollisionDSSolid this, const Plane plane)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_plane_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_plane_a_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef const &CollisionDSSolid::get_plane_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_plane_a_189(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef const &CollisionDSSolid::get_plane_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlaneA", key_word_list));
        else
            (PyArg_Parse(args, ":getPlaneA"));
        if(!PyErr_Occurred())
        {
            Planef const *return_value = &(((const CollisionDSSolid*)local_this)->get_plane_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlaneA(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_plane_a_189_comment =
    "C++ Interface:\n"
    "getPlaneA(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_plane_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_plane_a_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f CollisionDSSolid::get_normal_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_normal_b_190(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f CollisionDSSolid::get_normal_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormalB", key_word_list));
        else
            (PyArg_Parse(args, ":getNormalB"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const CollisionDSSolid*)local_this)->get_normal_b();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormalB(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_normal_b_190_comment =
    "C++ Interface:\n"
    "getNormalB(const CollisionDSSolid this)\n"
    "\n"
    "// Plane b\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_normal_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_normal_b_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionDSSolid::dist_to_plane_b(LPoint3f const &point) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_dist_to_plane_b_191(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline float CollisionDSSolid::dist_to_plane_b(LPoint3f const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:distToPlaneB", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:distToPlaneB", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionDSSolid.distToPlaneB", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = ((const CollisionDSSolid*)local_this)->dist_to_plane_b(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "distToPlaneB(const CollisionDSSolid this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_dist_to_plane_b_191_comment =
    "C++ Interface:\n"
    "distToPlaneB(const CollisionDSSolid this, const Point3 point)\n"
    "\n"
    "// Plane b\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::dist_to_plane_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_dist_to_plane_b_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionDSSolid::set_plane_b(Planef const &plane)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_set_plane_b_192(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionDSSolid::set_plane_b(Planef const &plane)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"plane", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPlaneB", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPlaneB", &param1));
            if(!PyErr_Occurred())
            {
                Planef *param1_this = (Planef *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Planef, 1, "CollisionDSSolid.setPlaneB", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_plane_b(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionDSSolid.setPlaneB() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlaneB(non-const CollisionDSSolid this, const Plane plane)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_set_plane_b_192_comment =
    "C++ Interface:\n"
    "setPlaneB(non-const CollisionDSSolid this, const Plane plane)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::set_plane_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_set_plane_b_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef const &CollisionDSSolid::get_plane_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_plane_b_193(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionDSSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionDSSolid,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef const &CollisionDSSolid::get_plane_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlaneB", key_word_list));
        else
            (PyArg_Parse(args, ":getPlaneB"));
        if(!PyErr_Occurred())
        {
            Planef const *return_value = &(((const CollisionDSSolid*)local_this)->get_plane_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlaneB(const CollisionDSSolid this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_plane_b_193_comment =
    "C++ Interface:\n"
    "getPlaneB(const CollisionDSSolid this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionDSSolid::get_plane_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_plane_b_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionDSSolid::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionDSSolid_get_class_type_194(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionDSSolid::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionDSSolid::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionDSSolid_get_class_type_194_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionDSSolid_get_class_type_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionDSSolid::CollisionDSSolid(LPoint3f const &center_a, float radius_a, LPoint3f const &center_b, float radius_b, Planef const &plane_a, Planef const &plane_b)
 * inline CollisionDSSolid::CollisionDSSolid(float ax, float ay, float az, float radius_a, float bx, float by, float bz, float radius_b, Planef const &plane_a, Planef const &plane_b)
 *******************************************************************/
int  Dtool_Init_CollisionDSSolid(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionDSSolid::CollisionDSSolid(LPoint3f const &center_a, float radius_a, LPoint3f const &center_b, float radius_b, Planef const &plane_a, Planef const &plane_b)
                PyObject *param0;
                double param1;
                PyObject *param2;
                double param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"center_a", (char *)"radius_a", (char *)"center_b", (char *)"radius_b", (char *)"plane_a", (char *)"plane_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdOdOO:CollisionDSSolid", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);
Planef *param4_this = (Planef *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_Planef, 4, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);
Planef *param5_this = (Planef *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_Planef, 5, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)))
                    {
                        CollisionDSSolid *return_value = new CollisionDSSolid(*param0_this, (float)param1, *param2_this, (float)param3, *param4_this, *param5_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionDSSolid,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(10):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionDSSolid::CollisionDSSolid(float ax, float ay, float az, float radius_a, float bx, float by, float bz, float radius_b, Planef const &plane_a, Planef const &plane_b)
                double param0;
                double param1;
                double param2;
                double param3;
                double param4;
                double param5;
                double param6;
                double param7;
                PyObject *param8;
                PyObject *param9;
                static char * key_word_list[] = {(char *)"ax", (char *)"ay", (char *)"az", (char *)"radius_a", (char *)"bx", (char *)"by", (char *)"bz", (char *)"radius_b", (char *)"plane_a", (char *)"plane_b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddddOO:CollisionDSSolid", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
                {
                    Planef *param8_this = (Planef *)DTOOL_Call_GetPointerThisClass(param8, &Dtool_Planef, 8, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);
Planef *param9_this = (Planef *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_Planef, 9, "CollisionDSSolid.CollisionDSSolid", 1, coerced_ptr, report_errors);

                    if (!((param8_this == NULL)|| (param9_this == NULL)))
                    {
                        CollisionDSSolid *return_value = new CollisionDSSolid((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, *param8_this, *param9_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionDSSolid,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionDSSolid() takes 6 or 10 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionDSSolid(const Point3 center_a, float radius_a, const Point3 center_b, float radius_b, const Plane plane_a, const Plane plane_b)\n"
          "CollisionDSSolid(float ax, float ay, float az, float radius_a, float bx, float by, float bz, float radius_b, const Plane plane_a, const Plane plane_b)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionDSSolid(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionDSSolid)
    {
        printf("CollisionDSSolid ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionDSSolid * local_this = (CollisionDSSolid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionDSSolid)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionDSSolid(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionDSSolid)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionDSSolid*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionBox 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int CollisionBox::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_num_points_198(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionBox::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionBox*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const CollisionBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_num_points_198_comment =
    "C++ Interface:\n"
    "getNumPoints(const CollisionBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_num_points\n"
    "//       Access: Published\n"
    "//  Description: Returns 8: the number of vertices of a rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_num_points_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f CollisionBox::get_point_aabb(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_point_aabb_199(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f CollisionBox::get_point_aabb(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPointAabb", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPointAabb", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const CollisionBox*)local_this)->get_point_aabb((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointAabb(const CollisionBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_point_aabb_199_comment =
    "C++ Interface:\n"
    "getPointAabb(const CollisionBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_point_aabb\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex of the Axis Aligned Bounding Box.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_point_aabb_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f CollisionBox::get_point(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_point_200(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f CollisionBox::get_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const CollisionBox*)local_this)->get_point((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const CollisionBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_point_200_comment =
    "C++ Interface:\n"
    "getPoint(const CollisionBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex of the OBB.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_point_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CollisionBox::get_num_planes(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_num_planes_201(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionBox::get_num_planes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPlanes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPlanes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionBox*)local_this)->get_num_planes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPlanes(const CollisionBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_num_planes_201_comment =
    "C++ Interface:\n"
    "getNumPlanes(const CollisionBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_num_planes\n"
    "//       Access: Published\n"
    "//  Description: Returns 6: the number of faces of a rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_num_planes_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef CollisionBox::set_plane(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_set_plane_202(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef CollisionBox::set_plane(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPlane", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPlane", &param1));
        if(!PyErr_Occurred())
        {
            Planef result = ((const CollisionBox*)local_this)->set_plane((int)param1);
            Planef *return_value = new Planef(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlane(const CollisionBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_set_plane_202_comment =
    "C++ Interface:\n"
    "setPlane(const CollisionBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::set_plane\n"
    "//       Access: Published\n"
    "//  Description: Creates the nth face of the rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_set_plane_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef CollisionBox::get_plane(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_plane_203(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef CollisionBox::get_plane(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPlane", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPlane", &param1));
        if(!PyErr_Occurred())
        {
            Planef result = ((const CollisionBox*)local_this)->get_plane((int)param1);
            Planef *return_value = new Planef(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlane(const CollisionBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_plane_203_comment =
    "C++ Interface:\n"
    "getPlane(const CollisionBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth face of the rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_plane_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionBox::set_center(LPoint3f const &center)
 * inline void CollisionBox::set_center(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionBox_set_center_204(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionBox::set_center(LPoint3f const &center)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"center", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenter", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setCenter", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionBox.setCenter", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_center(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionBox.setCenter() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionBox::set_center(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setCenter", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_center((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionBox.setCenter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCenter() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCenter(non-const CollisionBox this, const Point3 center)\n"
          "setCenter(non-const CollisionBox this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_set_center_204_comment =
    "C++ Interface:\n"
    "setCenter(non-const CollisionBox this, const Point3 center)\n"
    "setCenter(non-const CollisionBox this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::set_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::set_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_set_center_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionBox::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_center_205(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionBox::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionBox*)local_this)->get_center());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const CollisionBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_center_205_comment =
    "C++ Interface:\n"
    "getCenter(const CollisionBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_center_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionBox::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_radius_206(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionBox::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionBox*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const CollisionBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_radius_206_comment =
    "C++ Interface:\n"
    "getRadius(const CollisionBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionBox::get_radius\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionBox_get_radius_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionBox::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionBox_get_class_type_207(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionBox::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionBox::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionBox_get_class_type_207_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionBox_get_class_type_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionBox::CollisionBox(LPoint3f const &min, LPoint3f const &max)
 * inline CollisionBox::CollisionBox(LPoint3f const &center, float x, float y, float z)
 * inline CollisionBox::CollisionBox(float cx, float cy, float cz, float x, float y, float z)
 *******************************************************************/
int  Dtool_Init_CollisionBox(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionBox::CollisionBox(LPoint3f const &min, LPoint3f const &max)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"min", (char *)"max", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CollisionBox", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionBox.CollisionBox", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionBox.CollisionBox", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionBox *return_value = new CollisionBox(*param0_this, *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionBox,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionBox::CollisionBox(LPoint3f const &center, float x, float y, float z)
                PyObject *param0;
                double param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"center", (char *)"x", (char *)"y", (char *)"z", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddd:CollisionBox", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionBox.CollisionBox", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CollisionBox *return_value = new CollisionBox(*param0_this, (float)param1, (float)param2, (float)param3);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionBox,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          // 1-inline CollisionBox::CollisionBox(float cx, float cy, float cz, float x, float y, float z)
            double param0;
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"cx", (char *)"cy", (char *)"cz", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:CollisionBox", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                CollisionBox *return_value = new CollisionBox((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionBox,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionBox() takes 2, 4, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionBox(const Point3 min, const Point3 max)\n"
          "CollisionBox(const Point3 center, float x, float y, float z)\n"
          "CollisionBox(float cx, float cy, float cz, float x, float y, float z)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionBox(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionBox)
    {
        printf("CollisionBox ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionBox * local_this = (CollisionBox *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionBox)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionBox(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionBox)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionBox*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionBox*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionSphere 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSphere::set_center(LPoint3f const &center)
 * inline void CollisionSphere::set_center(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionSphere_set_center_211(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionSphere::set_center(LPoint3f const &center)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"center", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCenter", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setCenter", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionSphere.setCenter", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_center(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionSphere.setCenter() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionSphere::set_center(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setCenter", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_center((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionSphere.setCenter() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setCenter() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setCenter(non-const CollisionSphere this, const Point3 center)\n"
          "setCenter(non-const CollisionSphere this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSphere_set_center_211_comment =
    "C++ Interface:\n"
    "setCenter(non-const CollisionSphere this, const Point3 center)\n"
    "setCenter(non-const CollisionSphere this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSphere::set_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSphere::set_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSphere_set_center_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionSphere::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSphere_get_center_212(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionSphere::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionSphere*)local_this)->get_center());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const CollisionSphere this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSphere_get_center_212_comment =
    "C++ Interface:\n"
    "getCenter(const CollisionSphere this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSphere::get_center\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSphere_get_center_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSphere::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_CollisionSphere_set_radius_213(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionSphere::set_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionSphere.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const CollisionSphere this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSphere_set_radius_213_comment =
    "C++ Interface:\n"
    "setRadius(non-const CollisionSphere this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSphere::set_radius\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSphere_set_radius_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionSphere::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSphere_get_radius_214(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionSphere::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionSphere*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const CollisionSphere this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSphere_get_radius_214_comment =
    "C++ Interface:\n"
    "getRadius(const CollisionSphere this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSphere::get_radius\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSphere_get_radius_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionSphere::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionSphere_get_class_type_215(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionSphere::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionSphere::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSphere_get_class_type_215_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionSphere_get_class_type_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionSphere::CollisionSphere(LPoint3f const &center, float radius)
 * inline CollisionSphere::CollisionSphere(float cx, float cy, float cz, float radius)
 *******************************************************************/
int  Dtool_Init_CollisionSphere(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionSphere::CollisionSphere(LPoint3f const &center, float radius)
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"center", (char *)"radius", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:CollisionSphere", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionSphere.CollisionSphere", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CollisionSphere *return_value = new CollisionSphere(*param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionSphere,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-inline CollisionSphere::CollisionSphere(float cx, float cy, float cz, float radius)
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"cx", (char *)"cy", (char *)"cz", (char *)"radius", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:CollisionSphere", key_word_list, &param0, &param1, &param2, &param3))
            {
                CollisionSphere *return_value = new CollisionSphere((float)param0, (float)param1, (float)param2, (float)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionSphere,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionSphere() takes 2 or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionSphere(const Point3 center, float radius)\n"
          "CollisionSphere(float cx, float cy, float cz, float radius)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionSphere(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionSphere)
    {
        printf("CollisionSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionSphere * local_this = (CollisionSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionSphere)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionSphere(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionSphere)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionSphere*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionSphere*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionInvSphere 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionInvSphere::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionInvSphere_get_class_type_219(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionInvSphere::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionInvSphere::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionInvSphere_get_class_type_219_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionInvSphere_get_class_type_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionInvSphere::CollisionInvSphere(LPoint3f const &center, float radius)
 * inline CollisionInvSphere::CollisionInvSphere(float cx, float cy, float cz, float radius)
 *******************************************************************/
int  Dtool_Init_CollisionInvSphere(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionInvSphere::CollisionInvSphere(LPoint3f const &center, float radius)
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"center", (char *)"radius", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:CollisionInvSphere", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionInvSphere.CollisionInvSphere", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CollisionInvSphere *return_value = new CollisionInvSphere(*param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionInvSphere,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-inline CollisionInvSphere::CollisionInvSphere(float cx, float cy, float cz, float radius)
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"cx", (char *)"cy", (char *)"cz", (char *)"radius", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:CollisionInvSphere", key_word_list, &param0, &param1, &param2, &param3))
            {
                CollisionInvSphere *return_value = new CollisionInvSphere((float)param0, (float)param1, (float)param2, (float)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionInvSphere,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionInvSphere() takes 2 or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionInvSphere(const Point3 center, float radius)\n"
          "CollisionInvSphere(float cx, float cy, float cz, float radius)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionInvSphere(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionInvSphere)
    {
        printf("CollisionInvSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionInvSphere * local_this = (CollisionInvSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionInvSphere)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_CollisionSphere)
        return ( CollisionSphere *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionSphere *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionInvSphere(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionInvSphere)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_CollisionSphere)
    {
          CollisionSphere* other_this = (CollisionSphere*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionInvSphere*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionRay 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionRay::set_origin(LPoint3f const &origin)
 * inline void CollisionRay::set_origin(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionRay_set_origin_223(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionRay * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionRay,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionRay::set_origin(LPoint3f const &origin)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"origin", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOrigin", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setOrigin", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionRay.setOrigin", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_origin(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionRay.setOrigin() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionRay::set_origin(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setOrigin", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_origin((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionRay.setOrigin() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setOrigin() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setOrigin(non-const CollisionRay this, const Point3 origin)\n"
          "setOrigin(non-const CollisionRay this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_set_origin_223_comment =
    "C++ Interface:\n"
    "setOrigin(non-const CollisionRay this, const Point3 origin)\n"
    "setOrigin(non-const CollisionRay this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_origin\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_origin\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionRay_set_origin_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionRay::get_origin(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionRay_get_origin_224(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionRay * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionRay,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionRay::get_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getOrigin"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionRay*)local_this)->get_origin());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrigin(const CollisionRay this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_get_origin_224_comment =
    "C++ Interface:\n"
    "getOrigin(const CollisionRay this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::get_origin\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionRay_get_origin_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionRay::set_direction(LVector3f const &direction)
 * inline void CollisionRay::set_direction(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionRay_set_direction_225(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionRay * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionRay,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionRay::set_direction(LVector3f const &direction)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"direction", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDirection", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setDirection", &param1));
                if(!PyErr_Occurred())
                {
                    LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionRay.setDirection", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_direction(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionRay.setDirection() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionRay::set_direction(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setDirection", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_direction((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionRay.setDirection() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setDirection() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setDirection(non-const CollisionRay this, const Vec3 direction)\n"
          "setDirection(non-const CollisionRay this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_set_direction_225_comment =
    "C++ Interface:\n"
    "setDirection(non-const CollisionRay this, const Vec3 direction)\n"
    "setDirection(non-const CollisionRay this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_direction\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_direction\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionRay_set_direction_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &CollisionRay::get_direction(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionRay_get_direction_226(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionRay * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionRay,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &CollisionRay::get_direction(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirection", key_word_list));
        else
            (PyArg_Parse(args, ":getDirection"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const CollisionRay*)local_this)->get_direction());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirection(const CollisionRay this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_get_direction_226_comment =
    "C++ Interface:\n"
    "getDirection(const CollisionRay this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::get_direction\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionRay_get_direction_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionRay::set_from_lens(LensNode *camera, LPoint2f const &point)
 * inline bool CollisionRay::set_from_lens(LensNode *camera, float px, float py)
 *******************************************************************/
static PyObject *Dtool_CollisionRay_set_from_lens_227(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionRay * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionRay,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool CollisionRay::set_from_lens(LensNode *camera, LPoint2f const &point)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"camera", (char *)"point", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setFromLens", key_word_list, &param1, &param2))
                {
                    LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LensNode, 1, "CollisionRay.setFromLens", 0, coerced_ptr, report_errors);
LPoint2f *param2_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint2f, 2, "CollisionRay.setFromLens", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_from_lens(param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionRay.setFromLens() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool CollisionRay::set_from_lens(LensNode *camera, float px, float py)
                PyObject *param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"camera", (char *)"px", (char *)"py", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:setFromLens", key_word_list, &param1, &param2, &param3))
                {
                    LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LensNode, 1, "CollisionRay.setFromLens", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->set_from_lens(param1_this, (float)param2, (float)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionRay.setFromLens() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFromLens() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFromLens(non-const CollisionRay this, non-const LensNode camera, const Point2 point)\n"
          "setFromLens(non-const CollisionRay this, non-const LensNode camera, float px, float py)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_set_from_lens_227_comment =
    "C++ Interface:\n"
    "setFromLens(non-const CollisionRay this, non-const LensNode camera, const Point2 point)\n"
    "setFromLens(non-const CollisionRay this, non-const LensNode camera, float px, float py)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_from_lens\n"
    "//       Access: Public\n"
    "//  Description: Accepts a LensNode and a 2-d point in the range\n"
    "//               [-1,1].  Sets the CollisionRay so that it begins at\n"
    "//               the LensNode's near plane and extends to\n"
    "//               infinity, making it suitable for picking objects from\n"
    "//               the screen given a camera and a mouse location.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionRay::set_from_lens\n"
    "//       Access: Public\n"
    "//  Description: Accepts a LensNode and a 2-d point in the range\n"
    "//               [-1,1].  Sets the CollisionRay so that it begins at\n"
    "//               the LensNode's near plane and extends to\n"
    "//               infinity, making it suitable for picking objects from\n"
    "//               the screen given a camera and a mouse location.\n"
    "//\n"
    "//               Returns true if the point was acceptable, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionRay_set_from_lens_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionRay::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionRay_get_class_type_228(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionRay::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionRay::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionRay_get_class_type_228_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionRay_get_class_type_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionRay::CollisionRay(void)
 * inline CollisionRay::CollisionRay(LPoint3f const &origin, LVector3f const &direction)
 * inline CollisionRay::CollisionRay(float ox, float oy, float oz, float dx, float dy, float dz)
 *******************************************************************/
int  Dtool_Init_CollisionRay(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline CollisionRay::CollisionRay(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionRay", key_word_list))
            {
                CollisionRay *return_value = new CollisionRay();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionRay,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionRay::CollisionRay(LPoint3f const &origin, LVector3f const &direction)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"origin", (char *)"direction", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CollisionRay", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionRay.CollisionRay", 1, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionRay.CollisionRay", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionRay *return_value = new CollisionRay(*param0_this, *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionRay,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          // 1-inline CollisionRay::CollisionRay(float ox, float oy, float oz, float dx, float dy, float dz)
            double param0;
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"ox", (char *)"oy", (char *)"oz", (char *)"dx", (char *)"dy", (char *)"dz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:CollisionRay", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                CollisionRay *return_value = new CollisionRay((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionRay,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionRay() takes 0, 2, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionRay()\n"
          "CollisionRay(const Point3 origin, const Vec3 direction)\n"
          "CollisionRay(float ox, float oy, float oz, float dx, float dy, float dz)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionRay(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionRay)
    {
        printf("CollisionRay ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionRay * local_this = (CollisionRay *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionRay)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionRay(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionRay)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionRay*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionRay*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionLine 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionLine::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionLine_get_class_type_232(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionLine::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionLine::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionLine_get_class_type_232_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionLine_get_class_type_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionLine::CollisionLine(void)
 * inline CollisionLine::CollisionLine(LPoint3f const &origin, LVector3f const &direction)
 * inline CollisionLine::CollisionLine(float ox, float oy, float oz, float dx, float dy, float dz)
 *******************************************************************/
int  Dtool_Init_CollisionLine(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline CollisionLine::CollisionLine(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionLine", key_word_list))
            {
                CollisionLine *return_value = new CollisionLine();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionLine,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionLine::CollisionLine(LPoint3f const &origin, LVector3f const &direction)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"origin", (char *)"direction", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CollisionLine", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionLine.CollisionLine", 1, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CollisionLine.CollisionLine", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionLine *return_value = new CollisionLine(*param0_this, *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionLine,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          // 1-inline CollisionLine::CollisionLine(float ox, float oy, float oz, float dx, float dy, float dz)
            double param0;
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"ox", (char *)"oy", (char *)"oz", (char *)"dx", (char *)"dy", (char *)"dz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:CollisionLine", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                CollisionLine *return_value = new CollisionLine((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionLine,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionLine() takes 0, 2, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionLine()\n"
          "CollisionLine(const Point3 origin, const Vec3 direction)\n"
          "CollisionLine(float ox, float oy, float oz, float dx, float dy, float dz)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionLine(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionLine)
    {
        printf("CollisionLine ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionLine * local_this = (CollisionLine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionLine)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_CollisionRay)
        return ( CollisionRay *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionRay *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionLine(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionLine)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_CollisionRay)
    {
          CollisionRay* other_this = (CollisionRay*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionLine*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionLine*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionPlane 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVector3f CollisionPlane::get_normal(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionPlane_get_normal_236(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPlane * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPlane,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f CollisionPlane::get_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getNormal"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const CollisionPlane*)local_this)->get_normal();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormal(const CollisionPlane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPlane_get_normal_236_comment =
    "C++ Interface:\n"
    "getNormal(const CollisionPlane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPlane::get_normal\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPlane_get_normal_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionPlane::dist_to_plane(LPoint3f const &point) const
 *******************************************************************/
static PyObject *Dtool_CollisionPlane_dist_to_plane_237(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPlane * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPlane,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline float CollisionPlane::dist_to_plane(LPoint3f const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:distToPlane", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:distToPlane", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionPlane.distToPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = ((const CollisionPlane*)local_this)->dist_to_plane(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "distToPlane(const CollisionPlane this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPlane_dist_to_plane_237_comment =
    "C++ Interface:\n"
    "distToPlane(const CollisionPlane this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPlane::dist_to_plane\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPlane_dist_to_plane_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionPlane::set_plane(Planef const &plane)
 *******************************************************************/
static PyObject *Dtool_CollisionPlane_set_plane_238(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPlane * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPlane,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionPlane::set_plane(Planef const &plane)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"plane", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPlane", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPlane", &param1));
            if(!PyErr_Occurred())
            {
                Planef *param1_this = (Planef *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Planef, 1, "CollisionPlane.setPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_plane(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionPlane.setPlane() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlane(non-const CollisionPlane this, const Plane plane)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPlane_set_plane_238_comment =
    "C++ Interface:\n"
    "setPlane(non-const CollisionPlane this, const Plane plane)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPlane::set_plane\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPlane_set_plane_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef const &CollisionPlane::get_plane(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionPlane_get_plane_239(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPlane * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPlane,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef const &CollisionPlane::get_plane(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlane", key_word_list));
        else
            (PyArg_Parse(args, ":getPlane"));
        if(!PyErr_Occurred())
        {
            Planef const *return_value = &(((const CollisionPlane*)local_this)->get_plane());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlane(const CollisionPlane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPlane_get_plane_239_comment =
    "C++ Interface:\n"
    "getPlane(const CollisionPlane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPlane::get_plane\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPlane_get_plane_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionPlane::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionPlane_get_class_type_240(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionPlane::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionPlane::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPlane_get_class_type_240_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionPlane_get_class_type_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
 * inline CollisionPlane::CollisionPlane(Planef const &plane)
 *******************************************************************/
int  Dtool_Init_CollisionPlane(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:CollisionPlane", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:CollisionPlane", &param0));
            if(!PyErr_Occurred())
            {
                CollisionPlane *param0_this = (CollisionPlane *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_CollisionPlane, 0, "CollisionPlane.CollisionPlane", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    CollisionPlane *return_value = new CollisionPlane(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionPlane,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline CollisionPlane::CollisionPlane(Planef const &plane)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"plane", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:CollisionPlane", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:CollisionPlane", &param0));
            if(!PyErr_Occurred())
            {
                Planef *param0_this = (Planef *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Planef, 0, "CollisionPlane.CollisionPlane", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    CollisionPlane *return_value = new CollisionPlane(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionPlane,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionPlane(const CollisionPlane copy)\n"
          "CollisionPlane(const Plane plane)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionPlane(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionPlane)
    {
        printf("CollisionPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionPlane * local_this = (CollisionPlane *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionPlane)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionPlane(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionPlane)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionPlane*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionPlane*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionPolygon 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int CollisionPolygon::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_get_num_points_244(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPolygon * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPolygon,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CollisionPolygon::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CollisionPolygon*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const CollisionPolygon this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_get_num_points_244_comment =
    "C++ Interface:\n"
    "getNumPoints(const CollisionPolygon this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::get_num_points\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of vertices of the\n"
    "//               CollisionPolygon.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPolygon_get_num_points_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f CollisionPolygon::get_point(int n) const
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_get_point_245(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPolygon * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPolygon,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f CollisionPolygon::get_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const CollisionPolygon*)local_this)->get_point((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const CollisionPolygon this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_get_point_245_comment =
    "C++ Interface:\n"
    "getPoint(const CollisionPolygon this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex of the CollisionPolygon,\n"
    "//               expressed in 3-D space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPolygon_get_point_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool CollisionPolygon::verify_points(LPoint3f const *begin, LPoint3f const *end)
 * static inline bool CollisionPolygon::verify_points(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
 * static inline bool CollisionPolygon::verify_points(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c, LPoint3f const &d)
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_verify_points_246(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static bool CollisionPolygon::verify_points(LPoint3f const *begin, LPoint3f const *end)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"begin", (char *)"end", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:verifyPoints", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = CollisionPolygon::verify_points(param0_this, param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline bool CollisionPolygon::verify_points(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:verifyPoints", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = CollisionPolygon::verify_points(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline bool CollisionPolygon::verify_points(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c, LPoint3f const &d)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:verifyPoints", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "CollisionPolygon.verifyPoints", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        bool return_value = CollisionPolygon::verify_points(*param0_this, *param1_this, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "verifyPoints() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "verifyPoints(const Point3 begin, const Point3 end)\n"
          "verifyPoints(const Point3 a, const Point3 b, const Point3 c)\n"
          "verifyPoints(const Point3 a, const Point3 b, const Point3 c, const Point3 d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_verify_points_246_comment =
    "C++ Interface:\n"
    "verifyPoints(const Point3 begin, const Point3 end)\n"
    "verifyPoints(const Point3 a, const Point3 b, const Point3 c)\n"
    "verifyPoints(const Point3 a, const Point3 b, const Point3 c, const Point3 d)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::verify_points\n"
    "//       Access: Published, Static\n"
    "//  Description: Verifies that the indicated set of points will define\n"
    "//               a valid CollisionPolygon: that is, at least three\n"
    "//               non-collinear points, with no points repeated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::verify_points\n"
    "//       Access: Published, Static\n"
    "//  Description: Verifies that the indicated set of points will define\n"
    "//               a valid CollisionPolygon: that is, at least three\n"
    "//               non-collinear points, with no points repeated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::verify_points\n"
    "//       Access: Public, Static\n"
    "//  Description: Verifies that the indicated set of points will define\n"
    "//               a valid CollisionPolygon: that is, at least three\n"
    "//               non-collinear points, with no points repeated.\n"
    "//\n"
    "//               This does not check that the polygon defined is\n"
    "//               convex; that check is made later, once we have\n"
    "//               projected the points to 2-d space where the decision\n"
    "//               is easier.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPolygon_verify_points_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionPolygon::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_is_valid_247(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPolygon * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPolygon,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool CollisionPolygon::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionPolygon*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const CollisionPolygon this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_is_valid_247_comment =
    "C++ Interface:\n"
    "isValid(const CollisionPolygon this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the CollisionPolygon is valid\n"
    "//               (that is, it has at least three vertices), or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPolygon_is_valid_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionPolygon::is_concave(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_is_concave_248(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionPolygon * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionPolygon,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool CollisionPolygon::is_concave(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isConcave", key_word_list));
        else
            (PyArg_Parse(args, ":isConcave"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CollisionPolygon*)local_this)->is_concave();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConcave(const CollisionPolygon this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_is_concave_248_comment =
    "C++ Interface:\n"
    "isConcave(const CollisionPolygon this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionPolygon::is_concave\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the CollisionPolygon appears to be\n"
    "//               concave, or false if it is safely convex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionPolygon_is_concave_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionPolygon::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionPolygon_get_class_type_249(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionPolygon::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionPolygon::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionPolygon_get_class_type_249_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionPolygon_get_class_type_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionPolygon::CollisionPolygon(LPoint3f const *begin, LPoint3f const *end)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c, LVecBase3f const &d)
 *******************************************************************/
int  Dtool_Init_CollisionPolygon(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionPolygon::CollisionPolygon(LPoint3f const *begin, LPoint3f const *end)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"begin", (char *)"end", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CollisionPolygon", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionPolygon,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:CollisionPolygon", key_word_list, &param0, &param1, &param2))
                {
                    LVecBase3f *param0_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase3f, 0, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionPolygon,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c, LVecBase3f const &d)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:CollisionPolygon", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LVecBase3f *param0_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase3f, 0, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "CollisionPolygon.CollisionPolygon", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionPolygon,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionPolygon() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionPolygon(const Point3 begin, const Point3 end)\n"
          "CollisionPolygon(const VBase3 a, const VBase3 b, const VBase3 c)\n"
          "CollisionPolygon(const VBase3 a, const VBase3 b, const VBase3 c, const VBase3 d)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionPolygon_get_points(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPoints", "getPoint");
}
inline void  * Dtool_UpcastInterface_CollisionPolygon(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionPolygon)
    {
        printf("CollisionPolygon ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionPolygon * local_this = (CollisionPolygon *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionPolygon)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_CollisionPlane)
        return ( CollisionPlane *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *)( CollisionPlane *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionPolygon(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionPolygon)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_CollisionPlane)
    {
          CollisionPlane* other_this = (CollisionPlane*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionPolygon*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionPolygon*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionParabola 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionParabola::set_parabola(Parabolaf const &parabola)
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_set_parabola_253(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionParabola::set_parabola(Parabolaf const &parabola)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"parabola", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setParabola", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setParabola", &param1));
            if(!PyErr_Occurred())
            {
                Parabolaf *param1_this = (Parabolaf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Parabolaf, 1, "CollisionParabola.setParabola", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_parabola(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionParabola.setParabola() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParabola(non-const CollisionParabola this, const Parabolaf parabola)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_set_parabola_253_comment =
    "C++ Interface:\n"
    "setParabola(non-const CollisionParabola this, const Parabolaf parabola)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::set_parabola\n"
    "//       Access: Public\n"
    "//  Description: Replaces the parabola specified by this solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_set_parabola_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Parabolaf const &CollisionParabola::get_parabola(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_get_parabola_254(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Parabolaf const &CollisionParabola::get_parabola(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParabola", key_word_list));
        else
            (PyArg_Parse(args, ":getParabola"));
        if(!PyErr_Occurred())
        {
            Parabolaf const *return_value = &(((const CollisionParabola*)local_this)->get_parabola());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Parabolaf,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParabola(const CollisionParabola this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_get_parabola_254_comment =
    "C++ Interface:\n"
    "getParabola(const CollisionParabola this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::get_parabola\n"
    "//       Access: Public\n"
    "//  Description: Returns the parabola specified by this solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_get_parabola_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionParabola::set_t1(float t1)
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_set_t1_255(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionParabola::set_t1(float t1)
        double param1;
        static char * key_word_list[] = {(char *)"t1", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT1", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT1", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t1((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionParabola.setT1() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT1(non-const CollisionParabola this, float t1)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_set_t1_255_comment =
    "C++ Interface:\n"
    "setT1(non-const CollisionParabola this, float t1)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::set_t1\n"
    "//       Access: Public\n"
    "//  Description: Changes the starting point on the parabola.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_set_t1_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionParabola::get_t1(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_get_t1_256(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionParabola::get_t1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT1", key_word_list));
        else
            (PyArg_Parse(args, ":getT1"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionParabola*)local_this)->get_t1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT1(const CollisionParabola this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_get_t1_256_comment =
    "C++ Interface:\n"
    "getT1(const CollisionParabola this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::get_t1\n"
    "//       Access: Public\n"
    "//  Description: Returns the starting point on the parabola.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_get_t1_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionParabola::set_t2(float t2)
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_set_t2_257(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionParabola::set_t2(float t2)
        double param1;
        static char * key_word_list[] = {(char *)"t2", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT2", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT2", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t2((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionParabola.setT2() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT2(non-const CollisionParabola this, float t2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_set_t2_257_comment =
    "C++ Interface:\n"
    "setT2(non-const CollisionParabola this, float t2)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::set_t2\n"
    "//       Access: Public\n"
    "//  Description: Changes the ending point on the parabola.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_set_t2_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionParabola::get_t2(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_get_t2_258(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionParabola * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionParabola,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionParabola::get_t2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT2", key_word_list));
        else
            (PyArg_Parse(args, ":getT2"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionParabola*)local_this)->get_t2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT2(const CollisionParabola this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_get_t2_258_comment =
    "C++ Interface:\n"
    "getT2(const CollisionParabola this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionParabola::get_t2\n"
    "//       Access: Public\n"
    "//  Description: Returns the ending point on the parabola.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionParabola_get_t2_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionParabola::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionParabola_get_class_type_259(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionParabola::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionParabola::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionParabola_get_class_type_259_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionParabola_get_class_type_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionParabola::CollisionParabola(void)
 * inline CollisionParabola::CollisionParabola(Parabolaf const &parabola, float t1, float t2)
 *******************************************************************/
int  Dtool_Init_CollisionParabola(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline CollisionParabola::CollisionParabola(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionParabola", key_word_list))
            {
                CollisionParabola *return_value = new CollisionParabola();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionParabola,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionParabola::CollisionParabola(Parabolaf const &parabola, float t1, float t2)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"parabola", (char *)"t1", (char *)"t2", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:CollisionParabola", key_word_list, &param0, &param1, &param2))
                {
                    Parabolaf *param0_this = (Parabolaf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Parabolaf, 0, "CollisionParabola.CollisionParabola", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CollisionParabola *return_value = new CollisionParabola(*param0_this, (float)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionParabola,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionParabola() takes 0 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionParabola()\n"
          "CollisionParabola(const Parabolaf parabola, float t1, float t2)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionParabola(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionParabola)
    {
        printf("CollisionParabola ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionParabola * local_this = (CollisionParabola *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionParabola)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionParabola(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionParabola)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionParabola*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionParabola*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionFloorMesh 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionFloorMesh::add_vertex(LPoint3f const &vert)
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_add_vertex_263(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionFloorMesh::add_vertex(LPoint3f const &vert)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vert", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addVertex", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addVertex", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionFloorMesh.addVertex", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_vertex(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionFloorMesh.addVertex() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addVertex(non-const CollisionFloorMesh this, const Point3 vert)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_add_vertex_263_comment =
    "C++ Interface:\n"
    "addVertex(non-const CollisionFloorMesh this, const Point3 vert)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionFloorMesh::add_vertex\n"
    "//       Access: Published\n"
    "//  Description: store away a vertex to index against\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_add_vertex_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_add_triangle_264(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"pointA", (char *)"pointB", (char *)"pointC", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:addTriangle", key_word_list, &param1, &param2, &param3))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)))
            {
                (local_this)->add_triangle(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionFloorMesh.addTriangle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTriangle(non-const CollisionFloorMesh this, unsigned int pointA, unsigned int pointB, unsigned int pointC)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_add_triangle_264_comment =
    "C++ Interface:\n"
    "addTriangle(non-const CollisionFloorMesh this, unsigned int pointA, unsigned int pointB, unsigned int pointC)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionFloorMesh::add_triangle\n"
    "//       Access: Published\n"
    "//  Description: store a triangle for processing\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_add_triangle_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int const CollisionFloorMesh::get_num_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_get_num_vertices_265(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int const CollisionFloorMesh::get_num_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVertices"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const CollisionFloorMesh*)local_this)->get_num_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVertices(const CollisionFloorMesh this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_get_num_vertices_265_comment =
    "C++ Interface:\n"
    "getNumVertices(const CollisionFloorMesh this)\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_get_num_vertices_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const CollisionFloorMesh::get_vertex(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_get_vertex_266(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const CollisionFloorMesh::get_vertex(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getVertex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getVertex", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LPoint3f const result = ((const CollisionFloorMesh*)local_this)->get_vertex(PyLong_AsUnsignedLong(param1_uint));
                LPoint3f const *return_value = new LPoint3f const(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertex(const CollisionFloorMesh this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_get_vertex_266_comment =
    "C++ Interface:\n"
    "getVertex(const CollisionFloorMesh this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_get_vertex_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int const CollisionFloorMesh::get_num_triangles(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_get_num_triangles_267(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int const CollisionFloorMesh::get_num_triangles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTriangles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTriangles"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const CollisionFloorMesh*)local_this)->get_num_triangles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTriangles(const CollisionFloorMesh this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_get_num_triangles_267_comment =
    "C++ Interface:\n"
    "getNumTriangles(const CollisionFloorMesh this)\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_get_num_triangles_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3d const CollisionFloorMesh::get_triangle(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_get_triangle_268(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionFloorMesh * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionFloorMesh,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3d const CollisionFloorMesh::get_triangle(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getTriangle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getTriangle", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LPoint3d const result = ((const CollisionFloorMesh*)local_this)->get_triangle(PyLong_AsUnsignedLong(param1_uint));
                LPoint3d const *return_value = new LPoint3d const(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3d,true, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriangle(const CollisionFloorMesh this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_get_triangle_268_comment =
    "C++ Interface:\n"
    "getTriangle(const CollisionFloorMesh this, unsigned int index)\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_get_triangle_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionFloorMesh::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionFloorMesh_get_class_type_269(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionFloorMesh::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionFloorMesh::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionFloorMesh_get_class_type_269_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionFloorMesh_get_class_type_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionFloorMesh::CollisionFloorMesh(void)
 *******************************************************************/
int  Dtool_Init_CollisionFloorMesh(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline CollisionFloorMesh::CollisionFloorMesh(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionFloorMesh", key_word_list))
        {
            CollisionFloorMesh *return_value = new CollisionFloorMesh();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionFloorMesh,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CollisionFloorMesh()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionFloorMesh_get_vertices(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVertices", "getVertex");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_CollisionFloorMesh_get_triangles(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumTriangles", "getTriangle");
}
inline void  * Dtool_UpcastInterface_CollisionFloorMesh(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionFloorMesh)
    {
        printf("CollisionFloorMesh ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionFloorMesh * local_this = (CollisionFloorMesh *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionFloorMesh)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionFloorMesh(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionFloorMesh)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionFloorMesh*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionSegment 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSegment::set_point_a(LPoint3f const &a)
 * inline void CollisionSegment::set_point_a(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_set_point_a_273(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionSegment::set_point_a(LPoint3f const &a)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"a", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPointA", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPointA", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionSegment.setPointA", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_point_a(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionSegment.setPointA() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionSegment::set_point_a(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPointA", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_point_a((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionSegment.setPointA() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPointA() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPointA(non-const CollisionSegment this, const Point3 a)\n"
          "setPointA(non-const CollisionSegment this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_set_point_a_273_comment =
    "C++ Interface:\n"
    "setPointA(non-const CollisionSegment this, const Point3 a)\n"
    "setPointA(non-const CollisionSegment this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_point_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_point_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSegment_set_point_a_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionSegment::get_point_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_get_point_a_274(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionSegment::get_point_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointA", key_word_list));
        else
            (PyArg_Parse(args, ":getPointA"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionSegment*)local_this)->get_point_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointA(const CollisionSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_get_point_a_274_comment =
    "C++ Interface:\n"
    "getPointA(const CollisionSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::get_point_a\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSegment_get_point_a_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionSegment::set_point_b(LPoint3f const &b)
 * inline void CollisionSegment::set_point_b(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_set_point_b_275(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionSegment::set_point_b(LPoint3f const &b)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"b", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPointB", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPointB", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionSegment.setPointB", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_point_b(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionSegment.setPointB() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionSegment::set_point_b(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPointB", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_point_b((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionSegment.setPointB() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPointB() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPointB(non-const CollisionSegment this, const Point3 b)\n"
          "setPointB(non-const CollisionSegment this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_set_point_b_275_comment =
    "C++ Interface:\n"
    "setPointB(non-const CollisionSegment this, const Point3 b)\n"
    "setPointB(non-const CollisionSegment this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_point_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_point_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSegment_set_point_b_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionSegment::get_point_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_get_point_b_276(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionSegment::get_point_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointB", key_word_list));
        else
            (PyArg_Parse(args, ":getPointB"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionSegment*)local_this)->get_point_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointB(const CollisionSegment this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_get_point_b_276_comment =
    "C++ Interface:\n"
    "getPointB(const CollisionSegment this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::get_point_b\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSegment_get_point_b_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2f const &point)
 * inline bool CollisionSegment::set_from_lens(LensNode *camera, float px, float py)
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_set_from_lens_277(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionSegment * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSegment,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2f const &point)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"camera", (char *)"point", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setFromLens", key_word_list, &param1, &param2))
                {
                    LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LensNode, 1, "CollisionSegment.setFromLens", 0, coerced_ptr, report_errors);
LPoint2f *param2_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint2f, 2, "CollisionSegment.setFromLens", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_from_lens(param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionSegment.setFromLens() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool CollisionSegment::set_from_lens(LensNode *camera, float px, float py)
                PyObject *param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"camera", (char *)"px", (char *)"py", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:setFromLens", key_word_list, &param1, &param2, &param3))
                {
                    LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LensNode, 1, "CollisionSegment.setFromLens", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->set_from_lens(param1_this, (float)param2, (float)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionSegment.setFromLens() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFromLens() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFromLens(non-const CollisionSegment this, non-const LensNode camera, const Point2 point)\n"
          "setFromLens(non-const CollisionSegment this, non-const LensNode camera, float px, float py)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_set_from_lens_277_comment =
    "C++ Interface:\n"
    "setFromLens(non-const CollisionSegment this, non-const LensNode camera, const Point2 point)\n"
    "setFromLens(non-const CollisionSegment this, non-const LensNode camera, float px, float py)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_from_lens\n"
    "//       Access: Public\n"
    "//  Description: Accepts a LensNode and a 2-d point in the range\n"
    "//               [-1,1].  Sets the CollisionSegment so that it begins at\n"
    "//               the LensNode's near plane and extends to the\n"
    "//               far plane, making it suitable for picking objects\n"
    "//               from the screen given a camera and a mouse location.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionSegment::set_from_lens\n"
    "//       Access: Public\n"
    "//  Description: Accepts a LensNode and a 2-d point in the range\n"
    "//               [-1,1].  Sets the CollisionSegment so that it begins at\n"
    "//               the LensNode's near plane and extends to the\n"
    "//               far plane, making it suitable for picking objects\n"
    "//               from the screen given a camera and a mouse location.\n"
    "//\n"
    "//               Returns true if the point was acceptable, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionSegment_set_from_lens_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionSegment::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionSegment_get_class_type_278(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionSegment::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionSegment::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionSegment_get_class_type_278_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionSegment_get_class_type_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionSegment::CollisionSegment(void)
 * inline CollisionSegment::CollisionSegment(LPoint3f const &a, LPoint3f const &db)
 * inline CollisionSegment::CollisionSegment(float ax, float ay, float az, float bx, float by, float bz)
 *******************************************************************/
int  Dtool_Init_CollisionSegment(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline CollisionSegment::CollisionSegment(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":CollisionSegment", key_word_list))
            {
                CollisionSegment *return_value = new CollisionSegment();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionSegment,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionSegment::CollisionSegment(LPoint3f const &a, LPoint3f const &db)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"a", (char *)"db", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:CollisionSegment", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionSegment.CollisionSegment", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionSegment.CollisionSegment", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionSegment *return_value = new CollisionSegment(*param0_this, *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionSegment,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          // 1-inline CollisionSegment::CollisionSegment(float ax, float ay, float az, float bx, float by, float bz)
            double param0;
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"ax", (char *)"ay", (char *)"az", (char *)"bx", (char *)"by", (char *)"bz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:CollisionSegment", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                CollisionSegment *return_value = new CollisionSegment((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionSegment,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionSegment() takes 0, 2, or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionSegment()\n"
          "CollisionSegment(const Point3 a, const Point3 db)\n"
          "CollisionSegment(float ax, float ay, float az, float bx, float by, float bz)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionSegment(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionSegment)
    {
        printf("CollisionSegment ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionSegment * local_this = (CollisionSegment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionSegment)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionSegment(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionSegment)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionSegment*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionSegment*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CollisionTube 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CollisionTube::set_point_a(LPoint3f const &a)
 * inline void CollisionTube::set_point_a(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionTube_set_point_a_282(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionTube::set_point_a(LPoint3f const &a)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"a", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPointA", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPointA", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionTube.setPointA", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_point_a(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionTube.setPointA() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionTube::set_point_a(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPointA", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_point_a((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionTube.setPointA() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPointA() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPointA(non-const CollisionTube this, const Point3 a)\n"
          "setPointA(non-const CollisionTube this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_set_point_a_282_comment =
    "C++ Interface:\n"
    "setPointA(non-const CollisionTube this, const Point3 a)\n"
    "setPointA(non-const CollisionTube this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::set_point_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::set_point_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_set_point_a_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionTube::get_point_a(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionTube_get_point_a_283(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionTube::get_point_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointA", key_word_list));
        else
            (PyArg_Parse(args, ":getPointA"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionTube*)local_this)->get_point_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointA(const CollisionTube this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_get_point_a_283_comment =
    "C++ Interface:\n"
    "getPointA(const CollisionTube this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::get_point_a\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_get_point_a_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionTube::set_point_b(LPoint3f const &b)
 * inline void CollisionTube::set_point_b(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_CollisionTube_set_point_b_284(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void CollisionTube::set_point_b(LPoint3f const &b)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"b", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPointB", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPointB", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionTube.setPointB", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_point_b(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CollisionTube.setPointB() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CollisionTube::set_point_b(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPointB", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_point_b((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CollisionTube.setPointB() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPointB() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPointB(non-const CollisionTube this, const Point3 b)\n"
          "setPointB(non-const CollisionTube this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_set_point_b_284_comment =
    "C++ Interface:\n"
    "setPointB(non-const CollisionTube this, const Point3 b)\n"
    "setPointB(non-const CollisionTube this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::set_point_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::set_point_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_set_point_b_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &CollisionTube::get_point_b(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionTube_get_point_b_285(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &CollisionTube::get_point_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointB", key_word_list));
        else
            (PyArg_Parse(args, ":getPointB"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const CollisionTube*)local_this)->get_point_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointB(const CollisionTube this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_get_point_b_285_comment =
    "C++ Interface:\n"
    "getPointB(const CollisionTube this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::get_point_b\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_get_point_b_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CollisionTube::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_CollisionTube_set_radius_286(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CollisionTube::set_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CollisionTube.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const CollisionTube this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_set_radius_286_comment =
    "C++ Interface:\n"
    "setRadius(non-const CollisionTube this, float radius)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::set_radius\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_set_radius_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CollisionTube::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_CollisionTube_get_radius_287(PyObject *self, PyObject *args,PyObject *kwds) {
    CollisionTube * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTube,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CollisionTube::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CollisionTube*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const CollisionTube this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_get_radius_287_comment =
    "C++ Interface:\n"
    "getRadius(const CollisionTube this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CollisionTube::get_radius\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CollisionTube_get_radius_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CollisionTube::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CollisionTube_get_class_type_288(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CollisionTube::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CollisionTube::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CollisionTube_get_class_type_288_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CollisionTube_get_class_type_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CollisionTube::CollisionTube(LPoint3f const &a, LPoint3f const &db, float radius)
 * inline CollisionTube::CollisionTube(float ax, float ay, float az, float bx, float by, float bz, float radius)
 *******************************************************************/
int  Dtool_Init_CollisionTube(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline CollisionTube::CollisionTube(LPoint3f const &a, LPoint3f const &db, float radius)
                PyObject *param0;
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"a", (char *)"db", (char *)"radius", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOd:CollisionTube", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "CollisionTube.CollisionTube", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "CollisionTube.CollisionTube", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        CollisionTube *return_value = new CollisionTube(*param0_this, *param1_this, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionTube,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          // 1-inline CollisionTube::CollisionTube(float ax, float ay, float az, float bx, float by, float bz, float radius)
            double param0;
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"ax", (char *)"ay", (char *)"az", (char *)"bx", (char *)"by", (char *)"bz", (char *)"radius", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddddd:CollisionTube", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                CollisionTube *return_value = new CollisionTube((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_CollisionTube,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CollisionTube() takes 3 or 7 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CollisionTube(const Point3 a, const Point3 db, float radius)\n"
          "CollisionTube(float ax, float ay, float az, float bx, float by, float bz, float radius)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CollisionTube(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CollisionTube)
    {
        printf("CollisionTube ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CollisionTube * local_this = (CollisionTube *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CollisionTube)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CollisionSolid)
        return ( CollisionSolid *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *)( CollisionSolid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CollisionTube(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CollisionTube)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_CollisionSolid)
    {
          CollisionSolid* other_this = (CollisionSolid*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CollisionTube*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CollisionTube*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CollisionHandler | CollisionHandler
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandler[]= {
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandler_get_class_type_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandler_get_class_type_3_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandler(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandler.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandler\n"
          "// Description : The abstract interface to a number of classes that\n"
          "//               decide what to do when a collision is detected.  One\n"
          "//               of these must be assigned to the CollisionTraverser\n"
          "//               that is processing collisions in order to specify how\n"
          "//               to dispatch detected collisions.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CollisionHandler.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CollisionHandler.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandler.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandler.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandler.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandler)");
             printf(" Error In PyType_ReadyCollisionHandler");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandler.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandler.As_PyTypeObject().tp_dict,"CollisionHandler",&Dtool_CollisionHandler.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandler.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandler[0],&Dtool_CollisionHandler.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandler,CollisionHandler::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandler.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandler",(PyObject *)&Dtool_CollisionHandler.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionSolid | CollisionSolid
//********************************************************************
PyMethodDef Dtool_Methods_CollisionSolid[]= {
  { "getCollisionOrigin",(PyCFunction ) &Dtool_CollisionSolid_get_collision_origin_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_get_collision_origin_7_comment},
  { "setTangible",(PyCFunction ) &Dtool_CollisionSolid_set_tangible_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_set_tangible_8_comment},
  { "isTangible",(PyCFunction ) &Dtool_CollisionSolid_is_tangible_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_is_tangible_9_comment},
  { "setEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_set_effective_normal_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_set_effective_normal_10_comment},
  { "clearEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_clear_effective_normal_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_clear_effective_normal_11_comment},
  { "hasEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_has_effective_normal_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_has_effective_normal_12_comment},
  { "getEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_get_effective_normal_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_get_effective_normal_13_comment},
  { "setRespectEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_set_respect_effective_normal_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_set_respect_effective_normal_14_comment},
  { "getRespectEffectiveNormal",(PyCFunction ) &Dtool_CollisionSolid_get_respect_effective_normal_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_get_respect_effective_normal_15_comment},
  { "getBounds",(PyCFunction ) &Dtool_CollisionSolid_get_bounds_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_get_bounds_16_comment},
  { "setBounds",(PyCFunction ) &Dtool_CollisionSolid_set_bounds_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_set_bounds_17_comment},
  { "output",(PyCFunction ) &Dtool_CollisionSolid_output_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_output_18_comment},
  { "write",(PyCFunction ) &Dtool_CollisionSolid_write_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_write_19_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionSolid_get_class_type_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSolid_get_class_type_20_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CollisionSolid
//////////////////
static PyObject *  Dtool_Repr_CollisionSolid(PyObject * self)
{
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CollisionSolid
//////////////////
static PyObject *  Dtool_Str_CollisionSolid(PyObject * self)
{
    CollisionSolid * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionSolid,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CollisionSolid(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionSolid.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionSolid\n"
          "// Description : The abstract base class for all things that can\n"
          "//               collide with other things in the world, and all the\n"
          "//               things they can collide with (except geometry).\n"
          "//\n"
          "//               This class and its derivatives really work very\n"
          "//               similarly to the way BoundingVolume and all of its\n"
          "//               derivatives work.  There's a different subclass for\n"
          "//               each basic shape of solid, and double-dispatch\n"
          "//               function calls handle the subset of the N*N\n"
          "//               intersection tests that we care about.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CopyOnWriteObject._Dtool_ClassInit(NULL);
        Dtool_CollisionSolid.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CopyOnWriteObject.As_PyTypeObject());
        Dtool_CollisionSolid.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionSolid.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionSolid.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CollisionSolid.As_PyTypeObject().tp_repr = & Dtool_Repr_CollisionSolid;
        // __str__
        Dtool_CollisionSolid.As_PyTypeObject().tp_str = & Dtool_Str_CollisionSolid;
        if(PyType_Ready(&Dtool_CollisionSolid.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionSolid)");
             printf(" Error In PyType_ReadyCollisionSolid");
             return;
        }
        Py_INCREF(&Dtool_CollisionSolid.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionSolid.As_PyTypeObject().tp_dict,"CollisionSolid",&Dtool_CollisionSolid.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionSolid.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionSolid[13],&Dtool_CollisionSolid.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionSolid,CollisionSolid::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionSolid.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionSolid",(PyObject *)&Dtool_CollisionSolid.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionNode | CollisionNode
//********************************************************************
PyMethodDef Dtool_Methods_CollisionNode[]= {
  { "setCollideMask",(PyCFunction ) &Dtool_CollisionNode_set_collide_mask_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_set_collide_mask_24_comment},
  { "setFromCollideMask",(PyCFunction ) &Dtool_CollisionNode_set_from_collide_mask_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_set_from_collide_mask_25_comment},
  { "setIntoCollideMask",(PyCFunction ) &Dtool_CollisionNode_set_into_collide_mask_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_set_into_collide_mask_26_comment},
  { "getFromCollideMask",(PyCFunction ) &Dtool_CollisionNode_get_from_collide_mask_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_from_collide_mask_27_comment},
  { "getIntoCollideMask",(PyCFunction ) &Dtool_CollisionNode_get_into_collide_mask_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_into_collide_mask_28_comment},
  { "clearSolids",(PyCFunction ) &Dtool_CollisionNode_clear_solids_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_clear_solids_29_comment},
  { "getNumSolids",(PyCFunction ) &Dtool_CollisionNode_get_num_solids_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_num_solids_30_comment},
  { "getSolid",(PyCFunction ) &Dtool_CollisionNode_get_solid_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_solid_31_comment},
  { "modifySolid",(PyCFunction ) &Dtool_CollisionNode_modify_solid_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_modify_solid_32_comment},
  { "setSolid",(PyCFunction ) &Dtool_CollisionNode_set_solid_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_set_solid_33_comment},
  { "removeSolid",(PyCFunction ) &Dtool_CollisionNode_remove_solid_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_remove_solid_34_comment},
  { "addSolid",(PyCFunction ) &Dtool_CollisionNode_add_solid_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_add_solid_35_comment},
  { "getColliderSort",(PyCFunction ) &Dtool_CollisionNode_get_collider_sort_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_collider_sort_36_comment},
  { "setColliderSort",(PyCFunction ) &Dtool_CollisionNode_set_collider_sort_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_set_collider_sort_37_comment},
  { "getDefaultCollideMask",(PyCFunction ) &Dtool_CollisionNode_get_default_collide_mask_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_default_collide_mask_38_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionNode_get_class_type_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionNode_get_class_type_39_comment},
  { "getSolids",(PyCFunction) &MakeSeq_CollisionNode_get_solids, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionNode\n"
          "// Description : A node in the scene graph that can hold any number of\n"
          "//               CollisionSolids.  This may either represent a bit of\n"
          "//               static geometry in the scene that things will collide\n"
          "//               with, or an animated object twirling around in the\n"
          "//               world and running into things.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_CollisionNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_CollisionNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionNode)");
             printf(" Error In PyType_ReadyCollisionNode");
             return;
        }
        Py_INCREF(&Dtool_CollisionNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionNode.As_PyTypeObject().tp_dict,"CollisionNode",&Dtool_CollisionNode.As_PyObject());
        //  Static Method getDefaultCollideMask
        PyDict_SetItemString(Dtool_CollisionNode.As_PyTypeObject().tp_dict,"getDefaultCollideMask",PyCFunction_New(&Dtool_Methods_CollisionNode[14],&Dtool_CollisionNode.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionNode[15],&Dtool_CollisionNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionNode,CollisionNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionNode.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionNode",(PyObject *)&Dtool_CollisionNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionTraverser | CollisionTraverser
//********************************************************************
PyMethodDef Dtool_Methods_CollisionTraverser[]= {
  { "setRespectPrevTransform",(PyCFunction ) &Dtool_CollisionTraverser_set_respect_prev_transform_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_set_respect_prev_transform_44_comment},
  { "getRespectPrevTransform",(PyCFunction ) &Dtool_CollisionTraverser_get_respect_prev_transform_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_get_respect_prev_transform_45_comment},
  { "addCollider",(PyCFunction ) &Dtool_CollisionTraverser_add_collider_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_add_collider_46_comment},
  { "removeCollider",(PyCFunction ) &Dtool_CollisionTraverser_remove_collider_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_remove_collider_47_comment},
  { "hasCollider",(PyCFunction ) &Dtool_CollisionTraverser_has_collider_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_has_collider_48_comment},
  { "getNumColliders",(PyCFunction ) &Dtool_CollisionTraverser_get_num_colliders_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_get_num_colliders_49_comment},
  { "getCollider",(PyCFunction ) &Dtool_CollisionTraverser_get_collider_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_get_collider_50_comment},
  { "getHandler",(PyCFunction ) &Dtool_CollisionTraverser_get_handler_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_get_handler_51_comment},
  { "clearColliders",(PyCFunction ) &Dtool_CollisionTraverser_clear_colliders_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_clear_colliders_52_comment},
  { "traverse",(PyCFunction ) &Dtool_CollisionTraverser_traverse_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_traverse_53_comment},
  { "output",(PyCFunction ) &Dtool_CollisionTraverser_output_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_output_54_comment},
  { "write",(PyCFunction ) &Dtool_CollisionTraverser_write_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_write_55_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionTraverser_get_class_type_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTraverser_get_class_type_56_comment},
  { "getColliders",(PyCFunction) &MakeSeq_CollisionTraverser_get_colliders, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CollisionTraverser
//////////////////
static PyObject *  Dtool_Repr_CollisionTraverser(PyObject * self)
{
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CollisionTraverser
//////////////////
static PyObject *  Dtool_Str_CollisionTraverser(PyObject * self)
{
    CollisionTraverser * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionTraverser,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CollisionTraverser(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionTraverser.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionTraverser\n"
          "// Description : This class manages the traversal through the scene\n"
          "//               graph to detect collisions.  It holds ownership of a\n"
          "//               number of collider objects, each of which is a\n"
          "//               CollisionNode and an associated CollisionHandler.\n"
          "//\n"
          "//               When traverse() is called, it begins at the indicated\n"
          "//               root and detects all collisions with any of its\n"
          "//               collider objects against nodes at or below the\n"
          "//               indicated root, calling the appropriate\n"
          "//               CollisionHandler for each detected collision.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_CollisionTraverser.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Namable.As_PyTypeObject());
        Dtool_CollisionTraverser.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionTraverser.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionTraverser.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CollisionTraverser.As_PyTypeObject().tp_repr = & Dtool_Repr_CollisionTraverser;
        // __str__
        Dtool_CollisionTraverser.As_PyTypeObject().tp_str = & Dtool_Str_CollisionTraverser;
        if(PyType_Ready(&Dtool_CollisionTraverser.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionTraverser)");
             printf(" Error In PyType_ReadyCollisionTraverser");
             return;
        }
        Py_INCREF(&Dtool_CollisionTraverser.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionTraverser.As_PyTypeObject().tp_dict,"CollisionTraverser",&Dtool_CollisionTraverser.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionTraverser.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionTraverser[12],&Dtool_CollisionTraverser.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionTraverser,CollisionTraverser::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionTraverser.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionTraverser",(PyObject *)&Dtool_CollisionTraverser.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionEntry | CollisionEntry
//********************************************************************
PyMethodDef Dtool_Methods_CollisionEntry[]= {
  { "getFrom",(PyCFunction ) &Dtool_CollisionEntry_get_from_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_from_59_comment},
  { "hasInto",(PyCFunction ) &Dtool_CollisionEntry_has_into_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_into_60_comment},
  { "getInto",(PyCFunction ) &Dtool_CollisionEntry_get_into_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_into_61_comment},
  { "getFromNode",(PyCFunction ) &Dtool_CollisionEntry_get_from_node_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_from_node_62_comment},
  { "getIntoNode",(PyCFunction ) &Dtool_CollisionEntry_get_into_node_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_into_node_63_comment},
  { "getFromNodePath",(PyCFunction ) &Dtool_CollisionEntry_get_from_node_path_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_from_node_path_64_comment},
  { "getIntoNodePath",(PyCFunction ) &Dtool_CollisionEntry_get_into_node_path_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_into_node_path_65_comment},
  { "setT",(PyCFunction ) &Dtool_CollisionEntry_set_t_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_t_66_comment},
  { "getT",(PyCFunction ) &Dtool_CollisionEntry_get_t_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_t_67_comment},
  { "collided",(PyCFunction ) &Dtool_CollisionEntry_collided_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_collided_68_comment},
  { "resetCollided",(PyCFunction ) &Dtool_CollisionEntry_reset_collided_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_reset_collided_69_comment},
  { "getRespectPrevTransform",(PyCFunction ) &Dtool_CollisionEntry_get_respect_prev_transform_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_respect_prev_transform_70_comment},
  { "setSurfacePoint",(PyCFunction ) &Dtool_CollisionEntry_set_surface_point_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_surface_point_71_comment},
  { "setSurfaceNormal",(PyCFunction ) &Dtool_CollisionEntry_set_surface_normal_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_surface_normal_72_comment},
  { "setInteriorPoint",(PyCFunction ) &Dtool_CollisionEntry_set_interior_point_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_interior_point_73_comment},
  { "hasSurfacePoint",(PyCFunction ) &Dtool_CollisionEntry_has_surface_point_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_surface_point_74_comment},
  { "hasSurfaceNormal",(PyCFunction ) &Dtool_CollisionEntry_has_surface_normal_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_surface_normal_75_comment},
  { "hasInteriorPoint",(PyCFunction ) &Dtool_CollisionEntry_has_interior_point_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_interior_point_76_comment},
  { "setContactPos",(PyCFunction ) &Dtool_CollisionEntry_set_contact_pos_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_contact_pos_77_comment},
  { "setContactNormal",(PyCFunction ) &Dtool_CollisionEntry_set_contact_normal_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_set_contact_normal_78_comment},
  { "hasContactPos",(PyCFunction ) &Dtool_CollisionEntry_has_contact_pos_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_contact_pos_79_comment},
  { "hasContactNormal",(PyCFunction ) &Dtool_CollisionEntry_has_contact_normal_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_has_contact_normal_80_comment},
  { "getSurfacePoint",(PyCFunction ) &Dtool_CollisionEntry_get_surface_point_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_surface_point_81_comment},
  { "getSurfaceNormal",(PyCFunction ) &Dtool_CollisionEntry_get_surface_normal_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_surface_normal_82_comment},
  { "getInteriorPoint",(PyCFunction ) &Dtool_CollisionEntry_get_interior_point_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_interior_point_83_comment},
  { "getAll",(PyCFunction ) &Dtool_CollisionEntry_get_all_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_all_84_comment},
  { "getContactPos",(PyCFunction ) &Dtool_CollisionEntry_get_contact_pos_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_contact_pos_85_comment},
  { "getContactNormal",(PyCFunction ) &Dtool_CollisionEntry_get_contact_normal_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_contact_normal_86_comment},
  { "getAllContactInfo",(PyCFunction ) &Dtool_CollisionEntry_get_all_contact_info_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_all_contact_info_87_comment},
  { "output",(PyCFunction ) &Dtool_CollisionEntry_output_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_output_88_comment},
  { "write",(PyCFunction ) &Dtool_CollisionEntry_write_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_write_89_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionEntry_get_class_type_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionEntry_get_class_type_90_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CollisionEntry
//////////////////
static PyObject *  Dtool_Repr_CollisionEntry(PyObject * self)
{
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CollisionEntry
//////////////////
static PyObject *  Dtool_Str_CollisionEntry(PyObject * self)
{
    CollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionEntry,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CollisionEntry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionEntry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionEntry\n"
          "// Description : Defines a single collision event.  One of these is\n"
          "//               created for each collision detected by a\n"
          "//               CollisionTraverser, to be dealt with by the\n"
          "//               CollisionHandler.\n"
          "//\n"
          "//               A CollisionEntry provides slots for a number of data\n"
          "//               values (such as intersection point and normal) that\n"
          "//               might or might not be known for each collision.  It\n"
          "//               is up to the handler to determine what information is\n"
          "//               known and to do the right thing with it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CollisionEntry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_CollisionEntry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionEntry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionEntry.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CollisionEntry.As_PyTypeObject().tp_repr = & Dtool_Repr_CollisionEntry;
        // __str__
        Dtool_CollisionEntry.As_PyTypeObject().tp_str = & Dtool_Str_CollisionEntry;
        if(PyType_Ready(&Dtool_CollisionEntry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionEntry)");
             printf(" Error In PyType_ReadyCollisionEntry");
             return;
        }
        Py_INCREF(&Dtool_CollisionEntry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionEntry.As_PyTypeObject().tp_dict,"CollisionEntry",&Dtool_CollisionEntry.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionEntry.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionEntry[31],&Dtool_CollisionEntry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionEntry,CollisionEntry::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionEntry.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionEntry",(PyObject *)&Dtool_CollisionEntry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerEvent | CollisionHandlerEvent
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerEvent[]= {
  { "clearInPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_clear_in_patterns_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_clear_in_patterns_94_comment},
  { "addInPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_add_in_pattern_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_add_in_pattern_95_comment},
  { "setInPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_set_in_pattern_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_set_in_pattern_96_comment},
  { "getNumInPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_num_in_patterns_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_num_in_patterns_97_comment},
  { "getInPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_in_pattern_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_in_pattern_98_comment},
  { "clearAgainPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_clear_again_patterns_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_clear_again_patterns_99_comment},
  { "addAgainPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_add_again_pattern_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_add_again_pattern_100_comment},
  { "setAgainPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_set_again_pattern_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_set_again_pattern_101_comment},
  { "getNumAgainPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_num_again_patterns_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_num_again_patterns_102_comment},
  { "getAgainPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_again_pattern_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_again_pattern_103_comment},
  { "clearOutPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_clear_out_patterns_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_clear_out_patterns_104_comment},
  { "addOutPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_add_out_pattern_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_add_out_pattern_105_comment},
  { "setOutPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_set_out_pattern_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_set_out_pattern_106_comment},
  { "getNumOutPatterns",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_num_out_patterns_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_num_out_patterns_107_comment},
  { "getOutPattern",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_out_pattern_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_out_pattern_108_comment},
  { "clear",(PyCFunction ) &Dtool_CollisionHandlerEvent_clear_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_clear_109_comment},
  { "flush",(PyCFunction ) &Dtool_CollisionHandlerEvent_flush_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_flush_110_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerEvent_get_class_type_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerEvent_get_class_type_111_comment},
  { "getInPatterns",(PyCFunction) &MakeSeq_CollisionHandlerEvent_get_in_patterns, METH_NOARGS, NULL},
  { "getAgainPatterns",(PyCFunction) &MakeSeq_CollisionHandlerEvent_get_again_patterns, METH_NOARGS, NULL},
  { "getOutPatterns",(PyCFunction) &MakeSeq_CollisionHandlerEvent_get_out_patterns, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerEvent(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerEvent\n"
          "// Description : A specialized kind of CollisionHandler that throws an\n"
          "//               event for each collision detected.  The event thrown\n"
          "//               may be based on the name of the moving object or the\n"
          "//               struck object, or both.  The first parameter of the\n"
          "//               event will be a pointer to the CollisionEntry that\n"
          "//               triggered it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandler._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandler.As_PyTypeObject());
        Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerEvent.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerEvent)");
             printf(" Error In PyType_ReadyCollisionHandlerEvent");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerEvent.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_dict,"CollisionHandlerEvent",&Dtool_CollisionHandlerEvent.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerEvent.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerEvent[17],&Dtool_CollisionHandlerEvent.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerEvent,CollisionHandlerEvent::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerEvent.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerEvent",(PyObject *)&Dtool_CollisionHandlerEvent.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerHighestEvent | CollisionHandlerHighestEvent
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerHighestEvent[]= {
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerHighestEvent_get_class_type_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerHighestEvent_get_class_type_115_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerEvent\n"
          "// Description : A specialized kind of CollisionHandler that throws an\n"
          "//               event for each collision detected.  The event thrown\n"
          "//               may be based on the name of the moving object or the\n"
          "//               struck object, or both.  The first parameter of the\n"
          "//               event will be a pointer to the CollisionEntry that\n"
          "//               triggered it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerEvent._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerEvent.As_PyTypeObject());
        Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerHighestEvent.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerHighestEvent)");
             printf(" Error In PyType_ReadyCollisionHandlerHighestEvent");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerHighestEvent.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_dict,"CollisionHandlerHighestEvent",&Dtool_CollisionHandlerHighestEvent.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerHighestEvent.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerHighestEvent[0],&Dtool_CollisionHandlerHighestEvent.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerHighestEvent,CollisionHandlerHighestEvent::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerHighestEvent.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerHighestEvent",(PyObject *)&Dtool_CollisionHandlerHighestEvent.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerPhysical | CollisionHandlerPhysical
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerPhysical[]= {
  { "addCollider",(PyCFunction ) &Dtool_CollisionHandlerPhysical_add_collider_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_add_collider_118_comment},
  { "removeCollider",(PyCFunction ) &Dtool_CollisionHandlerPhysical_remove_collider_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_remove_collider_119_comment},
  { "hasCollider",(PyCFunction ) &Dtool_CollisionHandlerPhysical_has_collider_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_has_collider_120_comment},
  { "clearColliders",(PyCFunction ) &Dtool_CollisionHandlerPhysical_clear_colliders_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_clear_colliders_121_comment},
  { "setCenter",(PyCFunction ) &Dtool_CollisionHandlerPhysical_set_center_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_set_center_122_comment},
  { "clearCenter",(PyCFunction ) &Dtool_CollisionHandlerPhysical_clear_center_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_clear_center_123_comment},
  { "getCenter",(PyCFunction ) &Dtool_CollisionHandlerPhysical_get_center_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_get_center_124_comment},
  { "hasCenter",(PyCFunction ) &Dtool_CollisionHandlerPhysical_has_center_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_has_center_125_comment},
  { "hasContact",(PyCFunction ) &Dtool_CollisionHandlerPhysical_has_contact_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_has_contact_126_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerPhysical_get_class_type_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPhysical_get_class_type_127_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerPhysical(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerPhysical\n"
          "// Description : The abstract base class for a number of\n"
          "//               CollisionHandlers that have some physical effect on\n"
          "//               their moving bodies: they need to update the nodes'\n"
          "//               positions based on the effects of the collision.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerEvent._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerEvent.As_PyTypeObject());
        Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerPhysical.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerPhysical)");
             printf(" Error In PyType_ReadyCollisionHandlerPhysical");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_dict,"CollisionHandlerPhysical",&Dtool_CollisionHandlerPhysical.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerPhysical.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerPhysical[9],&Dtool_CollisionHandlerPhysical.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerPhysical,CollisionHandlerPhysical::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerPhysical",(PyObject *)&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerFloor | CollisionHandlerFloor
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerFloor[]= {
  { "setOffset",(PyCFunction ) &Dtool_CollisionHandlerFloor_set_offset_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_set_offset_130_comment},
  { "getOffset",(PyCFunction ) &Dtool_CollisionHandlerFloor_get_offset_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_get_offset_131_comment},
  { "setReach",(PyCFunction ) &Dtool_CollisionHandlerFloor_set_reach_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_set_reach_132_comment},
  { "getReach",(PyCFunction ) &Dtool_CollisionHandlerFloor_get_reach_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_get_reach_133_comment},
  { "setMaxVelocity",(PyCFunction ) &Dtool_CollisionHandlerFloor_set_max_velocity_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_set_max_velocity_134_comment},
  { "getMaxVelocity",(PyCFunction ) &Dtool_CollisionHandlerFloor_get_max_velocity_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_get_max_velocity_135_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerFloor_get_class_type_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFloor_get_class_type_136_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerFloor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerFloor\n"
          "// Description : A specialized kind of CollisionHandler that sets the\n"
          "//               Z height of the collider to a fixed linear offset\n"
          "//               from the highest detected collision point each frame.\n"
          "//               It's intended to implement walking around on a floor\n"
          "//               of varying height by casting a ray down from the\n"
          "//               avatar's head.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerPhysical._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
        Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerFloor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerFloor)");
             printf(" Error In PyType_ReadyCollisionHandlerFloor");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerFloor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_dict,"CollisionHandlerFloor",&Dtool_CollisionHandlerFloor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerFloor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerFloor[6],&Dtool_CollisionHandlerFloor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerFloor,CollisionHandlerFloor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerFloor.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerFloor",(PyObject *)&Dtool_CollisionHandlerFloor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerGravity | CollisionHandlerGravity
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerGravity[]= {
  { "setOffset",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_offset_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_offset_139_comment},
  { "getOffset",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_offset_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_offset_140_comment},
  { "setReach",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_reach_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_reach_141_comment},
  { "getReach",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_reach_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_reach_142_comment},
  { "getAirborneHeight",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_airborne_height_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_airborne_height_143_comment},
  { "isOnGround",(PyCFunction ) &Dtool_CollisionHandlerGravity_is_on_ground_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_is_on_ground_144_comment},
  { "getImpactVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_impact_velocity_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_impact_velocity_145_comment},
  { "getContactNormal",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_contact_normal_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_contact_normal_146_comment},
  { "addVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_add_velocity_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_add_velocity_147_comment},
  { "setVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_velocity_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_velocity_148_comment},
  { "getVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_velocity_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_velocity_149_comment},
  { "setGravity",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_gravity_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_gravity_150_comment},
  { "getGravity",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_gravity_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_gravity_151_comment},
  { "setMaxVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_max_velocity_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_max_velocity_152_comment},
  { "getMaxVelocity",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_max_velocity_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_max_velocity_153_comment},
  { "setLegacyMode",(PyCFunction ) &Dtool_CollisionHandlerGravity_set_legacy_mode_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_set_legacy_mode_154_comment},
  { "getLegacyMode",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_legacy_mode_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_legacy_mode_155_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerGravity_get_class_type_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerGravity_get_class_type_156_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerGravity(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerGravity\n"
          "// Description : A specialized kind of CollisionHandler that sets the\n"
          "//               Z height of the collider to a fixed linear offset\n"
          "//               from the highest detected collision point each frame.\n"
          "//               It's intended to implement walking around on a floor\n"
          "//               of varying height by casting a ray down from the\n"
          "//               avatar's head.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerPhysical._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
        Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerGravity.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerGravity)");
             printf(" Error In PyType_ReadyCollisionHandlerGravity");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerGravity.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_dict,"CollisionHandlerGravity",&Dtool_CollisionHandlerGravity.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerGravity.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerGravity[17],&Dtool_CollisionHandlerGravity.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerGravity,CollisionHandlerGravity::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerGravity.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerGravity",(PyObject *)&Dtool_CollisionHandlerGravity.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerPusher | CollisionHandlerPusher
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerPusher[]= {
  { "setHorizontal",(PyCFunction ) &Dtool_CollisionHandlerPusher_set_horizontal_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPusher_set_horizontal_159_comment},
  { "getHorizontal",(PyCFunction ) &Dtool_CollisionHandlerPusher_get_horizontal_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPusher_get_horizontal_160_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerPusher_get_class_type_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerPusher_get_class_type_161_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerPusher(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerPusher\n"
          "// Description : A specialized kind of CollisionHandler that simply\n"
          "//               pushes back on things that attempt to move into solid\n"
          "//               walls.  This is the simplest kind of \"real-world\"\n"
          "//               collisions you can have.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerPhysical._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerPhysical.As_PyTypeObject());
        Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerPusher.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerPusher)");
             printf(" Error In PyType_ReadyCollisionHandlerPusher");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerPusher.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_dict,"CollisionHandlerPusher",&Dtool_CollisionHandlerPusher.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerPusher.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerPusher[2],&Dtool_CollisionHandlerPusher.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerPusher,CollisionHandlerPusher::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerPusher.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerPusher",(PyObject *)&Dtool_CollisionHandlerPusher.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerFluidPusher | CollisionHandlerFluidPusher
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerFluidPusher[]= {
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerFluidPusher_get_class_type_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerFluidPusher_get_class_type_164_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerFluidPusher\n"
          "// Description : A CollisionHandlerPusher that makes use of timing\n"
          "//               and spatial information from fluid collisions to improve\n"
          "//               collision response\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerPusher._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerPusher.As_PyTypeObject());
        Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionHandlerFluidPusher.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerFluidPusher)");
             printf(" Error In PyType_ReadyCollisionHandlerFluidPusher");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerFluidPusher.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_dict,"CollisionHandlerFluidPusher",&Dtool_CollisionHandlerFluidPusher.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerFluidPusher.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerFluidPusher[0],&Dtool_CollisionHandlerFluidPusher.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerFluidPusher,CollisionHandlerFluidPusher::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerFluidPusher.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerFluidPusher",(PyObject *)&Dtool_CollisionHandlerFluidPusher.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionHandlerQueue | CollisionHandlerQueue
//********************************************************************
PyMethodDef Dtool_Methods_CollisionHandlerQueue[]= {
  { "sortEntries",(PyCFunction ) &Dtool_CollisionHandlerQueue_sort_entries_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_sort_entries_168_comment},
  { "clearEntries",(PyCFunction ) &Dtool_CollisionHandlerQueue_clear_entries_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_clear_entries_169_comment},
  { "getNumEntries",(PyCFunction ) &Dtool_CollisionHandlerQueue_get_num_entries_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_get_num_entries_170_comment},
  { "getEntry",(PyCFunction ) &Dtool_CollisionHandlerQueue_get_entry_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_get_entry_171_comment},
  { "output",(PyCFunction ) &Dtool_CollisionHandlerQueue_output_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_output_172_comment},
  { "write",(PyCFunction ) &Dtool_CollisionHandlerQueue_write_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_write_173_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionHandlerQueue_get_class_type_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionHandlerQueue_get_class_type_174_comment},
  { "getEntries",(PyCFunction) &MakeSeq_CollisionHandlerQueue_get_entries, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CollisionHandlerQueue
//////////////////
static PyObject *  Dtool_Repr_CollisionHandlerQueue(PyObject * self)
{
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CollisionHandlerQueue
//////////////////
static PyObject *  Dtool_Str_CollisionHandlerQueue(PyObject * self)
{
    CollisionHandlerQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CollisionHandlerQueue,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CollisionHandlerQueue(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionHandlerQueue\n"
          "// Description : A special kind of CollisionHandler that does nothing\n"
          "//               except remember the CollisionEntries detected the\n"
          "//               last pass.  This set of CollisionEntries may then be\n"
          "//               queried by the calling function.  It's primarily\n"
          "//               useful when a simple intersection test is being made,\n"
          "//               e.g. for picking from the window.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandler._Dtool_ClassInit(NULL);
        Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandler.As_PyTypeObject());
        Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_repr = & Dtool_Repr_CollisionHandlerQueue;
        // __str__
        Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_str = & Dtool_Str_CollisionHandlerQueue;
        if(PyType_Ready(&Dtool_CollisionHandlerQueue.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionHandlerQueue)");
             printf(" Error In PyType_ReadyCollisionHandlerQueue");
             return;
        }
        Py_INCREF(&Dtool_CollisionHandlerQueue.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_dict,"CollisionHandlerQueue",&Dtool_CollisionHandlerQueue.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionHandlerQueue.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionHandlerQueue[6],&Dtool_CollisionHandlerQueue.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionHandlerQueue,CollisionHandlerQueue::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionHandlerQueue.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionHandlerQueue",(PyObject *)&Dtool_CollisionHandlerQueue.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionDSSolid | CollisionDSSolid
//********************************************************************
PyMethodDef Dtool_Methods_CollisionDSSolid[]= {
  { "setCenterA",(PyCFunction ) &Dtool_CollisionDSSolid_set_center_a_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_center_a_178_comment},
  { "getCenterA",(PyCFunction ) &Dtool_CollisionDSSolid_get_center_a_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_center_a_179_comment},
  { "setRadiusA",(PyCFunction ) &Dtool_CollisionDSSolid_set_radius_a_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_radius_a_180_comment},
  { "getRadiusA",(PyCFunction ) &Dtool_CollisionDSSolid_get_radius_a_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_radius_a_181_comment},
  { "setCenterB",(PyCFunction ) &Dtool_CollisionDSSolid_set_center_b_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_center_b_182_comment},
  { "getCenterB",(PyCFunction ) &Dtool_CollisionDSSolid_get_center_b_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_center_b_183_comment},
  { "setRadiusB",(PyCFunction ) &Dtool_CollisionDSSolid_set_radius_b_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_radius_b_184_comment},
  { "getRadiusB",(PyCFunction ) &Dtool_CollisionDSSolid_get_radius_b_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_radius_b_185_comment},
  { "getNormalA",(PyCFunction ) &Dtool_CollisionDSSolid_get_normal_a_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_normal_a_186_comment},
  { "distToPlaneA",(PyCFunction ) &Dtool_CollisionDSSolid_dist_to_plane_a_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_dist_to_plane_a_187_comment},
  { "setPlaneA",(PyCFunction ) &Dtool_CollisionDSSolid_set_plane_a_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_plane_a_188_comment},
  { "getPlaneA",(PyCFunction ) &Dtool_CollisionDSSolid_get_plane_a_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_plane_a_189_comment},
  { "getNormalB",(PyCFunction ) &Dtool_CollisionDSSolid_get_normal_b_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_normal_b_190_comment},
  { "distToPlaneB",(PyCFunction ) &Dtool_CollisionDSSolid_dist_to_plane_b_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_dist_to_plane_b_191_comment},
  { "setPlaneB",(PyCFunction ) &Dtool_CollisionDSSolid_set_plane_b_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_set_plane_b_192_comment},
  { "getPlaneB",(PyCFunction ) &Dtool_CollisionDSSolid_get_plane_b_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_plane_b_193_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionDSSolid_get_class_type_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionDSSolid_get_class_type_194_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionDSSolid(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionDSSolid.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionDSSolid\n"
          "// Description : A collision volume or object made up of the intersection\n"
          "//               of two spheres (potentially a lens) and two half-spaces\n"
          "//               (planes).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionDSSolid.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionDSSolid.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionDSSolid.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionDSSolid.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionDSSolid.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionDSSolid)");
             printf(" Error In PyType_ReadyCollisionDSSolid");
             return;
        }
        Py_INCREF(&Dtool_CollisionDSSolid.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionDSSolid.As_PyTypeObject().tp_dict,"CollisionDSSolid",&Dtool_CollisionDSSolid.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionDSSolid.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionDSSolid[16],&Dtool_CollisionDSSolid.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionDSSolid,CollisionDSSolid::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionDSSolid.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionDSSolid",(PyObject *)&Dtool_CollisionDSSolid.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionBox | CollisionBox
//********************************************************************
PyMethodDef Dtool_Methods_CollisionBox[]= {
  { "getNumPoints",(PyCFunction ) &Dtool_CollisionBox_get_num_points_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_num_points_198_comment},
  { "getPointAabb",(PyCFunction ) &Dtool_CollisionBox_get_point_aabb_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_point_aabb_199_comment},
  { "getPoint",(PyCFunction ) &Dtool_CollisionBox_get_point_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_point_200_comment},
  { "getNumPlanes",(PyCFunction ) &Dtool_CollisionBox_get_num_planes_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_num_planes_201_comment},
  { "setPlane",(PyCFunction ) &Dtool_CollisionBox_set_plane_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_set_plane_202_comment},
  { "getPlane",(PyCFunction ) &Dtool_CollisionBox_get_plane_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_plane_203_comment},
  { "setCenter",(PyCFunction ) &Dtool_CollisionBox_set_center_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_set_center_204_comment},
  { "getCenter",(PyCFunction ) &Dtool_CollisionBox_get_center_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_center_205_comment},
  { "getRadius",(PyCFunction ) &Dtool_CollisionBox_get_radius_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_radius_206_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionBox_get_class_type_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionBox_get_class_type_207_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionBox(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionBox.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionBox\n"
          "// Description : A cuboid collision volume or object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionBox.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionBox.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionBox.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionBox.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionBox.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionBox)");
             printf(" Error In PyType_ReadyCollisionBox");
             return;
        }
        Py_INCREF(&Dtool_CollisionBox.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionBox.As_PyTypeObject().tp_dict,"CollisionBox",&Dtool_CollisionBox.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionBox.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionBox[9],&Dtool_CollisionBox.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionBox,CollisionBox::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionBox.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionBox",(PyObject *)&Dtool_CollisionBox.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionSphere | CollisionSphere
//********************************************************************
PyMethodDef Dtool_Methods_CollisionSphere[]= {
  { "setCenter",(PyCFunction ) &Dtool_CollisionSphere_set_center_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSphere_set_center_211_comment},
  { "getCenter",(PyCFunction ) &Dtool_CollisionSphere_get_center_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSphere_get_center_212_comment},
  { "setRadius",(PyCFunction ) &Dtool_CollisionSphere_set_radius_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSphere_set_radius_213_comment},
  { "getRadius",(PyCFunction ) &Dtool_CollisionSphere_get_radius_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSphere_get_radius_214_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionSphere_get_class_type_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSphere_get_class_type_215_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionSphere(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionSphere.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionSphere\n"
          "// Description : A spherical collision volume or object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionSphere.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionSphere.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionSphere.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionSphere.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionSphere.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionSphere)");
             printf(" Error In PyType_ReadyCollisionSphere");
             return;
        }
        Py_INCREF(&Dtool_CollisionSphere.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionSphere.As_PyTypeObject().tp_dict,"CollisionSphere",&Dtool_CollisionSphere.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionSphere.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionSphere[4],&Dtool_CollisionSphere.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionSphere,CollisionSphere::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionSphere.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionSphere",(PyObject *)&Dtool_CollisionSphere.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionInvSphere | CollisionInvSphere
//********************************************************************
PyMethodDef Dtool_Methods_CollisionInvSphere[]= {
  { "getClassType",(PyCFunction ) &Dtool_CollisionInvSphere_get_class_type_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionInvSphere_get_class_type_219_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionInvSphere(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionInvSphere.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionInvSphere\n"
          "// Description : An inverted sphere: this is a sphere whose collision\n"
          "//               surface is the inside surface of the sphere.\n"
          "//               Everything outside the sphere is solid matter;\n"
          "//               everything inside is empty space.  Useful for\n"
          "//               constraining objects to remain within a spherical\n"
          "//               perimeter.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSphere._Dtool_ClassInit(NULL);
        Dtool_CollisionInvSphere.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSphere.As_PyTypeObject());
        Dtool_CollisionInvSphere.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionInvSphere.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionInvSphere.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionInvSphere.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionInvSphere)");
             printf(" Error In PyType_ReadyCollisionInvSphere");
             return;
        }
        Py_INCREF(&Dtool_CollisionInvSphere.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionInvSphere.As_PyTypeObject().tp_dict,"CollisionInvSphere",&Dtool_CollisionInvSphere.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionInvSphere.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionInvSphere[0],&Dtool_CollisionInvSphere.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionInvSphere,CollisionInvSphere::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionInvSphere.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionInvSphere",(PyObject *)&Dtool_CollisionInvSphere.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionRay | CollisionRay
//********************************************************************
PyMethodDef Dtool_Methods_CollisionRay[]= {
  { "setOrigin",(PyCFunction ) &Dtool_CollisionRay_set_origin_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_set_origin_223_comment},
  { "getOrigin",(PyCFunction ) &Dtool_CollisionRay_get_origin_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_get_origin_224_comment},
  { "setDirection",(PyCFunction ) &Dtool_CollisionRay_set_direction_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_set_direction_225_comment},
  { "getDirection",(PyCFunction ) &Dtool_CollisionRay_get_direction_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_get_direction_226_comment},
  { "setFromLens",(PyCFunction ) &Dtool_CollisionRay_set_from_lens_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_set_from_lens_227_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionRay_get_class_type_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionRay_get_class_type_228_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionRay(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionRay.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionRay\n"
          "// Description : An infinite ray, with a specific origin and\n"
          "//               direction.  It begins at its origin and continues in\n"
          "//               one direction to infinity, and it has no radius.\n"
          "//               Useful for picking from a window, or for gravity\n"
          "//               effects.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionRay.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionRay.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionRay.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionRay.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionRay.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionRay)");
             printf(" Error In PyType_ReadyCollisionRay");
             return;
        }
        Py_INCREF(&Dtool_CollisionRay.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionRay.As_PyTypeObject().tp_dict,"CollisionRay",&Dtool_CollisionRay.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionRay.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionRay[5],&Dtool_CollisionRay.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionRay,CollisionRay::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionRay.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionRay",(PyObject *)&Dtool_CollisionRay.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionLine | CollisionLine
//********************************************************************
PyMethodDef Dtool_Methods_CollisionLine[]= {
  { "getClassType",(PyCFunction ) &Dtool_CollisionLine_get_class_type_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionLine_get_class_type_232_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionLine(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionLine.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionLine\n"
          "// Description : An infinite line, similar to a CollisionRay, except\n"
          "//               that it extends in both directions.  It is, however,\n"
          "//               directional.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionRay._Dtool_ClassInit(NULL);
        Dtool_CollisionLine.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionRay.As_PyTypeObject());
        Dtool_CollisionLine.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionLine.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionLine.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionLine.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionLine)");
             printf(" Error In PyType_ReadyCollisionLine");
             return;
        }
        Py_INCREF(&Dtool_CollisionLine.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionLine.As_PyTypeObject().tp_dict,"CollisionLine",&Dtool_CollisionLine.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionLine.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionLine[0],&Dtool_CollisionLine.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionLine,CollisionLine::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionLine.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionLine",(PyObject *)&Dtool_CollisionLine.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionPlane | CollisionPlane
//********************************************************************
PyMethodDef Dtool_Methods_CollisionPlane[]= {
  { "getNormal",(PyCFunction ) &Dtool_CollisionPlane_get_normal_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPlane_get_normal_236_comment},
  { "distToPlane",(PyCFunction ) &Dtool_CollisionPlane_dist_to_plane_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPlane_dist_to_plane_237_comment},
  { "setPlane",(PyCFunction ) &Dtool_CollisionPlane_set_plane_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPlane_set_plane_238_comment},
  { "getPlane",(PyCFunction ) &Dtool_CollisionPlane_get_plane_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPlane_get_plane_239_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionPlane_get_class_type_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPlane_get_class_type_240_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionPlane(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionPlane.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionPlane\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionPlane.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionPlane.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionPlane.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionPlane.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionPlane.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionPlane)");
             printf(" Error In PyType_ReadyCollisionPlane");
             return;
        }
        Py_INCREF(&Dtool_CollisionPlane.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionPlane.As_PyTypeObject().tp_dict,"CollisionPlane",&Dtool_CollisionPlane.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionPlane.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionPlane[4],&Dtool_CollisionPlane.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionPlane,CollisionPlane::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionPlane.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionPlane",(PyObject *)&Dtool_CollisionPlane.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionPolygon | CollisionPolygon
//********************************************************************
PyMethodDef Dtool_Methods_CollisionPolygon[]= {
  { "getNumPoints",(PyCFunction ) &Dtool_CollisionPolygon_get_num_points_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_get_num_points_244_comment},
  { "getPoint",(PyCFunction ) &Dtool_CollisionPolygon_get_point_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_get_point_245_comment},
  { "verifyPoints",(PyCFunction ) &Dtool_CollisionPolygon_verify_points_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_verify_points_246_comment},
  { "isValid",(PyCFunction ) &Dtool_CollisionPolygon_is_valid_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_is_valid_247_comment},
  { "isConcave",(PyCFunction ) &Dtool_CollisionPolygon_is_concave_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_is_concave_248_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionPolygon_get_class_type_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionPolygon_get_class_type_249_comment},
  { "getPoints",(PyCFunction) &MakeSeq_CollisionPolygon_get_points, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionPolygon(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionPolygon.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionPolygon\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionPlane._Dtool_ClassInit(NULL);
        Dtool_CollisionPolygon.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionPlane.As_PyTypeObject());
        Dtool_CollisionPolygon.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionPolygon.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionPolygon.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionPolygon.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionPolygon)");
             printf(" Error In PyType_ReadyCollisionPolygon");
             return;
        }
        Py_INCREF(&Dtool_CollisionPolygon.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionPolygon.As_PyTypeObject().tp_dict,"CollisionPolygon",&Dtool_CollisionPolygon.As_PyObject());
        //  Static Method verifyPoints
        PyDict_SetItemString(Dtool_CollisionPolygon.As_PyTypeObject().tp_dict,"verifyPoints",PyCFunction_New(&Dtool_Methods_CollisionPolygon[2],&Dtool_CollisionPolygon.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionPolygon.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionPolygon[5],&Dtool_CollisionPolygon.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionPolygon,CollisionPolygon::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionPolygon.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionPolygon",(PyObject *)&Dtool_CollisionPolygon.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionParabola | CollisionParabola
//********************************************************************
PyMethodDef Dtool_Methods_CollisionParabola[]= {
  { "setParabola",(PyCFunction ) &Dtool_CollisionParabola_set_parabola_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_set_parabola_253_comment},
  { "getParabola",(PyCFunction ) &Dtool_CollisionParabola_get_parabola_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_get_parabola_254_comment},
  { "setT1",(PyCFunction ) &Dtool_CollisionParabola_set_t1_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_set_t1_255_comment},
  { "getT1",(PyCFunction ) &Dtool_CollisionParabola_get_t1_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_get_t1_256_comment},
  { "setT2",(PyCFunction ) &Dtool_CollisionParabola_set_t2_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_set_t2_257_comment},
  { "getT2",(PyCFunction ) &Dtool_CollisionParabola_get_t2_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_get_t2_258_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionParabola_get_class_type_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionParabola_get_class_type_259_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionParabola(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionParabola.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionParabola\n"
          "// Description : This defines a parabolic arc, or subset of an arc,\n"
          "//               similar to the path of a projectile or falling\n"
          "//               object.  It is finite, having a specific beginning\n"
          "//               and end, but it is infinitely thin.\n"
          "//\n"
          "//               Think of it as a wire bending from point t1 to point\n"
          "//               t2 along the path of a pre-defined parabola.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionParabola.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionParabola.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionParabola.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionParabola.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionParabola.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionParabola)");
             printf(" Error In PyType_ReadyCollisionParabola");
             return;
        }
        Py_INCREF(&Dtool_CollisionParabola.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionParabola.As_PyTypeObject().tp_dict,"CollisionParabola",&Dtool_CollisionParabola.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionParabola.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionParabola[6],&Dtool_CollisionParabola.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionParabola,CollisionParabola::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionParabola.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionParabola",(PyObject *)&Dtool_CollisionParabola.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionFloorMesh | CollisionFloorMesh
//********************************************************************
PyMethodDef Dtool_Methods_CollisionFloorMesh[]= {
  { "addVertex",(PyCFunction ) &Dtool_CollisionFloorMesh_add_vertex_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_add_vertex_263_comment},
  { "addTriangle",(PyCFunction ) &Dtool_CollisionFloorMesh_add_triangle_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_add_triangle_264_comment},
  { "getNumVertices",(PyCFunction ) &Dtool_CollisionFloorMesh_get_num_vertices_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_get_num_vertices_265_comment},
  { "getVertex",(PyCFunction ) &Dtool_CollisionFloorMesh_get_vertex_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_get_vertex_266_comment},
  { "getNumTriangles",(PyCFunction ) &Dtool_CollisionFloorMesh_get_num_triangles_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_get_num_triangles_267_comment},
  { "getTriangle",(PyCFunction ) &Dtool_CollisionFloorMesh_get_triangle_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_get_triangle_268_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionFloorMesh_get_class_type_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionFloorMesh_get_class_type_269_comment},
  { "getVertices",(PyCFunction) &MakeSeq_CollisionFloorMesh_get_vertices, METH_NOARGS, NULL},
  { "getTriangles",(PyCFunction) &MakeSeq_CollisionFloorMesh_get_triangles, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionFloorMesh(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionFloorMesh.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionFloorMesh\n"
          "// Description : This object represents a solid made entirely of triangles, which\n"
          "//               will only be tested again z axis aligned rays\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionFloorMesh.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionFloorMesh.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionFloorMesh.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionFloorMesh.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionFloorMesh.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionFloorMesh)");
             printf(" Error In PyType_ReadyCollisionFloorMesh");
             return;
        }
        Py_INCREF(&Dtool_CollisionFloorMesh.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionFloorMesh.As_PyTypeObject().tp_dict,"CollisionFloorMesh",&Dtool_CollisionFloorMesh.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionFloorMesh.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionFloorMesh[6],&Dtool_CollisionFloorMesh.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionFloorMesh,CollisionFloorMesh::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionFloorMesh.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionFloorMesh",(PyObject *)&Dtool_CollisionFloorMesh.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionSegment | CollisionSegment
//********************************************************************
PyMethodDef Dtool_Methods_CollisionSegment[]= {
  { "setPointA",(PyCFunction ) &Dtool_CollisionSegment_set_point_a_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_set_point_a_273_comment},
  { "getPointA",(PyCFunction ) &Dtool_CollisionSegment_get_point_a_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_get_point_a_274_comment},
  { "setPointB",(PyCFunction ) &Dtool_CollisionSegment_set_point_b_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_set_point_b_275_comment},
  { "getPointB",(PyCFunction ) &Dtool_CollisionSegment_get_point_b_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_get_point_b_276_comment},
  { "setFromLens",(PyCFunction ) &Dtool_CollisionSegment_set_from_lens_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_set_from_lens_277_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionSegment_get_class_type_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionSegment_get_class_type_278_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionSegment(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionSegment.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionSegment\n"
          "// Description : A finite line segment, with two specific endpoints\n"
          "//               but no thickness.  It's similar to a CollisionRay,\n"
          "//               except it does not continue to infinity.\n"
          "//\n"
          "//               It does have an ordering, from point A to point B.\n"
          "//               If more than a single point of the segment is\n"
          "//               intersecting a solid, the reported intersection point\n"
          "//               is generally the closest on the segment to point A.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionSegment.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionSegment.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionSegment.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionSegment.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionSegment.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionSegment)");
             printf(" Error In PyType_ReadyCollisionSegment");
             return;
        }
        Py_INCREF(&Dtool_CollisionSegment.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionSegment.As_PyTypeObject().tp_dict,"CollisionSegment",&Dtool_CollisionSegment.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionSegment.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionSegment[5],&Dtool_CollisionSegment.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionSegment,CollisionSegment::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionSegment.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionSegment",(PyObject *)&Dtool_CollisionSegment.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CollisionTube | CollisionTube
//********************************************************************
PyMethodDef Dtool_Methods_CollisionTube[]= {
  { "setPointA",(PyCFunction ) &Dtool_CollisionTube_set_point_a_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_set_point_a_282_comment},
  { "getPointA",(PyCFunction ) &Dtool_CollisionTube_get_point_a_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_get_point_a_283_comment},
  { "setPointB",(PyCFunction ) &Dtool_CollisionTube_set_point_b_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_set_point_b_284_comment},
  { "getPointB",(PyCFunction ) &Dtool_CollisionTube_get_point_b_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_get_point_b_285_comment},
  { "setRadius",(PyCFunction ) &Dtool_CollisionTube_set_radius_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_set_radius_286_comment},
  { "getRadius",(PyCFunction ) &Dtool_CollisionTube_get_radius_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_get_radius_287_comment},
  { "getClassType",(PyCFunction ) &Dtool_CollisionTube_get_class_type_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CollisionTube_get_class_type_288_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CollisionTube(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CollisionTube.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CollisionTube\n"
          "// Description : This implements a solid roughly in cylindrical shape.\n"
          "//               It's not called a CollisionCylinder because it's not\n"
          "//               a true cylinder; specifically, it has rounded ends\n"
          "//               instead of flat ends.  It looks more like a Contac\n"
          "//               pill.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionSolid._Dtool_ClassInit(NULL);
        Dtool_CollisionTube.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionSolid.As_PyTypeObject());
        Dtool_CollisionTube.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CollisionTube.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CollisionTube.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CollisionTube.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CollisionTube)");
             printf(" Error In PyType_ReadyCollisionTube");
             return;
        }
        Py_INCREF(&Dtool_CollisionTube.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CollisionTube.As_PyTypeObject().tp_dict,"CollisionTube",&Dtool_CollisionTube.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CollisionTube.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CollisionTube[6],&Dtool_CollisionTube.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CollisionTube,CollisionTube::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CollisionTube.As_PyTypeObject());
        PyModule_AddObject(module, "CollisionTube",(PyObject *)&Dtool_CollisionTube.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CollisionHandler
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandler(module);
//********************************************************************
//*** Module Init Updcall ..CollisionSolid
//********************************************************************
   Dtool_PyModuleClassInit_CollisionSolid(module);
//********************************************************************
//*** Module Init Updcall ..CollisionNode
//********************************************************************
   Dtool_PyModuleClassInit_CollisionNode(module);
//********************************************************************
//*** Module Init Updcall ..CollisionTraverser
//********************************************************************
   Dtool_PyModuleClassInit_CollisionTraverser(module);
//********************************************************************
//*** Module Init Updcall ..CollisionEntry
//********************************************************************
   Dtool_PyModuleClassInit_CollisionEntry(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerEvent
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerEvent(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerHighestEvent
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerPhysical
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerPhysical(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerFloor
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerFloor(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerGravity
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerGravity(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerPusher
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerPusher(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerFluidPusher
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(module);
//********************************************************************
//*** Module Init Updcall ..CollisionHandlerQueue
//********************************************************************
   Dtool_PyModuleClassInit_CollisionHandlerQueue(module);
//********************************************************************
//*** Module Init Updcall ..CollisionDSSolid
//********************************************************************
   Dtool_PyModuleClassInit_CollisionDSSolid(module);
//********************************************************************
//*** Module Init Updcall ..CollisionBox
//********************************************************************
   Dtool_PyModuleClassInit_CollisionBox(module);
//********************************************************************
//*** Module Init Updcall ..CollisionSphere
//********************************************************************
   Dtool_PyModuleClassInit_CollisionSphere(module);
//********************************************************************
//*** Module Init Updcall ..CollisionInvSphere
//********************************************************************
   Dtool_PyModuleClassInit_CollisionInvSphere(module);
//********************************************************************
//*** Module Init Updcall ..CollisionRay
//********************************************************************
   Dtool_PyModuleClassInit_CollisionRay(module);
//********************************************************************
//*** Module Init Updcall ..CollisionLine
//********************************************************************
   Dtool_PyModuleClassInit_CollisionLine(module);
//********************************************************************
//*** Module Init Updcall ..CollisionPlane
//********************************************************************
   Dtool_PyModuleClassInit_CollisionPlane(module);
//********************************************************************
//*** Module Init Updcall ..CollisionPolygon
//********************************************************************
   Dtool_PyModuleClassInit_CollisionPolygon(module);
//********************************************************************
//*** Module Init Updcall ..CollisionParabola
//********************************************************************
   Dtool_PyModuleClassInit_CollisionParabola(module);
//********************************************************************
//*** Module Init Updcall ..CollisionFloorMesh
//********************************************************************
   Dtool_PyModuleClassInit_CollisionFloorMesh(module);
//********************************************************************
//*** Module Init Updcall ..CollisionSegment
//********************************************************************
   Dtool_PyModuleClassInit_CollisionSegment(module);
//********************************************************************
//*** Module Init Updcall ..CollisionTube
//********************************************************************
   Dtool_PyModuleClassInit_CollisionTube(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libcollide_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212910,  /* file_identifier */
  "libcollide",  /* library_name */
  "Hwca",  /* library_hash_name */
  "panda",  /* module_name */
  "libcollide.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  689  /* next_index */
};

Configure(_in_configure_libcollide);
ConfigureFn(_in_configure_libcollide) {
  interrogate_request_module(&_in_module_def);
}

