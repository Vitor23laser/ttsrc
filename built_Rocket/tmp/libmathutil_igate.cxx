/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/mathutil -Ipanda/src/mathutil -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libmathutil_igate.cxx -od built_Rocket/pandac/input/libmathutil.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/mathutil -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/fftw/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libmathutil boundingBox.h boundingHexahedron.h boundingLine.h boundingPlane.h boundingSphere.h boundingVolume.h config_mathutil.h fftCompressor.h finiteBoundingVolume.h frustum.h frustum_src.h geometricBoundingVolume.h linmath_events.h look_at.h look_at_src.h mathutil_composite.cxx mersenne.h omniBoundingVolume.h parabola.h parabola_src.h perlinNoise.h perlinNoise2.h perlinNoise3.h plane.h plane_src.h pta_LMatrix3f.h pta_LMatrix4f.h pta_LVecBase2f.h pta_LVecBase3f.h pta_LVecBase4f.h randomizer.h rotate_to.h stackedPerlinNoise2.h stackedPerlinNoise3.h triangulator.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libmathutil
#include "py_panda.h"  

#include "boundingBox.h"
#include "boundingHexahedron.h"
#include "boundingLine.h"
#include "boundingPlane.h"
#include "boundingSphere.h"
#include "boundingVolume.h"
#include "cmath.h"
#include "config_mathutil.h"
#include "coordinateSystem.h"
#include "dblnames.h"
#include "eventParameter.h"
#include "fftCompressor.h"
#include "finiteBoundingVolume.h"
#include "fltnames.h"
#include "frustum.h"
#include "geometricBoundingVolume.h"
#include "linmath_events.h"
#include "look_at.h"
#include "luse.h"
#include "mersenne.h"
#include "omniBoundingVolume.h"
#include "pandabase.h"
#include "parabola.h"
#include "perlinNoise.h"
#include "perlinNoise2.h"
#include "perlinNoise3.h"
#include "plane.h"
#include "pointerToArray.h"
#include "pta_LMatrix3f.h"
#include "pta_LMatrix4f.h"
#include "pta_LVecBase2f.h"
#include "pta_LVecBase3f.h"
#include "pta_LVecBase4f.h"
#include "randomizer.h"
#include "rotate_to.h"
#include "stackedPerlinNoise2.h"
#include "stackedPerlinNoise3.h"
#include "triangulator.h"
#include "vector_LVecBase3f.h"
#include "vector_double.h"
#include "vector_float.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ConstPointerToArray_LMatrix3f
//********************************************************************
typedef  ConstPointerToArray< LMatrix3f >  ConstPointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda,ConstPointerToArray_LMatrix3f,ConstPointerToArray_LMatrix3f_localtype,ConstPointerToArrayLMatrix3f);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_LMatrix3f
//********************************************************************
typedef  PointerToArrayBase< LMatrix3f >  PointerToArrayBase_LMatrix3f_localtype;
Define_Module_Class(panda,PointerToArrayBase_LMatrix3f,PointerToArrayBase_LMatrix3f_localtype,PointerToArrayBaseLMatrix3f);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_LMatrix3f
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< LMatrix3f > >  PointerToBase_ReferenceCountedVector_LMatrix3f_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_LMatrix3f,PointerToBase_ReferenceCountedVector_LMatrix3f_localtype,PointerToBaseReferenceCountedVectorLMatrix3f);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_LMatrix4f
//********************************************************************
typedef  ConstPointerToArray< LMatrix4f >  ConstPointerToArray_LMatrix4f_localtype;
Define_Module_Class(panda,ConstPointerToArray_LMatrix4f,ConstPointerToArray_LMatrix4f_localtype,ConstPointerToArrayLMatrix4f);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_LMatrix4f
//********************************************************************
typedef  PointerToArrayBase< LMatrix4f >  PointerToArrayBase_LMatrix4f_localtype;
Define_Module_Class(panda,PointerToArrayBase_LMatrix4f,PointerToArrayBase_LMatrix4f_localtype,PointerToArrayBaseLMatrix4f);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_LMatrix4f
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< LMatrix4f > >  PointerToBase_ReferenceCountedVector_LMatrix4f_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_LMatrix4f,PointerToBase_ReferenceCountedVector_LMatrix4f_localtype,PointerToBaseReferenceCountedVectorLMatrix4f);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_LVecBase2f
//********************************************************************
typedef  ConstPointerToArray< LVecBase2f >  ConstPointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda,ConstPointerToArray_LVecBase2f,ConstPointerToArray_LVecBase2f_localtype,ConstPointerToArrayLVecBase2f);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_LVecBase2f
//********************************************************************
typedef  PointerToArrayBase< LVecBase2f >  PointerToArrayBase_LVecBase2f_localtype;
Define_Module_Class(panda,PointerToArrayBase_LVecBase2f,PointerToArrayBase_LVecBase2f_localtype,PointerToArrayBaseLVecBase2f);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_LVecBase2f
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< LVecBase2f > >  PointerToBase_ReferenceCountedVector_LVecBase2f_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_LVecBase2f,PointerToBase_ReferenceCountedVector_LVecBase2f_localtype,PointerToBaseReferenceCountedVectorLVecBase2f);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_LVecBase3f
//********************************************************************
typedef  ConstPointerToArray< LVecBase3f >  ConstPointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda,ConstPointerToArray_LVecBase3f,ConstPointerToArray_LVecBase3f_localtype,ConstPointerToArrayLVecBase3f);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_LVecBase3f
//********************************************************************
typedef  PointerToArrayBase< LVecBase3f >  PointerToArrayBase_LVecBase3f_localtype;
Define_Module_Class(panda,PointerToArrayBase_LVecBase3f,PointerToArrayBase_LVecBase3f_localtype,PointerToArrayBaseLVecBase3f);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_LVecBase3f
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< LVecBase3f > >  PointerToBase_ReferenceCountedVector_LVecBase3f_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_LVecBase3f,PointerToBase_ReferenceCountedVector_LVecBase3f_localtype,PointerToBaseReferenceCountedVectorLVecBase3f);
//********************************************************************
//*** prototypes for .. ConstPointerToArray_LVecBase4f
//********************************************************************
typedef  ConstPointerToArray< LVecBase4f >  ConstPointerToArray_LVecBase4f_localtype;
Define_Module_Class(panda,ConstPointerToArray_LVecBase4f,ConstPointerToArray_LVecBase4f_localtype,ConstPointerToArrayLVecBase4f);
//********************************************************************
//*** prototypes for .. PointerToArrayBase_LVecBase4f
//********************************************************************
typedef  PointerToArrayBase< LVecBase4f >  PointerToArrayBase_LVecBase4f_localtype;
Define_Module_Class(panda,PointerToArrayBase_LVecBase4f,PointerToArrayBase_LVecBase4f_localtype,PointerToArrayBaseLVecBase4f);
//********************************************************************
//*** prototypes for .. PointerToBase_ReferenceCountedVector_LVecBase4f
//********************************************************************
typedef  PointerToBase< ReferenceCountedVector< LVecBase4f > >  PointerToBase_ReferenceCountedVector_LVecBase4f_localtype;
Define_Module_Class_Private(panda,PointerToBase_ReferenceCountedVector_LVecBase4f,PointerToBase_ReferenceCountedVector_LVecBase4f_localtype,PointerToBaseReferenceCountedVectorLVecBase4f);
//********************************************************************
//*** prototypes for .. Frustumd
//********************************************************************
typedef  Frustumd  Frustumd_localtype;
Define_Module_Class(panda,Frustumd,Frustumd_localtype,FrustumD);
//********************************************************************
//*** prototypes for .. Frustumf
//********************************************************************
typedef  Frustumf  Frustumf_localtype;
Define_Module_Class(panda,Frustumf,Frustumf_localtype,Frustum);
//********************************************************************
//*** prototypes for .. Planed
//********************************************************************
typedef  Planed  Planed_localtype;
Define_Module_Class(panda,Planed,Planed_localtype,PlaneD);
//********************************************************************
//*** prototypes for .. Planef
//********************************************************************
typedef  Planef  Planef_localtype;
Define_Module_Class(panda,Planef,Planef_localtype,Plane);
//********************************************************************
//*** prototypes for .. PointerToArray_LMatrix3f
//********************************************************************
typedef  PointerToArray< LMatrix3f >  PointerToArray_LMatrix3f_localtype;
Define_Module_Class(panda,PointerToArray_LMatrix3f,PointerToArray_LMatrix3f_localtype,PointerToArrayLMatrix3f);
//********************************************************************
//*** prototypes for .. PointerToArray_LMatrix4f
//********************************************************************
typedef  PointerToArray< LMatrix4f >  PointerToArray_LMatrix4f_localtype;
Define_Module_Class(panda,PointerToArray_LMatrix4f,PointerToArray_LMatrix4f_localtype,PointerToArrayLMatrix4f);
//********************************************************************
//*** prototypes for .. PointerToArray_LVecBase2f
//********************************************************************
typedef  PointerToArray< LVecBase2f >  PointerToArray_LVecBase2f_localtype;
Define_Module_Class(panda,PointerToArray_LVecBase2f,PointerToArray_LVecBase2f_localtype,PointerToArrayLVecBase2f);
//********************************************************************
//*** prototypes for .. PointerToArray_LVecBase3f
//********************************************************************
typedef  PointerToArray< LVecBase3f >  PointerToArray_LVecBase3f_localtype;
Define_Module_Class(panda,PointerToArray_LVecBase3f,PointerToArray_LVecBase3f_localtype,PointerToArrayLVecBase3f);
//********************************************************************
//*** prototypes for .. PointerToArray_LVecBase4f
//********************************************************************
typedef  PointerToArray< LVecBase4f >  PointerToArray_LVecBase4f_localtype;
Define_Module_Class(panda,PointerToArray_LVecBase4f,PointerToArray_LVecBase4f_localtype,PointerToArrayLVecBase4f);
//********************************************************************
//*** prototypes for .. BoundingVolume
//********************************************************************
typedef  BoundingVolume  BoundingVolume_localtype;
Define_Module_ClassRef(panda,BoundingVolume,BoundingVolume_localtype,BoundingVolume);
//********************************************************************
//*** prototypes for .. GeometricBoundingVolume
//********************************************************************
typedef  GeometricBoundingVolume  GeometricBoundingVolume_localtype;
Define_Module_ClassRef(panda,GeometricBoundingVolume,GeometricBoundingVolume_localtype,GeometricBoundingVolume);
//********************************************************************
//*** prototypes for .. FiniteBoundingVolume
//********************************************************************
typedef  FiniteBoundingVolume  FiniteBoundingVolume_localtype;
Define_Module_ClassRef(panda,FiniteBoundingVolume,FiniteBoundingVolume_localtype,FiniteBoundingVolume);
//********************************************************************
//*** prototypes for .. Parabolaf
//********************************************************************
typedef  Parabolaf  Parabolaf_localtype;
Define_Module_Class(panda,Parabolaf,Parabolaf_localtype,Parabolaf);
//********************************************************************
//*** prototypes for .. Parabolad
//********************************************************************
typedef  Parabolad  Parabolad_localtype;
Define_Module_Class(panda,Parabolad,Parabolad_localtype,Parabolad);
//********************************************************************
//*** prototypes for .. BoundingBox
//********************************************************************
typedef  BoundingBox  BoundingBox_localtype;
Define_Module_ClassRef(panda,BoundingBox,BoundingBox_localtype,BoundingBox);
//********************************************************************
//*** prototypes for .. BoundingHexahedron
//********************************************************************
typedef  BoundingHexahedron  BoundingHexahedron_localtype;
Define_Module_ClassRef(panda,BoundingHexahedron,BoundingHexahedron_localtype,BoundingHexahedron);
//********************************************************************
//*** prototypes for .. BoundingLine
//********************************************************************
typedef  BoundingLine  BoundingLine_localtype;
Define_Module_ClassRef(panda,BoundingLine,BoundingLine_localtype,BoundingLine);
//********************************************************************
//*** prototypes for .. BoundingPlane
//********************************************************************
typedef  BoundingPlane  BoundingPlane_localtype;
Define_Module_ClassRef(panda,BoundingPlane,BoundingPlane_localtype,BoundingPlane);
//********************************************************************
//*** prototypes for .. BoundingSphere
//********************************************************************
typedef  BoundingSphere  BoundingSphere_localtype;
Define_Module_ClassRef(panda,BoundingSphere,BoundingSphere_localtype,BoundingSphere);
//********************************************************************
//*** prototypes for .. OmniBoundingVolume
//********************************************************************
typedef  OmniBoundingVolume  OmniBoundingVolume_localtype;
Define_Module_ClassRef(panda,OmniBoundingVolume,OmniBoundingVolume_localtype,OmniBoundingVolume);
//********************************************************************
//*** prototypes for .. Mersenne
//********************************************************************
typedef  Mersenne  Mersenne_localtype;
Define_Module_Class(panda,Mersenne,Mersenne_localtype,Mersenne);
//********************************************************************
//*** prototypes for .. PerlinNoise
//********************************************************************
typedef  PerlinNoise  PerlinNoise_localtype;
Define_Module_Class(panda,PerlinNoise,PerlinNoise_localtype,PerlinNoise);
//********************************************************************
//*** prototypes for .. PerlinNoise2
//********************************************************************
typedef  PerlinNoise2  PerlinNoise2_localtype;
Define_Module_Class(panda,PerlinNoise2,PerlinNoise2_localtype,PerlinNoise2);
//********************************************************************
//*** prototypes for .. PerlinNoise3
//********************************************************************
typedef  PerlinNoise3  PerlinNoise3_localtype;
Define_Module_Class(panda,PerlinNoise3,PerlinNoise3_localtype,PerlinNoise3);
//********************************************************************
//*** prototypes for .. StackedPerlinNoise2
//********************************************************************
typedef  StackedPerlinNoise2  StackedPerlinNoise2_localtype;
Define_Module_Class(panda,StackedPerlinNoise2,StackedPerlinNoise2_localtype,StackedPerlinNoise2);
//********************************************************************
//*** prototypes for .. StackedPerlinNoise3
//********************************************************************
typedef  StackedPerlinNoise3  StackedPerlinNoise3_localtype;
Define_Module_Class(panda,StackedPerlinNoise3,StackedPerlinNoise3_localtype,StackedPerlinNoise3);
//********************************************************************
//*** prototypes for .. Triangulator
//********************************************************************
typedef  Triangulator  Triangulator_localtype;
Define_Module_Class(panda,Triangulator,Triangulator_localtype,Triangulator);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LQuaterniond;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LQuaternionf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3d;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerToVoid;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 *******************************************************************/
static PyObject *Dtool_heads_up_312(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:headsUp", key_word_list, &param0, &param1))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:headsUp", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 void heads_up(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void heads_up(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void heads_up(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:headsUp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "headsUp", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "headsUp", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "headsUp", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        heads_up(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "headsUp() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "headsUp(non-const Mat3 mat, const Vec3 fwd)\n"
          "headsUp(non-const Mat4D mat, const Vec3D fwd)\n"
          "headsUp(non-const Mat3D mat, const Vec3D fwd)\n"
          "headsUp(non-const QuatD quat, const Vec3D fwd)\n"
          "headsUp(non-const Quat quat, const Vec3 fwd)\n"
          "headsUp(non-const Mat4 mat, const Vec3 fwd)\n"
          "headsUp(non-const Mat3D mat, const Vec3D fwd, const Vec3D up)\n"
          "headsUp(non-const Mat3 mat, const Vec3 fwd, const Vec3 up)\n"
          "headsUp(non-const QuatD quat, const Vec3D fwd, const Vec3D up)\n"
          "headsUp(non-const Quat quat, const Vec3 fwd, const Vec3 up)\n"
          "headsUp(non-const Mat4D mat, const Vec3D fwd, const Vec3D up)\n"
          "headsUp(non-const Mat4 mat, const Vec3 fwd, const Vec3 up)\n"
          "headsUp(non-const QuatD quat, const Vec3D fwd, int cs)\n"
          "headsUp(non-const Mat4D mat, const Vec3D fwd, int cs)\n"
          "headsUp(non-const Mat4 mat, const Vec3 fwd, int cs)\n"
          "headsUp(non-const Mat3 mat, const Vec3 fwd, int cs)\n"
          "headsUp(non-const Quat quat, const Vec3 fwd, int cs)\n"
          "headsUp(non-const Mat3D mat, const Vec3D fwd, int cs)\n"
          "headsUp(non-const Mat3D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "headsUp(non-const Mat4D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "headsUp(non-const Mat4 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "headsUp(non-const QuatD quat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "headsUp(non-const Quat quat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "headsUp(non-const Mat3 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_heads_up_312_comment =
    "C++ Interface:\n"
    "headsUp(non-const Mat3 mat, const Vec3 fwd)\n"
    "headsUp(non-const Mat4D mat, const Vec3D fwd)\n"
    "headsUp(non-const Mat3D mat, const Vec3D fwd)\n"
    "headsUp(non-const QuatD quat, const Vec3D fwd)\n"
    "headsUp(non-const Quat quat, const Vec3 fwd)\n"
    "headsUp(non-const Mat4 mat, const Vec3 fwd)\n"
    "headsUp(non-const Mat3D mat, const Vec3D fwd, const Vec3D up)\n"
    "headsUp(non-const Mat3 mat, const Vec3 fwd, const Vec3 up)\n"
    "headsUp(non-const QuatD quat, const Vec3D fwd, const Vec3D up)\n"
    "headsUp(non-const Quat quat, const Vec3 fwd, const Vec3 up)\n"
    "headsUp(non-const Mat4D mat, const Vec3D fwd, const Vec3D up)\n"
    "headsUp(non-const Mat4 mat, const Vec3 fwd, const Vec3 up)\n"
    "headsUp(non-const QuatD quat, const Vec3D fwd, int cs)\n"
    "headsUp(non-const Mat4D mat, const Vec3D fwd, int cs)\n"
    "headsUp(non-const Mat4 mat, const Vec3 fwd, int cs)\n"
    "headsUp(non-const Mat3 mat, const Vec3 fwd, int cs)\n"
    "headsUp(non-const Quat quat, const Vec3 fwd, int cs)\n"
    "headsUp(non-const Mat3D mat, const Vec3D fwd, int cs)\n"
    "headsUp(non-const Mat3D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "headsUp(non-const Mat4D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "headsUp(non-const Mat4 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "headsUp(non-const QuatD quat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "headsUp(non-const Quat quat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "headsUp(non-const Mat3 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: heads_up\n"
    "//  Description: Given two vectors defining a forward direction and an\n"
    "//               up vector, constructs the matrix that rotates things\n"
    "//               from the defined coordinate system to y-forward and\n"
    "//               z-up.  The up vector will be rotated to z-up first,\n"
    "//               then the forward vector will be rotated as nearly to\n"
    "//               y-forward as possible.  This will only have a\n"
    "//               different effect from look_at() if the forward and up\n"
    "//               vectors are not perpendicular.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: heads_up\n"
    "//  Description: Given two vectors defining a forward direction and an\n"
    "//               up vector, constructs the matrix that rotates things\n"
    "//               from the defined coordinate system to y-forward and\n"
    "//               z-up.  The up vector will be rotated to z-up first,\n"
    "//               then the forward vector will be rotated as nearly to\n"
    "//               y-forward as possible.  This will only have a\n"
    "//               different effect from look_at() if the forward and up\n"
    "//               vectors are not perpendicular.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_heads_up_312_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
 * inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
 * inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
 *******************************************************************/
static PyObject *Dtool_look_at_313(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up = ((up())), CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:lookAt", key_word_list, &param0, &param1))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix3d &mat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix3f &mat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:lookAt", key_word_list, &param0, &param1, &param2))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, (CoordinateSystem)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 void look_at(LMatrix3f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LMatrix4f &mat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaterniond &quat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LQuaterniond *param0_this = (LQuaterniond *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaterniond, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 void look_at(LMatrix3d &mat, LVector3d const &fwd, LVector3d const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"mat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline void look_at(LQuaternionf &quat, LVector3f const &fwd, LVector3f const &up, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"quat", (char *)"fwd", (char *)"up", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:lookAt", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LQuaternionf *param0_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LQuaternionf, 0, "lookAt", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "lookAt", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "lookAt", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        look_at(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "lookAt() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "lookAt(non-const Mat4D mat, const Vec3D fwd)\n"
          "lookAt(non-const Mat4 mat, const Vec3 fwd)\n"
          "lookAt(non-const Mat3D mat, const Vec3D fwd)\n"
          "lookAt(non-const QuatD quat, const Vec3D fwd)\n"
          "lookAt(non-const Quat quat, const Vec3 fwd)\n"
          "lookAt(non-const Mat3 mat, const Vec3 fwd)\n"
          "lookAt(non-const QuatD quat, const Vec3D fwd, const Vec3D up)\n"
          "lookAt(non-const Mat4D mat, const Vec3D fwd, const Vec3D up)\n"
          "lookAt(non-const Mat3D mat, const Vec3D fwd, const Vec3D up)\n"
          "lookAt(non-const Quat quat, const Vec3 fwd, const Vec3 up)\n"
          "lookAt(non-const Mat3 mat, const Vec3 fwd, const Vec3 up)\n"
          "lookAt(non-const Mat4 mat, const Vec3 fwd, const Vec3 up)\n"
          "lookAt(non-const Mat3D mat, const Vec3D fwd, int cs)\n"
          "lookAt(non-const Mat3 mat, const Vec3 fwd, int cs)\n"
          "lookAt(non-const Mat4 mat, const Vec3 fwd, int cs)\n"
          "lookAt(non-const QuatD quat, const Vec3D fwd, int cs)\n"
          "lookAt(non-const Quat quat, const Vec3 fwd, int cs)\n"
          "lookAt(non-const Mat4D mat, const Vec3D fwd, int cs)\n"
          "lookAt(non-const Mat3 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "lookAt(non-const Mat4D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "lookAt(non-const Mat4 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "lookAt(non-const QuatD quat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "lookAt(non-const Mat3D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
          "lookAt(non-const Quat quat, const Vec3 fwd, const Vec3 up, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_look_at_313_comment =
    "C++ Interface:\n"
    "lookAt(non-const Mat4D mat, const Vec3D fwd)\n"
    "lookAt(non-const Mat4 mat, const Vec3 fwd)\n"
    "lookAt(non-const Mat3D mat, const Vec3D fwd)\n"
    "lookAt(non-const QuatD quat, const Vec3D fwd)\n"
    "lookAt(non-const Quat quat, const Vec3 fwd)\n"
    "lookAt(non-const Mat3 mat, const Vec3 fwd)\n"
    "lookAt(non-const QuatD quat, const Vec3D fwd, const Vec3D up)\n"
    "lookAt(non-const Mat4D mat, const Vec3D fwd, const Vec3D up)\n"
    "lookAt(non-const Mat3D mat, const Vec3D fwd, const Vec3D up)\n"
    "lookAt(non-const Quat quat, const Vec3 fwd, const Vec3 up)\n"
    "lookAt(non-const Mat3 mat, const Vec3 fwd, const Vec3 up)\n"
    "lookAt(non-const Mat4 mat, const Vec3 fwd, const Vec3 up)\n"
    "lookAt(non-const Mat3D mat, const Vec3D fwd, int cs)\n"
    "lookAt(non-const Mat3 mat, const Vec3 fwd, int cs)\n"
    "lookAt(non-const Mat4 mat, const Vec3 fwd, int cs)\n"
    "lookAt(non-const QuatD quat, const Vec3D fwd, int cs)\n"
    "lookAt(non-const Quat quat, const Vec3 fwd, int cs)\n"
    "lookAt(non-const Mat4D mat, const Vec3D fwd, int cs)\n"
    "lookAt(non-const Mat3 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "lookAt(non-const Mat4D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "lookAt(non-const Mat4 mat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "lookAt(non-const QuatD quat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "lookAt(non-const Mat3D mat, const Vec3D fwd, const Vec3D up, int cs)\n"
    "lookAt(non-const Quat quat, const Vec3 fwd, const Vec3 up, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: look_at\n"
    "//  Description: Given two vectors defining a forward direction and an\n"
    "//               up vector, constructs the matrix that rotates things\n"
    "//               from the defined coordinate system to y-forward and\n"
    "//               z-up.  The forward vector will be rotated to\n"
    "//               y-forward first, then the up vector will be rotated\n"
    "//               as nearly to z-up as possible.  This will only have a\n"
    "//               different effect from heads_up() if the forward and\n"
    "//               up vectors are not perpendicular.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: look_at\n"
    "//  Description: Given two vectors defining a forward direction and an\n"
    "//               up vector, constructs the matrix that rotates things\n"
    "//               from the defined coordinate system to y-forward and\n"
    "//               z-up.  The forward vector will be rotated to\n"
    "//               y-forward first, then the up vector will be rotated\n"
    "//               as nearly to z-up as possible.  This will only have a\n"
    "//               different effect from heads_up() if the forward and\n"
    "//               up vectors are not perpendicular.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_look_at_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
 * void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
 * void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
 *******************************************************************/
static PyObject *Dtool_rotate_to_339(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 void rotate_to(LMatrix3f &mat, LVector3f const &a, LVector3f const &b)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mat", (char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:rotateTo", key_word_list, &param0, &param1, &param2))
            {
                LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3f, 0, "rotateTo", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "rotateTo", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "rotateTo", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                {
                    rotate_to(*param0_this, *param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 void rotate_to(LMatrix4d &mat, LVector3d const &a, LVector3d const &b)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mat", (char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:rotateTo", key_word_list, &param0, &param1, &param2))
            {
                LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4d, 0, "rotateTo", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "rotateTo", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "rotateTo", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                {
                    rotate_to(*param0_this, *param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 void rotate_to(LMatrix4f &mat, LVector3f const &a, LVector3f const &b)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mat", (char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:rotateTo", key_word_list, &param0, &param1, &param2))
            {
                LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix4f, 0, "rotateTo", 0, coerced_ptr, report_errors);
LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "rotateTo", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "rotateTo", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                {
                    rotate_to(*param0_this, *param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 void rotate_to(LMatrix3d &mat, LVector3d const &a, LVector3d const &b)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mat", (char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:rotateTo", key_word_list, &param0, &param1, &param2))
            {
                LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LMatrix3d, 0, "rotateTo", 0, coerced_ptr, report_errors);
LVector3d *param1_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3d, 1, "rotateTo", 1, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "rotateTo", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                {
                    rotate_to(*param0_this, *param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rotateTo(non-const Mat3 mat, const Vec3 a, const Vec3 b)\n"
          "rotateTo(non-const Mat4D mat, const Vec3D a, const Vec3D b)\n"
          "rotateTo(non-const Mat4 mat, const Vec3 a, const Vec3 b)\n"
          "rotateTo(non-const Mat3D mat, const Vec3D a, const Vec3D b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_rotate_to_339_comment =
    "C++ Interface:\n"
    "rotateTo(non-const Mat3 mat, const Vec3 a, const Vec3 b)\n"
    "rotateTo(non-const Mat4D mat, const Vec3D a, const Vec3D b)\n"
    "rotateTo(non-const Mat4 mat, const Vec3 a, const Vec3 b)\n"
    "rotateTo(non-const Mat3D mat, const Vec3D a, const Vec3D b)\n"
    "\n"
    "";
#else
static const char * Dtool_rotate_to_339_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. ConstPointerToArray< LMatrix3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< LMatrix3f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_size_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< LMatrix3f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< LMatrix3f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_size_9_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_size_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f const &::ConstPointerToArray< LMatrix3f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_element_10(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f const &::ConstPointerToArray< LMatrix3f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LMatrix3f const *return_value = &(((const ConstPointerToArray< LMatrix3f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_element_10_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_element_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f const &::ConstPointerToArray< LMatrix3f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_getitem_11(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f const &::ConstPointerToArray< LMatrix3f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< LMatrix3f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LMatrix3f const *return_value = &(((const ConstPointerToArray< LMatrix3f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_getitem_11_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_getitem_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LMatrix3f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_data_12(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LMatrix3f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< LMatrix3f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_data_12_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_data_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LMatrix3f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_subdata_13(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LMatrix3f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< LMatrix3f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_subdata_13_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_subdata_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_14(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LMatrix3f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LMatrix3f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_14_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_15(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LMatrix3f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LMatrix3f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_15_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
 * inline ::ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< LMatrix3f >::ConstPointerToArray(ConstPointerToArray< LMatrix3f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< LMatrix3f > *param0_this = (ConstPointerToArray< LMatrix3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_LMatrix3f, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LMatrix3f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< LMatrix3f >::ConstPointerToArray(PointerToArray< LMatrix3f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< LMatrix3f > *param0_this = (PointerToArray< LMatrix3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LMatrix3f, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LMatrix3f > *return_value = new ConstPointerToArray< LMatrix3f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LMatrix3f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_LMatrix3f)
    {
        printf("ConstPointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< LMatrix3f > * local_this = (ConstPointerToArray< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_LMatrix3f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix3f)
        return ( PointerToArrayBase< LMatrix3f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix3f > > *)( PointerToArrayBase< LMatrix3f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix3f > > *)( PointerToArrayBase< LMatrix3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_LMatrix3f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix3f)
    {
          PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
          return (ConstPointerToArray< LMatrix3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
          return (ConstPointerToArray< LMatrix3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< LMatrix3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< LMatrix3f > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< LMatrix3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_LMatrix3f)
    {
        printf("PointerToArrayBase_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< LMatrix3f > * local_this = (PointerToArrayBase< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix3f)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix3f > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix3f)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
          return (PointerToArrayBase< LMatrix3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< LMatrix3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< LMatrix3f > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_5(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< LMatrix3f > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_5_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_6(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LMatrix3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< LMatrix3f > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< LMatrix3f > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_6_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_6_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< LMatrix3f > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
    {
        printf("PointerToBase_ReferenceCountedVector_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< LMatrix3f > > * local_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< LMatrix4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< LMatrix4f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_size_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< LMatrix4f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< LMatrix4f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_size_24_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_size_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &::ConstPointerToArray< LMatrix4f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_get_element_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &::ConstPointerToArray< LMatrix4f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LMatrix4f const *return_value = &(((const ConstPointerToArray< LMatrix4f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_element_25_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_element_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &::ConstPointerToArray< LMatrix4f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_getitem_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &::ConstPointerToArray< LMatrix4f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< LMatrix4f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LMatrix4f const *return_value = &(((const ConstPointerToArray< LMatrix4f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_getitem_26_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_getitem_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LMatrix4f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_get_data_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LMatrix4f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< LMatrix4f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_data_27_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_data_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LMatrix4f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_get_subdata_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LMatrix4f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< LMatrix4f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_subdata_28_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_subdata_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LMatrix4f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_get_ref_count_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LMatrix4f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LMatrix4f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_ref_count_29_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_ref_count_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LMatrix4f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LMatrix4f_get_node_ref_count_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LMatrix4f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LMatrix4f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_node_ref_count_30_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LMatrix4f_get_node_ref_count_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< LMatrix4f >::ConstPointerToArray(ConstPointerToArray< LMatrix4f > const &copy)
 * inline ::ConstPointerToArray< LMatrix4f >::ConstPointerToArray(PointerToArray< LMatrix4f > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< LMatrix4f >::ConstPointerToArray(PointerToArray< LMatrix4f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< LMatrix4f > *param0_this = (PointerToArray< LMatrix4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LMatrix4f, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LMatrix4f > *return_value = new ConstPointerToArray< LMatrix4f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LMatrix4f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< LMatrix4f >::ConstPointerToArray(ConstPointerToArray< LMatrix4f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< LMatrix4f > *param0_this = (ConstPointerToArray< LMatrix4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_LMatrix4f, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LMatrix4f > *return_value = new ConstPointerToArray< LMatrix4f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LMatrix4f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_LMatrix4f)
    {
        printf("ConstPointerToArray_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< LMatrix4f > * local_this = (ConstPointerToArray< LMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_LMatrix4f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix4f)
        return ( PointerToArrayBase< LMatrix4f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix4f > > *)( PointerToArrayBase< LMatrix4f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix4f > > *)( PointerToArrayBase< LMatrix4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_LMatrix4f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix4f)
    {
          PointerToArrayBase< LMatrix4f >* other_this = (PointerToArrayBase< LMatrix4f >*)from_this;
          return (ConstPointerToArray< LMatrix4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix4f > >*)from_this;
          return (ConstPointerToArray< LMatrix4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< LMatrix4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< LMatrix4f > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< LMatrix4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_LMatrix4f)
    {
        printf("PointerToArrayBase_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< LMatrix4f > * local_this = (PointerToArrayBase< LMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix4f)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix4f > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix4f > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix4f)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix4f > >*)from_this;
          return (PointerToArrayBase< LMatrix4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< LMatrix4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< LMatrix4f > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< LMatrix4f > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_clear_20(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LMatrix4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< LMatrix4f > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_clear_20_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_clear_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< LMatrix4f > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_output_21(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LMatrix4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< LMatrix4f > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< LMatrix4f > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_output_21_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_output_21_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< LMatrix4f > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
    {
        printf("PointerToBase_ReferenceCountedVector_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< LMatrix4f > > * local_this = (PointerToBase< ReferenceCountedVector< LMatrix4f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< LMatrix4f > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< LVecBase2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< LVecBase2f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_size_39(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< LVecBase2f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< LVecBase2f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_size_39_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_size_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::ConstPointerToArray< LVecBase2f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_element_40(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::ConstPointerToArray< LVecBase2f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase2f const *return_value = &(((const ConstPointerToArray< LVecBase2f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_element_40_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_element_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::ConstPointerToArray< LVecBase2f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_getitem_41(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::ConstPointerToArray< LVecBase2f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< LVecBase2f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase2f const *return_value = &(((const ConstPointerToArray< LVecBase2f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_getitem_41_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_getitem_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase2f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_data_42(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase2f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< LVecBase2f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_data_42_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_data_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase2f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_subdata_43(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase2f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< LVecBase2f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_subdata_43_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_subdata_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_44(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase2f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase2f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_44_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_45(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase2f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase2f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_45_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
 * inline ::ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< LVecBase2f >::ConstPointerToArray(ConstPointerToArray< LVecBase2f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< LVecBase2f > *param0_this = (ConstPointerToArray< LVecBase2f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_LVecBase2f, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase2f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< LVecBase2f >::ConstPointerToArray(PointerToArray< LVecBase2f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< LVecBase2f > *param0_this = (PointerToArray< LVecBase2f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase2f, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase2f > *return_value = new ConstPointerToArray< LVecBase2f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase2f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_LVecBase2f)
    {
        printf("ConstPointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< LVecBase2f > * local_this = (ConstPointerToArray< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase2f)
        return ( PointerToArrayBase< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase2f > > *)( PointerToArrayBase< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase2f > > *)( PointerToArrayBase< LVecBase2f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase2f)
    {
          PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
          return (ConstPointerToArray< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
          return (ConstPointerToArray< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< LVecBase2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< LVecBase2f > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< LVecBase2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_LVecBase2f)
    {
        printf("PointerToArrayBase_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< LVecBase2f > * local_this = (PointerToArrayBase< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase2f > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
          return (PointerToArrayBase< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< LVecBase2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< LVecBase2f > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_35(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< LVecBase2f > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_35_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_36(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase2f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< LVecBase2f > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< LVecBase2f > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_36_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_36_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< LVecBase2f > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
    {
        printf("PointerToBase_ReferenceCountedVector_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< LVecBase2f > > * local_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< LVecBase3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< LVecBase3f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_size_54(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< LVecBase3f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< LVecBase3f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_size_54_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_size_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::ConstPointerToArray< LVecBase3f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_element_55(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::ConstPointerToArray< LVecBase3f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase3f const *return_value = &(((const ConstPointerToArray< LVecBase3f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_element_55_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_element_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::ConstPointerToArray< LVecBase3f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_getitem_56(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::ConstPointerToArray< LVecBase3f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< LVecBase3f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase3f const *return_value = &(((const ConstPointerToArray< LVecBase3f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_getitem_56_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_getitem_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase3f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_data_57(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase3f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< LVecBase3f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_data_57_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_data_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase3f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_subdata_58(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase3f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< LVecBase3f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_subdata_58_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_subdata_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_59(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase3f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase3f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_59_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_60(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase3f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase3f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_60_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
 * inline ::ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< LVecBase3f >::ConstPointerToArray(ConstPointerToArray< LVecBase3f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< LVecBase3f > *param0_this = (ConstPointerToArray< LVecBase3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_LVecBase3f, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase3f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< LVecBase3f >::ConstPointerToArray(PointerToArray< LVecBase3f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< LVecBase3f > *param0_this = (PointerToArray< LVecBase3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase3f, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase3f > *return_value = new ConstPointerToArray< LVecBase3f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase3f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_LVecBase3f)
    {
        printf("ConstPointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< LVecBase3f > * local_this = (ConstPointerToArray< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase3f)
        return ( PointerToArrayBase< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase3f > > *)( PointerToArrayBase< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase3f > > *)( PointerToArrayBase< LVecBase3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase3f)
    {
          PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
          return (ConstPointerToArray< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
          return (ConstPointerToArray< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< LVecBase3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< LVecBase3f > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< LVecBase3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_LVecBase3f)
    {
        printf("PointerToArrayBase_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< LVecBase3f > * local_this = (PointerToArrayBase< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase3f > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
          return (PointerToArrayBase< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< LVecBase3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< LVecBase3f > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_50(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< LVecBase3f > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_50_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_51(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< LVecBase3f > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< LVecBase3f > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_51_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_51_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< LVecBase3f > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
    {
        printf("PointerToBase_ReferenceCountedVector_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< LVecBase3f > > * local_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConstPointerToArray< LVecBase4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::ConstPointerToArray< LVecBase4f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_size_69(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::ConstPointerToArray< LVecBase4f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const ConstPointerToArray< LVecBase4f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_size_69_comment =
    "C++ Interface:\n"
    "size(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_size_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::ConstPointerToArray< LVecBase4f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_get_element_70(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::ConstPointerToArray< LVecBase4f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase4f const *return_value = &(((const ConstPointerToArray< LVecBase4f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_element_70_comment =
    "C++ Interface:\n"
    "getElement(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_element_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::ConstPointerToArray< LVecBase4f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_getitem_71(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::ConstPointerToArray< LVecBase4f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const ConstPointerToArray< LVecBase4f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase4f const *return_value = &(((const ConstPointerToArray< LVecBase4f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const ConstPointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_getitem_71_comment =
    "C++ Interface:\n"
    "Getitem(const ConstPointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_getitem_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase4f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_get_data_72(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase4f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ConstPointerToArray< LVecBase4f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_data_72_comment =
    "C++ Interface:\n"
    "getData(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_data_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::ConstPointerToArray< LVecBase4f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_get_subdata_73(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::ConstPointerToArray< LVecBase4f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const ConstPointerToArray< LVecBase4f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_subdata_73_comment =
    "C++ Interface:\n"
    "getSubdata(const ConstPointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_subdata_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase4f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_get_ref_count_74(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase4f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase4f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_ref_count_74_comment =
    "C++ Interface:\n"
    "getRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_ref_count_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::ConstPointerToArray< LVecBase4f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_ConstPointerToArray_LVecBase4f_get_node_ref_count_75(PyObject *self, PyObject *args,PyObject *kwds) {
    ConstPointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConstPointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::ConstPointerToArray< LVecBase4f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ConstPointerToArray< LVecBase4f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const ConstPointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_node_ref_count_75_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const ConstPointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_ConstPointerToArray_LVecBase4f_get_node_ref_count_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::ConstPointerToArray< LVecBase4f >::ConstPointerToArray(ConstPointerToArray< LVecBase4f > const &copy)
 * inline ::ConstPointerToArray< LVecBase4f >::ConstPointerToArray(PointerToArray< LVecBase4f > const &copy)
 *******************************************************************/
int  Dtool_Init_ConstPointerToArray_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline ::ConstPointerToArray< LVecBase4f >::ConstPointerToArray(ConstPointerToArray< LVecBase4f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< LVecBase4f > *param0_this = (ConstPointerToArray< LVecBase4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ConstPointerToArray_LVecBase4f, 0, "ConstPointerToArray.ConstPointerToArray", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase4f > *return_value = new ConstPointerToArray< LVecBase4f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase4f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline ::ConstPointerToArray< LVecBase4f >::ConstPointerToArray(PointerToArray< LVecBase4f > const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConstPointerToArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConstPointerToArray", &param0));
            if(!PyErr_Occurred())
            {
                PointerToArray< LVecBase4f > *param0_this = (PointerToArray< LVecBase4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase4f, 0, "ConstPointerToArray.ConstPointerToArray", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConstPointerToArray< LVecBase4f > *return_value = new ConstPointerToArray< LVecBase4f >(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConstPointerToArray_LVecBase4f,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConstPointerToArray(const ConstPointerToArray copy)\n"
          "ConstPointerToArray(const PointerToArray copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConstPointerToArray_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConstPointerToArray_LVecBase4f)
    {
        printf("ConstPointerToArray_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConstPointerToArray< LVecBase4f > * local_this = (ConstPointerToArray< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConstPointerToArray_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase4f)
        return ( PointerToArrayBase< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase4f > > *)( PointerToArrayBase< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase4f > > *)( PointerToArrayBase< LVecBase4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConstPointerToArray_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConstPointerToArray_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase4f)
    {
          PointerToArrayBase< LVecBase4f >* other_this = (PointerToArrayBase< LVecBase4f >*)from_this;
          return (ConstPointerToArray< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase4f > >*)from_this;
          return (ConstPointerToArray< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (ConstPointerToArray< LVecBase4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArrayBase< LVecBase4f > 
//********************************************************************
int  Dtool_Init_PointerToArrayBase_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToArrayBase< LVecBase4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToArrayBase_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArrayBase_LVecBase4f)
    {
        printf("PointerToArrayBase_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArrayBase< LVecBase4f > * local_this = (PointerToArrayBase< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase4f > > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase4f > > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArrayBase_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase4f > >*)from_this;
          return (PointerToArrayBase< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArrayBase< LVecBase4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToBase< ReferenceCountedVector< LVecBase4f > > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToBase< ReferenceCountedVector< LVecBase4f > >::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_clear_65(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToBase< ReferenceCountedVector< LVecBase4f > >::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToBase.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerToBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_clear_65_comment =
    "C++ Interface:\n"
    "clear(non-const PointerToBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_clear_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ::PointerToBase< ReferenceCountedVector< LVecBase4f > >::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_output_66(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToBase< ReferenceCountedVector< LVecBase4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ::PointerToBase< ReferenceCountedVector< LVecBase4f > >::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PointerToBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PointerToBase< ReferenceCountedVector< LVecBase4f > >*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PointerToBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_output_66_comment =
    "C++ Interface:\n"
    "output(const PointerToBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_output_66_comment = NULL;
#endif

int  Dtool_Init_PointerToBase_ReferenceCountedVector_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PointerToBase< ReferenceCountedVector< LVecBase4f > >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
    {
        printf("PointerToBase_ReferenceCountedVector_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToBase< ReferenceCountedVector< LVecBase4f > > * local_this = (PointerToBase< ReferenceCountedVector< LVecBase4f > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToBase< ReferenceCountedVector< LVecBase4f > >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Frustumd 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Frustumd::make_ortho_2D(void)
 * inline void Frustumd::make_ortho_2D(double l, double r, double t, double b)
 *******************************************************************/
static PyObject *Dtool_Frustumd_make_ortho_2D_79(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumd * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumd,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumd::make_ortho_2D(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeOrtho2D", key_word_list));
            else
                (PyArg_Parse(args, ":makeOrtho2D"));
            if(!PyErr_Occurred())
            {
                (local_this)->make_ortho_2D();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrustumD.makeOrtho2D() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumd::make_ortho_2D(double l, double r, double t, double b)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"t", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makeOrtho2D", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->make_ortho_2D((double)param1, (double)param2, (double)param3, (double)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrustumD.makeOrtho2D() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeOrtho2D() takes 1 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeOrtho2D(non-const FrustumD this)\n"
          "makeOrtho2D(non-const FrustumD this, float l, float r, float t, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumd_make_ortho_2D_79_comment =
    "C++ Interface:\n"
    "makeOrtho2D(non-const FrustumD this)\n"
    "makeOrtho2D(non-const FrustumD this, float l, float r, float t, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumd_make_ortho_2D_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumd::make_ortho(double fnear, double ffar)
 * inline void Frustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
 *******************************************************************/
static PyObject *Dtool_Frustumd_make_ortho_80(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumd * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumd,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumd::make_ortho(double fnear, double ffar)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"fnear", (char *)"ffar", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:makeOrtho", key_word_list, &param1, &param2))
            {
                (local_this)->make_ortho((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrustumD.makeOrtho() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumd::make_ortho(double fnear, double ffar, double l, double r, double t, double b)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fnear", (char *)"ffar", (char *)"l", (char *)"r", (char *)"t", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:makeOrtho", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->make_ortho((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call FrustumD.makeOrtho() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeOrtho() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeOrtho(non-const FrustumD this, float fnear, float ffar)\n"
          "makeOrtho(non-const FrustumD this, float fnear, float ffar, float l, float r, float t, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumd_make_ortho_80_comment =
    "C++ Interface:\n"
    "makeOrtho(non-const FrustumD this, float fnear, float ffar)\n"
    "makeOrtho(non-const FrustumD this, float fnear, float ffar, float l, float r, float t, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumd_make_ortho_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumd_make_perspective_hfov_81(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumd * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumd,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumd::make_perspective_hfov(double xfov, double aspect, double fnear, double ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xfov", (char *)"aspect", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspectiveHfov", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective_hfov((double)param1, (double)param2, (double)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrustumD.makePerspectiveHfov() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspectiveHfov(non-const FrustumD this, float xfov, float aspect, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumd_make_perspective_hfov_81_comment =
    "C++ Interface:\n"
    "makePerspectiveHfov(non-const FrustumD this, float xfov, float aspect, float fnear, float ffar)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_perspective\n"
    "//       Access:\n"
    "//  Description: Behaves like gluPerspective (Aspect = width/height,\n"
    "//               Yfov in degrees)\n"
    "//       aspect\n"
    "//   +------------+\n"
    "//   |            |\n"
    "// 1 |            | yfov\n"
    "//   |            |\n"
    "//   +------------+\n"
    "//\n"
    "//     -------+------\n"
    "//      \\     |     /\n"
    "//       \\    |    /\n"
    "//        \\   |   /\n"
    "//         \\  |  /\n"
    "//          \\ | /\n"
    "//           \\|/\n"
    "//            W yfov\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_perspective\n"
    "//       Access:\n"
    "//  Description: Behaves like gluPerspective (Aspect = width/height,\n"
    "//               Yfov in degrees)\n"
    "//       aspect\n"
    "//   +------------+\n"
    "//   |            |\n"
    "// 1 |            | yfov\n"
    "//   |            |\n"
    "//   +------------+\n"
    "//\n"
    "//     -------+------\n"
    "//      \\     |     /\n"
    "//       \\    |    /\n"
    "//        \\   |   /\n"
    "//         \\  |  /\n"
    "//          \\ | /\n"
    "//           \\|/\n"
    "//            W yfov\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumd_make_perspective_hfov_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumd_make_perspective_vfov_82(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumd * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumd,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumd::make_perspective_vfov(double yfov, double aspect, double fnear, double ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"yfov", (char *)"aspect", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspectiveVfov", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective_vfov((double)param1, (double)param2, (double)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrustumD.makePerspectiveVfov() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspectiveVfov(non-const FrustumD this, float yfov, float aspect, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumd_make_perspective_vfov_82_comment =
    "C++ Interface:\n"
    "makePerspectiveVfov(non-const FrustumD this, float yfov, float aspect, float fnear, float ffar)\n"
    "\n"
    "";
#else
static const char * Dtool_Frustumd_make_perspective_vfov_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumd_make_perspective_83(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumd * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumd,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumd::make_perspective(double xfov, double yfov, double fnear, double ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xfov", (char *)"yfov", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspective", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective((double)param1, (double)param2, (double)param3, (double)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call FrustumD.makePerspective() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspective(non-const FrustumD this, float xfov, float yfov, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumd_make_perspective_83_comment =
    "C++ Interface:\n"
    "makePerspective(non-const FrustumD this, float xfov, float yfov, float fnear, float ffar)\n"
    "\n"
    "";
#else
static const char * Dtool_Frustumd_make_perspective_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Frustumd::Frustumd(void)
 *******************************************************************/
int  Dtool_Init_Frustumd(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Frustumd::Frustumd(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Frustumd", key_word_list))
        {
            Frustumd *return_value = new Frustumd();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Frustumd,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Frustumd()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Frustumd(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Frustumd)
    {
        printf("Frustumd ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Frustumd * local_this = (Frustumd *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Frustumd)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Frustumd(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Frustumd)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Frustumf 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Frustumf::make_ortho_2D(void)
 * inline void Frustumf::make_ortho_2D(float l, float r, float t, float b)
 *******************************************************************/
static PyObject *Dtool_Frustumf_make_ortho_2D_88(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumf::make_ortho_2D(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":makeOrtho2D", key_word_list));
            else
                (PyArg_Parse(args, ":makeOrtho2D"));
            if(!PyErr_Occurred())
            {
                (local_this)->make_ortho_2D();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Frustum.makeOrtho2D() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumf::make_ortho_2D(float l, float r, float t, float b)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"t", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makeOrtho2D", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->make_ortho_2D((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Frustum.makeOrtho2D() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeOrtho2D() takes 1 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeOrtho2D(non-const Frustum this)\n"
          "makeOrtho2D(non-const Frustum this, float l, float r, float t, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumf_make_ortho_2D_88_comment =
    "C++ Interface:\n"
    "makeOrtho2D(non-const Frustum this)\n"
    "makeOrtho2D(non-const Frustum this, float l, float r, float t, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Sets up a two-dimensional orthographic frustum\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumf_make_ortho_2D_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumf::make_ortho(float fnear, float ffar)
 * inline void Frustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
 *******************************************************************/
static PyObject *Dtool_Frustumf_make_ortho_89(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumf::make_ortho(float fnear, float ffar)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"fnear", (char *)"ffar", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:makeOrtho", key_word_list, &param1, &param2))
            {
                (local_this)->make_ortho((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Frustum.makeOrtho() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Frustumf::make_ortho(float fnear, float ffar, float l, float r, float t, float b)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fnear", (char *)"ffar", (char *)"l", (char *)"r", (char *)"t", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:makeOrtho", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->make_ortho((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Frustum.makeOrtho() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "makeOrtho() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "makeOrtho(non-const Frustum this, float fnear, float ffar)\n"
          "makeOrtho(non-const Frustum this, float fnear, float ffar, float l, float r, float t, float b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumf_make_ortho_89_comment =
    "C++ Interface:\n"
    "makeOrtho(non-const Frustum this, float fnear, float ffar)\n"
    "makeOrtho(non-const Frustum this, float fnear, float ffar, float l, float r, float t, float b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_ortho_2D\n"
    "//       Access:\n"
    "//  Description: Behaves like gluOrtho\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumf_make_ortho_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumf_make_perspective_hfov_90(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumf::make_perspective_hfov(float xfov, float aspect, float fnear, float ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xfov", (char *)"aspect", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspectiveHfov", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective_hfov((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Frustum.makePerspectiveHfov() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspectiveHfov(non-const Frustum this, float xfov, float aspect, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumf_make_perspective_hfov_90_comment =
    "C++ Interface:\n"
    "makePerspectiveHfov(non-const Frustum this, float xfov, float aspect, float fnear, float ffar)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: make_perspective\n"
    "//       Access:\n"
    "//  Description: Behaves like gluPerspective (Aspect = width/height,\n"
    "//               Yfov in degrees)\n"
    "//       aspect\n"
    "//   +------------+\n"
    "//   |            |\n"
    "// 1 |            | yfov\n"
    "//   |            |\n"
    "//   +------------+\n"
    "//\n"
    "//     -------+------\n"
    "//      \\     |     /\n"
    "//       \\    |    /\n"
    "//        \\   |   /\n"
    "//         \\  |  /\n"
    "//          \\ | /\n"
    "//           \\|/\n"
    "//            W yfov\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Frustumf_make_perspective_hfov_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumf_make_perspective_vfov_91(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumf::make_perspective_vfov(float yfov, float aspect, float fnear, float ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"yfov", (char *)"aspect", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspectiveVfov", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective_vfov((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Frustum.makePerspectiveVfov() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspectiveVfov(non-const Frustum this, float yfov, float aspect, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumf_make_perspective_vfov_91_comment =
    "C++ Interface:\n"
    "makePerspectiveVfov(non-const Frustum this, float yfov, float aspect, float fnear, float ffar)\n"
    "\n"
    "";
#else
static const char * Dtool_Frustumf_make_perspective_vfov_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Frustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
 *******************************************************************/
static PyObject *Dtool_Frustumf_make_perspective_92(PyObject *self, PyObject *args,PyObject *kwds) {
    Frustumf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Frustumf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Frustumf::make_perspective(float xfov, float yfov, float fnear, float ffar)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"xfov", (char *)"yfov", (char *)"fnear", (char *)"ffar", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:makePerspective", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->make_perspective((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Frustum.makePerspective() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makePerspective(non-const Frustum this, float xfov, float yfov, float fnear, float ffar)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Frustumf_make_perspective_92_comment =
    "C++ Interface:\n"
    "makePerspective(non-const Frustum this, float xfov, float yfov, float fnear, float ffar)\n"
    "\n"
    "";
#else
static const char * Dtool_Frustumf_make_perspective_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Frustumf::Frustumf(void)
 *******************************************************************/
int  Dtool_Init_Frustumf(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline Frustumf::Frustumf(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Frustumf", key_word_list))
        {
            Frustumf *return_value = new Frustumf();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Frustumf,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Frustumf()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Frustumf(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Frustumf)
    {
        printf("Frustumf ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Frustumf * local_this = (Frustumf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Frustumf)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Frustumf(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Frustumf)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Planed 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Planed Planed::operator *(LMatrix3d const &mat) const
 * inline Planed Planed::operator *(LMatrix4d const &mat) const
 *******************************************************************/
static PyObject *Dtool_Planed_operator_98(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline Planed Planed::operator *(LMatrix3d const &mat) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3d *param1_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3d, 1, "PlaneD.__mul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Planed result = ((const Planed*)local_this)->operator *(*param1_this);
                    Planed *return_value = new Planed(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Planed,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline Planed Planed::operator *(LMatrix4d const &mat) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4d *param1_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4d, 1, "PlaneD.__mul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Planed result = ((const Planed*)local_this)->operator *(*param1_this);
                    Planed *return_value = new Planed(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Planed,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__mul__(const PlaneD this, const Mat3D mat)\n"
          "__mul__(const PlaneD this, const Mat4D mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_operator_98_comment =
    "C++ Interface:\n"
    "__mul__(const PlaneD this, const Mat3D mat)\n"
    "__mul__(const PlaneD this, const Mat4D mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix3\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix3\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_operator_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Planed::operator *=(LMatrix4d const &mat)
 *******************************************************************/
static PyObject *Dtool_Planed_operator_99(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Planed::operator *=(LMatrix4d const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__imul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__imul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4d *param1_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4d, 1, "PlaneD.__imul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator *=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PlaneD.__imul__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__imul__(non-const PlaneD this, const Mat4D mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_operator_99_comment =
    "C++ Interface:\n"
    "__imul__(non-const PlaneD this, const Mat4D mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator *= LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator *= LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_operator_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Planed::xform(LMatrix4d const &mat)
 *******************************************************************/
static PyObject *Dtool_Planed_xform_100(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Planed::xform(LMatrix4d const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4d *param1_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4d, 1, "PlaneD.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PlaneD.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const PlaneD this, const Mat4D mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_xform_100_comment =
    "C++ Interface:\n"
    "xform(non-const PlaneD this, const Mat4D mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::xform\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::xform\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_xform_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planed Planed::operator -(void) const
 *******************************************************************/
static PyObject *Dtool_Planed_operator_101(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planed Planed::operator -(void) const
        {
            Planed result = ((const Planed*)local_this)->operator -();
            Planed *return_value = new Planed(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planed,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__neg__(const PlaneD this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_operator_101_comment =
    "C++ Interface:\n"
    "__neg__(const PlaneD this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Unary -\n"
    "//       Access: Published\n"
    "//  Description: Returns the same plane facing the opposite direction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Unary -\n"
    "//       Access: Published\n"
    "//  Description: Returns the same plane facing the opposite direction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_operator_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4d Planed::get_reflection_mat(void) const
 *******************************************************************/
static PyObject *Dtool_Planed_get_reflection_mat_102(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LMatrix4d Planed::get_reflection_mat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReflectionMat", key_word_list));
        else
            (PyArg_Parse(args, ":getReflectionMat"));
        if(!PyErr_Occurred())
        {
            LMatrix4d result = ((const Planed*)local_this)->get_reflection_mat();
            LMatrix4d *return_value = new LMatrix4d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReflectionMat(const PlaneD this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_get_reflection_mat_102_comment =
    "C++ Interface:\n"
    "getReflectionMat(const PlaneD this)\n"
    "\n"
    "// Filename: plane_src.cxx\n"
    "// Created by:  drose (03Apr01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_reflection_mat\n"
    "//       Access: Published\n"
    "//  Description: This computes a transform matrix that reflects the\n"
    "//               universe to the other side of the plane, as in a\n"
    "//               mirror.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_get_reflection_mat_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3d Planed::get_normal(void) const
 *******************************************************************/
static PyObject *Dtool_Planed_get_normal_103(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3d Planed::get_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getNormal"));
        if(!PyErr_Occurred())
        {
            LVector3d result = ((const Planed*)local_this)->get_normal();
            LVector3d *return_value = new LVector3d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormal(const PlaneD this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_get_normal_103_comment =
    "C++ Interface:\n"
    "getNormal(const PlaneD this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the surface normal of the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the surface normal of the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_get_normal_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3d Planed::get_point(void) const
 *******************************************************************/
static PyObject *Dtool_Planed_get_point_104(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3d Planed::get_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getPoint"));
        if(!PyErr_Occurred())
        {
            LPoint3d result = ((const Planed*)local_this)->get_point();
            LPoint3d *return_value = new LPoint3d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const PlaneD this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_get_point_104_comment =
    "C++ Interface:\n"
    "getPoint(const PlaneD this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns an arbitrary point in the plane.  This can be\n"
    "//               used along with the normal returned by get_normal()\n"
    "//               to reconstruct the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_get_point_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double Planed::dist_to_plane(LPoint3d const &point) const
 *******************************************************************/
static PyObject *Dtool_Planed_dist_to_plane_105(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline double Planed::dist_to_plane(LPoint3d const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:distToPlane", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:distToPlane", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.distToPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    double return_value = ((const Planed*)local_this)->dist_to_plane(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "distToPlane(const PlaneD this, const Point3D point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_dist_to_plane_105_comment =
    "C++ Interface:\n"
    "distToPlane(const PlaneD this, const Point3D point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::dist_to_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the straight-line shortest distance from the\n"
    "//               point to the plane.  The returned value is positive\n"
    "//               if the point is in front of the plane (on the side\n"
    "//               with the normal), or negative in the point is behind\n"
    "//               the plane (on the opposite side from the normal).\n"
    "//               It's zero if the point is exactly in the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::dist_to_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the straight-line shortest distance from the\n"
    "//               point to the plane.  The returned value is positive\n"
    "//               if the point is in front of the plane (on the side\n"
    "//               with the normal), or negative in the point is behind\n"
    "//               the plane (on the opposite side from the normal).\n"
    "//               It's zero if the point is exactly in the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_dist_to_plane_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3d Planed::project(LPoint3d const &point) const
 *******************************************************************/
static PyObject *Dtool_Planed_project_106(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline LPoint3d Planed::project(LPoint3d const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:project", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:project", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.project", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LPoint3d result = ((const Planed*)local_this)->project(*param1_this);
                    LPoint3d *return_value = new LPoint3d(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3d,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "project(const PlaneD this, const Point3D point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_project_106_comment =
    "C++ Interface:\n"
    "project(const PlaneD this, const Point3D point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::project\n"
    "//       Access: Published\n"
    "//  Description: Returns the point within the plane nearest to the\n"
    "//               indicated point in space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::project\n"
    "//       Access: Published\n"
    "//  Description: Returns the point within the plane nearest to the\n"
    "//               indicated point in space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_project_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Planed::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
 *******************************************************************/
static PyObject *Dtool_Planed_intersects_line_107(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Planed::intersects_line(LPoint3d &intersection_point, LPoint3d const &p1, LPoint3d const &p2) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"intersection_point", (char *)"p1", (char *)"p2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:intersectsLine", key_word_list, &param1, &param2, &param3))
            {
                LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.intersectsLine", 0, coerced_ptr, report_errors);
LPoint3d *param2_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3d, 2, "PlaneD.intersectsLine", 1, coerced_ptr, report_errors);
LPoint3d *param3_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3d, 3, "PlaneD.intersectsLine", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const Planed*)local_this)->intersects_line(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "intersectsLine(const PlaneD this, non-const Point3D intersection_point, const Point3D p1, const Point3D p2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_intersects_line_107_comment =
    "C++ Interface:\n"
    "intersectsLine(const PlaneD this, non-const Point3D intersection_point, const Point3D p1, const Point3D p2)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the plane intersects the infinite\n"
    "//               line passing through points p1 and p2, false if the\n"
    "//               line is parallel.  The points p1 and p2 are used only\n"
    "//               to define the Euclidean line; they have no other\n"
    "//               bearing on the intersection test.  If true, sets\n"
    "//               intersection_point to the point of intersection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: This flavor of intersects_line() returns a bit more\n"
    "//               information about the nature of the intersecting\n"
    "//               point.  The line is defined via the parametric\n"
    "//               equation from + t * delta for all real values of t.\n"
    "//\n"
    "//               If there is no intersection with the plane, the\n"
    "//               function returns false and leaves t undefined.  If\n"
    "//               there is an intersection with the plane, the function\n"
    "//               returns true and sets t to the parametric value that\n"
    "//               defines the point of intersection.  That is, t == 0.0f\n"
    "//               implies that the intersection occurred exactly at\n"
    "//               point from, and t == 1.0f implies at point from +\n"
    "//               delta, with other values of t accordingly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the plane intersects the infinite\n"
    "//               line passing through points p1 and p2, false if the\n"
    "//               line is parallel.  The points p1 and p2 are used only\n"
    "//               to define the Euclidean line; they have no other\n"
    "//               bearing on the intersection test.  If true, sets\n"
    "//               intersection_point to the point of intersection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: This flavor of intersects_line() returns a bit more\n"
    "//               information about the nature of the intersecting\n"
    "//               point.  The line is defined via the parametric\n"
    "//               equation from + t * delta for all real values of t.\n"
    "//\n"
    "//               If there is no intersection with the plane, the\n"
    "//               function returns false and leaves t undefined.  If\n"
    "//               there is an intersection with the plane, the function\n"
    "//               returns true and sets t to the parametric value that\n"
    "//               defines the point of intersection.  That is, t == 0.0f\n"
    "//               implies that the intersection occurred exactly at\n"
    "//               point from, and t == 1.0f implies at point from +\n"
    "//               delta, with other values of t accordingly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_intersects_line_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Planed::intersects_plane(LPoint3d &from, LVector3d &delta, Planed const &other) const
 *******************************************************************/
static PyObject *Dtool_Planed_intersects_plane_108(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool Planed::intersects_plane(LPoint3d &from, LVector3d &delta, Planed const &other) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"from", (char *)"delta", (char *)"other", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:intersectsPlane", key_word_list, &param1, &param2, &param3))
            {
                LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.intersectsPlane", 0, coerced_ptr, report_errors);
LVector3d *param2_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3d, 2, "PlaneD.intersectsPlane", 0, coerced_ptr, report_errors);
Planed *param3_this = (Planed *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Planed, 3, "PlaneD.intersectsPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const Planed*)local_this)->intersects_plane(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "intersectsPlane(const PlaneD this, non-const Point3D from, non-const Vec3D delta, const PlaneD other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_intersects_plane_108_comment =
    "C++ Interface:\n"
    "intersectsPlane(const PlaneD this, non-const Point3D from, non-const Vec3D delta, const PlaneD other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the two planes intersect, false if\n"
    "//               they do not.  If they do intersect, then from and\n"
    "//               delta are filled in with the parametric\n"
    "//               representation of the line of intersection: that is,\n"
    "//               from is a point on that line, and delta is a vector\n"
    "//               showing the direction of the line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_intersects_plane_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Planed::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Planed_output_110(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Planed::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PlaneD.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Planed*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PlaneD this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_output_110_comment =
    "C++ Interface:\n"
    "output(const PlaneD this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_output_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Planed::write(ostream &out, int indent_level) const
 * void Planed::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_Planed_write_111(PyObject *self, PyObject *args,PyObject *kwds) {
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Planed::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PlaneD.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Planed*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Planed::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PlaneD.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Planed*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PlaneD this, non-const Ostream out)\n"
          "write(const PlaneD this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planed_write_111_comment =
    "C++ Interface:\n"
    "write(const PlaneD this, non-const Ostream out)\n"
    "write(const PlaneD this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planed_write_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planed::Planed(void)
 * inline Planed::Planed(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
 * inline Planed::Planed(LVecBase4d const &copy)
 * inline Planed::Planed(LVector3d const &normal, LPoint3d const &point)
 * inline Planed::Planed(double a, double b, double c, double d)
 *******************************************************************/
int  Dtool_Init_Planed(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Planed::Planed(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Planed", key_word_list))
            {
                Planed *return_value = new Planed();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Planed,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planed::Planed(LVecBase4d const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Planed", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Planed", &param0));
                if(!PyErr_Occurred())
                {
                    LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4d, 0, "PlaneD.Planed", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Planed *return_value = new Planed(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planed,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planed::Planed(LVector3d const &normal, LPoint3d const &point)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"normal", (char *)"point", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Planed", key_word_list, &param0, &param1))
                {
                    LVector3d *param0_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVector3d, 0, "PlaneD.Planed", 1, coerced_ptr, report_errors);
LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.Planed", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        Planed *return_value = new Planed(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planed,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planed::Planed(LPoint3d const &a, LPoint3d const &b, LPoint3d const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:Planed", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3d *param0_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3d, 0, "PlaneD.Planed", 1, coerced_ptr, report_errors);
LPoint3d *param1_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3d, 1, "PlaneD.Planed", 1, coerced_ptr, report_errors);
LPoint3d *param2_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3d, 2, "PlaneD.Planed", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        Planed *return_value = new Planed(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planed,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-inline Planed::Planed(double a, double b, double c, double d)
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:Planed", key_word_list, &param0, &param1, &param2, &param3))
            {
                Planed *return_value = new Planed((double)param0, (double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Planed,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Planed() takes 0, 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Planed()\n"
          "Planed(const VBase4D copy)\n"
          "Planed(const Vec3D normal, const Point3D point)\n"
          "Planed(const Point3D a, const Point3D b, const Point3D c)\n"
          "Planed(float a, float b, float c, float d)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Planed(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Planed)
    {
        printf("Planed ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Planed * local_this = (Planed *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Planed)
        return local_this;
    if(requested_type == &Dtool_LVecBase4d)
        return ( LVecBase4d *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Planed(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Planed)
        return from_this;
    if(from_type == &Dtool_LVecBase4d)
    {
          LVecBase4d* other_this = (LVecBase4d*)from_this;
          return (Planed*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Planef 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Planef Planef::operator *(LMatrix3f const &mat) const
 * inline Planef Planef::operator *(LMatrix4f const &mat) const
 *******************************************************************/
static PyObject *Dtool_Planef_operator_116(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 inline Planef Planef::operator *(LMatrix3f const &mat) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "Plane.__mul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Planef result = ((const Planef*)local_this)->operator *(*param1_this);
                    Planef *return_value = new Planef(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 inline Planef Planef::operator *(LMatrix4f const &mat) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__mul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__mul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "Plane.__mul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    Planef result = ((const Planef*)local_this)->operator *(*param1_this);
                    Planef *return_value = new Planef(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__mul__(const Plane this, const Mat3 mat)\n"
          "__mul__(const Plane this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_operator_116_comment =
    "C++ Interface:\n"
    "__mul__(const Plane this, const Mat3 mat)\n"
    "__mul__(const Plane this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix3\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator * LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_operator_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Planef::operator *=(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_Planef_operator_117(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Planef::operator *=(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__imul__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__imul__", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "Plane.__imul__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator *=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Plane.__imul__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__imul__(non-const Plane this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_operator_117_comment =
    "C++ Interface:\n"
    "__imul__(non-const Plane this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Operator *= LMatrix4\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_operator_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Planef::xform(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_Planef_xform_118(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Planef::xform(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "Plane.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Plane.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const Plane this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_xform_118_comment =
    "C++ Interface:\n"
    "xform(non-const Plane this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::xform\n"
    "//       Access: Published\n"
    "//  Description: Transforms the plane by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_xform_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef Planef::operator -(void) const
 *******************************************************************/
static PyObject *Dtool_Planef_operator_119(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef Planef::operator -(void) const
        {
            Planef result = ((const Planef*)local_this)->operator -();
            Planef *return_value = new Planef(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__neg__(const Plane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_operator_119_comment =
    "C++ Interface:\n"
    "__neg__(const Plane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::Unary -\n"
    "//       Access: Published\n"
    "//  Description: Returns the same plane facing the opposite direction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_operator_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4f Planef::get_reflection_mat(void) const
 *******************************************************************/
static PyObject *Dtool_Planef_get_reflection_mat_120(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LMatrix4f Planef::get_reflection_mat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReflectionMat", key_word_list));
        else
            (PyArg_Parse(args, ":getReflectionMat"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const Planef*)local_this)->get_reflection_mat();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReflectionMat(const Plane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_get_reflection_mat_120_comment =
    "C++ Interface:\n"
    "getReflectionMat(const Plane this)\n"
    "\n"
    "// Filename: plane_src.cxx\n"
    "// Created by:  drose (03Apr01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_reflection_mat\n"
    "//       Access: Published\n"
    "//  Description: This computes a transform matrix that reflects the\n"
    "//               universe to the other side of the plane, as in a\n"
    "//               mirror.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_get_reflection_mat_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f Planef::get_normal(void) const
 *******************************************************************/
static PyObject *Dtool_Planef_get_normal_121(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f Planef::get_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getNormal"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const Planef*)local_this)->get_normal();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormal(const Plane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_get_normal_121_comment =
    "C++ Interface:\n"
    "getNormal(const Plane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_normal\n"
    "//       Access: Published\n"
    "//  Description: Returns the surface normal of the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_get_normal_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f Planef::get_point(void) const
 *******************************************************************/
static PyObject *Dtool_Planef_get_point_122(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f Planef::get_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getPoint"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const Planef*)local_this)->get_point();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const Plane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_get_point_122_comment =
    "C++ Interface:\n"
    "getPoint(const Plane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns an arbitrary point in the plane.  This can be\n"
    "//               used along with the normal returned by get_normal()\n"
    "//               to reconstruct the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_get_point_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Planef::dist_to_plane(LPoint3f const &point) const
 *******************************************************************/
static PyObject *Dtool_Planef_dist_to_plane_123(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline float Planef::dist_to_plane(LPoint3f const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:distToPlane", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:distToPlane", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.distToPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = ((const Planef*)local_this)->dist_to_plane(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "distToPlane(const Plane this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_dist_to_plane_123_comment =
    "C++ Interface:\n"
    "distToPlane(const Plane this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::dist_to_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the straight-line shortest distance from the\n"
    "//               point to the plane.  The returned value is positive\n"
    "//               if the point is in front of the plane (on the side\n"
    "//               with the normal), or negative in the point is behind\n"
    "//               the plane (on the opposite side from the normal).\n"
    "//               It's zero if the point is exactly in the plane.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_dist_to_plane_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f Planef::project(LPoint3f const &point) const
 *******************************************************************/
static PyObject *Dtool_Planef_project_124(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline LPoint3f Planef::project(LPoint3f const &point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:project", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:project", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.project", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LPoint3f result = ((const Planef*)local_this)->project(*param1_this);
                    LPoint3f *return_value = new LPoint3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "project(const Plane this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_project_124_comment =
    "C++ Interface:\n"
    "project(const Plane this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::project\n"
    "//       Access: Published\n"
    "//  Description: Returns the point within the plane nearest to the\n"
    "//               indicated point in space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_project_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Planef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
 *******************************************************************/
static PyObject *Dtool_Planef_intersects_line_125(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool Planef::intersects_line(LPoint3f &intersection_point, LPoint3f const &p1, LPoint3f const &p2) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"intersection_point", (char *)"p1", (char *)"p2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:intersectsLine", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.intersectsLine", 0, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "Plane.intersectsLine", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "Plane.intersectsLine", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const Planef*)local_this)->intersects_line(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "intersectsLine(const Plane this, non-const Point3 intersection_point, const Point3 p1, const Point3 p2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_intersects_line_125_comment =
    "C++ Interface:\n"
    "intersectsLine(const Plane this, non-const Point3 intersection_point, const Point3 p1, const Point3 p2)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the plane intersects the infinite\n"
    "//               line passing through points p1 and p2, false if the\n"
    "//               line is parallel.  The points p1 and p2 are used only\n"
    "//               to define the Euclidean line; they have no other\n"
    "//               bearing on the intersection test.  If true, sets\n"
    "//               intersection_point to the point of intersection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_line\n"
    "//       Access: Published\n"
    "//  Description: This flavor of intersects_line() returns a bit more\n"
    "//               information about the nature of the intersecting\n"
    "//               point.  The line is defined via the parametric\n"
    "//               equation from + t * delta for all real values of t.\n"
    "//\n"
    "//               If there is no intersection with the plane, the\n"
    "//               function returns false and leaves t undefined.  If\n"
    "//               there is an intersection with the plane, the function\n"
    "//               returns true and sets t to the parametric value that\n"
    "//               defines the point of intersection.  That is, t == 0.0f\n"
    "//               implies that the intersection occurred exactly at\n"
    "//               point from, and t == 1.0f implies at point from +\n"
    "//               delta, with other values of t accordingly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_intersects_line_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Planef::intersects_plane(LPoint3f &from, LVector3f &delta, Planef const &other) const
 *******************************************************************/
static PyObject *Dtool_Planef_intersects_plane_126(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool Planef::intersects_plane(LPoint3f &from, LVector3f &delta, Planef const &other) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"from", (char *)"delta", (char *)"other", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:intersectsPlane", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.intersectsPlane", 0, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "Plane.intersectsPlane", 0, coerced_ptr, report_errors);
Planef *param3_this = (Planef *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Planef, 3, "Plane.intersectsPlane", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const Planef*)local_this)->intersects_plane(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "intersectsPlane(const Plane this, non-const Point3 from, non-const Vec3 delta, const Plane other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_intersects_plane_126_comment =
    "C++ Interface:\n"
    "intersectsPlane(const Plane this, non-const Point3 from, non-const Vec3 delta, const Plane other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::intersects_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the two planes intersect, false if\n"
    "//               they do not.  If they do intersect, then from and\n"
    "//               delta are filled in with the parametric\n"
    "//               representation of the line of intersection: that is,\n"
    "//               from is a point on that line, and delta is a vector\n"
    "//               showing the direction of the line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_intersects_plane_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Planef::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Planef_output_128(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Planef::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Plane.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Planef*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Plane this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_output_128_comment =
    "C++ Interface:\n"
    "output(const Plane this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_output_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Planef::write(ostream &out, int indent_level) const
 * void Planef::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_Planef_write_129(PyObject *self, PyObject *args,PyObject *kwds) {
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Planef::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Plane.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Planef*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Planef::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Plane.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Planef*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Plane this, non-const Ostream out)\n"
          "write(const Plane this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Planef_write_129_comment =
    "C++ Interface:\n"
    "write(const Plane this, non-const Ostream out)\n"
    "write(const Plane this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Plane::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Planef_write_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef::Planef(void)
 * inline Planef::Planef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
 * inline Planef::Planef(LVecBase4f const &copy)
 * inline Planef::Planef(LVector3f const &normal, LPoint3f const &point)
 * inline Planef::Planef(float a, float b, float c, float d)
 *******************************************************************/
int  Dtool_Init_Planef(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Planef::Planef(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Planef", key_word_list))
            {
                Planef *return_value = new Planef();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Planef,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planef::Planef(LVecBase4f const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Planef", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Planef", &param0));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "Plane.Planef", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        Planef *return_value = new Planef(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planef,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planef::Planef(LVector3f const &normal, LPoint3f const &point)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"normal", (char *)"point", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Planef", key_word_list, &param0, &param1))
                {
                    LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVector3f, 0, "Plane.Planef", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.Planef", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        Planef *return_value = new Planef(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planef,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Planef::Planef(LPoint3f const &a, LPoint3f const &b, LPoint3f const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:Planef", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "Plane.Planef", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "Plane.Planef", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "Plane.Planef", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        Planef *return_value = new Planef(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Planef,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-inline Planef::Planef(float a, float b, float c, float d)
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:Planef", key_word_list, &param0, &param1, &param2, &param3))
            {
                Planef *return_value = new Planef((float)param0, (float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Planef,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Planef() takes 0, 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Planef()\n"
          "Planef(const VBase4 copy)\n"
          "Planef(const Vec3 normal, const Point3 point)\n"
          "Planef(const Point3 a, const Point3 b, const Point3 c)\n"
          "Planef(float a, float b, float c, float d)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Planef(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Planef)
    {
        printf("Planef ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Planef * local_this = (Planef *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Planef)
        return local_this;
    if(requested_type == &Dtool_LVecBase4f)
        return ( LVecBase4f *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Planef(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Planef)
        return from_this;
    if(from_type == &Dtool_LVecBase4f)
    {
          LVecBase4f* other_this = (LVecBase4f*)from_this;
          return (Planef*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< LMatrix3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< LMatrix3f > ::PointerToArray< LMatrix3f >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< LMatrix3f > ::PointerToArray< LMatrix3f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LMatrix3f const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_empty_array_133(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< LMatrix3f > ::PointerToArray< LMatrix3f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LMatrix3f const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< LMatrix3f > result = ::PointerToArray< LMatrix3f >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LMatrix3f,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< LMatrix3f > ::PointerToArray< LMatrix3f >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< LMatrix3f > result = ::PointerToArray< LMatrix3f >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LMatrix3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_empty_array_133_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_empty_array_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< LMatrix3f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_size_134(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< LMatrix3f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< LMatrix3f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_size_134_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_size_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_push_back_135(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix3f >::push_back(LMatrix3f const &x)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"x", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pushBack", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "PointerToArray.pushBack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->push_back(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.pushBack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, const Mat3 x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_push_back_135_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, const Mat3 x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_push_back_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_pop_back_136(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix3f >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_pop_back_136_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_pop_back_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f const &::PointerToArray< LMatrix3f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_get_element_137(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f const &::PointerToArray< LMatrix3f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LMatrix3f const *return_value = &(((const PointerToArray< LMatrix3f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_get_element_137_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_get_element_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::set_element(unsigned int n, LMatrix3f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_set_element_138(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix3f >::set_element(unsigned int n, LMatrix3f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LMatrix3f *param2_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix3f, 2, "PointerToArray.setElement", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.setElement() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, const Mat3 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_set_element_138_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, const Mat3 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_set_element_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f const &::PointerToArray< LMatrix3f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_getitem_139(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f const &::PointerToArray< LMatrix3f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< LMatrix3f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LMatrix3f const *return_value = &(((const PointerToArray< LMatrix3f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_getitem_139_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_getitem_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::__setitem__(unsigned int n, LMatrix3f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_setitem_140(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix3f >::__setitem__(unsigned int n, LMatrix3f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LMatrix3f *param2_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix3f, 2, "PointerToArray.Setitem", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                      Py_XDECREF(coerced);
                      PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                      return NULL;
                    }
                    (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.Setitem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, const Mat3 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_setitem_140_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, const Mat3 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_setitem_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LMatrix3f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_get_data_141(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LMatrix3f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< LMatrix3f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_get_data_141_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_get_data_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_set_data_142(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix3f >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_set_data_142_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_set_data_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LMatrix3f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_get_subdata_143(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LMatrix3f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< LMatrix3f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_get_subdata_143_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_get_subdata_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix3f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_set_subdata_144(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix3f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_set_subdata_144_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_set_subdata_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LMatrix3f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_get_ref_count_145(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LMatrix3f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LMatrix3f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_get_ref_count_145_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_get_ref_count_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LMatrix3f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix3f_get_node_ref_count_146(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LMatrix3f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LMatrix3f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix3f_get_node_ref_count_146_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix3f_get_node_ref_count_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
 * ::PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LMatrix3f const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LMatrix3f const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix3f,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< LMatrix3f >::PointerToArray(PointerToArray< LMatrix3f > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LMatrix3f > *param0_this = (PointerToArray< LMatrix3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LMatrix3f, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix3f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< LMatrix3f >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix3f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< LMatrix3f >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LMatrix3f, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LMatrix3f > *return_value = new PointerToArray< LMatrix3f >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix3f,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_LMatrix3f)
    {
        printf("PointerToArray_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< LMatrix3f > * local_this = (PointerToArray< LMatrix3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_LMatrix3f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix3f)
        return ( PointerToArrayBase< LMatrix3f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix3f > > *)( PointerToArrayBase< LMatrix3f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix3f > > *)( PointerToArrayBase< LMatrix3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_LMatrix3f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix3f)
    {
          PointerToArrayBase< LMatrix3f >* other_this = (PointerToArrayBase< LMatrix3f >*)from_this;
          return (PointerToArray< LMatrix3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix3f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix3f > >*)from_this;
          return (PointerToArray< LMatrix3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< LMatrix3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< LMatrix4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< LMatrix4f > ::PointerToArray< LMatrix4f >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< LMatrix4f > ::PointerToArray< LMatrix4f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LMatrix4f const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_empty_array_150(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< LMatrix4f > ::PointerToArray< LMatrix4f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LMatrix4f const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< LMatrix4f > result = ::PointerToArray< LMatrix4f >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LMatrix4f,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< LMatrix4f > ::PointerToArray< LMatrix4f >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< LMatrix4f > result = ::PointerToArray< LMatrix4f >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LMatrix4f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_empty_array_150_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_empty_array_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< LMatrix4f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_size_151(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< LMatrix4f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< LMatrix4f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_size_151_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_size_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::push_back(LMatrix4f const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_push_back_152(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix4f >::push_back(LMatrix4f const &x)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"x", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pushBack", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "PointerToArray.pushBack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->push_back(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.pushBack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, const Mat4 x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_push_back_152_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, const Mat4 x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_push_back_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_pop_back_153(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix4f >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_pop_back_153_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_pop_back_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &::PointerToArray< LMatrix4f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_get_element_154(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &::PointerToArray< LMatrix4f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LMatrix4f const *return_value = &(((const PointerToArray< LMatrix4f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_get_element_154_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_get_element_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::set_element(unsigned int n, LMatrix4f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_set_element_155(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix4f >::set_element(unsigned int n, LMatrix4f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "PointerToArray.setElement", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.setElement() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, const Mat4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_set_element_155_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, const Mat4 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_set_element_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &::PointerToArray< LMatrix4f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_getitem_156(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &::PointerToArray< LMatrix4f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< LMatrix4f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LMatrix4f const *return_value = &(((const PointerToArray< LMatrix4f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_getitem_156_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_getitem_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::__setitem__(unsigned int n, LMatrix4f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_setitem_157(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LMatrix4f >::__setitem__(unsigned int n, LMatrix4f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "PointerToArray.Setitem", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                      Py_XDECREF(coerced);
                      PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                      return NULL;
                    }
                    (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.Setitem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, const Mat4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_setitem_157_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, const Mat4 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_setitem_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LMatrix4f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_get_data_158(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LMatrix4f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< LMatrix4f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_get_data_158_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_get_data_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_set_data_159(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix4f >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_set_data_159_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_set_data_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LMatrix4f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_get_subdata_160(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LMatrix4f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< LMatrix4f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_get_subdata_160_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_get_subdata_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LMatrix4f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_set_subdata_161(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LMatrix4f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_set_subdata_161_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_set_subdata_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LMatrix4f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_get_ref_count_162(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LMatrix4f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LMatrix4f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_get_ref_count_162_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_get_ref_count_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LMatrix4f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LMatrix4f_get_node_ref_count_163(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LMatrix4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LMatrix4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LMatrix4f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LMatrix4f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LMatrix4f_get_node_ref_count_163_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LMatrix4f_get_node_ref_count_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< LMatrix4f >::PointerToArray(PointerToArray< LMatrix4f > const &copy)
 * ::PointerToArray< LMatrix4f >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< LMatrix4f >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< LMatrix4f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LMatrix4f const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< LMatrix4f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LMatrix4f const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix4f,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< LMatrix4f >::PointerToArray(PointerToArray< LMatrix4f > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LMatrix4f > *param0_this = (PointerToArray< LMatrix4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LMatrix4f, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix4f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< LMatrix4f >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix4f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< LMatrix4f >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LMatrix4f, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LMatrix4f > *return_value = new PointerToArray< LMatrix4f >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LMatrix4f,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_LMatrix4f)
    {
        printf("PointerToArray_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< LMatrix4f > * local_this = (PointerToArray< LMatrix4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_LMatrix4f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LMatrix4f)
        return ( PointerToArrayBase< LMatrix4f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
        return ( PointerToBase< ReferenceCountedVector< LMatrix4f > > *)( PointerToArrayBase< LMatrix4f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LMatrix4f > > *)( PointerToArrayBase< LMatrix4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_LMatrix4f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LMatrix4f)
    {
          PointerToArrayBase< LMatrix4f >* other_this = (PointerToArrayBase< LMatrix4f >*)from_this;
          return (PointerToArray< LMatrix4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f)
    {
          PointerToBase< ReferenceCountedVector< LMatrix4f > >* other_this = (PointerToBase< ReferenceCountedVector< LMatrix4f > >*)from_this;
          return (PointerToArray< LMatrix4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< LMatrix4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< LVecBase2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< LVecBase2f > ::PointerToArray< LVecBase2f >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< LVecBase2f > ::PointerToArray< LVecBase2f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase2f const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_empty_array_167(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< LVecBase2f > ::PointerToArray< LVecBase2f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase2f const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< LVecBase2f > result = ::PointerToArray< LVecBase2f >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase2f,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< LVecBase2f > ::PointerToArray< LVecBase2f >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< LVecBase2f > result = ::PointerToArray< LVecBase2f >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase2f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_empty_array_167_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_empty_array_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< LVecBase2f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_size_168(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< LVecBase2f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< LVecBase2f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_size_168_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_size_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_push_back_169(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase2f >::push_back(LVecBase2f const &x)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"x", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pushBack", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PointerToArray.pushBack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->push_back(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.pushBack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, const VBase2 x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_push_back_169_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, const VBase2 x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_push_back_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_pop_back_170(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase2f >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_pop_back_170_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_pop_back_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::PointerToArray< LVecBase2f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_get_element_171(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::PointerToArray< LVecBase2f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase2f const *return_value = &(((const PointerToArray< LVecBase2f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_get_element_171_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_get_element_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::set_element(unsigned int n, LVecBase2f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_set_element_172(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase2f >::set_element(unsigned int n, LVecBase2f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase2f *param2_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase2f, 2, "PointerToArray.setElement", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.setElement() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, const VBase2 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_set_element_172_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, const VBase2 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_set_element_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::PointerToArray< LVecBase2f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_getitem_173(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::PointerToArray< LVecBase2f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< LVecBase2f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase2f const *return_value = &(((const PointerToArray< LVecBase2f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_getitem_173_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_getitem_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::__setitem__(unsigned int n, LVecBase2f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_setitem_174(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase2f >::__setitem__(unsigned int n, LVecBase2f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase2f *param2_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase2f, 2, "PointerToArray.Setitem", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                      Py_XDECREF(coerced);
                      PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                      return NULL;
                    }
                    (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.Setitem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, const VBase2 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_setitem_174_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, const VBase2 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_setitem_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase2f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_get_data_175(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase2f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< LVecBase2f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_get_data_175_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_get_data_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_set_data_176(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase2f >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_set_data_176_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_set_data_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase2f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_get_subdata_177(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase2f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< LVecBase2f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_get_subdata_177_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_get_subdata_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase2f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_set_subdata_178(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase2f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_set_subdata_178_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_set_subdata_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase2f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_get_ref_count_179(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase2f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase2f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_get_ref_count_179_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_get_ref_count_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase2f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase2f_get_node_ref_count_180(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase2f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase2f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase2f_get_node_ref_count_180_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase2f_get_node_ref_count_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
 * ::PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase2f const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase2f const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase2f,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< LVecBase2f >::PointerToArray(PointerToArray< LVecBase2f > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase2f > *param0_this = (PointerToArray< LVecBase2f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase2f, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase2f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< LVecBase2f >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase2f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< LVecBase2f >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase2f, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase2f > *return_value = new PointerToArray< LVecBase2f >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase2f,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_LVecBase2f)
    {
        printf("PointerToArray_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< LVecBase2f > * local_this = (PointerToArray< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase2f)
        return ( PointerToArrayBase< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase2f > > *)( PointerToArrayBase< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase2f > > *)( PointerToArrayBase< LVecBase2f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase2f)
    {
          PointerToArrayBase< LVecBase2f >* other_this = (PointerToArrayBase< LVecBase2f >*)from_this;
          return (PointerToArray< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase2f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase2f > >*)from_this;
          return (PointerToArray< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< LVecBase2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< LVecBase3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< LVecBase3f > ::PointerToArray< LVecBase3f >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< LVecBase3f > ::PointerToArray< LVecBase3f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase3f const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_empty_array_184(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< LVecBase3f > ::PointerToArray< LVecBase3f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase3f const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< LVecBase3f > result = ::PointerToArray< LVecBase3f >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase3f,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< LVecBase3f > ::PointerToArray< LVecBase3f >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< LVecBase3f > result = ::PointerToArray< LVecBase3f >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_empty_array_184_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_empty_array_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< LVecBase3f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_size_185(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< LVecBase3f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< LVecBase3f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_size_185_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_size_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_push_back_186(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase3f >::push_back(LVecBase3f const &x)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"x", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pushBack", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PointerToArray.pushBack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->push_back(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.pushBack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, const VBase3 x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_push_back_186_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, const VBase3 x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_push_back_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_pop_back_187(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase3f >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_pop_back_187_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_pop_back_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::PointerToArray< LVecBase3f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_get_element_188(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::PointerToArray< LVecBase3f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase3f const *return_value = &(((const PointerToArray< LVecBase3f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_get_element_188_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_get_element_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::set_element(unsigned int n, LVecBase3f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_set_element_189(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase3f >::set_element(unsigned int n, LVecBase3f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "PointerToArray.setElement", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.setElement() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, const VBase3 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_set_element_189_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, const VBase3 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_set_element_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::PointerToArray< LVecBase3f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_getitem_190(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::PointerToArray< LVecBase3f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< LVecBase3f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase3f const *return_value = &(((const PointerToArray< LVecBase3f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_getitem_190_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_getitem_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::__setitem__(unsigned int n, LVecBase3f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_setitem_191(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase3f >::__setitem__(unsigned int n, LVecBase3f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "PointerToArray.Setitem", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                      Py_XDECREF(coerced);
                      PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                      return NULL;
                    }
                    (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.Setitem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, const VBase3 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_setitem_191_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, const VBase3 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_setitem_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase3f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_get_data_192(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase3f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< LVecBase3f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_get_data_192_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_get_data_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_set_data_193(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase3f >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_set_data_193_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_set_data_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase3f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_get_subdata_194(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase3f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< LVecBase3f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_get_subdata_194_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_get_subdata_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase3f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_set_subdata_195(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase3f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_set_subdata_195_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_set_subdata_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase3f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_get_ref_count_196(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase3f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase3f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_get_ref_count_196_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_get_ref_count_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase3f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase3f_get_node_ref_count_197(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase3f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase3f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase3f_get_node_ref_count_197_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase3f_get_node_ref_count_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
 * ::PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase3f const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase3f const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase3f,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< LVecBase3f >::PointerToArray(PointerToArray< LVecBase3f > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase3f > *param0_this = (PointerToArray< LVecBase3f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase3f, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase3f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< LVecBase3f >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase3f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< LVecBase3f >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase3f, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase3f > *return_value = new PointerToArray< LVecBase3f >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase3f,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_LVecBase3f)
    {
        printf("PointerToArray_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< LVecBase3f > * local_this = (PointerToArray< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase3f)
        return ( PointerToArrayBase< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase3f > > *)( PointerToArrayBase< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase3f > > *)( PointerToArrayBase< LVecBase3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase3f)
    {
          PointerToArrayBase< LVecBase3f >* other_this = (PointerToArrayBase< LVecBase3f >*)from_this;
          return (PointerToArray< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase3f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase3f > >*)from_this;
          return (PointerToArray< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< LVecBase3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerToArray< LVecBase4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline PointerToArray< LVecBase4f > ::PointerToArray< LVecBase4f >::empty_array(unsigned int n, TypeHandle type_handle)
 * static inline PointerToArray< LVecBase4f > ::PointerToArray< LVecBase4f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase4f const *)(0)))))
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_empty_array_201(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-static inline PointerToArray< LVecBase4f > ::PointerToArray< LVecBase4f >::empty_array(unsigned int n, TypeHandle type_handle = ((_get_type_handle((LVecBase4f const *)(0)))))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"n", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:emptyArray", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:emptyArray", &param0));
            if(!PyErr_Occurred())
            {
                 PyObject *param0_uint = PyNumber_Long(param0);
                if (!((param0_uint == NULL)))
                {
                    PointerToArray< LVecBase4f > result = ::PointerToArray< LVecBase4f >::empty_array(PyLong_AsUnsignedLong(param0_uint));
                    PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >(result);
                     Py_XDECREF(param0_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase4f,true, false);
                    }
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline PointerToArray< LVecBase4f > ::PointerToArray< LVecBase4f >::empty_array(unsigned int n, TypeHandle type_handle)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"n", (char *)"type_handle", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:emptyArray", key_word_list, &param0, &param1))
                {
                     PyObject *param0_uint = PyNumber_Long(param0);TypeHandle *param1_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypeHandle, 1, "PointerToArray.emptyArray", 1, coerced_ptr, report_errors);

                    if (!((param0_uint == NULL)|| (param1_this == NULL)))
                    {
                        PointerToArray< LVecBase4f > result = ::PointerToArray< LVecBase4f >::empty_array(PyLong_AsUnsignedLong(param0_uint), *param1_this);
                        PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >(result);
                         Py_XDECREF(param0_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_PointerToArray_LVecBase4f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "emptyArray() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "emptyArray(unsigned int n)\n"
          "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_empty_array_201_comment =
    "C++ Interface:\n"
    "emptyArray(unsigned int n)\n"
    "emptyArray(unsigned int n, const TypeHandle type_handle)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_empty_array_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int ::PointerToArray< LVecBase4f >::size(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_size_202(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int ::PointerToArray< LVecBase4f >::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const PointerToArray< LVecBase4f >*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_size_202_comment =
    "C++ Interface:\n"
    "size(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_size_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::push_back(LVecBase4f const &x)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_push_back_203(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase4f >::push_back(LVecBase4f const &x)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"x", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:pushBack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:pushBack", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "PointerToArray.pushBack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->push_back(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.pushBack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushBack(non-const PointerToArray this, const VBase4 x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_push_back_203_comment =
    "C++ Interface:\n"
    "pushBack(non-const PointerToArray this, const VBase4 x)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_push_back_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::pop_back(void)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_pop_back_204(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase4f >::pop_back(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popBack", key_word_list));
        else
            (PyArg_Parse(args, ":popBack"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_back();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.popBack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popBack(non-const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_pop_back_204_comment =
    "C++ Interface:\n"
    "popBack(non-const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_pop_back_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::PointerToArray< LVecBase4f >::get_element(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_get_element_205(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::PointerToArray< LVecBase4f >::get_element(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getElement", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LVecBase4f const *return_value = &(((const PointerToArray< LVecBase4f >*)local_this)->get_element(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_get_element_205_comment =
    "C++ Interface:\n"
    "getElement(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_get_element_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::set_element(unsigned int n, LVecBase4f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_set_element_206(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase4f >::set_element(unsigned int n, LVecBase4f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setElement", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "PointerToArray.setElement", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->set_element(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.setElement() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setElement(non-const PointerToArray this, unsigned int n, const VBase4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_set_element_206_comment =
    "C++ Interface:\n"
    "setElement(non-const PointerToArray this, unsigned int n, const VBase4 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_set_element_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::PointerToArray< LVecBase4f >::__getitem__(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_getitem_207(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::PointerToArray< LVecBase4f >::__getitem__(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Getitem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:Getitem", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= ((const PointerToArray< LVecBase4f >*)local_this)->size()) {
                  PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                  return NULL;
                }
                LVecBase4f const *return_value = &(((const PointerToArray< LVecBase4f >*)local_this)->__getitem__(PyLong_AsUnsignedLong(param1_uint)));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getitem(const PointerToArray this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_getitem_207_comment =
    "C++ Interface:\n"
    "Getitem(const PointerToArray this, unsigned int n)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_getitem_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::__setitem__(unsigned int n, LVecBase4f const &value)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_setitem_208(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ::PointerToArray< LVecBase4f >::__setitem__(unsigned int n, LVecBase4f const &value)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"n", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:Setitem", key_word_list, &param1, &param2))
            {
                 PyObject *param1_uint = PyNumber_Long(param1);LVecBase4f *param2_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase4f, 2, "PointerToArray.Setitem", 1, coerced_ptr, report_errors);

                if (!((param1_uint == NULL)|| (param2_this == NULL)))
                {
                    if ((PyLong_AsUnsignedLong(param1_uint)) < 0 || (PyLong_AsUnsignedLong(param1_uint)) >= (local_this)->size()) {
                      Py_XDECREF(coerced);
                      PyErr_SetString(PyExc_IndexError, "Out of bounds.");
                      return NULL;
                    }
                    (local_this)->__setitem__(PyLong_AsUnsignedLong(param1_uint), *param2_this);
                     Py_XDECREF(param1_uint);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PointerToArray.Setitem() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Setitem(non-const PointerToArray this, unsigned int n, const VBase4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_setitem_208_comment =
    "C++ Interface:\n"
    "Setitem(non-const PointerToArray this, unsigned int n, const VBase4 value)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_setitem_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase4f >::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_get_data_209(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase4f >::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const PointerToArray< LVecBase4f >*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_get_data_209_comment =
    "C++ Interface:\n"
    "getData(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_get_data_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::set_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_set_data_210(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase4f >::set_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const PointerToArray this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_set_data_210_comment =
    "C++ Interface:\n"
    "setData(non-const PointerToArray this, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_set_data_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ::PointerToArray< LVecBase4f >::get_subdata(unsigned int n, unsigned int count) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_get_subdata_211(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ::PointerToArray< LVecBase4f >::get_subdata(unsigned int n, unsigned int count) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"n", (char *)"count", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getSubdata", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const PointerToArray< LVecBase4f >*)local_this)->get_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_get_subdata_211_comment =
    "C++ Interface:\n"
    "getSubdata(const PointerToArray this, unsigned int n, unsigned int count)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_get_subdata_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ::PointerToArray< LVecBase4f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_set_subdata_212(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ::PointerToArray< LVecBase4f >::set_subdata(unsigned int n, unsigned int count, basic_string< char > const &data)
        PyObject *param1;
        PyObject *param2;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"n", (char *)"count", (char *)"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:setSubdata", key_word_list, &param1, &param2, &param3_str, &param3_len))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_subdata(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), basic_string<char>(param3_str, param3_len));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerToArray.setSubdata() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_set_subdata_212_comment =
    "C++ Interface:\n"
    "setSubdata(non-const PointerToArray this, unsigned int n, unsigned int count, string data)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_set_subdata_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase4f >::get_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_get_ref_count_213(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase4f >::get_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase4f >*)local_this)->get_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_get_ref_count_213_comment =
    "C++ Interface:\n"
    "getRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_get_ref_count_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ::PointerToArray< LVecBase4f >::get_node_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_PointerToArray_LVecBase4f_get_node_ref_count_214(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerToArray< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToArray_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ::PointerToArray< LVecBase4f >::get_node_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodeRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":getNodeRefCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerToArray< LVecBase4f >*)local_this)->get_node_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodeRefCount(const PointerToArray this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerToArray_LVecBase4f_get_node_ref_count_214_comment =
    "C++ Interface:\n"
    "getNodeRefCount(const PointerToArray this)\n"
    "\n"
    "";
#else
static const char * Dtool_PointerToArray_LVecBase4f_get_node_ref_count_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ::PointerToArray< LVecBase4f >::PointerToArray(PointerToArray< LVecBase4f > const &copy)
 * ::PointerToArray< LVecBase4f >::PointerToArray(PyObject *self, PyObject *sequence)
 * inline ::PointerToArray< LVecBase4f >::PointerToArray(TypeHandle type_handle)
 * inline ::PointerToArray< LVecBase4f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase4f const *)(0)))))
 *******************************************************************/
int  Dtool_Init_PointerToArray_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ::PointerToArray< LVecBase4f >::PointerToArray(TypeHandle type_handle = ((_get_type_handle((LVecBase4f const *)(0)))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerToArray", key_word_list))
            {
                PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase4f,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline ::PointerToArray< LVecBase4f >::PointerToArray(PointerToArray< LVecBase4f > const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase4f > *param0_this = (PointerToArray< LVecBase4f > *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PointerToArray_LVecBase4f, 0, "PointerToArray.PointerToArray", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase4f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline ::PointerToArray< LVecBase4f >::PointerToArray(TypeHandle type_handle)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"type_handle", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    TypeHandle *param0_this = (TypeHandle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypeHandle, 0, "PointerToArray.PointerToArray", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase4f,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ::PointerToArray< LVecBase4f >::PointerToArray(PyObject *self, PyObject *sequence)
                // Pre-initialize self for the constructor
                DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_LVecBase4f, false, false);
                PyObject *param0;
                static char * key_word_list[] = {(char *)"sequence", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PointerToArray", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PointerToArray", &param0));
                if(!PyErr_Occurred())
                {
                    PointerToArray< LVecBase4f > *return_value = new PointerToArray< LVecBase4f >(self, param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerToArray_LVecBase4f,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PointerToArray() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PointerToArray()\n"
          "PointerToArray(const PointerToArray copy)\n"
          "PointerToArray(const TypeHandle type_handle)\n"
          "PointerToArray(any sequence)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerToArray_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerToArray_LVecBase4f)
    {
        printf("PointerToArray_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerToArray< LVecBase4f > * local_this = (PointerToArray< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerToArray_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_PointerToArrayBase_LVecBase4f)
        return ( PointerToArrayBase< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
        return ( PointerToBase< ReferenceCountedVector< LVecBase4f > > *)( PointerToArrayBase< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_PointerToVoid)
        return ( PointerToVoid *)( PointerToBase< ReferenceCountedVector< LVecBase4f > > *)( PointerToArrayBase< LVecBase4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerToArray_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerToArray_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_PointerToArrayBase_LVecBase4f)
    {
          PointerToArrayBase< LVecBase4f >* other_this = (PointerToArrayBase< LVecBase4f >*)from_this;
          return (PointerToArray< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f)
    {
          PointerToBase< ReferenceCountedVector< LVecBase4f > >* other_this = (PointerToBase< ReferenceCountedVector< LVecBase4f > >*)from_this;
          return (PointerToArray< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_PointerToVoid)
    {
          PointerToVoid* other_this = (PointerToVoid*)from_this;
          return (PointerToArray< LVecBase4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingVolume 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_make_copy_218(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual BoundingVolume *BoundingVolume::make_copy(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            BoundingVolume *return_value = ((const BoundingVolume*)local_this)->make_copy();
            if (return_value != (BoundingVolume *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_BoundingVolume,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const BoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_make_copy_218_comment =
    "C++ Interface:\n"
    "makeCopy(const BoundingVolume this)\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingVolume_make_copy_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BoundingVolume::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_is_empty_219(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BoundingVolume::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BoundingVolume*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const BoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_is_empty_219_comment =
    "C++ Interface:\n"
    "isEmpty(const BoundingVolume this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Any kind of volume might be empty.  This is a\n"
    "//               degenerate volume that contains no points; it's not\n"
    "//               the same as, for instance, a sphere with radius zero,\n"
    "//               since that contains one point (the center).  It\n"
    "//               intersects with no other volumes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_is_empty_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BoundingVolume::is_infinite(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_is_infinite_220(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BoundingVolume::is_infinite(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isInfinite", key_word_list));
        else
            (PyArg_Parse(args, ":isInfinite"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BoundingVolume*)local_this)->is_infinite();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isInfinite(const BoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_is_infinite_220_comment =
    "C++ Interface:\n"
    "isInfinite(const BoundingVolume this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::is_infinite\n"
    "//       Access: Published\n"
    "//  Description: The other side of the empty coin is an infinite\n"
    "//               volume.  This is a degenerate state of a normally\n"
    "//               finite volume that contains all points.  (Note that\n"
    "//               some kinds of infinite bounding volumes, like binary\n"
    "//               separating planes, do not contain all points and thus\n"
    "//               correctly return is_infinite() == false, even though\n"
    "//               they are technically infinite.  This is a special\n"
    "//               case of the word 'infinite' meaning the volume covers\n"
    "//               all points in space.)\n"
    "//\n"
    "//               It completely intersects with all other volumes\n"
    "//               except empty volumes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_is_infinite_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BoundingVolume::set_infinite(void)
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_set_infinite_221(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BoundingVolume::set_infinite(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setInfinite", key_word_list));
        else
            (PyArg_Parse(args, ":setInfinite"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_infinite();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BoundingVolume.setInfinite() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInfinite(non-const BoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_set_infinite_221_comment =
    "C++ Interface:\n"
    "setInfinite(non-const BoundingVolume this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::set_infinite\n"
    "//       Access: Published\n"
    "//  Description: Marks the volume as infinite, even if it is normally\n"
    "//               finite.  You can think of this as an infinite\n"
    "//               extend_by() operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_set_infinite_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_extend_by_222(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool BoundingVolume::extend_by(BoundingVolume const *vol)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vol", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:extendBy", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:extendBy", &param1));
            if(!PyErr_Occurred())
            {
                BoundingVolume *param1_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BoundingVolume, 1, "BoundingVolume.extendBy", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->extend_by(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call BoundingVolume.extendBy() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extendBy(non-const BoundingVolume this, const BoundingVolume vol)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_extend_by_222_comment =
    "C++ Interface:\n"
    "extendBy(non-const BoundingVolume this, const BoundingVolume vol)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::extend_by\n"
    "//       Access: Published\n"
    "//  Description: Increases the size of the volume to include the given\n"
    "//               volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_extend_by_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BoundingVolume::contains(BoundingVolume const *vol) const
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_contains_225(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int BoundingVolume::contains(BoundingVolume const *vol) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vol", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:contains", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:contains", &param1));
            if(!PyErr_Occurred())
            {
                BoundingVolume *param1_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BoundingVolume, 1, "BoundingVolume.contains", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const BoundingVolume*)local_this)->contains(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "contains(const BoundingVolume this, const BoundingVolume vol)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_contains_225_comment =
    "C++ Interface:\n"
    "contains(const BoundingVolume this, const BoundingVolume vol)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::contains\n"
    "//       Access: Published\n"
    "//  Description: Returns the appropriate set of IntersectionFlags to\n"
    "//               indicate the amount of intersection with the\n"
    "//               indicated volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_contains_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BoundingVolume::output(ostream &out) const = 0
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_output_226(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BoundingVolume::output(ostream &out) const = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BoundingVolume.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BoundingVolume*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BoundingVolume this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_output_226_comment =
    "C++ Interface:\n"
    "output(const BoundingVolume this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingVolume_output_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BoundingVolume::write(ostream &out, int indent_level) const
 * virtual void BoundingVolume::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_write_227(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BoundingVolume::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BoundingVolume.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BoundingVolume*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BoundingVolume::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BoundingVolume.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BoundingVolume*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BoundingVolume this, non-const Ostream out)\n"
          "write(const BoundingVolume this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_write_227_comment =
    "C++ Interface:\n"
    "write(const BoundingVolume this, non-const Ostream out)\n"
    "write(const BoundingVolume this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingVolume::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingVolume_write_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingVolume::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingVolume_get_class_type_229(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingVolume::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingVolume::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingVolume_get_class_type_229_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingVolume_get_class_type_229_comment = NULL;
#endif

int  Dtool_Init_BoundingVolume(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BoundingVolume)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingVolume)
    {
        printf("BoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingVolume * local_this = (BoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingVolume)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingVolume(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingVolume)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingVolume*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GeometricBoundingVolume 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
 * inline bool GeometricBoundingVolume::extend_by(LPoint3f const &point)
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_extend_by_232(PyObject *self, PyObject *args,PyObject *kwds) {
    GeometricBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeometricBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeometricBoundingVolume::extend_by(GeometricBoundingVolume const *vol)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vol", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:extendBy", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:extendBy", &param1));
            if(!PyErr_Occurred())
            {
                GeometricBoundingVolume *param1_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GeometricBoundingVolume, 1, "GeometricBoundingVolume.extendBy", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->extend_by(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline bool GeometricBoundingVolume::extend_by(LPoint3f const &point)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:extendBy", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:extendBy", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "GeometricBoundingVolume.extendBy", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->extend_by(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "extendBy(non-const GeometricBoundingVolume this, const GeometricBoundingVolume vol)\n"
          "extendBy(non-const GeometricBoundingVolume this, const Point3 point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_extend_by_232_comment =
    "C++ Interface:\n"
    "extendBy(non-const GeometricBoundingVolume this, const GeometricBoundingVolume vol)\n"
    "extendBy(non-const GeometricBoundingVolume this, const Point3 point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::extend_by\n"
    "//       Access: Public\n"
    "//  Description: Increases the size of the volume to include the given\n"
    "//               volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::extend_by\n"
    "//       Access: Public\n"
    "//  Description: Increases the size of the volume to include the given\n"
    "//               point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_extend_by_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool GeometricBoundingVolume::around(LPoint3f const *first, LPoint3f const *last)
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_around_233(PyObject *self, PyObject *args,PyObject *kwds) {
    GeometricBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeometricBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool GeometricBoundingVolume::around(LPoint3f const *first, LPoint3f const *last)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"first", (char *)"last", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:around", key_word_list, &param1, &param2))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "GeometricBoundingVolume.around", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "GeometricBoundingVolume.around", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->around(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeometricBoundingVolume.around() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "around(non-const GeometricBoundingVolume this, const Point3 first, const Point3 last)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_around_233_comment =
    "C++ Interface:\n"
    "around(non-const GeometricBoundingVolume this, const Point3 first, const Point3 last)\n"
    "\n"
    "// It might be nice to make these template member functions so we\n"
    "// could have true STL-style first/last iterators, but that's\n"
    "// impossible for virtual functions.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::around\n"
    "//       Access: Public\n"
    "//  Description: Resets the volume to enclose only the volumes\n"
    "//               indicated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::around\n"
    "//       Access: Public\n"
    "//  Description: Resets the volume to enclose only the points\n"
    "//               indicated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_around_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
 * inline int GeometricBoundingVolume::contains(LPoint3f const &point) const
 * inline int GeometricBoundingVolume::contains(LPoint3f const &a, LPoint3f const &b) const
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_contains_234(PyObject *self, PyObject *args,PyObject *kwds) {
    GeometricBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeometricBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline int GeometricBoundingVolume::contains(GeometricBoundingVolume const *vol) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vol", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:contains", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:contains", &param1));
                if(!PyErr_Occurred())
                {
                    GeometricBoundingVolume *param1_this = (GeometricBoundingVolume *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GeometricBoundingVolume, 1, "GeometricBoundingVolume.contains", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const GeometricBoundingVolume*)local_this)->contains(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline int GeometricBoundingVolume::contains(LPoint3f const &point) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"point", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:contains", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:contains", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "GeometricBoundingVolume.contains", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = ((const GeometricBoundingVolume*)local_this)->contains(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline int GeometricBoundingVolume::contains(LPoint3f const &a, LPoint3f const &b) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:contains", key_word_list, &param1, &param2))
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "GeometricBoundingVolume.contains", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "GeometricBoundingVolume.contains", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        int return_value = ((const GeometricBoundingVolume*)local_this)->contains(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "contains() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "contains(const GeometricBoundingVolume this, const GeometricBoundingVolume vol)\n"
          "contains(const GeometricBoundingVolume this, const Point3 point)\n"
          "contains(const GeometricBoundingVolume this, const Point3 a, const Point3 b)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_contains_234_comment =
    "C++ Interface:\n"
    "contains(const GeometricBoundingVolume this, const GeometricBoundingVolume vol)\n"
    "contains(const GeometricBoundingVolume this, const Point3 point)\n"
    "contains(const GeometricBoundingVolume this, const Point3 a, const Point3 b)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::contains\n"
    "//       Access: Public\n"
    "//  Description: Returns the appropriate set of IntersectionFlags to\n"
    "//               indicate the amount of intersection with the\n"
    "//               indicated volume.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::contains\n"
    "//       Access: Public\n"
    "//  Description: Returns the appropriate set of IntersectionFlags to\n"
    "//               indicate the amount of intersection with the\n"
    "//               indicated point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GeometricBoundingVolume::contains\n"
    "//       Access: Public\n"
    "//  Description: Returns the appropriate set of IntersectionFlags to\n"
    "//               indicate the amount of intersection with the\n"
    "//               indicated line segment.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_contains_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LPoint3f GeometricBoundingVolume::get_approx_center(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_get_approx_center_235(PyObject *self, PyObject *args,PyObject *kwds) {
    GeometricBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeometricBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LPoint3f GeometricBoundingVolume::get_approx_center(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getApproxCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getApproxCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const GeometricBoundingVolume*)local_this)->get_approx_center();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getApproxCenter(const GeometricBoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_get_approx_center_235_comment =
    "C++ Interface:\n"
    "getApproxCenter(const GeometricBoundingVolume this)\n"
    "\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_get_approx_center_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void GeometricBoundingVolume::xform(LMatrix4f const &mat) = 0
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_xform_236(PyObject *self, PyObject *args,PyObject *kwds) {
    GeometricBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GeometricBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void GeometricBoundingVolume::xform(LMatrix4f const &mat) = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "GeometricBoundingVolume.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call GeometricBoundingVolume.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const GeometricBoundingVolume this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_xform_236_comment =
    "C++ Interface:\n"
    "xform(non-const GeometricBoundingVolume this, const Mat4 mat)\n"
    "\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_xform_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GeometricBoundingVolume::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GeometricBoundingVolume_get_class_type_237(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GeometricBoundingVolume::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GeometricBoundingVolume::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GeometricBoundingVolume_get_class_type_237_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GeometricBoundingVolume_get_class_type_237_comment = NULL;
#endif

int  Dtool_Init_GeometricBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GeometricBoundingVolume)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GeometricBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GeometricBoundingVolume)
    {
        printf("GeometricBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GeometricBoundingVolume * local_this = (GeometricBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GeometricBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GeometricBoundingVolume)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (GeometricBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GeometricBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GeometricBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (GeometricBoundingVolume*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FiniteBoundingVolume 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual LPoint3f FiniteBoundingVolume::get_min(void) const = 0
 *******************************************************************/
static PyObject *Dtool_FiniteBoundingVolume_get_min_240(PyObject *self, PyObject *args,PyObject *kwds) {
    FiniteBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FiniteBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LPoint3f FiniteBoundingVolume::get_min(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMin", key_word_list));
        else
            (PyArg_Parse(args, ":getMin"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const FiniteBoundingVolume*)local_this)->get_min();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMin(const FiniteBoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FiniteBoundingVolume_get_min_240_comment =
    "C++ Interface:\n"
    "getMin(const FiniteBoundingVolume this)\n"
    "\n"
    "";
#else
static const char * Dtool_FiniteBoundingVolume_get_min_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LPoint3f FiniteBoundingVolume::get_max(void) const = 0
 *******************************************************************/
static PyObject *Dtool_FiniteBoundingVolume_get_max_241(PyObject *self, PyObject *args,PyObject *kwds) {
    FiniteBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FiniteBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LPoint3f FiniteBoundingVolume::get_max(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMax", key_word_list));
        else
            (PyArg_Parse(args, ":getMax"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const FiniteBoundingVolume*)local_this)->get_max();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMax(const FiniteBoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FiniteBoundingVolume_get_max_241_comment =
    "C++ Interface:\n"
    "getMax(const FiniteBoundingVolume this)\n"
    "\n"
    "";
#else
static const char * Dtool_FiniteBoundingVolume_get_max_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual float FiniteBoundingVolume::get_volume(void) const
 *******************************************************************/
static PyObject *Dtool_FiniteBoundingVolume_get_volume_242(PyObject *self, PyObject *args,PyObject *kwds) {
    FiniteBoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_FiniteBoundingVolume,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual float FiniteBoundingVolume::get_volume(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVolume", key_word_list));
        else
            (PyArg_Parse(args, ":getVolume"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const FiniteBoundingVolume*)local_this)->get_volume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVolume(const FiniteBoundingVolume this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FiniteBoundingVolume_get_volume_242_comment =
    "C++ Interface:\n"
    "getVolume(const FiniteBoundingVolume this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: FiniteBoundingVolume::get_volume\n"
    "//       Access: Public, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_FiniteBoundingVolume_get_volume_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FiniteBoundingVolume::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FiniteBoundingVolume_get_class_type_243(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FiniteBoundingVolume::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FiniteBoundingVolume::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FiniteBoundingVolume_get_class_type_243_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FiniteBoundingVolume_get_class_type_243_comment = NULL;
#endif

int  Dtool_Init_FiniteBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (FiniteBoundingVolume)");
       return -1;
}
inline void  * Dtool_UpcastInterface_FiniteBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FiniteBoundingVolume)
    {
        printf("FiniteBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FiniteBoundingVolume * local_this = (FiniteBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FiniteBoundingVolume)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FiniteBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FiniteBoundingVolume)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (FiniteBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (FiniteBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FiniteBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FiniteBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (FiniteBoundingVolume*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Parabolaf 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Parabolaf::operator =(Parabolaf const &copy)
 *******************************************************************/
static PyObject *Dtool_Parabolaf_operator_247(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Parabolaf::operator =(Parabolaf const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Parabolaf *param1_this = (Parabolaf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Parabolaf, 1, "Parabolaf.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Parabolaf *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Parabolaf,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Parabolaf.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Parabolaf this, const Parabolaf copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_operator_247_comment =
    "C++ Interface:\n"
    "assign(non-const Parabolaf this, const Parabolaf copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_operator_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolaf::xform(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_Parabolaf_xform_249(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Parabolaf::xform(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "Parabolaf.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Parabolaf.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const Parabolaf this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_xform_249_comment =
    "C++ Interface:\n"
    "xform(non-const Parabolaf this, const Mat4 mat)\n"
    "\n"
    "// Filename: parabola_src.cxx\n"
    "// Created by:  drose (10Oct07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::xform\n"
    "//       Access: Published\n"
    "//  Description: Transforms the parabola by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_xform_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &Parabolaf::get_a(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_get_a_250(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &Parabolaf::get_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getA", key_word_list));
        else
            (PyArg_Parse(args, ":getA"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const Parabolaf*)local_this)->get_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getA(const Parabolaf this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_get_a_250_comment =
    "C++ Interface:\n"
    "getA(const Parabolaf this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first point of the parabola's parametric\n"
    "//               equation: the acceleration.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_get_a_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &Parabolaf::get_b(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_get_b_251(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &Parabolaf::get_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getB", key_word_list));
        else
            (PyArg_Parse(args, ":getB"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const Parabolaf*)local_this)->get_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getB(const Parabolaf this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_get_b_251_comment =
    "C++ Interface:\n"
    "getB(const Parabolaf this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the second point of the parabola's parametric\n"
    "//               equation: the initial velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_get_b_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &Parabolaf::get_c(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_get_c_252(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &Parabolaf::get_c(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getC", key_word_list));
        else
            (PyArg_Parse(args, ":getC"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const Parabolaf*)local_this)->get_c());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getC(const Parabolaf this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_get_c_252_comment =
    "C++ Interface:\n"
    "getC(const Parabolaf this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_c\n"
    "//       Access: Published\n"
    "//  Description: Returns the third point of the parabola's parametric\n"
    "//               equation: the start point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_get_c_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f Parabolaf::calc_point(float t) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_calc_point_253(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f Parabolaf::calc_point(float t) const
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:calcPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:calcPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const Parabolaf*)local_this)->calc_point((float)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcPoint(const Parabolaf this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_calc_point_253_comment =
    "C++ Interface:\n"
    "calcPoint(const Parabolaf this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::calc_point\n"
    "//       Access: Published\n"
    "//  Description: Computes the point on the parabola at time t.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_calc_point_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolaf::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_output_254(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Parabolaf::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolaf.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Parabolaf*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Parabolaf this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_output_254_comment =
    "C++ Interface:\n"
    "output(const Parabolaf this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_output_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolaf::write(ostream &out, int indent_level) const
 * void Parabolaf::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_Parabolaf_write_255(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Parabolaf::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolaf.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Parabolaf*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Parabolaf::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolaf.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Parabolaf*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Parabolaf this, non-const Ostream out)\n"
          "write(const Parabolaf this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolaf_write_255_comment =
    "C++ Interface:\n"
    "write(const Parabolaf this, non-const Ostream out)\n"
    "write(const Parabolaf this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolaf_write_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Parabolaf::Parabolaf(void)
 * inline Parabolaf::Parabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
 * inline Parabolaf::Parabolaf(Parabolaf const &copy)
 *******************************************************************/
int  Dtool_Init_Parabolaf(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Parabolaf::Parabolaf(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Parabolaf", key_word_list))
            {
                Parabolaf *return_value = new Parabolaf();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolaf,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Parabolaf::Parabolaf(Parabolaf const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Parabolaf", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Parabolaf", &param0));
                if(!PyErr_Occurred())
                {
                    Parabolaf *param0_this = (Parabolaf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Parabolaf, 0, "Parabolaf.Parabolaf", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Parabolaf *return_value = new Parabolaf(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolaf,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Parabolaf::Parabolaf(LVecBase3f const &a, LVecBase3f const &b, LVecBase3f const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:Parabolaf", key_word_list, &param0, &param1, &param2))
                {
                    LVecBase3f *param0_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase3f, 0, "Parabolaf.Parabolaf", 1, coerced_ptr, report_errors);
LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "Parabolaf.Parabolaf", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "Parabolaf.Parabolaf", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        Parabolaf *return_value = new Parabolaf(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolaf,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Parabolaf() takes 0, 1, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Parabolaf()\n"
          "Parabolaf(const Parabolaf copy)\n"
          "Parabolaf(const VBase3 a, const VBase3 b, const VBase3 c)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Parabolaf(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Parabolaf)
    {
        printf("Parabolaf ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Parabolaf * local_this = (Parabolaf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Parabolaf)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Parabolaf(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Parabolaf)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Parabolad 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Parabolad::operator =(Parabolad const &copy)
 *******************************************************************/
static PyObject *Dtool_Parabolad_operator_258(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Parabolad::operator =(Parabolad const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Parabolad *param1_this = (Parabolad *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Parabolad, 1, "Parabolad.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Parabolad *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_Parabolad,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Parabolad.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Parabolad this, const Parabolad copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_operator_258_comment =
    "C++ Interface:\n"
    "assign(non-const Parabolad this, const Parabolad copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_operator_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolad::xform(LMatrix4d const &mat)
 *******************************************************************/
static PyObject *Dtool_Parabolad_xform_260(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Parabolad::xform(LMatrix4d const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4d *param1_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4d, 1, "Parabolad.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Parabolad.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const Parabolad this, const Mat4D mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_xform_260_comment =
    "C++ Interface:\n"
    "xform(non-const Parabolad this, const Mat4D mat)\n"
    "\n"
    "// Filename: parabola_src.cxx\n"
    "// Created by:  drose (10Oct07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::xform\n"
    "//       Access: Published\n"
    "//  Description: Transforms the parabola by the indicated matrix.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_xform_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3d const &Parabolad::get_a(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_get_a_261(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3d const &Parabolad::get_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getA", key_word_list));
        else
            (PyArg_Parse(args, ":getA"));
        if(!PyErr_Occurred())
        {
            LVecBase3d const *return_value = &(((const Parabolad*)local_this)->get_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3d,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getA(const Parabolad this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_get_a_261_comment =
    "C++ Interface:\n"
    "getA(const Parabolad this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first point of the parabola's parametric\n"
    "//               equation: the acceleration.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first point of the parabola's parametric\n"
    "//               equation: the acceleration.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_get_a_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3d const &Parabolad::get_b(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_get_b_262(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3d const &Parabolad::get_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getB", key_word_list));
        else
            (PyArg_Parse(args, ":getB"));
        if(!PyErr_Occurred())
        {
            LVecBase3d const *return_value = &(((const Parabolad*)local_this)->get_b());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3d,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getB(const Parabolad this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_get_b_262_comment =
    "C++ Interface:\n"
    "getB(const Parabolad this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the second point of the parabola's parametric\n"
    "//               equation: the initial velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the second point of the parabola's parametric\n"
    "//               equation: the initial velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_get_b_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3d const &Parabolad::get_c(void) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_get_c_263(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3d const &Parabolad::get_c(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getC", key_word_list));
        else
            (PyArg_Parse(args, ":getC"));
        if(!PyErr_Occurred())
        {
            LVecBase3d const *return_value = &(((const Parabolad*)local_this)->get_c());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3d,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getC(const Parabolad this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_get_c_263_comment =
    "C++ Interface:\n"
    "getC(const Parabolad this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_c\n"
    "//       Access: Published\n"
    "//  Description: Returns the third point of the parabola's parametric\n"
    "//               equation: the start point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::get_c\n"
    "//       Access: Published\n"
    "//  Description: Returns the third point of the parabola's parametric\n"
    "//               equation: the start point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_get_c_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3d Parabolad::calc_point(double t) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_calc_point_264(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3d Parabolad::calc_point(double t) const
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:calcPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:calcPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3d result = ((const Parabolad*)local_this)->calc_point((double)param1);
            LPoint3d *return_value = new LPoint3d(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3d,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "calcPoint(const Parabolad this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_calc_point_264_comment =
    "C++ Interface:\n"
    "calcPoint(const Parabolad this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::calc_point\n"
    "//       Access: Published\n"
    "//  Description: Computes the point on the parabola at time t.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::calc_point\n"
    "//       Access: Published\n"
    "//  Description: Computes the point on the parabola at time t.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_calc_point_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolad::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_output_265(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Parabolad::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolad.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Parabolad*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Parabolad this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_output_265_comment =
    "C++ Interface:\n"
    "output(const Parabolad this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_output_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Parabolad::write(ostream &out, int indent_level) const
 * void Parabolad::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_Parabolad_write_266(PyObject *self, PyObject *args,PyObject *kwds) {
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Parabolad::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolad.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Parabolad*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void Parabolad::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Parabolad.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Parabolad*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Parabolad this, non-const Ostream out)\n"
          "write(const Parabolad this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Parabolad_write_266_comment =
    "C++ Interface:\n"
    "write(const Parabolad this, non-const Ostream out)\n"
    "write(const Parabolad this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Parabola::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Parabolad_write_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Parabolad::Parabolad(void)
 * inline Parabolad::Parabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
 * inline Parabolad::Parabolad(Parabolad const &copy)
 *******************************************************************/
int  Dtool_Init_Parabolad(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Parabolad::Parabolad(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Parabolad", key_word_list))
            {
                Parabolad *return_value = new Parabolad();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolad,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Parabolad::Parabolad(Parabolad const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Parabolad", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Parabolad", &param0));
                if(!PyErr_Occurred())
                {
                    Parabolad *param0_this = (Parabolad *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Parabolad, 0, "Parabolad.Parabolad", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Parabolad *return_value = new Parabolad(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolad,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline Parabolad::Parabolad(LVecBase3d const &a, LVecBase3d const &b, LVecBase3d const &c)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:Parabolad", key_word_list, &param0, &param1, &param2))
                {
                    LVecBase3d *param0_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase3d, 0, "Parabolad.Parabolad", 1, coerced_ptr, report_errors);
LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "Parabolad.Parabolad", 1, coerced_ptr, report_errors);
LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3d, 2, "Parabolad.Parabolad", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        Parabolad *return_value = new Parabolad(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Parabolad,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Parabolad() takes 0, 1, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Parabolad()\n"
          "Parabolad(const Parabolad copy)\n"
          "Parabolad(const VBase3D a, const VBase3D b, const VBase3D c)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Parabolad(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Parabolad)
    {
        printf("Parabolad ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Parabolad * local_this = (Parabolad *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Parabolad)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Parabolad(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Parabolad)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingBox 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int BoundingBox::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingBox_get_num_points_272(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BoundingBox::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BoundingBox*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const BoundingBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingBox_get_num_points_272_comment =
    "C++ Interface:\n"
    "getNumPoints(const BoundingBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingBox::get_num_points\n"
    "//       Access: Published\n"
    "//  Description: Returns 8: the number of vertices of a rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingBox_get_num_points_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoundingBox::get_point(int n) const
 *******************************************************************/
static PyObject *Dtool_BoundingBox_get_point_273(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoundingBox::get_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoundingBox*)local_this)->get_point((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const BoundingBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingBox_get_point_273_comment =
    "C++ Interface:\n"
    "getPoint(const BoundingBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingBox::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex of the rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingBox_get_point_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BoundingBox::get_num_planes(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingBox_get_num_planes_274(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BoundingBox::get_num_planes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPlanes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPlanes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BoundingBox*)local_this)->get_num_planes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPlanes(const BoundingBox this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingBox_get_num_planes_274_comment =
    "C++ Interface:\n"
    "getNumPlanes(const BoundingBox this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingBox::get_num_planes\n"
    "//       Access: Published\n"
    "//  Description: Returns 6: the number of faces of a rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingBox_get_num_planes_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef BoundingBox::get_plane(int n) const
 *******************************************************************/
static PyObject *Dtool_BoundingBox_get_plane_275(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingBox * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingBox,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef BoundingBox::get_plane(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPlane", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPlane", &param1));
        if(!PyErr_Occurred())
        {
            Planef result = ((const BoundingBox*)local_this)->get_plane((int)param1);
            Planef *return_value = new Planef(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlane(const BoundingBox this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingBox_get_plane_275_comment =
    "C++ Interface:\n"
    "getPlane(const BoundingBox this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingBox::get_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth face of the rectangular solid.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingBox_get_plane_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingBox::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingBox_get_class_type_276(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingBox::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingBox::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingBox_get_class_type_276_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingBox_get_class_type_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BoundingBox::BoundingBox(void)
 * inline BoundingBox::BoundingBox(LPoint3f const &min, LPoint3f const &max)
 *******************************************************************/
int  Dtool_Init_BoundingBox(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BoundingBox::BoundingBox(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BoundingBox", key_word_list))
            {
                BoundingBox *return_value = new BoundingBox();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingBox,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline BoundingBox::BoundingBox(LPoint3f const &min, LPoint3f const &max)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"min", (char *)"max", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:BoundingBox", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "BoundingBox.BoundingBox", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BoundingBox.BoundingBox", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        BoundingBox *return_value = new BoundingBox(*param0_this, *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingBox,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BoundingBox() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BoundingBox()\n"
          "BoundingBox(const Point3 min, const Point3 max)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_BoundingBox_get_points(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPoints", "getPoint");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_BoundingBox_get_planes(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPlanes", "getPlane");
}
inline void  * Dtool_UpcastInterface_BoundingBox(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingBox)
    {
        printf("BoundingBox ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingBox * local_this = (BoundingBox *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingBox)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_FiniteBoundingVolume)
        return ( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingBox(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingBox)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (BoundingBox*)other_this;
    }
    if(from_type == &Dtool_FiniteBoundingVolume)
    {
          FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
          return (BoundingBox*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (BoundingBox*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingBox*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingBox*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingBox*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingHexahedron 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int BoundingHexahedron::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingHexahedron_get_num_points_280(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingHexahedron * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingHexahedron,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BoundingHexahedron::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BoundingHexahedron*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const BoundingHexahedron this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingHexahedron_get_num_points_280_comment =
    "C++ Interface:\n"
    "getNumPoints(const BoundingHexahedron this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingHexahedron::get_num_points\n"
    "//       Access: Published\n"
    "//  Description: Returns 8: the number of vertices of a hexahedron.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingHexahedron_get_num_points_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoundingHexahedron::get_point(int n) const
 *******************************************************************/
static PyObject *Dtool_BoundingHexahedron_get_point_281(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingHexahedron * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingHexahedron,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoundingHexahedron::get_point(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPoint", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoundingHexahedron*)local_this)->get_point((int)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const BoundingHexahedron this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingHexahedron_get_point_281_comment =
    "C++ Interface:\n"
    "getPoint(const BoundingHexahedron this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingHexahedron::get_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex of the hexahedron.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingHexahedron_get_point_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BoundingHexahedron::get_num_planes(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingHexahedron_get_num_planes_282(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingHexahedron * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingHexahedron,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int BoundingHexahedron::get_num_planes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPlanes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPlanes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const BoundingHexahedron*)local_this)->get_num_planes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPlanes(const BoundingHexahedron this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingHexahedron_get_num_planes_282_comment =
    "C++ Interface:\n"
    "getNumPlanes(const BoundingHexahedron this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingHexahedron::get_num_planes\n"
    "//       Access: Published\n"
    "//  Description: Returns 6: the number of faces of a hexahedron.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingHexahedron_get_num_planes_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Planef BoundingHexahedron::get_plane(int n) const
 *******************************************************************/
static PyObject *Dtool_BoundingHexahedron_get_plane_283(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingHexahedron * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingHexahedron,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef BoundingHexahedron::get_plane(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPlane", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPlane", &param1));
        if(!PyErr_Occurred())
        {
            Planef result = ((const BoundingHexahedron*)local_this)->get_plane((int)param1);
            Planef *return_value = new Planef(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlane(const BoundingHexahedron this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingHexahedron_get_plane_283_comment =
    "C++ Interface:\n"
    "getPlane(const BoundingHexahedron this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingHexahedron::get_plane\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth face of the hexahedron.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingHexahedron_get_plane_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingHexahedron::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingHexahedron_get_class_type_284(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingHexahedron::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingHexahedron::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingHexahedron_get_class_type_284_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingHexahedron_get_class_type_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BoundingHexahedron::BoundingHexahedron(Frustumf const &frustum, bool is_ortho, CoordinateSystem cs)
 * BoundingHexahedron::BoundingHexahedron(Frustumf const &frustum, bool is_ortho, CoordinateSystem cs = (CS_default))
 * BoundingHexahedron::BoundingHexahedron(LPoint3f const &fll, LPoint3f const &flr, LPoint3f const &fur, LPoint3f const &ful, LPoint3f const &nll, LPoint3f const &nlr, LPoint3f const &nur, LPoint3f const &nul)
 *******************************************************************/
int  Dtool_Init_BoundingHexahedron(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BoundingHexahedron::BoundingHexahedron(Frustumf const &frustum, bool is_ortho, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frustum", (char *)"is_ortho", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:BoundingHexahedron", key_word_list, &param0, &param1))
                {
                    Frustumf *param0_this = (Frustumf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Frustumf, 0, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingHexahedron,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BoundingHexahedron::BoundingHexahedron(Frustumf const &frustum, bool is_ortho, CoordinateSystem cs)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"frustum", (char *)"is_ortho", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:BoundingHexahedron", key_word_list, &param0, &param1, &param2))
                {
                    Frustumf *param0_this = (Frustumf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Frustumf, 0, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, (PyObject_IsTrue(param1)!=0), (CoordinateSystem)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingHexahedron,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(8):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-BoundingHexahedron::BoundingHexahedron(LPoint3f const &fll, LPoint3f const &flr, LPoint3f const &fur, LPoint3f const &ful, LPoint3f const &nll, LPoint3f const &nlr, LPoint3f const &nur, LPoint3f const &nul)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                PyObject *param7;
                static char * key_word_list[] = {(char *)"fll", (char *)"flr", (char *)"fur", (char *)"ful", (char *)"nll", (char *)"nlr", (char *)"nur", (char *)"nul", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOOO:BoundingHexahedron", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param4_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint3f, 4, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param5_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LPoint3f, 5, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param6_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LPoint3f, 6, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);
LPoint3f *param7_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param7, &Dtool_LPoint3f, 7, "BoundingHexahedron.BoundingHexahedron", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)|| (param7_this == NULL)))
                    {
                        BoundingHexahedron *return_value = new BoundingHexahedron(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, *param5_this, *param6_this, *param7_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingHexahedron,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BoundingHexahedron() takes 2, 3, or 8 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BoundingHexahedron(const Frustum frustum, bool is_ortho)\n"
          "BoundingHexahedron(const Frustum frustum, bool is_ortho, int cs)\n"
          "BoundingHexahedron(const Point3 fll, const Point3 flr, const Point3 fur, const Point3 ful, const Point3 nll, const Point3 nlr, const Point3 nur, const Point3 nul)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_BoundingHexahedron_get_points(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPoints", "getPoint");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_BoundingHexahedron_get_planes(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPlanes", "getPlane");
}
inline void  * Dtool_UpcastInterface_BoundingHexahedron(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingHexahedron)
    {
        printf("BoundingHexahedron ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingHexahedron * local_this = (BoundingHexahedron *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingHexahedron)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_FiniteBoundingVolume)
        return ( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingHexahedron(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingHexahedron)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    if(from_type == &Dtool_FiniteBoundingVolume)
    {
          FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingHexahedron*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingLine 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &BoundingLine::get_point_a(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingLine_get_point_a_291(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingLine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingLine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &BoundingLine::get_point_a(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointA", key_word_list));
        else
            (PyArg_Parse(args, ":getPointA"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const BoundingLine*)local_this)->get_point_a());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointA(const BoundingLine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingLine_get_point_a_291_comment =
    "C++ Interface:\n"
    "getPointA(const BoundingLine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingLine::get_point_a\n"
    "//       Access: Published\n"
    "//  Description: Returns the first point that defines the line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingLine_get_point_a_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoundingLine::get_point_b(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingLine_get_point_b_292(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingLine * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingLine,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoundingLine::get_point_b(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointB", key_word_list));
        else
            (PyArg_Parse(args, ":getPointB"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoundingLine*)local_this)->get_point_b();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointB(const BoundingLine this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingLine_get_point_b_292_comment =
    "C++ Interface:\n"
    "getPointB(const BoundingLine this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingLine::get_point_b\n"
    "//       Access: Published\n"
    "//  Description: Returns the second point that defines the line.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingLine_get_point_b_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingLine::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingLine_get_class_type_293(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingLine::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingLine::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingLine_get_class_type_293_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingLine_get_class_type_293_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BoundingLine::BoundingLine(LPoint3f const &a, LPoint3f const &b)
 *******************************************************************/
int  Dtool_Init_BoundingLine(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline BoundingLine::BoundingLine(LPoint3f const &a, LPoint3f const &b)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"a", (char *)"b", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:BoundingLine", key_word_list, &param0, &param1))
            {
                LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "BoundingLine.BoundingLine", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "BoundingLine.BoundingLine", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    BoundingLine *return_value = new BoundingLine(*param0_this, *param1_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingLine,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "BoundingLine(const Point3 a, const Point3 b)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BoundingLine(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingLine)
    {
        printf("BoundingLine ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingLine * local_this = (BoundingLine *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingLine)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingLine(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingLine)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (BoundingLine*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (BoundingLine*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingLine*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingLine*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingLine*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingPlane 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Planef const &BoundingPlane::get_plane(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingPlane_get_plane_300(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingPlane * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingPlane,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Planef const &BoundingPlane::get_plane(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlane", key_word_list));
        else
            (PyArg_Parse(args, ":getPlane"));
        if(!PyErr_Occurred())
        {
            Planef const *return_value = &(((const BoundingPlane*)local_this)->get_plane());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Planef,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlane(const BoundingPlane this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingPlane_get_plane_300_comment =
    "C++ Interface:\n"
    "getPlane(const BoundingPlane this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingPlane::get_plane\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingPlane_get_plane_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingPlane::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingPlane_get_class_type_301(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingPlane::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingPlane::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingPlane_get_class_type_301_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingPlane_get_class_type_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BoundingPlane::BoundingPlane(void)
 * inline BoundingPlane::BoundingPlane(Planef const &plane)
 *******************************************************************/
int  Dtool_Init_BoundingPlane(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BoundingPlane::BoundingPlane(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BoundingPlane", key_word_list))
            {
                BoundingPlane *return_value = new BoundingPlane();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingPlane,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline BoundingPlane::BoundingPlane(Planef const &plane)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"plane", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:BoundingPlane", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:BoundingPlane", &param0));
                if(!PyErr_Occurred())
                {
                    Planef *param0_this = (Planef *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Planef, 0, "BoundingPlane.BoundingPlane", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BoundingPlane *return_value = new BoundingPlane(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingPlane,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BoundingPlane() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BoundingPlane()\n"
          "BoundingPlane(const Plane plane)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BoundingPlane(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingPlane)
    {
        printf("BoundingPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingPlane * local_this = (BoundingPlane *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingPlane)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingPlane(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingPlane)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (BoundingPlane*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (BoundingPlane*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingPlane*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingPlane*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingPlane*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BoundingSphere 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f BoundingSphere::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingSphere_get_center_308(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f BoundingSphere::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const BoundingSphere*)local_this)->get_center();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const BoundingSphere this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingSphere_get_center_308_comment =
    "C++ Interface:\n"
    "getCenter(const BoundingSphere this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingSphere::get_center\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingSphere_get_center_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float BoundingSphere::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_BoundingSphere_get_radius_309(PyObject *self, PyObject *args,PyObject *kwds) {
    BoundingSphere * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingSphere,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float BoundingSphere::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const BoundingSphere*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const BoundingSphere this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingSphere_get_radius_309_comment =
    "C++ Interface:\n"
    "getRadius(const BoundingSphere this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BoundingSphere::get_radius\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BoundingSphere_get_radius_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BoundingSphere::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BoundingSphere_get_class_type_310(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BoundingSphere::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BoundingSphere::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BoundingSphere_get_class_type_310_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BoundingSphere_get_class_type_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BoundingSphere::BoundingSphere(void)
 * inline BoundingSphere::BoundingSphere(LPoint3f const &center, float radius)
 *******************************************************************/
int  Dtool_Init_BoundingSphere(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline BoundingSphere::BoundingSphere(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":BoundingSphere", key_word_list))
            {
                BoundingSphere *return_value = new BoundingSphere();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingSphere,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline BoundingSphere::BoundingSphere(LPoint3f const &center, float radius)
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"center", (char *)"radius", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:BoundingSphere", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "BoundingSphere.BoundingSphere", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        BoundingSphere *return_value = new BoundingSphere(*param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_BoundingSphere,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "BoundingSphere() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "BoundingSphere()\n"
          "BoundingSphere(const Point3 center, float radius)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BoundingSphere(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BoundingSphere)
    {
        printf("BoundingSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BoundingSphere * local_this = (BoundingSphere *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BoundingSphere)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_FiniteBoundingVolume)
        return ( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *)( FiniteBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BoundingSphere(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BoundingSphere)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (BoundingSphere*)other_this;
    }
    if(from_type == &Dtool_FiniteBoundingVolume)
    {
          FiniteBoundingVolume* other_this = (FiniteBoundingVolume*)from_this;
          return (BoundingSphere*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (BoundingSphere*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BoundingSphere*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BoundingSphere*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BoundingSphere*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OmniBoundingVolume 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OmniBoundingVolume::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OmniBoundingVolume_get_class_type_316(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OmniBoundingVolume::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OmniBoundingVolume::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OmniBoundingVolume_get_class_type_316_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OmniBoundingVolume_get_class_type_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OmniBoundingVolume::OmniBoundingVolume(void)
 *******************************************************************/
int  Dtool_Init_OmniBoundingVolume(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline OmniBoundingVolume::OmniBoundingVolume(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":OmniBoundingVolume", key_word_list))
        {
            OmniBoundingVolume *return_value = new OmniBoundingVolume();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_OmniBoundingVolume,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OmniBoundingVolume()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OmniBoundingVolume(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OmniBoundingVolume)
    {
        printf("OmniBoundingVolume ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OmniBoundingVolume * local_this = (OmniBoundingVolume *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OmniBoundingVolume)
        return local_this;
    if(requested_type == &Dtool_BoundingVolume)
        return ( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_GeometricBoundingVolume)
        return ( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BoundingVolume *)( GeometricBoundingVolume *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OmniBoundingVolume(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OmniBoundingVolume)
        return from_this;
    if(from_type == &Dtool_BoundingVolume)
    {
          BoundingVolume* other_this = (BoundingVolume*)from_this;
          return (OmniBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_GeometricBoundingVolume)
    {
          GeometricBoundingVolume* other_this = (GeometricBoundingVolume*)from_this;
          return (OmniBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OmniBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OmniBoundingVolume*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OmniBoundingVolume*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Mersenne 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * unsigned long int Mersenne::get_uint31(void)
 *******************************************************************/
static PyObject *Dtool_Mersenne_get_uint31_320(PyObject *self, PyObject *args,PyObject *kwds) {
    Mersenne * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Mersenne,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-unsigned long int Mersenne::get_uint31(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUint31", key_word_list));
        else
            (PyArg_Parse(args, ":getUint31"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = (local_this)->get_uint31();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Mersenne.getUint31() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUint31(non-const Mersenne this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Mersenne_get_uint31_320_comment =
    "C++ Interface:\n"
    "getUint31(non-const Mersenne this)\n"
    "\n"
    "/* generates a random number on [0,0x7fffffff]-interval */\n"
    "";
#else
static const char * Dtool_Mersenne_get_uint31_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Mersenne::Mersenne(unsigned long int seed)
 *******************************************************************/
int  Dtool_Init_Mersenne(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Mersenne::Mersenne(unsigned long int seed)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"seed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:Mersenne", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:Mersenne", &param0));
        if(!PyErr_Occurred())
        {
             PyObject *param0_uint = PyNumber_Long(param0);
            if (!((param0_uint == NULL)))
            {
                Mersenne *return_value = new Mersenne(PyLong_AsUnsignedLong(param0_uint));
                 Py_XDECREF(param0_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Mersenne,true,false);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Mersenne(unsigned int seed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Mersenne(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Mersenne)
    {
        printf("Mersenne ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Mersenne * local_this = (Mersenne *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Mersenne)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Mersenne(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Mersenne)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PerlinNoise 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline unsigned long int PerlinNoise::get_seed(void)
 *******************************************************************/
static PyObject *Dtool_PerlinNoise_get_seed_323(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned long int PerlinNoise::get_seed(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSeed", key_word_list));
        else
            (PyArg_Parse(args, ":getSeed"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = (local_this)->get_seed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PerlinNoise.getSeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSeed(non-const PerlinNoise this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise_get_seed_323_comment =
    "C++ Interface:\n"
    "getSeed(non-const PerlinNoise this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise::get_seed\n"
    "//       Access: Published\n"
    "//  Description: Returns a unique seed value based on the seed value\n"
    "//               passed to this PerlinNoise object (and on its current\n"
    "//               state).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise_get_seed_323_comment = NULL;
#endif

int  Dtool_Init_PerlinNoise(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PerlinNoise)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PerlinNoise(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PerlinNoise)
    {
        printf("PerlinNoise ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PerlinNoise * local_this = (PerlinNoise *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PerlinNoise)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PerlinNoise(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PerlinNoise)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PerlinNoise2 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
 *******************************************************************/
static PyObject *Dtool_PerlinNoise2_operator_327(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PerlinNoise2::operator =(PerlinNoise2 const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PerlinNoise2 *param1_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise2, 1, "PerlinNoise2.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PerlinNoise2 *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PerlinNoise2,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PerlinNoise2.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PerlinNoise2 this, const PerlinNoise2 copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise2_operator_327_comment =
    "C++ Interface:\n"
    "assign(non-const PerlinNoise2 this, const PerlinNoise2 copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: Makes an exact copy of the existing PerlinNoise\n"
    "//               object, including its random seed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise2_operator_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
 * inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
 * inline void PerlinNoise2::set_scale(double scale)
 * inline void PerlinNoise2::set_scale(double sx, double sy)
 *******************************************************************/
static PyObject *Dtool_PerlinNoise2_set_scale_328(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise2::set_scale(LVecBase2f const &scale)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PerlinNoise2.setScale", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_scale(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise2::set_scale(LVecBase2d const &scale)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2d *param1_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2d, 1, "PerlinNoise2.setScale", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_scale(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise2::set_scale(double scale)
                double param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "d:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    (local_this)->set_scale((double)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PerlinNoise2::set_scale(double sx, double sy)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setScale", key_word_list, &param1, &param2))
            {
                (local_this)->set_scale((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PerlinNoise2.setScale() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setScale() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setScale(non-const PerlinNoise2 this, const VBase2 scale)\n"
          "setScale(non-const PerlinNoise2 this, const VBase2D scale)\n"
          "setScale(non-const PerlinNoise2 this, float scale)\n"
          "setScale(non-const PerlinNoise2 this, float sx, float sy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise2_set_scale_328_comment =
    "C++ Interface:\n"
    "setScale(non-const PerlinNoise2 this, const VBase2 scale)\n"
    "setScale(non-const PerlinNoise2 this, const VBase2D scale)\n"
    "setScale(non-const PerlinNoise2 this, float scale)\n"
    "setScale(non-const PerlinNoise2 this, float sx, float sy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise2_set_scale_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double PerlinNoise2::noise(LVecBase2d const &value) const
 * inline float PerlinNoise2::noise(LVecBase2f const &value) const
 * inline double PerlinNoise2::noise(double x, double y) const
 *******************************************************************/
static PyObject *Dtool_PerlinNoise2_noise_329(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 double PerlinNoise2::noise(LVecBase2d const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2d *param1_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2d, 1, "PerlinNoise2.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const PerlinNoise2*)local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline float PerlinNoise2::noise(LVecBase2f const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PerlinNoise2.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const PerlinNoise2*)local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline double PerlinNoise2::noise(double x, double y) const
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:noise", key_word_list, &param1, &param2))
            {
                double return_value = ((const PerlinNoise2*)local_this)->noise((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "noise() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "noise(const PerlinNoise2 this, const VBase2D value)\n"
          "noise(const PerlinNoise2 this, const VBase2 value)\n"
          "noise(const PerlinNoise2 this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise2_noise_329_comment =
    "C++ Interface:\n"
    "noise(const PerlinNoise2 this, const VBase2D value)\n"
    "noise(const PerlinNoise2 this, const VBase2 value)\n"
    "noise(const PerlinNoise2 this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise2_noise_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
 * inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
 * inline double PerlinNoise2::operator ()(double x, double y) const
 *******************************************************************/
static PyObject *Dtool_PerlinNoise2_operator_330(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline double PerlinNoise2::operator ()(LVecBase2d const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2d *param1_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2d, 1, "PerlinNoise2.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const PerlinNoise2*)local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline float PerlinNoise2::operator ()(LVecBase2f const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "PerlinNoise2.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const PerlinNoise2*)local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline double PerlinNoise2::operator ()(double x, double y) const
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:__call__", key_word_list, &param1, &param2))
            {
                double return_value = ((const PerlinNoise2*)local_this)->operator ()((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "__call__() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "__call__(const PerlinNoise2 this, const VBase2D value)\n"
          "__call__(const PerlinNoise2 this, const VBase2 value)\n"
          "__call__(const PerlinNoise2 this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise2_operator_330_comment =
    "C++ Interface:\n"
    "__call__(const PerlinNoise2 this, const VBase2D value)\n"
    "__call__(const PerlinNoise2 this, const VBase2 value)\n"
    "__call__(const PerlinNoise2 this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::operator ()\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the two inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the two inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the two inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise2_operator_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PerlinNoise2::PerlinNoise2(void)
 * inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
 * inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size, unsigned long int seed)
 * inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size, unsigned long int seed = (0))
 * inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = (256), unsigned long int seed = (0))
 *******************************************************************/
int  Dtool_Init_PerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline PerlinNoise2::PerlinNoise2(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PerlinNoise2", key_word_list))
            {
                PerlinNoise2 *return_value = new PerlinNoise2();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PerlinNoise2::PerlinNoise2(PerlinNoise2 const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PerlinNoise2", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PerlinNoise2", &param0));
                if(!PyErr_Occurred())
                {
                    PerlinNoise2 *param0_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PerlinNoise2, 0, "PerlinNoise2.PerlinNoise2", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PerlinNoise2 *return_value = new PerlinNoise2(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise2,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:PerlinNoise2", key_word_list, &param0, &param1))
            {
                PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size, unsigned long int seed = (0))
            double param0;
            double param1;
            int param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"table_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddi:PerlinNoise2", key_word_list, &param0, &param1, &param2))
            {
                PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline PerlinNoise2::PerlinNoise2(double sx, double sy, int table_size, unsigned long int seed)
            double param0;
            double param1;
            int param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"table_size", (char *)"seed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddiO:PerlinNoise2", key_word_list, &param0, &param1, &param2, &param3))
            {
                 PyObject *param3_uint = PyNumber_Long(param3);
                if (!((param3_uint == NULL)))
                {
                    PerlinNoise2 *return_value = new PerlinNoise2((double)param0, (double)param1, (int)param2, PyLong_AsUnsignedLong(param3_uint));
                     Py_XDECREF(param3_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise2,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PerlinNoise2() takes 0, 1, 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PerlinNoise2()\n"
          "PerlinNoise2(const PerlinNoise2 copy)\n"
          "PerlinNoise2(float sx, float sy)\n"
          "PerlinNoise2(float sx, float sy, int table_size)\n"
          "PerlinNoise2(float sx, float sy, int table_size, unsigned int seed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PerlinNoise2)
    {
        printf("PerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PerlinNoise2 * local_this = (PerlinNoise2 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PerlinNoise2)
        return local_this;
    if(requested_type == &Dtool_PerlinNoise)
        return ( PerlinNoise *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PerlinNoise2)
        return from_this;
    if(from_type == &Dtool_PerlinNoise)
    {
          PerlinNoise* other_this = (PerlinNoise*)from_this;
          return (PerlinNoise2*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PerlinNoise3 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
 *******************************************************************/
static PyObject *Dtool_PerlinNoise3_operator_334(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PerlinNoise3::operator =(PerlinNoise3 const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PerlinNoise3 *param1_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise3, 1, "PerlinNoise3.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PerlinNoise3 *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PerlinNoise3,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PerlinNoise3.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PerlinNoise3 this, const PerlinNoise3 copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise3_operator_334_comment =
    "C++ Interface:\n"
    "assign(non-const PerlinNoise3 this, const PerlinNoise3 copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: Makes an exact copy of the existing PerlinNoise\n"
    "//               object, including its random seed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise3_operator_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
 * inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
 * inline void PerlinNoise3::set_scale(double scale)
 * inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
 *******************************************************************/
static PyObject *Dtool_PerlinNoise3_set_scale_335(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise3::set_scale(LVecBase3d const &scale)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "PerlinNoise3.setScale", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_scale(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise3::set_scale(LVecBase3f const &scale)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PerlinNoise3.setScale", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_scale(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void PerlinNoise3::set_scale(double scale)
                double param1;
                static char * key_word_list[] = {(char *)"scale", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:setScale", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "d:setScale", &param1));
                if(!PyErr_Occurred())
                {
                    (local_this)->set_scale((double)param1);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PerlinNoise3::set_scale(double sx, double sy, double sz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setScale", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_scale((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PerlinNoise3.setScale() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setScale() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setScale(non-const PerlinNoise3 this, const VBase3D scale)\n"
          "setScale(non-const PerlinNoise3 this, const VBase3 scale)\n"
          "setScale(non-const PerlinNoise3 this, float scale)\n"
          "setScale(non-const PerlinNoise3 this, float sx, float sy, float sz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise3_set_scale_335_comment =
    "C++ Interface:\n"
    "setScale(non-const PerlinNoise3 this, const VBase3D scale)\n"
    "setScale(non-const PerlinNoise3 this, const VBase3 scale)\n"
    "setScale(non-const PerlinNoise3 this, float scale)\n"
    "setScale(non-const PerlinNoise3 this, float sx, float sy, float sz)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::set_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale (frequency) of the noise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise3_set_scale_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double PerlinNoise3::noise(LVecBase3d const &value) const
 * inline float PerlinNoise3::noise(LVecBase3f const &value) const
 * inline double PerlinNoise3::noise(double x, double y, double z) const
 *******************************************************************/
static PyObject *Dtool_PerlinNoise3_noise_336(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline float PerlinNoise3::noise(LVecBase3f const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PerlinNoise3.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const PerlinNoise3*)local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 double PerlinNoise3::noise(LVecBase3d const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "PerlinNoise3.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const PerlinNoise3*)local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline double PerlinNoise3::noise(double x, double y, double z) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:noise", key_word_list, &param1, &param2, &param3))
            {
                double return_value = ((const PerlinNoise3*)local_this)->noise((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "noise() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "noise(const PerlinNoise3 this, const VBase3 value)\n"
          "noise(const PerlinNoise3 this, const VBase3D value)\n"
          "noise(const PerlinNoise3 this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise3_noise_336_comment =
    "C++ Interface:\n"
    "noise(const PerlinNoise3 this, const VBase3 value)\n"
    "noise(const PerlinNoise3 this, const VBase3D value)\n"
    "noise(const PerlinNoise3 this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise3_noise_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
 * inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
 * inline double PerlinNoise3::operator ()(double x, double y, double z) const
 *******************************************************************/
static PyObject *Dtool_PerlinNoise3_operator_337(PyObject *self, PyObject *args,PyObject *kwds) {
    PerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline double PerlinNoise3::operator ()(LVecBase3d const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "PerlinNoise3.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = ((const PerlinNoise3*)local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline float PerlinNoise3::operator ()(LVecBase3f const &value) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PerlinNoise3.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const PerlinNoise3*)local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline double PerlinNoise3::operator ()(double x, double y, double z) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:__call__", key_word_list, &param1, &param2, &param3))
            {
                double return_value = ((const PerlinNoise3*)local_this)->operator ()((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "__call__() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "__call__(const PerlinNoise3 this, const VBase3D value)\n"
          "__call__(const PerlinNoise3 this, const VBase3 value)\n"
          "__call__(const PerlinNoise3 this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PerlinNoise3_operator_337_comment =
    "C++ Interface:\n"
    "__call__(const PerlinNoise3 this, const VBase3D value)\n"
    "__call__(const PerlinNoise3 this, const VBase3 value)\n"
    "__call__(const PerlinNoise3 this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::operator ()\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PerlinNoise3_operator_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PerlinNoise3::PerlinNoise3(void)
 * inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
 * inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size, unsigned long int seed)
 * inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size, unsigned long int seed = (0))
 * inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = (256), unsigned long int seed = (0))
 *******************************************************************/
int  Dtool_Init_PerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline PerlinNoise3::PerlinNoise3(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PerlinNoise3", key_word_list))
            {
                PerlinNoise3 *return_value = new PerlinNoise3();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PerlinNoise3::PerlinNoise3(PerlinNoise3 const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PerlinNoise3", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PerlinNoise3", &param0));
                if(!PyErr_Occurred())
                {
                    PerlinNoise3 *param0_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PerlinNoise3, 0, "PerlinNoise3.PerlinNoise3", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PerlinNoise3 *return_value = new PerlinNoise3(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise3,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:PerlinNoise3", key_word_list, &param0, &param1, &param2))
            {
                PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size, unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            int param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"table_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddi:PerlinNoise3", key_word_list, &param0, &param1, &param2, &param3))
            {
                PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-inline PerlinNoise3::PerlinNoise3(double sx, double sy, double sz, int table_size, unsigned long int seed)
            double param0;
            double param1;
            double param2;
            int param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"table_size", (char *)"seed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddiO:PerlinNoise3", key_word_list, &param0, &param1, &param2, &param3, &param4))
            {
                 PyObject *param4_uint = PyNumber_Long(param4);
                if (!((param4_uint == NULL)))
                {
                    PerlinNoise3 *return_value = new PerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, PyLong_AsUnsignedLong(param4_uint));
                     Py_XDECREF(param4_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PerlinNoise3,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PerlinNoise3() takes 0, 1, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PerlinNoise3()\n"
          "PerlinNoise3(const PerlinNoise3 copy)\n"
          "PerlinNoise3(float sx, float sy, float sz)\n"
          "PerlinNoise3(float sx, float sy, float sz, int table_size)\n"
          "PerlinNoise3(float sx, float sy, float sz, int table_size, unsigned int seed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PerlinNoise3)
    {
        printf("PerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PerlinNoise3 * local_this = (PerlinNoise3 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PerlinNoise3)
        return local_this;
    if(requested_type == &Dtool_PerlinNoise)
        return ( PerlinNoise *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PerlinNoise3)
        return from_this;
    if(from_type == &Dtool_PerlinNoise)
    {
          PerlinNoise* other_this = (PerlinNoise*)from_this;
          return (PerlinNoise3*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StackedPerlinNoise2 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise2_operator_342(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void StackedPerlinNoise2::operator =(StackedPerlinNoise2 const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                StackedPerlinNoise2 *param1_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StackedPerlinNoise2, 1, "StackedPerlinNoise2.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    StackedPerlinNoise2 *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_StackedPerlinNoise2,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise2.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const StackedPerlinNoise2 this, const StackedPerlinNoise2 copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise2_operator_342_comment =
    "C++ Interface:\n"
    "assign(non-const StackedPerlinNoise2 this, const StackedPerlinNoise2 copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: Creates an exact duplicate of the existing\n"
    "//               StackedPerlinNoise2 object, including the random\n"
    "//               seed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise2_operator_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp)
 * void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = (1))
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise2_add_level_343(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"level", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLevel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addLevel", &param1));
                if(!PyErr_Occurred())
                {
                    PerlinNoise2 *param1_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise2, 1, "StackedPerlinNoise2.addLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_level(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call StackedPerlinNoise2.addLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void StackedPerlinNoise2::add_level(PerlinNoise2 const &level, double amp)
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"level", (char *)"amp", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:addLevel", key_word_list, &param1, &param2))
                {
                    PerlinNoise2 *param1_this = (PerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise2, 1, "StackedPerlinNoise2.addLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_level(*param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call StackedPerlinNoise2.addLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addLevel() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addLevel(non-const StackedPerlinNoise2 this, const PerlinNoise2 level)\n"
          "addLevel(non-const StackedPerlinNoise2 this, const PerlinNoise2 level, float amp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise2_add_level_343_comment =
    "C++ Interface:\n"
    "addLevel(non-const StackedPerlinNoise2 this, const PerlinNoise2 level)\n"
    "addLevel(non-const StackedPerlinNoise2 this, const PerlinNoise2 level, float amp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::add_level\n"
    "//       Access: Published\n"
    "//  Description: Adds an arbitrary PerlinNoise2 object, and an\n"
    "//               associated amplitude, to the stack.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise2_add_level_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise2::clear(void)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise2_clear_344(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void StackedPerlinNoise2::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StackedPerlinNoise2.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const StackedPerlinNoise2 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise2_clear_344_comment =
    "C++ Interface:\n"
    "clear(non-const StackedPerlinNoise2 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all levels from the stack.  You must call\n"
    "//               add_level() again to restore them.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise2_clear_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double StackedPerlinNoise2::noise(LVecBase2d const &value)
 * inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::noise(double x, double y)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise2_noise_345(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 double StackedPerlinNoise2::noise(LVecBase2d const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2d *param1_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2d, 1, "StackedPerlinNoise2.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = (local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline float StackedPerlinNoise2::noise(LVecBase2f const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "StackedPerlinNoise2.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = (local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline double StackedPerlinNoise2::noise(double x, double y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:noise", key_word_list, &param1, &param2))
            {
                double return_value = (local_this)->noise((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise2.noise() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "noise() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "noise(non-const StackedPerlinNoise2 this, const VBase2D value)\n"
          "noise(non-const StackedPerlinNoise2 this, const VBase2 value)\n"
          "noise(non-const StackedPerlinNoise2 this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise2_noise_345_comment =
    "C++ Interface:\n"
    "noise(non-const StackedPerlinNoise2 this, const VBase2D value)\n"
    "noise(non-const StackedPerlinNoise2 this, const VBase2 value)\n"
    "noise(non-const StackedPerlinNoise2 this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise2_noise_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
 * inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
 * inline double StackedPerlinNoise2::operator ()(double x, double y)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise2_operator_346(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise2 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise2,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline double StackedPerlinNoise2::operator ()(LVecBase2d const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2d *param1_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2d, 1, "StackedPerlinNoise2.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = (local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline float StackedPerlinNoise2::operator ()(LVecBase2f const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "StackedPerlinNoise2.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = (local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline double StackedPerlinNoise2::operator ()(double x, double y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:__call__", key_word_list, &param1, &param2))
            {
                double return_value = (local_this)->operator ()((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise2.__call__() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "__call__() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "__call__(non-const StackedPerlinNoise2 this, const VBase2D value)\n"
          "__call__(non-const StackedPerlinNoise2 this, const VBase2 value)\n"
          "__call__(non-const StackedPerlinNoise2 this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise2_operator_346_comment =
    "C++ Interface:\n"
    "__call__(non-const StackedPerlinNoise2 this, const VBase2D value)\n"
    "__call__(non-const StackedPerlinNoise2 this, const VBase2 value)\n"
    "__call__(non-const StackedPerlinNoise2 this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::operator ()\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise2::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise2_operator_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StackedPerlinNoise2::StackedPerlinNoise2(void)
 * StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed)
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed = (0))
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = (2), double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 *******************************************************************/
int  Dtool_Init_StackedPerlinNoise2(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline StackedPerlinNoise2::StackedPerlinNoise2(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":StackedPerlinNoise2", key_word_list))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-StackedPerlinNoise2::StackedPerlinNoise2(StackedPerlinNoise2 const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:StackedPerlinNoise2", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:StackedPerlinNoise2", &param0));
                if(!PyErr_Occurred())
                {
                    StackedPerlinNoise2 *param0_this = (StackedPerlinNoise2 *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_StackedPerlinNoise2, 0, "StackedPerlinNoise2.StackedPerlinNoise2", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        StackedPerlinNoise2 *return_value = new StackedPerlinNoise2(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels = (2), double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:StackedPerlinNoise2", key_word_list, &param0, &param1))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            int param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"num_levels", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddi:StackedPerlinNoise2", key_word_list, &param0, &param1, &param2))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            int param2;
            double param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"num_levels", (char *)"scale_factor", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddid:StackedPerlinNoise2", key_word_list, &param0, &param1, &param2, &param3))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            int param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddidd:StackedPerlinNoise2", key_word_list, &param0, &param1, &param2, &param3, &param4))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(6):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed = (0))
            double param0;
            double param1;
            int param2;
            double param3;
            double param4;
            int param5;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", (char *)"table_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddiddi:StackedPerlinNoise2", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                }
            }
        }

        }
        break;
    case(7):
        {
        {
          // 1-StackedPerlinNoise2::StackedPerlinNoise2(double sx, double sy, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed)
            double param0;
            double param1;
            int param2;
            double param3;
            double param4;
            int param5;
            PyObject *param6;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", (char *)"table_size", (char *)"seed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddiddiO:StackedPerlinNoise2", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                 PyObject *param6_uint = PyNumber_Long(param6);
                if (!((param6_uint == NULL)))
                {
                    StackedPerlinNoise2 *return_value = new StackedPerlinNoise2((double)param0, (double)param1, (int)param2, (double)param3, (double)param4, (int)param5, PyLong_AsUnsignedLong(param6_uint));
                     Py_XDECREF(param6_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise2,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "StackedPerlinNoise2() takes 0, 1, 2, 3, 4, 5, 6, or 7 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "StackedPerlinNoise2()\n"
          "StackedPerlinNoise2(const StackedPerlinNoise2 copy)\n"
          "StackedPerlinNoise2(float sx, float sy)\n"
          "StackedPerlinNoise2(float sx, float sy, int num_levels)\n"
          "StackedPerlinNoise2(float sx, float sy, int num_levels, float scale_factor)\n"
          "StackedPerlinNoise2(float sx, float sy, int num_levels, float scale_factor, float amp_scale)\n"
          "StackedPerlinNoise2(float sx, float sy, int num_levels, float scale_factor, float amp_scale, int table_size)\n"
          "StackedPerlinNoise2(float sx, float sy, int num_levels, float scale_factor, float amp_scale, int table_size, unsigned int seed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StackedPerlinNoise2(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StackedPerlinNoise2)
    {
        printf("StackedPerlinNoise2 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StackedPerlinNoise2 * local_this = (StackedPerlinNoise2 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StackedPerlinNoise2)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StackedPerlinNoise2(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StackedPerlinNoise2)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. StackedPerlinNoise3 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise3_operator_350(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void StackedPerlinNoise3::operator =(StackedPerlinNoise3 const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                StackedPerlinNoise3 *param1_this = (StackedPerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_StackedPerlinNoise3, 1, "StackedPerlinNoise3.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    StackedPerlinNoise3 *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_StackedPerlinNoise3,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise3.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const StackedPerlinNoise3 this, const StackedPerlinNoise3 copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise3_operator_350_comment =
    "C++ Interface:\n"
    "assign(non-const StackedPerlinNoise3 this, const StackedPerlinNoise3 copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: Creates an exact duplicate of the existing\n"
    "//               StackedPerlinNoise3 object, including the random\n"
    "//               seed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise3_operator_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp)
 * void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = (1))
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise3_add_level_351(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"level", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLevel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addLevel", &param1));
                if(!PyErr_Occurred())
                {
                    PerlinNoise3 *param1_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise3, 1, "StackedPerlinNoise3.addLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_level(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call StackedPerlinNoise3.addLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void StackedPerlinNoise3::add_level(PerlinNoise3 const &level, double amp)
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"level", (char *)"amp", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:addLevel", key_word_list, &param1, &param2))
                {
                    PerlinNoise3 *param1_this = (PerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PerlinNoise3, 1, "StackedPerlinNoise3.addLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_level(*param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call StackedPerlinNoise3.addLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addLevel() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addLevel(non-const StackedPerlinNoise3 this, const PerlinNoise3 level)\n"
          "addLevel(non-const StackedPerlinNoise3 this, const PerlinNoise3 level, float amp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise3_add_level_351_comment =
    "C++ Interface:\n"
    "addLevel(non-const StackedPerlinNoise3 this, const PerlinNoise3 level)\n"
    "addLevel(non-const StackedPerlinNoise3 this, const PerlinNoise3 level, float amp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::add_level\n"
    "//       Access: Published\n"
    "//  Description: Adds an arbitrary PerlinNoise3 object, and an\n"
    "//               associated amplitude, to the stack.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise3_add_level_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void StackedPerlinNoise3::clear(void)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise3_clear_352(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void StackedPerlinNoise3::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call StackedPerlinNoise3.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const StackedPerlinNoise3 this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise3_clear_352_comment =
    "C++ Interface:\n"
    "clear(non-const StackedPerlinNoise3 this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all levels from the stack.  You must call\n"
    "//               add_level() again to restore them.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise3_clear_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double StackedPerlinNoise3::noise(LVecBase3d const &value)
 * inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
 * inline double StackedPerlinNoise3::noise(double x, double y, double z)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise3_noise_353(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 double StackedPerlinNoise3::noise(LVecBase3d const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "StackedPerlinNoise3.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = (local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline float StackedPerlinNoise3::noise(LVecBase3f const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:noise", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:noise", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "StackedPerlinNoise3.noise", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = (local_this)->noise(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline double StackedPerlinNoise3::noise(double x, double y, double z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:noise", key_word_list, &param1, &param2, &param3))
            {
                double return_value = (local_this)->noise((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise3.noise() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "noise() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "noise(non-const StackedPerlinNoise3 this, const VBase3D value)\n"
          "noise(non-const StackedPerlinNoise3 this, const VBase3 value)\n"
          "noise(non-const StackedPerlinNoise3 this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise3_noise_353_comment =
    "C++ Interface:\n"
    "noise(non-const StackedPerlinNoise3 this, const VBase3D value)\n"
    "noise(non-const StackedPerlinNoise3 this, const VBase3 value)\n"
    "noise(non-const StackedPerlinNoise3 this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise3_noise_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
 * inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
 * inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
 *******************************************************************/
static PyObject *Dtool_StackedPerlinNoise3_operator_354(PyObject *self, PyObject *args,PyObject *kwds) {
    StackedPerlinNoise3 * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_StackedPerlinNoise3,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline float StackedPerlinNoise3::operator ()(LVecBase3f const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "StackedPerlinNoise3.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = (local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline double StackedPerlinNoise3::operator ()(LVecBase3d const &value)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:__call__", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:__call__", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3d, 1, "StackedPerlinNoise3.__call__", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = (local_this)->operator ()(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline double StackedPerlinNoise3::operator ()(double x, double y, double z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:__call__", key_word_list, &param1, &param2, &param3))
            {
                double return_value = (local_this)->operator ()((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call StackedPerlinNoise3.__call__() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "__call__() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "__call__(non-const StackedPerlinNoise3 this, const VBase3 value)\n"
          "__call__(non-const StackedPerlinNoise3 this, const VBase3D value)\n"
          "__call__(non-const StackedPerlinNoise3 this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_StackedPerlinNoise3_operator_354_comment =
    "C++ Interface:\n"
    "__call__(non-const StackedPerlinNoise3 this, const VBase3 value)\n"
    "__call__(non-const StackedPerlinNoise3 this, const VBase3D value)\n"
    "__call__(non-const StackedPerlinNoise3 this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::operator ()\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: StackedPerlinNoise3::noise\n"
    "//       Access: Published\n"
    "//  Description: Returns the noise function of the three inputs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_StackedPerlinNoise3_operator_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline StackedPerlinNoise3::StackedPerlinNoise3(void)
 * StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed)
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed = (0))
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 * StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = (3), double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
 *******************************************************************/
int  Dtool_Init_StackedPerlinNoise3(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline StackedPerlinNoise3::StackedPerlinNoise3(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":StackedPerlinNoise3", key_word_list))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-StackedPerlinNoise3::StackedPerlinNoise3(StackedPerlinNoise3 const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:StackedPerlinNoise3", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:StackedPerlinNoise3", &param0));
                if(!PyErr_Occurred())
                {
                    StackedPerlinNoise3 *param0_this = (StackedPerlinNoise3 *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_StackedPerlinNoise3, 0, "StackedPerlinNoise3.StackedPerlinNoise3", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        StackedPerlinNoise3 *return_value = new StackedPerlinNoise3(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels = (3), double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor = (4), double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            int param3;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"num_levels", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddi:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2, &param3))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale = (0.5), int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            int param3;
            double param4;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"num_levels", (char *)"scale_factor", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddid:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2, &param3, &param4))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(6):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size = (256), unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            int param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddidd:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(7):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed = (0))
            double param0;
            double param1;
            double param2;
            int param3;
            double param4;
            double param5;
            int param6;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", (char *)"table_size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddiddi:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                }
            }
        }

        }
        break;
    case(8):
        {
        {
          // 1-StackedPerlinNoise3::StackedPerlinNoise3(double sx, double sy, double sz, int num_levels, double scale_factor, double amp_scale, int table_size, unsigned long int seed)
            double param0;
            double param1;
            double param2;
            int param3;
            double param4;
            double param5;
            int param6;
            PyObject *param7;
            static char * key_word_list[] = {(char *)"sx", (char *)"sy", (char *)"sz", (char *)"num_levels", (char *)"scale_factor", (char *)"amp_scale", (char *)"table_size", (char *)"seed", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddiddiO:StackedPerlinNoise3", key_word_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
            {
                 PyObject *param7_uint = PyNumber_Long(param7);
                if (!((param7_uint == NULL)))
                {
                    StackedPerlinNoise3 *return_value = new StackedPerlinNoise3((double)param0, (double)param1, (double)param2, (int)param3, (double)param4, (double)param5, (int)param6, PyLong_AsUnsignedLong(param7_uint));
                     Py_XDECREF(param7_uint);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_StackedPerlinNoise3,true,false);
                    }
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "StackedPerlinNoise3() takes 0, 1, 3, 4, 5, 6, 7, or 8 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "StackedPerlinNoise3()\n"
          "StackedPerlinNoise3(const StackedPerlinNoise3 copy)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz, int num_levels)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz, int num_levels, float scale_factor)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz, int num_levels, float scale_factor, float amp_scale)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz, int num_levels, float scale_factor, float amp_scale, int table_size)\n"
          "StackedPerlinNoise3(float sx, float sy, float sz, int num_levels, float scale_factor, float amp_scale, int table_size, unsigned int seed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_StackedPerlinNoise3(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_StackedPerlinNoise3)
    {
        printf("StackedPerlinNoise3 ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    StackedPerlinNoise3 * local_this = (StackedPerlinNoise3 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_StackedPerlinNoise3)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_StackedPerlinNoise3(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_StackedPerlinNoise3)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Triangulator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void Triangulator::clear(void)
 *******************************************************************/
static PyObject *Dtool_Triangulator_clear_358(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_clear_358_comment =
    "C++ Interface:\n"
    "clear(non-const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all vertices and polygon specifications from\n"
    "//               the Triangulator, and prepares it to start over.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_clear_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Triangulator::add_vertex(LPoint2d const &point)
 * inline int Triangulator::add_vertex(double x, double y)
 *******************************************************************/
static PyObject *Dtool_Triangulator_add_vertex_359(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int Triangulator::add_vertex(LPoint2d const &point)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"point", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addVertex", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addVertex", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2d *param1_this = (LPoint2d *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2d, 1, "Triangulator.addVertex", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_vertex(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Triangulator.addVertex() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int Triangulator::add_vertex(double x, double y)
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addVertex", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->add_vertex((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Triangulator.addVertex() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addVertex() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addVertex(non-const Triangulator this, const Point2D point)\n"
          "addVertex(non-const Triangulator this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_add_vertex_359_comment =
    "C++ Interface:\n"
    "addVertex(non-const Triangulator this, const Point2D point)\n"
    "addVertex(non-const Triangulator this, float x, float y)\n"
    "\n"
    "// Filename: triangulator.I\n"
    "// Created by:  drose (18Jan07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::add_vertex\n"
    "//       Access: Published\n"
    "//  Description: Adds a new vertex to the vertex pool.  Returns the\n"
    "//               vertex index number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::add_vertex\n"
    "//       Access: Published\n"
    "//  Description: Adds a new vertex to the vertex pool.  Returns the\n"
    "//               vertex index number.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_add_vertex_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Triangulator::get_num_vertices(void) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_num_vertices_360(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Triangulator::get_num_vertices(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVertices", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVertices"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Triangulator*)local_this)->get_num_vertices();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVertices(const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_num_vertices_360_comment =
    "C++ Interface:\n"
    "getNumVertices(const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_num_vertices\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of vertices in the pool.  Note\n"
    "//               that the Triangulator might append new vertices, in\n"
    "//               addition to those added by the user, if any of the\n"
    "//               polygon is self-intersecting, or if any of the holes\n"
    "//               intersect some part of the polygon edges.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_num_vertices_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2d const &Triangulator::get_vertex(int n) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_vertex_361(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2d const &Triangulator::get_vertex(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getVertex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getVertex", &param1));
        if(!PyErr_Occurred())
        {
            LPoint2d const *return_value = &(((const Triangulator*)local_this)->get_vertex((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2d,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVertex(const Triangulator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_vertex_361_comment =
    "C++ Interface:\n"
    "getVertex(const Triangulator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_vertex\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth vertex.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_vertex_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Triangulator::clear_polygon(void)
 *******************************************************************/
static PyObject *Dtool_Triangulator_clear_polygon_362(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::clear_polygon(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearPolygon", key_word_list));
        else
            (PyArg_Parse(args, ":clearPolygon"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_polygon();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.clearPolygon() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPolygon(non-const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_clear_polygon_362_comment =
    "C++ Interface:\n"
    "clearPolygon(non-const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::clear_polygon\n"
    "//       Access: Published\n"
    "//  Description: Removes the current polygon definition (and its set\n"
    "//               of holes), but does not clear the vertex pool.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_clear_polygon_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Triangulator::add_polygon_vertex(int index)
 *******************************************************************/
static PyObject *Dtool_Triangulator_add_polygon_vertex_363(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::add_polygon_vertex(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addPolygonVertex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addPolygonVertex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_polygon_vertex((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.addPolygonVertex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPolygonVertex(non-const Triangulator this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_add_polygon_vertex_363_comment =
    "C++ Interface:\n"
    "addPolygonVertex(non-const Triangulator this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::add_polygon_vertex\n"
    "//       Access: Published\n"
    "//  Description: Adds the next consecutive vertex of the polygon.\n"
    "//               This vertex should index into the vertex pool\n"
    "//               established by repeated calls to add_vertex().\n"
    "//\n"
    "//               The vertices may be listed in either clockwise or\n"
    "//               counterclockwise order.  Vertices should not be\n"
    "//               repeated.  In particular, do not repeat the first\n"
    "//               vertex at the end.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_add_polygon_vertex_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Triangulator::is_left_winding(void) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_is_left_winding_364(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Triangulator::is_left_winding(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isLeftWinding", key_word_list));
        else
            (PyArg_Parse(args, ":isLeftWinding"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Triangulator*)local_this)->is_left_winding();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isLeftWinding(const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_is_left_winding_364_comment =
    "C++ Interface:\n"
    "isLeftWinding(const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::is_left_winding\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the polygon vertices are listed in\n"
    "//               counterclockwise order, or false if they appear to be\n"
    "//               listed in clockwise order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_is_left_winding_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Triangulator::begin_hole(void)
 *******************************************************************/
static PyObject *Dtool_Triangulator_begin_hole_365(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::begin_hole(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":beginHole", key_word_list));
        else
            (PyArg_Parse(args, ":beginHole"));
        if(!PyErr_Occurred())
        {
            (local_this)->begin_hole();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.beginHole() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginHole(non-const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_begin_hole_365_comment =
    "C++ Interface:\n"
    "beginHole(non-const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::begin_hole\n"
    "//       Access: Published\n"
    "//  Description: Finishes the previous hole, if any, and prepares to\n"
    "//               add a new hole.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_begin_hole_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Triangulator::add_hole_vertex(int index)
 *******************************************************************/
static PyObject *Dtool_Triangulator_add_hole_vertex_366(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::add_hole_vertex(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:addHoleVertex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:addHoleVertex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_hole_vertex((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.addHoleVertex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addHoleVertex(non-const Triangulator this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_add_hole_vertex_366_comment =
    "C++ Interface:\n"
    "addHoleVertex(non-const Triangulator this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::add_hole_vertex\n"
    "//       Access: Published\n"
    "//  Description: Adds the next consecutive vertex of the current hole.\n"
    "//               This vertex should index into the vertex pool\n"
    "//               established by repeated calls to add_vertex().\n"
    "//\n"
    "//               The vertices may be listed in either clockwise or\n"
    "//               counterclockwise order.  Vertices should not be\n"
    "//               repeated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_add_hole_vertex_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Triangulator::triangulate(void)
 *******************************************************************/
static PyObject *Dtool_Triangulator_triangulate_367(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Triangulator::triangulate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":triangulate", key_word_list));
        else
            (PyArg_Parse(args, ":triangulate"));
        if(!PyErr_Occurred())
        {
            (local_this)->triangulate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Triangulator.triangulate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "triangulate(non-const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_triangulate_367_comment =
    "C++ Interface:\n"
    "triangulate(non-const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::triangulate\n"
    "//       Access: Published\n"
    "//  Description: Does the work of triangulating the specified polygon.\n"
    "//               After this call, you may retrieve the new triangles\n"
    "//               one at a time by iterating through\n"
    "//               get_triangle_v0/1/2().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_triangulate_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Triangulator::get_num_triangles(void) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_num_triangles_368(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Triangulator::get_num_triangles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTriangles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTriangles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Triangulator*)local_this)->get_num_triangles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTriangles(const Triangulator this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_num_triangles_368_comment =
    "C++ Interface:\n"
    "getNumTriangles(const Triangulator this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_num_triangles\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of triangles generated by the\n"
    "//               previous call to triangulate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_num_triangles_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Triangulator::get_triangle_v0(int n) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_triangle_v0_369(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Triangulator::get_triangle_v0(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTriangleV0", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTriangleV0", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Triangulator*)local_this)->get_triangle_v0((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriangleV0(const Triangulator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_triangle_v0_369_comment =
    "C++ Interface:\n"
    "getTriangleV0(const Triangulator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_triangle_v0\n"
    "//       Access: Published\n"
    "//  Description: Returns vertex 0 of the nth triangle generated by the\n"
    "//               previous call to triangulate().\n"
    "//\n"
    "//               This is a zero-based index into the vertices added by\n"
    "//               repeated calls to add_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_triangle_v0_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Triangulator::get_triangle_v1(int n) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_triangle_v1_370(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Triangulator::get_triangle_v1(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTriangleV1", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTriangleV1", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Triangulator*)local_this)->get_triangle_v1((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriangleV1(const Triangulator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_triangle_v1_370_comment =
    "C++ Interface:\n"
    "getTriangleV1(const Triangulator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_triangle_v1\n"
    "//       Access: Published\n"
    "//  Description: Returns vertex 1 of the nth triangle generated by the\n"
    "//               previous call to triangulate().\n"
    "//\n"
    "//               This is a zero-based index into the vertices added by\n"
    "//               repeated calls to add_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_triangle_v1_370_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Triangulator::get_triangle_v2(int n) const
 *******************************************************************/
static PyObject *Dtool_Triangulator_get_triangle_v2_371(PyObject *self, PyObject *args,PyObject *kwds) {
    Triangulator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Triangulator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Triangulator::get_triangle_v2(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTriangleV2", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTriangleV2", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Triangulator*)local_this)->get_triangle_v2((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriangleV2(const Triangulator this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Triangulator_get_triangle_v2_371_comment =
    "C++ Interface:\n"
    "getTriangleV2(const Triangulator this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Triangulator::get_triangle_v2\n"
    "//       Access: Published\n"
    "//  Description: Returns vertex 2 of the nth triangle generated by the\n"
    "//               previous call to triangulate().\n"
    "//\n"
    "//               This is a zero-based index into the vertices added by\n"
    "//               repeated calls to add_vertex().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Triangulator_get_triangle_v2_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Triangulator::Triangulator(void)
 *******************************************************************/
int  Dtool_Init_Triangulator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Triangulator::Triangulator(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":Triangulator", key_word_list))
        {
            Triangulator *return_value = new Triangulator();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Triangulator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Triangulator()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_Triangulator_get_vertices(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumVertices", "getVertex");
}
inline void  * Dtool_UpcastInterface_Triangulator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Triangulator)
    {
        printf("Triangulator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Triangulator * local_this = (Triangulator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Triangulator)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Triangulator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Triangulator)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_LMatrix3f | CPTAMat3
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix3f[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_size_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_size_9_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_get_element_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_get_element_10_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_getitem_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_getitem_11_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_get_data_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_get_data_12_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_get_subdata_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_get_subdata_13_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_get_ref_count_14_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix3f_get_node_ref_count_15_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LMatrix3f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_LMatrix3f_getitem_11Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_LMatrix3f_getitem_11(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LMatrix3f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix3f_size_9size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_LMatrix3f_size_9(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LMatrix3f._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject());
        Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_LMatrix3f_getitem_11Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_LMatrix3f_size_9size;
        if(PyType_Ready(&Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_LMatrix3f)");
             printf(" Error In PyType_ReadyConstPointerToArray_LMatrix3f");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject().tp_dict,"CPTAMat3",&Dtool_ConstPointerToArray_LMatrix3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_LMatrix3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAMat3",(PyObject *)&Dtool_ConstPointerToArray_LMatrix3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_LMatrix3f | PointerToArrayBaseLMatrix3f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix3f[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject());
        Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_LMatrix3f)");
             printf(" Error In PyType_ReadyPointerToArrayBase_LMatrix3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject().tp_dict,"PointerToArrayBaseLMatrix3f",&Dtool_PointerToArrayBase_LMatrix3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_LMatrix3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseLMatrix3f",(PyObject *)&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_LMatrix3f | PointerToBaseReferenceCountedVectorLMatrix3f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix3f[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_clear_5_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f_output_6_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_LMatrix3f
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< LMatrix3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix3f;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix3f)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_LMatrix3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorLMatrix3f",&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix3f",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_LMatrix4f | CPTAMat4
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_LMatrix4f[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_size_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_size_24_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_get_element_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_get_element_25_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_getitem_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_getitem_26_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_get_data_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_get_data_27_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_get_subdata_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_get_subdata_28_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_get_ref_count_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_get_ref_count_29_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LMatrix4f_get_node_ref_count_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LMatrix4f_get_node_ref_count_30_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LMatrix4f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_LMatrix4f_getitem_26Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_LMatrix4f_getitem_26(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LMatrix4f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LMatrix4f_size_24size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_LMatrix4f_size_24(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LMatrix4f._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject());
        Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_LMatrix4f_getitem_26Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_LMatrix4f_size_24size;
        if(PyType_Ready(&Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_LMatrix4f)");
             printf(" Error In PyType_ReadyConstPointerToArray_LMatrix4f");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject().tp_dict,"CPTAMat4",&Dtool_ConstPointerToArray_LMatrix4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_LMatrix4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject());
        PyModule_AddObject(module, "CPTAMat4",(PyObject *)&Dtool_ConstPointerToArray_LMatrix4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_LMatrix4f | PointerToArrayBaseLMatrix4f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_LMatrix4f[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject());
        Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_LMatrix4f)");
             printf(" Error In PyType_ReadyPointerToArrayBase_LMatrix4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject().tp_dict,"PointerToArrayBaseLMatrix4f",&Dtool_PointerToArrayBase_LMatrix4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_LMatrix4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseLMatrix4f",(PyObject *)&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_LMatrix4f | PointerToBaseReferenceCountedVectorLMatrix4f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LMatrix4f[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_clear_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_clear_20_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_output_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f_output_21_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_LMatrix4f
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix4f(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< LMatrix4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix4f;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LMatrix4f;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_LMatrix4f)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_LMatrix4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorLMatrix4f",&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLMatrix4f",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LMatrix4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_LVecBase2f | PTAVecBase2
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase2f[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_size_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_size_39_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_get_element_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_get_element_40_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_getitem_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_getitem_41_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_get_data_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_get_data_42_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_get_subdata_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_get_subdata_43_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_get_ref_count_44_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase2f_get_node_ref_count_45_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase2f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase2f_size_39size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_LVecBase2f_size_39(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase2f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_LVecBase2f_getitem_41Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_LVecBase2f_getitem_41(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase2f._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject());
        Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_LVecBase2f_size_39size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_LVecBase2f_getitem_41Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_LVecBase2f)");
             printf(" Error In PyType_ReadyConstPointerToArray_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject().tp_dict,"PTAVecBase2",&Dtool_ConstPointerToArray_LVecBase2f.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_LVecBase2f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase2",(PyObject *)&Dtool_ConstPointerToArray_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_LVecBase2f | PointerToArrayBaseLVecBase2f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase2f[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject());
        Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_LVecBase2f)");
             printf(" Error In PyType_ReadyPointerToArrayBase_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject().tp_dict,"PointerToArrayBaseLVecBase2f",&Dtool_PointerToArrayBase_LVecBase2f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_LVecBase2f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseLVecBase2f",(PyObject *)&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_LVecBase2f | PointerToBaseReferenceCountedVectorLVecBase2f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase2f[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_clear_35_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f_output_36_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_LVecBase2f
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< LVecBase2f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase2f;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase2f)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorLVecBase2f",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase2f",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_LVecBase3f | PTAVecBase3
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase3f[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_size_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_size_54_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_get_element_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_get_element_55_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_getitem_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_getitem_56_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_get_data_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_get_data_57_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_get_subdata_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_get_subdata_58_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_get_ref_count_59_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase3f_get_node_ref_count_60_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase3f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_LVecBase3f_getitem_56Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_LVecBase3f_getitem_56(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase3f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase3f_size_54size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_LVecBase3f_size_54(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase3f._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject());
        Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_LVecBase3f_getitem_56Getitem;
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_LVecBase3f_size_54size;
        if(PyType_Ready(&Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_LVecBase3f)");
             printf(" Error In PyType_ReadyConstPointerToArray_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject().tp_dict,"PTAVecBase3",&Dtool_ConstPointerToArray_LVecBase3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_LVecBase3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase3",(PyObject *)&Dtool_ConstPointerToArray_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_LVecBase3f | PointerToArrayBaseLVecBase3f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase3f[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject());
        Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_LVecBase3f)");
             printf(" Error In PyType_ReadyPointerToArrayBase_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject().tp_dict,"PointerToArrayBaseLVecBase3f",&Dtool_PointerToArrayBase_LVecBase3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_LVecBase3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseLVecBase3f",(PyObject *)&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_LVecBase3f | PointerToBaseReferenceCountedVectorLVecBase3f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase3f[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_clear_50_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f_output_51_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_LVecBase3f
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< LVecBase3f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase3f;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase3f)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorLVecBase3f",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase3f",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConstPointerToArray_LVecBase4f | PTAVecBase4
//********************************************************************
PyMethodDef Dtool_Methods_ConstPointerToArray_LVecBase4f[]= {
  { "size",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_size_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_size_69_comment},
  { "getElement",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_get_element_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_get_element_70_comment},
  { "Getitem",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_getitem_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_getitem_71_comment},
  { "getData",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_get_data_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_get_data_72_comment},
  { "getSubdata",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_get_subdata_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_get_subdata_73_comment},
  { "getRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_get_ref_count_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_get_ref_count_74_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_ConstPointerToArray_LVecBase4f_get_node_ref_count_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConstPointerToArray_LVecBase4f_get_node_ref_count_75_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase4f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_LVecBase4f_size_69size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_ConstPointerToArray_LVecBase4f_size_69(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     ConstPointerToArray_LVecBase4f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_ConstPointerToArray_LVecBase4f_getitem_71Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_ConstPointerToArray_LVecBase4f_getitem_71(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase4f._Dtool_ClassInit(NULL);
        Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject());
        Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_ConstPointerToArray_LVecBase4f_size_69size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_ConstPointerToArray_LVecBase4f_getitem_71Getitem;
        if(PyType_Ready(&Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConstPointerToArray_LVecBase4f)");
             printf(" Error In PyType_ReadyConstPointerToArray_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject().tp_dict,"PTAVecBase4",&Dtool_ConstPointerToArray_LVecBase4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConstPointerToArray_LVecBase4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase4",(PyObject *)&Dtool_ConstPointerToArray_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArrayBase_LVecBase4f | PointerToArrayBaseLVecBase4f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArrayBase_LVecBase4f[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f._Dtool_ClassInit(NULL);
        Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject());
        Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArrayBase_LVecBase4f)");
             printf(" Error In PyType_ReadyPointerToArrayBase_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject().tp_dict,"PointerToArrayBaseLVecBase4f",&Dtool_PointerToArrayBase_LVecBase4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToArrayBase_LVecBase4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToArrayBaseLVecBase4f",(PyObject *)&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToBase_ReferenceCountedVector_LVecBase4f | PointerToBaseReferenceCountedVectorLVecBase4f
//********************************************************************
PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_LVecBase4f[]= {
  { "clear",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_clear_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_clear_65_comment},
  { "output",(PyCFunction ) &Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_output_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f_output_66_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PointerToBase_ReferenceCountedVector_LVecBase4f
//////////////////
static PyObject *  Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase4f(PyObject * self)
{
    PointerToBase< ReferenceCountedVector< LVecBase4f > > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToVoid._Dtool_ClassInit(NULL);
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToVoid.As_PyTypeObject());
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_repr = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase4f;
        // __str__ Repr Proxy
        Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_str = & Dtool_Repr_PointerToBase_ReferenceCountedVector_LVecBase4f;
        if(PyType_Ready(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToBase_ReferenceCountedVector_LVecBase4f)");
             printf(" Error In PyType_ReadyPointerToBase_ReferenceCountedVector_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject().tp_dict,"PointerToBaseReferenceCountedVectorLVecBase4f",&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyObject());
        RegisterRuntimeClass(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorLVecBase4f",(PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Frustumd | FrustumD
//********************************************************************
PyMethodDef Dtool_Methods_Frustumd[]= {
  { "makeOrtho2D",(PyCFunction ) &Dtool_Frustumd_make_ortho_2D_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumd_make_ortho_2D_79_comment},
  { "makeOrtho",(PyCFunction ) &Dtool_Frustumd_make_ortho_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumd_make_ortho_80_comment},
  { "makePerspectiveHfov",(PyCFunction ) &Dtool_Frustumd_make_perspective_hfov_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumd_make_perspective_hfov_81_comment},
  { "makePerspectiveVfov",(PyCFunction ) &Dtool_Frustumd_make_perspective_vfov_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumd_make_perspective_vfov_82_comment},
  { "makePerspective",(PyCFunction ) &Dtool_Frustumd_make_perspective_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumd_make_perspective_83_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Frustumd(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Frustumd.As_PyTypeObject().tp_doc =
          "// Filename: frustum_src.h\n"
          "// Created by:  mike (09Jan97)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Frustum\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Frustumd.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Frustumd.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Frustumd.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Frustumd.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Frustumd.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Frustumd)");
             printf(" Error In PyType_ReadyFrustumd");
             return;
        }
        Py_INCREF(&Dtool_Frustumd.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Frustumd.As_PyTypeObject().tp_dict,"FrustumD",&Dtool_Frustumd.As_PyObject());
        RegisterRuntimeClass(&Dtool_Frustumd,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Frustumd.As_PyTypeObject());
        PyModule_AddObject(module, "FrustumD",(PyObject *)&Dtool_Frustumd.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Frustumf | Frustum
//********************************************************************
PyMethodDef Dtool_Methods_Frustumf[]= {
  { "makeOrtho2D",(PyCFunction ) &Dtool_Frustumf_make_ortho_2D_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumf_make_ortho_2D_88_comment},
  { "makeOrtho",(PyCFunction ) &Dtool_Frustumf_make_ortho_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumf_make_ortho_89_comment},
  { "makePerspectiveHfov",(PyCFunction ) &Dtool_Frustumf_make_perspective_hfov_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumf_make_perspective_hfov_90_comment},
  { "makePerspectiveVfov",(PyCFunction ) &Dtool_Frustumf_make_perspective_vfov_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumf_make_perspective_vfov_91_comment},
  { "makePerspective",(PyCFunction ) &Dtool_Frustumf_make_perspective_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Frustumf_make_perspective_92_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Frustumf(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Frustumf.As_PyTypeObject().tp_doc =
          "// Filename: frustum_src.h\n"
          "// Created by:  mike (09Jan97)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Frustum\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Frustumf.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Frustumf.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Frustumf.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Frustumf.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Frustumf.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Frustumf)");
             printf(" Error In PyType_ReadyFrustumf");
             return;
        }
        Py_INCREF(&Dtool_Frustumf.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Frustumf.As_PyTypeObject().tp_dict,"Frustum",&Dtool_Frustumf.As_PyObject());
        RegisterRuntimeClass(&Dtool_Frustumf,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Frustumf.As_PyTypeObject());
        PyModule_AddObject(module, "Frustum",(PyObject *)&Dtool_Frustumf.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Planed | PlaneD
//********************************************************************
PyMethodDef Dtool_Methods_Planed[]= {
  { "__mul__",(PyCFunction ) &Dtool_Planed_operator_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_operator_98_comment},
  { "__imul__",(PyCFunction ) &Dtool_Planed_operator_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_operator_99_comment},
  { "xform",(PyCFunction ) &Dtool_Planed_xform_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_xform_100_comment},
  { "__neg__",(PyCFunction ) &Dtool_Planed_operator_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_operator_101_comment},
  { "getReflectionMat",(PyCFunction ) &Dtool_Planed_get_reflection_mat_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_get_reflection_mat_102_comment},
  { "getNormal",(PyCFunction ) &Dtool_Planed_get_normal_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_get_normal_103_comment},
  { "getPoint",(PyCFunction ) &Dtool_Planed_get_point_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_get_point_104_comment},
  { "distToPlane",(PyCFunction ) &Dtool_Planed_dist_to_plane_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_dist_to_plane_105_comment},
  { "project",(PyCFunction ) &Dtool_Planed_project_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_project_106_comment},
  { "intersectsLine",(PyCFunction ) &Dtool_Planed_intersects_line_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_intersects_line_107_comment},
  { "intersectsPlane",(PyCFunction ) &Dtool_Planed_intersects_plane_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_intersects_plane_108_comment},
  { "output",(PyCFunction ) &Dtool_Planed_output_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_output_110_comment},
  { "write",(PyCFunction ) &Dtool_Planed_write_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planed_write_111_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planed ...tp_as_number->nb_negative = __neg__
//////////////////
static PyObject * Dtool_Planed_operator_101__neg__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_Planed_operator_101(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planed ...tp_as_number->nb_inplace_multiply = __imul__
//////////////////
static PyObject *Dtool_Planed_operator_99__imul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Planed_operator_99(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planed ...tp_as_number->nb_multiply = __mul__
//////////////////
static PyObject *Dtool_Planed_operator_98__mul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Planed_operator_98(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     Planed
//////////////////
static PyObject *  Dtool_Repr_Planed(PyObject * self)
{
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Planed
//////////////////
static PyObject *  Dtool_Str_Planed(PyObject * self)
{
    Planed * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planed,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Planed(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Planed.As_PyTypeObject().tp_doc =
          "// Filename: plane_src.h\n"
          "// Created by:  mike (09Jan97)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Plane\n"
          "// Description : An abstract mathematical description of a plane.  A\n"
          "//               plane is defined by the equation Ax + By + Cz + D = 0.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LVecBase4d._Dtool_ClassInit(NULL);
        Dtool_Planed.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LVecBase4d.As_PyTypeObject());
        Dtool_Planed.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Planed.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Planed.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_negative = __neg__
        Dtool_Planed.As_PyTypeObject().tp_as_number->nb_negative = &Dtool_Planed_operator_101__neg__;
        // tp_as_number->nb_inplace_multiply = __imul__
        Dtool_Planed.As_PyTypeObject().tp_as_number->nb_inplace_multiply = &Dtool_Planed_operator_99__imul__;
        // tp_as_number->nb_multiply = __mul__
        Dtool_Planed.As_PyTypeObject().tp_as_number->nb_multiply = &Dtool_Planed_operator_98__mul__;
        // __repr__
        Dtool_Planed.As_PyTypeObject().tp_repr = & Dtool_Repr_Planed;
        // __str__
        Dtool_Planed.As_PyTypeObject().tp_str = & Dtool_Str_Planed;
        if(PyType_Ready(&Dtool_Planed.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Planed)");
             printf(" Error In PyType_ReadyPlaned");
             return;
        }
        Py_INCREF(&Dtool_Planed.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Planed.As_PyTypeObject().tp_dict,"PlaneD",&Dtool_Planed.As_PyObject());
        RegisterRuntimeClass(&Dtool_Planed,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Planed.As_PyTypeObject());
        PyModule_AddObject(module, "PlaneD",(PyObject *)&Dtool_Planed.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Planef | Plane
//********************************************************************
PyMethodDef Dtool_Methods_Planef[]= {
  { "__mul__",(PyCFunction ) &Dtool_Planef_operator_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_operator_116_comment},
  { "__imul__",(PyCFunction ) &Dtool_Planef_operator_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_operator_117_comment},
  { "xform",(PyCFunction ) &Dtool_Planef_xform_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_xform_118_comment},
  { "__neg__",(PyCFunction ) &Dtool_Planef_operator_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_operator_119_comment},
  { "getReflectionMat",(PyCFunction ) &Dtool_Planef_get_reflection_mat_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_get_reflection_mat_120_comment},
  { "getNormal",(PyCFunction ) &Dtool_Planef_get_normal_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_get_normal_121_comment},
  { "getPoint",(PyCFunction ) &Dtool_Planef_get_point_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_get_point_122_comment},
  { "distToPlane",(PyCFunction ) &Dtool_Planef_dist_to_plane_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_dist_to_plane_123_comment},
  { "project",(PyCFunction ) &Dtool_Planef_project_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_project_124_comment},
  { "intersectsLine",(PyCFunction ) &Dtool_Planef_intersects_line_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_intersects_line_125_comment},
  { "intersectsPlane",(PyCFunction ) &Dtool_Planef_intersects_plane_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_intersects_plane_126_comment},
  { "output",(PyCFunction ) &Dtool_Planef_output_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_output_128_comment},
  { "write",(PyCFunction ) &Dtool_Planef_write_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Planef_write_129_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planef ...tp_as_number->nb_inplace_multiply = __imul__
//////////////////
static PyObject *Dtool_Planef_operator_117__imul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Planef_operator_117(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planef ...tp_as_number->nb_multiply = __mul__
//////////////////
static PyObject *Dtool_Planef_operator_116__mul__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_Planef_operator_116(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     Planef ...tp_as_number->nb_negative = __neg__
//////////////////
static PyObject * Dtool_Planef_operator_119__neg__( PyObject * self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_Planef_operator_119(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     Planef
//////////////////
static PyObject *  Dtool_Repr_Planef(PyObject * self)
{
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Planef
//////////////////
static PyObject *  Dtool_Str_Planef(PyObject * self)
{
    Planef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Planef,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Planef(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Planef.As_PyTypeObject().tp_doc =
          "// Filename: plane_src.h\n"
          "// Created by:  mike (09Jan97)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Plane\n"
          "// Description : An abstract mathematical description of a plane.  A\n"
          "//               plane is defined by the equation Ax + By + Cz + D = 0.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LVecBase4f._Dtool_ClassInit(NULL);
        Dtool_Planef.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LVecBase4f.As_PyTypeObject());
        Dtool_Planef.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Planef.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Planef.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_inplace_multiply = __imul__
        Dtool_Planef.As_PyTypeObject().tp_as_number->nb_inplace_multiply = &Dtool_Planef_operator_117__imul__;
        // tp_as_number->nb_multiply = __mul__
        Dtool_Planef.As_PyTypeObject().tp_as_number->nb_multiply = &Dtool_Planef_operator_116__mul__;
        // tp_as_number->nb_negative = __neg__
        Dtool_Planef.As_PyTypeObject().tp_as_number->nb_negative = &Dtool_Planef_operator_119__neg__;
        // __repr__
        Dtool_Planef.As_PyTypeObject().tp_repr = & Dtool_Repr_Planef;
        // __str__
        Dtool_Planef.As_PyTypeObject().tp_str = & Dtool_Str_Planef;
        if(PyType_Ready(&Dtool_Planef.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Planef)");
             printf(" Error In PyType_ReadyPlanef");
             return;
        }
        Py_INCREF(&Dtool_Planef.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Planef.As_PyTypeObject().tp_dict,"Plane",&Dtool_Planef.As_PyObject());
        RegisterRuntimeClass(&Dtool_Planef,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Planef.As_PyTypeObject());
        PyModule_AddObject(module, "Plane",(PyObject *)&Dtool_Planef.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_LMatrix3f | PTAMat3
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_LMatrix3f[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_empty_array_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_empty_array_133_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_size_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_size_134_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_push_back_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_push_back_135_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_pop_back_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_pop_back_136_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_get_element_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_get_element_137_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_set_element_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_set_element_138_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_getitem_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_getitem_139_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_setitem_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_setitem_140_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_get_data_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_get_data_141_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_set_data_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_set_data_142_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_get_subdata_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_get_subdata_143_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_set_subdata_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_set_subdata_144_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_get_ref_count_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_get_ref_count_145_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_LMatrix3f_get_node_ref_count_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix3f_get_node_ref_count_146_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix3f ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_LMatrix3f_setitem_140Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_LMatrix3f_setitem_140(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix3f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix3f_size_134size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_LMatrix3f_size_134(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix3f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_LMatrix3f_getitem_139Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_LMatrix3f_getitem_139(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LMatrix3f._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LMatrix3f.As_PyTypeObject());
        Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_LMatrix3f_setitem_140Setitem;
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_LMatrix3f_size_134size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_LMatrix3f_getitem_139Getitem;
        if(PyType_Ready(&Dtool_PointerToArray_LMatrix3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_LMatrix3f)");
             printf(" Error In PyType_ReadyPointerToArray_LMatrix3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_LMatrix3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_dict,"PTAMat3",&Dtool_PointerToArray_LMatrix3f.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix3f.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_LMatrix3f[0],&Dtool_PointerToArray_LMatrix3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_LMatrix3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_LMatrix3f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAMat3",(PyObject *)&Dtool_PointerToArray_LMatrix3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_LMatrix4f | PTAMat4
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_LMatrix4f[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_empty_array_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_empty_array_150_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_size_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_size_151_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_push_back_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_push_back_152_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_pop_back_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_pop_back_153_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_get_element_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_get_element_154_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_set_element_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_set_element_155_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_getitem_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_getitem_156_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_setitem_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_setitem_157_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_get_data_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_get_data_158_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_set_data_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_set_data_159_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_get_subdata_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_get_subdata_160_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_set_subdata_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_set_subdata_161_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_get_ref_count_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_get_ref_count_162_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_LMatrix4f_get_node_ref_count_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LMatrix4f_get_node_ref_count_163_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix4f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LMatrix4f_size_151size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_LMatrix4f_size_151(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix4f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_LMatrix4f_getitem_156Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_LMatrix4f_getitem_156(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LMatrix4f ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_LMatrix4f_setitem_157Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_LMatrix4f_setitem_157(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

void   Dtool_PyModuleClassInit_PointerToArray_LMatrix4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LMatrix4f._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LMatrix4f.As_PyTypeObject());
        Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_LMatrix4f_size_151size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_LMatrix4f_getitem_156Getitem;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_LMatrix4f_setitem_157Setitem;
        if(PyType_Ready(&Dtool_PointerToArray_LMatrix4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_LMatrix4f)");
             printf(" Error In PyType_ReadyPointerToArray_LMatrix4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_LMatrix4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_dict,"PTAMat4",&Dtool_PointerToArray_LMatrix4f.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_LMatrix4f.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_LMatrix4f[0],&Dtool_PointerToArray_LMatrix4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_LMatrix4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_LMatrix4f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAMat4",(PyObject *)&Dtool_PointerToArray_LMatrix4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_LVecBase2f | PTAVecBase2
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_LVecBase2f[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_empty_array_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_empty_array_167_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_size_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_size_168_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_push_back_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_push_back_169_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_pop_back_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_pop_back_170_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_get_element_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_get_element_171_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_set_element_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_set_element_172_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_getitem_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_getitem_173_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_setitem_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_setitem_174_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_get_data_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_get_data_175_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_set_data_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_set_data_176_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_get_subdata_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_get_subdata_177_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_set_subdata_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_set_subdata_178_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_get_ref_count_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_get_ref_count_179_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase2f_get_node_ref_count_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase2f_get_node_ref_count_180_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase2f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase2f_size_168size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_LVecBase2f_size_168(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase2f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_LVecBase2f_getitem_173Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_LVecBase2f_getitem_173(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase2f ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_LVecBase2f_setitem_174Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_LVecBase2f_setitem_174(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

void   Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase2f._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase2f.As_PyTypeObject());
        Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_LVecBase2f_size_168size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_LVecBase2f_getitem_173Getitem;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_LVecBase2f_setitem_174Setitem;
        if(PyType_Ready(&Dtool_PointerToArray_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_LVecBase2f)");
             printf(" Error In PyType_ReadyPointerToArray_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_dict,"PTAVecBase2",&Dtool_PointerToArray_LVecBase2f.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase2f.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_LVecBase2f[0],&Dtool_PointerToArray_LVecBase2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_LVecBase2f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase2",(PyObject *)&Dtool_PointerToArray_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_LVecBase3f | PTAVecBase3
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_LVecBase3f[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_empty_array_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_empty_array_184_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_size_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_size_185_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_push_back_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_push_back_186_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_pop_back_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_pop_back_187_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_get_element_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_get_element_188_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_set_element_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_set_element_189_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_getitem_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_getitem_190_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_setitem_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_setitem_191_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_get_data_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_get_data_192_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_set_data_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_set_data_193_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_get_subdata_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_get_subdata_194_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_set_subdata_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_set_subdata_195_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_get_ref_count_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_get_ref_count_196_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase3f_get_node_ref_count_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase3f_get_node_ref_count_197_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase3f ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_LVecBase3f_setitem_191Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_LVecBase3f_setitem_191(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase3f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase3f_size_185size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_LVecBase3f_size_185(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase3f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_LVecBase3f_getitem_190Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_LVecBase3f_getitem_190(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase3f._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase3f.As_PyTypeObject());
        Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_LVecBase3f_setitem_191Setitem;
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_LVecBase3f_size_185size;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_LVecBase3f_getitem_190Getitem;
        if(PyType_Ready(&Dtool_PointerToArray_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_LVecBase3f)");
             printf(" Error In PyType_ReadyPointerToArray_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_dict,"PTAVecBase3",&Dtool_PointerToArray_LVecBase3f.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase3f.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_LVecBase3f[0],&Dtool_PointerToArray_LVecBase3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_LVecBase3f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase3",(PyObject *)&Dtool_PointerToArray_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerToArray_LVecBase4f | PTAVecBase4
//********************************************************************
PyMethodDef Dtool_Methods_PointerToArray_LVecBase4f[]= {
  { "emptyArray",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_empty_array_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_empty_array_201_comment},
  { "size",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_size_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_size_202_comment},
  { "pushBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_push_back_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_push_back_203_comment},
  { "popBack",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_pop_back_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_pop_back_204_comment},
  { "getElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_get_element_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_get_element_205_comment},
  { "setElement",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_set_element_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_set_element_206_comment},
  { "Getitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_getitem_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_getitem_207_comment},
  { "Setitem",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_setitem_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_setitem_208_comment},
  { "getData",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_get_data_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_get_data_209_comment},
  { "setData",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_set_data_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_set_data_210_comment},
  { "getSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_get_subdata_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_get_subdata_211_comment},
  { "setSubdata",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_set_subdata_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_set_subdata_212_comment},
  { "getRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_get_ref_count_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_get_ref_count_213_comment},
  { "getNodeRefCount",(PyCFunction ) &Dtool_PointerToArray_LVecBase4f_get_node_ref_count_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerToArray_LVecBase4f_get_node_ref_count_214_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase4f ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PointerToArray_LVecBase4f_size_202size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PointerToArray_LVecBase4f_size_202(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase4f ...tp_as_sequence->sq_ass_item = Setitem
//////////////////
static int Dtool_PointerToArray_LVecBase4f_setitem_208Setitem( PyObject * self, Py_ssize_t index, PyObject *value)
{
    PyObject *args = Py_BuildValue("(iO)", index, value);
    PyObject *result = Dtool_PointerToArray_LVecBase4f_setitem_208(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_DECREF(result);
    return 0;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PointerToArray_LVecBase4f ...tp_as_sequence->sq_item = Getitem
//////////////////
static PyObject * Dtool_PointerToArray_LVecBase4f_getitem_207Getitem( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PointerToArray_LVecBase4f_getitem_207(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_PointerToArray_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PointerToArrayBase_LVecBase4f._Dtool_ClassInit(NULL);
        Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PointerToArrayBase_LVecBase4f.As_PyTypeObject());
        Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PointerToArray_LVecBase4f_size_202size;
        // tp_as_sequence->sq_ass_item = Setitem
        Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_as_sequence->sq_ass_item = &Dtool_PointerToArray_LVecBase4f_setitem_208Setitem;
        // tp_as_sequence->sq_item = Getitem
        Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PointerToArray_LVecBase4f_getitem_207Getitem;
        if(PyType_Ready(&Dtool_PointerToArray_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerToArray_LVecBase4f)");
             printf(" Error In PyType_ReadyPointerToArray_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_PointerToArray_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_dict,"PTAVecBase4",&Dtool_PointerToArray_LVecBase4f.As_PyObject());
        //  Static Method emptyArray
        PyDict_SetItemString(Dtool_PointerToArray_LVecBase4f.As_PyTypeObject().tp_dict,"emptyArray",PyCFunction_New(&Dtool_Methods_PointerToArray_LVecBase4f[0],&Dtool_PointerToArray_LVecBase4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerToArray_LVecBase4f,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerToArray_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "PTAVecBase4",(PyObject *)&Dtool_PointerToArray_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingVolume | BoundingVolume
//********************************************************************
PyMethodDef Dtool_Methods_BoundingVolume[]= {
  { "makeCopy",(PyCFunction ) &Dtool_BoundingVolume_make_copy_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_make_copy_218_comment},
  { "isEmpty",(PyCFunction ) &Dtool_BoundingVolume_is_empty_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_is_empty_219_comment},
  { "isInfinite",(PyCFunction ) &Dtool_BoundingVolume_is_infinite_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_is_infinite_220_comment},
  { "setInfinite",(PyCFunction ) &Dtool_BoundingVolume_set_infinite_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_set_infinite_221_comment},
  { "extendBy",(PyCFunction ) &Dtool_BoundingVolume_extend_by_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_extend_by_222_comment},
  { "contains",(PyCFunction ) &Dtool_BoundingVolume_contains_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_contains_225_comment},
  { "output",(PyCFunction ) &Dtool_BoundingVolume_output_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_output_226_comment},
  { "write",(PyCFunction ) &Dtool_BoundingVolume_write_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_write_227_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingVolume_get_class_type_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingVolume_get_class_type_229_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BoundingVolume
//////////////////
static PyObject *  Dtool_Repr_BoundingVolume(PyObject * self)
{
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BoundingVolume
//////////////////
static PyObject *  Dtool_Str_BoundingVolume(PyObject * self)
{
    BoundingVolume * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BoundingVolume,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BoundingVolume(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingVolume.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingVolume\n"
          "// Description : This is an abstract class for any volume in any sense\n"
          "//               which can be said to define the locality of reference\n"
          "//               of a node in a graph, along with all of its\n"
          "//               descendants.  It is not necessarily a geometric\n"
          "//               volume (although see GeometricBoundingVolume); this\n"
          "//               is simply an abstract interface for bounds of any\n"
          "//               sort.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BoundingVolume.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_BoundingVolume.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingVolume.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BoundingVolume.As_PyTypeObject().tp_repr = & Dtool_Repr_BoundingVolume;
        // __str__
        Dtool_BoundingVolume.As_PyTypeObject().tp_str = & Dtool_Str_BoundingVolume;
        // Enum  BoundingVolume::IntersectionFlags;
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"IFNoIntersection",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"IFPossible",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"IFSome",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"IFAll",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"IFDontUnderstand",PyInt_FromLong(8));
        // Enum  BoundingVolume::BoundsType;
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"BTDefault",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"BTBest",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"BTSphere",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"BTBox",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_BoundingVolume.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingVolume)");
             printf(" Error In PyType_ReadyBoundingVolume");
             return;
        }
        Py_INCREF(&Dtool_BoundingVolume.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"BoundingVolume",&Dtool_BoundingVolume.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingVolume.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingVolume[8],&Dtool_BoundingVolume.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingVolume,BoundingVolume::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingVolume.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingVolume",(PyObject *)&Dtool_BoundingVolume.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GeometricBoundingVolume | GeometricBoundingVolume
//********************************************************************
PyMethodDef Dtool_Methods_GeometricBoundingVolume[]= {
  { "extendBy",(PyCFunction ) &Dtool_GeometricBoundingVolume_extend_by_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_extend_by_232_comment},
  { "around",(PyCFunction ) &Dtool_GeometricBoundingVolume_around_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_around_233_comment},
  { "contains",(PyCFunction ) &Dtool_GeometricBoundingVolume_contains_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_contains_234_comment},
  { "getApproxCenter",(PyCFunction ) &Dtool_GeometricBoundingVolume_get_approx_center_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_get_approx_center_235_comment},
  { "xform",(PyCFunction ) &Dtool_GeometricBoundingVolume_xform_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_xform_236_comment},
  { "getClassType",(PyCFunction ) &Dtool_GeometricBoundingVolume_get_class_type_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GeometricBoundingVolume_get_class_type_237_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GeometricBoundingVolume(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GeometricBoundingVolume\n"
          "// Description : This is another abstract class, for a general class\n"
          "//               of bounding volumes that actually enclose points in\n"
          "//               3-d space, such as BSP's and bounding spheres.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BoundingVolume._Dtool_ClassInit(NULL);
        Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BoundingVolume.As_PyTypeObject());
        Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GeometricBoundingVolume.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GeometricBoundingVolume)");
             printf(" Error In PyType_ReadyGeometricBoundingVolume");
             return;
        }
        Py_INCREF(&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_dict,"GeometricBoundingVolume",&Dtool_GeometricBoundingVolume.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GeometricBoundingVolume.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GeometricBoundingVolume[5],&Dtool_GeometricBoundingVolume.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GeometricBoundingVolume,GeometricBoundingVolume::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        PyModule_AddObject(module, "GeometricBoundingVolume",(PyObject *)&Dtool_GeometricBoundingVolume.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FiniteBoundingVolume | FiniteBoundingVolume
//********************************************************************
PyMethodDef Dtool_Methods_FiniteBoundingVolume[]= {
  { "getMin",(PyCFunction ) &Dtool_FiniteBoundingVolume_get_min_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FiniteBoundingVolume_get_min_240_comment},
  { "getMax",(PyCFunction ) &Dtool_FiniteBoundingVolume_get_max_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FiniteBoundingVolume_get_max_241_comment},
  { "getVolume",(PyCFunction ) &Dtool_FiniteBoundingVolume_get_volume_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FiniteBoundingVolume_get_volume_242_comment},
  { "getClassType",(PyCFunction ) &Dtool_FiniteBoundingVolume_get_class_type_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FiniteBoundingVolume_get_class_type_243_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FiniteBoundingVolume(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FiniteBoundingVolume\n"
          "// Description : A special kind of GeometricBoundingVolume that is\n"
          "//               known to be finite.  It is possible to query this\n"
          "//               kind of volume for its minimum and maximum extents.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GeometricBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FiniteBoundingVolume.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FiniteBoundingVolume)");
             printf(" Error In PyType_ReadyFiniteBoundingVolume");
             return;
        }
        Py_INCREF(&Dtool_FiniteBoundingVolume.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_dict,"FiniteBoundingVolume",&Dtool_FiniteBoundingVolume.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FiniteBoundingVolume.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FiniteBoundingVolume[3],&Dtool_FiniteBoundingVolume.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FiniteBoundingVolume,FiniteBoundingVolume::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FiniteBoundingVolume.As_PyTypeObject());
        PyModule_AddObject(module, "FiniteBoundingVolume",(PyObject *)&Dtool_FiniteBoundingVolume.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Parabolaf | Parabolaf
//********************************************************************
PyMethodDef Dtool_Methods_Parabolaf[]= {
  { "assign",(PyCFunction ) &Dtool_Parabolaf_operator_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_operator_247_comment},
  { "xform",(PyCFunction ) &Dtool_Parabolaf_xform_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_xform_249_comment},
  { "getA",(PyCFunction ) &Dtool_Parabolaf_get_a_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_get_a_250_comment},
  { "getB",(PyCFunction ) &Dtool_Parabolaf_get_b_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_get_b_251_comment},
  { "getC",(PyCFunction ) &Dtool_Parabolaf_get_c_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_get_c_252_comment},
  { "calcPoint",(PyCFunction ) &Dtool_Parabolaf_calc_point_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_calc_point_253_comment},
  { "output",(PyCFunction ) &Dtool_Parabolaf_output_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_output_254_comment},
  { "write",(PyCFunction ) &Dtool_Parabolaf_write_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolaf_write_255_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Parabolaf
//////////////////
static PyObject *  Dtool_Repr_Parabolaf(PyObject * self)
{
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Parabolaf
//////////////////
static PyObject *  Dtool_Str_Parabolaf(PyObject * self)
{
    Parabolaf * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolaf,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Parabolaf(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Parabolaf.As_PyTypeObject().tp_doc =
          "// Filename: parabola_src.h\n"
          "// Created by:  drose (10Oct07)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Parabola\n"
          "// Description : An abstract mathematical description of a parabola,\n"
          "//               particularly useful for describing arcs of\n"
          "//               projectiles.\n"
          "//\n"
          "//               The parabolic equation, given parametrically here, is\n"
          "//               P = At^2 + Bt + C.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Parabolaf.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Parabolaf.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Parabolaf.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Parabolaf.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Parabolaf.As_PyTypeObject().tp_repr = & Dtool_Repr_Parabolaf;
        // __str__
        Dtool_Parabolaf.As_PyTypeObject().tp_str = & Dtool_Str_Parabolaf;
        if(PyType_Ready(&Dtool_Parabolaf.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Parabolaf)");
             printf(" Error In PyType_ReadyParabolaf");
             return;
        }
        Py_INCREF(&Dtool_Parabolaf.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Parabolaf.As_PyTypeObject().tp_dict,"Parabolaf",&Dtool_Parabolaf.As_PyObject());
        RegisterRuntimeClass(&Dtool_Parabolaf,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Parabolaf.As_PyTypeObject());
        PyModule_AddObject(module, "Parabolaf",(PyObject *)&Dtool_Parabolaf.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Parabolad | Parabolad
//********************************************************************
PyMethodDef Dtool_Methods_Parabolad[]= {
  { "assign",(PyCFunction ) &Dtool_Parabolad_operator_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_operator_258_comment},
  { "xform",(PyCFunction ) &Dtool_Parabolad_xform_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_xform_260_comment},
  { "getA",(PyCFunction ) &Dtool_Parabolad_get_a_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_get_a_261_comment},
  { "getB",(PyCFunction ) &Dtool_Parabolad_get_b_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_get_b_262_comment},
  { "getC",(PyCFunction ) &Dtool_Parabolad_get_c_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_get_c_263_comment},
  { "calcPoint",(PyCFunction ) &Dtool_Parabolad_calc_point_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_calc_point_264_comment},
  { "output",(PyCFunction ) &Dtool_Parabolad_output_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_output_265_comment},
  { "write",(PyCFunction ) &Dtool_Parabolad_write_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Parabolad_write_266_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Parabolad
//////////////////
static PyObject *  Dtool_Repr_Parabolad(PyObject * self)
{
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Parabolad
//////////////////
static PyObject *  Dtool_Str_Parabolad(PyObject * self)
{
    Parabolad * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Parabolad,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Parabolad(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Parabolad.As_PyTypeObject().tp_doc =
          "// Filename: parabola_src.h\n"
          "// Created by:  drose (10Oct07)\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//\n"
          "// PANDA 3D SOFTWARE\n"
          "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
          "//\n"
          "// All use of this software is subject to the terms of the revised BSD\n"
          "// license.  You should have received a copy of this license along\n"
          "// with this source code in a file named \"LICENSE.\"\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Parabola\n"
          "// Description : An abstract mathematical description of a parabola,\n"
          "//               particularly useful for describing arcs of\n"
          "//               projectiles.\n"
          "//\n"
          "//               The parabolic equation, given parametrically here, is\n"
          "//               P = At^2 + Bt + C.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Parabolad.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Parabolad.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Parabolad.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Parabolad.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Parabolad.As_PyTypeObject().tp_repr = & Dtool_Repr_Parabolad;
        // __str__
        Dtool_Parabolad.As_PyTypeObject().tp_str = & Dtool_Str_Parabolad;
        if(PyType_Ready(&Dtool_Parabolad.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Parabolad)");
             printf(" Error In PyType_ReadyParabolad");
             return;
        }
        Py_INCREF(&Dtool_Parabolad.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Parabolad.As_PyTypeObject().tp_dict,"Parabolad",&Dtool_Parabolad.As_PyObject());
        RegisterRuntimeClass(&Dtool_Parabolad,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Parabolad.As_PyTypeObject());
        PyModule_AddObject(module, "Parabolad",(PyObject *)&Dtool_Parabolad.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingBox | BoundingBox
//********************************************************************
PyMethodDef Dtool_Methods_BoundingBox[]= {
  { "getNumPoints",(PyCFunction ) &Dtool_BoundingBox_get_num_points_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingBox_get_num_points_272_comment},
  { "getPoint",(PyCFunction ) &Dtool_BoundingBox_get_point_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingBox_get_point_273_comment},
  { "getNumPlanes",(PyCFunction ) &Dtool_BoundingBox_get_num_planes_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingBox_get_num_planes_274_comment},
  { "getPlane",(PyCFunction ) &Dtool_BoundingBox_get_plane_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingBox_get_plane_275_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingBox_get_class_type_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingBox_get_class_type_276_comment},
  { "getPoints",(PyCFunction) &MakeSeq_BoundingBox_get_points, METH_NOARGS, NULL},
  { "getPlanes",(PyCFunction) &MakeSeq_BoundingBox_get_planes, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoundingBox(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingBox.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingBox\n"
          "// Description : An axis-aligned bounding box; that is, a minimum and\n"
          "//               maximum coordinate triple.\n"
          "//\n"
          "//               This box is always axis-aligned.  If you need a more\n"
          "//               general bounding box, try BoundingHexahedron.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_FiniteBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_BoundingBox.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_FiniteBoundingVolume.As_PyTypeObject());
        Dtool_BoundingBox.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingBox.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingBox.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoundingBox.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingBox)");
             printf(" Error In PyType_ReadyBoundingBox");
             return;
        }
        Py_INCREF(&Dtool_BoundingBox.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingBox.As_PyTypeObject().tp_dict,"BoundingBox",&Dtool_BoundingBox.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingBox.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingBox[4],&Dtool_BoundingBox.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingBox,BoundingBox::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingBox.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingBox",(PyObject *)&Dtool_BoundingBox.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingHexahedron | BoundingHexahedron
//********************************************************************
PyMethodDef Dtool_Methods_BoundingHexahedron[]= {
  { "getNumPoints",(PyCFunction ) &Dtool_BoundingHexahedron_get_num_points_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingHexahedron_get_num_points_280_comment},
  { "getPoint",(PyCFunction ) &Dtool_BoundingHexahedron_get_point_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingHexahedron_get_point_281_comment},
  { "getNumPlanes",(PyCFunction ) &Dtool_BoundingHexahedron_get_num_planes_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingHexahedron_get_num_planes_282_comment},
  { "getPlane",(PyCFunction ) &Dtool_BoundingHexahedron_get_plane_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingHexahedron_get_plane_283_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingHexahedron_get_class_type_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingHexahedron_get_class_type_284_comment},
  { "getPoints",(PyCFunction) &MakeSeq_BoundingHexahedron_get_points, METH_NOARGS, NULL},
  { "getPlanes",(PyCFunction) &MakeSeq_BoundingHexahedron_get_planes, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoundingHexahedron(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingHexahedron.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingHexahedron\n"
          "// Description : This defines a bounding convex hexahedron.  It is\n"
          "//               typically used to represent a frustum, but may\n"
          "//               represent any enclosing convex hexahedron, including\n"
          "//               simple boxes.  However, if all you want is an\n"
          "//               axis-aligned bounding box, you may be better off with\n"
          "//               the simpler BoundingBox class.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_FiniteBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_BoundingHexahedron.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_FiniteBoundingVolume.As_PyTypeObject());
        Dtool_BoundingHexahedron.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingHexahedron.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingHexahedron.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoundingHexahedron.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingHexahedron)");
             printf(" Error In PyType_ReadyBoundingHexahedron");
             return;
        }
        Py_INCREF(&Dtool_BoundingHexahedron.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingHexahedron.As_PyTypeObject().tp_dict,"BoundingHexahedron",&Dtool_BoundingHexahedron.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingHexahedron.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingHexahedron[4],&Dtool_BoundingHexahedron.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingHexahedron,BoundingHexahedron::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingHexahedron.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingHexahedron",(PyObject *)&Dtool_BoundingHexahedron.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingLine | BoundingLine
//********************************************************************
PyMethodDef Dtool_Methods_BoundingLine[]= {
  { "getPointA",(PyCFunction ) &Dtool_BoundingLine_get_point_a_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingLine_get_point_a_291_comment},
  { "getPointB",(PyCFunction ) &Dtool_BoundingLine_get_point_b_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingLine_get_point_b_292_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingLine_get_class_type_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingLine_get_class_type_293_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoundingLine(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingLine.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingLine\n"
          "// Description : This funny bounding volume is an infinite line with\n"
          "//               no thickness and extending to infinity in both\n"
          "//               directions.\n"
          "//\n"
          "//               Note that it *always* extends in both directions,\n"
          "//               despite the fact that you specify two points to the\n"
          "//               constructor.  These are not endpoints, they are two\n"
          "//               arbitrary points on the line.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GeometricBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_BoundingLine.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        Dtool_BoundingLine.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingLine.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingLine.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoundingLine.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingLine)");
             printf(" Error In PyType_ReadyBoundingLine");
             return;
        }
        Py_INCREF(&Dtool_BoundingLine.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingLine.As_PyTypeObject().tp_dict,"BoundingLine",&Dtool_BoundingLine.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingLine.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingLine[2],&Dtool_BoundingLine.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingLine,BoundingLine::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingLine.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingLine",(PyObject *)&Dtool_BoundingLine.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingPlane | BoundingPlane
//********************************************************************
PyMethodDef Dtool_Methods_BoundingPlane[]= {
  { "getPlane",(PyCFunction ) &Dtool_BoundingPlane_get_plane_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingPlane_get_plane_300_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingPlane_get_class_type_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingPlane_get_class_type_301_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoundingPlane(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingPlane.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingPlane\n"
          "// Description : This funny bounding volume is an infinite plane that\n"
          "//               divides space into two regions: the part behind the\n"
          "//               normal, which is \"inside\" the bounding volume, and\n"
          "//               the part in front of the normal, which is \"outside\"\n"
          "//               the bounding volume.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GeometricBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_BoundingPlane.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        Dtool_BoundingPlane.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingPlane.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingPlane.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoundingPlane.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingPlane)");
             printf(" Error In PyType_ReadyBoundingPlane");
             return;
        }
        Py_INCREF(&Dtool_BoundingPlane.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingPlane.As_PyTypeObject().tp_dict,"BoundingPlane",&Dtool_BoundingPlane.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingPlane.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingPlane[1],&Dtool_BoundingPlane.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingPlane,BoundingPlane::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingPlane.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingPlane",(PyObject *)&Dtool_BoundingPlane.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BoundingSphere | BoundingSphere
//********************************************************************
PyMethodDef Dtool_Methods_BoundingSphere[]= {
  { "getCenter",(PyCFunction ) &Dtool_BoundingSphere_get_center_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingSphere_get_center_308_comment},
  { "getRadius",(PyCFunction ) &Dtool_BoundingSphere_get_radius_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingSphere_get_radius_309_comment},
  { "getClassType",(PyCFunction ) &Dtool_BoundingSphere_get_class_type_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BoundingSphere_get_class_type_310_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BoundingSphere(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BoundingSphere.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BoundingSphere\n"
          "// Description : This defines a bounding sphere, consisting of a\n"
          "//               center and a radius.  It is always a sphere, and\n"
          "//               never an ellipsoid or other quadric.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_FiniteBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_BoundingSphere.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_FiniteBoundingVolume.As_PyTypeObject());
        Dtool_BoundingSphere.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BoundingSphere.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BoundingSphere.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BoundingSphere.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BoundingSphere)");
             printf(" Error In PyType_ReadyBoundingSphere");
             return;
        }
        Py_INCREF(&Dtool_BoundingSphere.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BoundingSphere.As_PyTypeObject().tp_dict,"BoundingSphere",&Dtool_BoundingSphere.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BoundingSphere.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BoundingSphere[2],&Dtool_BoundingSphere.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BoundingSphere,BoundingSphere::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BoundingSphere.As_PyTypeObject());
        PyModule_AddObject(module, "BoundingSphere",(PyObject *)&Dtool_BoundingSphere.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OmniBoundingVolume | OmniBoundingVolume
//********************************************************************
PyMethodDef Dtool_Methods_OmniBoundingVolume[]= {
  { "getClassType",(PyCFunction ) &Dtool_OmniBoundingVolume_get_class_type_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OmniBoundingVolume_get_class_type_316_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OmniBoundingVolume(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OmniBoundingVolume.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OmniBoundingVolume\n"
          "// Description : This is a special kind of GeometricBoundingVolume\n"
          "//               that fills all of space.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_GeometricBoundingVolume._Dtool_ClassInit(NULL);
        Dtool_OmniBoundingVolume.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_GeometricBoundingVolume.As_PyTypeObject());
        Dtool_OmniBoundingVolume.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OmniBoundingVolume.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OmniBoundingVolume.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OmniBoundingVolume.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OmniBoundingVolume)");
             printf(" Error In PyType_ReadyOmniBoundingVolume");
             return;
        }
        Py_INCREF(&Dtool_OmniBoundingVolume.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OmniBoundingVolume.As_PyTypeObject().tp_dict,"OmniBoundingVolume",&Dtool_OmniBoundingVolume.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OmniBoundingVolume.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OmniBoundingVolume[0],&Dtool_OmniBoundingVolume.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OmniBoundingVolume,OmniBoundingVolume::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OmniBoundingVolume.As_PyTypeObject());
        PyModule_AddObject(module, "OmniBoundingVolume",(PyObject *)&Dtool_OmniBoundingVolume.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Mersenne | Mersenne
//********************************************************************
PyMethodDef Dtool_Methods_Mersenne[]= {
  { "getUint31",(PyCFunction ) &Dtool_Mersenne_get_uint31_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Mersenne_get_uint31_320_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Mersenne(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Mersenne.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Mersenne.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Mersenne.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Mersenne.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Mersenne.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Mersenne)");
             printf(" Error In PyType_ReadyMersenne");
             return;
        }
        Py_INCREF(&Dtool_Mersenne.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Mersenne.As_PyTypeObject().tp_dict,"Mersenne",&Dtool_Mersenne.As_PyObject());
        RegisterRuntimeClass(&Dtool_Mersenne,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Mersenne.As_PyTypeObject());
        PyModule_AddObject(module, "Mersenne",(PyObject *)&Dtool_Mersenne.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PerlinNoise | PerlinNoise
//********************************************************************
PyMethodDef Dtool_Methods_PerlinNoise[]= {
  { "getSeed",(PyCFunction ) &Dtool_PerlinNoise_get_seed_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise_get_seed_323_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PerlinNoise(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PerlinNoise.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PerlinNoise\n"
          "// Description : This is the base class for PerlinNoise2 and\n"
          "//               PerlinNoise3, different dimensions of Perlin noise\n"
          "//               implementation.  The base class just collects the\n"
          "//               common functionality.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PerlinNoise.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PerlinNoise.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PerlinNoise.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PerlinNoise.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PerlinNoise.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PerlinNoise)");
             printf(" Error In PyType_ReadyPerlinNoise");
             return;
        }
        Py_INCREF(&Dtool_PerlinNoise.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PerlinNoise.As_PyTypeObject().tp_dict,"PerlinNoise",&Dtool_PerlinNoise.As_PyObject());
        RegisterRuntimeClass(&Dtool_PerlinNoise,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PerlinNoise.As_PyTypeObject());
        PyModule_AddObject(module, "PerlinNoise",(PyObject *)&Dtool_PerlinNoise.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PerlinNoise2 | PerlinNoise2
//********************************************************************
PyMethodDef Dtool_Methods_PerlinNoise2[]= {
  { "assign",(PyCFunction ) &Dtool_PerlinNoise2_operator_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise2_operator_327_comment},
  { "setScale",(PyCFunction ) &Dtool_PerlinNoise2_set_scale_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise2_set_scale_328_comment},
  { "noise",(PyCFunction ) &Dtool_PerlinNoise2_noise_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise2_noise_329_comment},
  { "__call__",(PyCFunction ) &Dtool_PerlinNoise2_operator_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise2_operator_330_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PerlinNoise2(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PerlinNoise2.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PerlinNoise2\n"
          "// Description : This class provides an implementation of Perlin noise\n"
          "//               for 2 variables.  This code is loosely based on the\n"
          "//               reference implementation at\n"
          "//               http://mrl.nyu.edu/~perlin/noise/ .\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PerlinNoise._Dtool_ClassInit(NULL);
        Dtool_PerlinNoise2.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PerlinNoise.As_PyTypeObject());
        Dtool_PerlinNoise2.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PerlinNoise2.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PerlinNoise2.As_PyTypeObject().tp_dict);
        // tp_call = __call__
        Dtool_PerlinNoise2.As_PyTypeObject().tp_call = &Dtool_PerlinNoise2_operator_330;
        if(PyType_Ready(&Dtool_PerlinNoise2.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PerlinNoise2)");
             printf(" Error In PyType_ReadyPerlinNoise2");
             return;
        }
        Py_INCREF(&Dtool_PerlinNoise2.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PerlinNoise2.As_PyTypeObject().tp_dict,"PerlinNoise2",&Dtool_PerlinNoise2.As_PyObject());
        RegisterRuntimeClass(&Dtool_PerlinNoise2,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PerlinNoise2.As_PyTypeObject());
        PyModule_AddObject(module, "PerlinNoise2",(PyObject *)&Dtool_PerlinNoise2.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PerlinNoise3 | PerlinNoise3
//********************************************************************
PyMethodDef Dtool_Methods_PerlinNoise3[]= {
  { "assign",(PyCFunction ) &Dtool_PerlinNoise3_operator_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise3_operator_334_comment},
  { "setScale",(PyCFunction ) &Dtool_PerlinNoise3_set_scale_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise3_set_scale_335_comment},
  { "noise",(PyCFunction ) &Dtool_PerlinNoise3_noise_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise3_noise_336_comment},
  { "__call__",(PyCFunction ) &Dtool_PerlinNoise3_operator_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PerlinNoise3_operator_337_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PerlinNoise3(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PerlinNoise3.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PerlinNoise3\n"
          "// Description : This class provides an implementation of Perlin noise\n"
          "//               for 3 variables.  This code is loosely based on the\n"
          "//               reference implementation at\n"
          "//               http://mrl.nyu.edu/~perlin/noise/ .\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PerlinNoise._Dtool_ClassInit(NULL);
        Dtool_PerlinNoise3.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PerlinNoise.As_PyTypeObject());
        Dtool_PerlinNoise3.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PerlinNoise3.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PerlinNoise3.As_PyTypeObject().tp_dict);
        // tp_call = __call__
        Dtool_PerlinNoise3.As_PyTypeObject().tp_call = &Dtool_PerlinNoise3_operator_337;
        if(PyType_Ready(&Dtool_PerlinNoise3.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PerlinNoise3)");
             printf(" Error In PyType_ReadyPerlinNoise3");
             return;
        }
        Py_INCREF(&Dtool_PerlinNoise3.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PerlinNoise3.As_PyTypeObject().tp_dict,"PerlinNoise3",&Dtool_PerlinNoise3.As_PyObject());
        RegisterRuntimeClass(&Dtool_PerlinNoise3,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PerlinNoise3.As_PyTypeObject());
        PyModule_AddObject(module, "PerlinNoise3",(PyObject *)&Dtool_PerlinNoise3.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StackedPerlinNoise2 | StackedPerlinNoise2
//********************************************************************
PyMethodDef Dtool_Methods_StackedPerlinNoise2[]= {
  { "assign",(PyCFunction ) &Dtool_StackedPerlinNoise2_operator_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise2_operator_342_comment},
  { "addLevel",(PyCFunction ) &Dtool_StackedPerlinNoise2_add_level_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise2_add_level_343_comment},
  { "clear",(PyCFunction ) &Dtool_StackedPerlinNoise2_clear_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise2_clear_344_comment},
  { "noise",(PyCFunction ) &Dtool_StackedPerlinNoise2_noise_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise2_noise_345_comment},
  { "__call__",(PyCFunction ) &Dtool_StackedPerlinNoise2_operator_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise2_operator_346_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StackedPerlinNoise2(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StackedPerlinNoise2\n"
          "// Description : Implements a multi-layer PerlinNoise, with one or\n"
          "//               more high-frequency noise functions added to a\n"
          "//               lower-frequency base noise function.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_dict);
        // tp_call = __call__
        Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_call = &Dtool_StackedPerlinNoise2_operator_346;
        if(PyType_Ready(&Dtool_StackedPerlinNoise2.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StackedPerlinNoise2)");
             printf(" Error In PyType_ReadyStackedPerlinNoise2");
             return;
        }
        Py_INCREF(&Dtool_StackedPerlinNoise2.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StackedPerlinNoise2.As_PyTypeObject().tp_dict,"StackedPerlinNoise2",&Dtool_StackedPerlinNoise2.As_PyObject());
        RegisterRuntimeClass(&Dtool_StackedPerlinNoise2,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StackedPerlinNoise2.As_PyTypeObject());
        PyModule_AddObject(module, "StackedPerlinNoise2",(PyObject *)&Dtool_StackedPerlinNoise2.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. StackedPerlinNoise3 | StackedPerlinNoise3
//********************************************************************
PyMethodDef Dtool_Methods_StackedPerlinNoise3[]= {
  { "assign",(PyCFunction ) &Dtool_StackedPerlinNoise3_operator_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise3_operator_350_comment},
  { "addLevel",(PyCFunction ) &Dtool_StackedPerlinNoise3_add_level_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise3_add_level_351_comment},
  { "clear",(PyCFunction ) &Dtool_StackedPerlinNoise3_clear_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise3_clear_352_comment},
  { "noise",(PyCFunction ) &Dtool_StackedPerlinNoise3_noise_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise3_noise_353_comment},
  { "__call__",(PyCFunction ) &Dtool_StackedPerlinNoise3_operator_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_StackedPerlinNoise3_operator_354_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_StackedPerlinNoise3(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : StackedPerlinNoise3\n"
          "// Description : Implements a multi-layer PerlinNoise, with one or\n"
          "//               more high-frequency noise functions added to a\n"
          "//               lower-frequency base noise function.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_dict);
        // tp_call = __call__
        Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_call = &Dtool_StackedPerlinNoise3_operator_354;
        if(PyType_Ready(&Dtool_StackedPerlinNoise3.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(StackedPerlinNoise3)");
             printf(" Error In PyType_ReadyStackedPerlinNoise3");
             return;
        }
        Py_INCREF(&Dtool_StackedPerlinNoise3.As_PyTypeObject());
        PyDict_SetItemString(Dtool_StackedPerlinNoise3.As_PyTypeObject().tp_dict,"StackedPerlinNoise3",&Dtool_StackedPerlinNoise3.As_PyObject());
        RegisterRuntimeClass(&Dtool_StackedPerlinNoise3,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_StackedPerlinNoise3.As_PyTypeObject());
        PyModule_AddObject(module, "StackedPerlinNoise3",(PyObject *)&Dtool_StackedPerlinNoise3.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Triangulator | Triangulator
//********************************************************************
PyMethodDef Dtool_Methods_Triangulator[]= {
  { "clear",(PyCFunction ) &Dtool_Triangulator_clear_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_clear_358_comment},
  { "addVertex",(PyCFunction ) &Dtool_Triangulator_add_vertex_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_add_vertex_359_comment},
  { "getNumVertices",(PyCFunction ) &Dtool_Triangulator_get_num_vertices_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_num_vertices_360_comment},
  { "getVertex",(PyCFunction ) &Dtool_Triangulator_get_vertex_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_vertex_361_comment},
  { "clearPolygon",(PyCFunction ) &Dtool_Triangulator_clear_polygon_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_clear_polygon_362_comment},
  { "addPolygonVertex",(PyCFunction ) &Dtool_Triangulator_add_polygon_vertex_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_add_polygon_vertex_363_comment},
  { "isLeftWinding",(PyCFunction ) &Dtool_Triangulator_is_left_winding_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_is_left_winding_364_comment},
  { "beginHole",(PyCFunction ) &Dtool_Triangulator_begin_hole_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_begin_hole_365_comment},
  { "addHoleVertex",(PyCFunction ) &Dtool_Triangulator_add_hole_vertex_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_add_hole_vertex_366_comment},
  { "triangulate",(PyCFunction ) &Dtool_Triangulator_triangulate_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_triangulate_367_comment},
  { "getNumTriangles",(PyCFunction ) &Dtool_Triangulator_get_num_triangles_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_num_triangles_368_comment},
  { "getTriangleV0",(PyCFunction ) &Dtool_Triangulator_get_triangle_v0_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_triangle_v0_369_comment},
  { "getTriangleV1",(PyCFunction ) &Dtool_Triangulator_get_triangle_v1_370, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_triangle_v1_370_comment},
  { "getTriangleV2",(PyCFunction ) &Dtool_Triangulator_get_triangle_v2_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Triangulator_get_triangle_v2_371_comment},
  { "getVertices",(PyCFunction) &MakeSeq_Triangulator_get_vertices, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Triangulator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Triangulator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Triangulator\n"
          "// Description : This class can triangulate a convex or concave\n"
          "//               polygon, even one with holes.  It is adapted from an\n"
          "//               algorithm published as:\n"
          "//\n"
          "//               Narkhede A. and Manocha D., Fast polygon\n"
          "//               triangulation algorithm based on Seidel's Algorithm,\n"
          "//               UNC-CH, 1994.\n"
          "//\n"
          "//               http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html\n"
          "//\n"
          "//               It works strictly on 2-d points.  You'll have to\n"
          "//               convert your polygon into a plane if you have 3-d\n"
          "//               points.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Triangulator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Triangulator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Triangulator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Triangulator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Triangulator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Triangulator)");
             printf(" Error In PyType_ReadyTriangulator");
             return;
        }
        Py_INCREF(&Dtool_Triangulator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Triangulator.As_PyTypeObject().tp_dict,"Triangulator",&Dtool_Triangulator.As_PyObject());
        RegisterRuntimeClass(&Dtool_Triangulator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Triangulator.As_PyTypeObject());
        PyModule_AddObject(module, "Triangulator",(PyObject *)&Dtool_Triangulator.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< LMatrix3f >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< LMatrix3f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< LMatrix3f > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix3f(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< LMatrix4f >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_LMatrix4f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< LMatrix4f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_LMatrix4f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< LMatrix4f > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LMatrix4f(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< LVecBase2f >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< LVecBase2f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< LVecBase2f > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< LVecBase3f >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< LVecBase3f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< LVecBase3f > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..ConstPointerToArray< LVecBase4f >
//********************************************************************
   Dtool_PyModuleClassInit_ConstPointerToArray_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArrayBase< LVecBase4f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArrayBase_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToBase< ReferenceCountedVector< LVecBase4f > >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..Frustumd
//********************************************************************
   Dtool_PyModuleClassInit_Frustumd(module);
//********************************************************************
//*** Module Init Updcall ..Frustumf
//********************************************************************
   Dtool_PyModuleClassInit_Frustumf(module);
//********************************************************************
//*** Module Init Updcall ..Planed
//********************************************************************
   Dtool_PyModuleClassInit_Planed(module);
//********************************************************************
//*** Module Init Updcall ..Planef
//********************************************************************
   Dtool_PyModuleClassInit_Planef(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< LMatrix3f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_LMatrix3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< LMatrix4f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_LMatrix4f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< LVecBase2f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< LVecBase3f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..PointerToArray< LVecBase4f >
//********************************************************************
   Dtool_PyModuleClassInit_PointerToArray_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..BoundingVolume
//********************************************************************
   Dtool_PyModuleClassInit_BoundingVolume(module);
//********************************************************************
//*** Module Init Updcall ..GeometricBoundingVolume
//********************************************************************
   Dtool_PyModuleClassInit_GeometricBoundingVolume(module);
//********************************************************************
//*** Module Init Updcall ..FiniteBoundingVolume
//********************************************************************
   Dtool_PyModuleClassInit_FiniteBoundingVolume(module);
//********************************************************************
//*** Module Init Updcall ..Parabolaf
//********************************************************************
   Dtool_PyModuleClassInit_Parabolaf(module);
//********************************************************************
//*** Module Init Updcall ..Parabolad
//********************************************************************
   Dtool_PyModuleClassInit_Parabolad(module);
//********************************************************************
//*** Module Init Updcall ..BoundingBox
//********************************************************************
   Dtool_PyModuleClassInit_BoundingBox(module);
//********************************************************************
//*** Module Init Updcall ..BoundingHexahedron
//********************************************************************
   Dtool_PyModuleClassInit_BoundingHexahedron(module);
//********************************************************************
//*** Module Init Updcall ..BoundingLine
//********************************************************************
   Dtool_PyModuleClassInit_BoundingLine(module);
//********************************************************************
//*** Module Init Updcall ..BoundingPlane
//********************************************************************
   Dtool_PyModuleClassInit_BoundingPlane(module);
//********************************************************************
//*** Module Init Updcall ..BoundingSphere
//********************************************************************
   Dtool_PyModuleClassInit_BoundingSphere(module);
//********************************************************************
//*** Module Init Updcall ..OmniBoundingVolume
//********************************************************************
   Dtool_PyModuleClassInit_OmniBoundingVolume(module);
//********************************************************************
//*** Module Init Updcall ..Mersenne
//********************************************************************
   Dtool_PyModuleClassInit_Mersenne(module);
//********************************************************************
//*** Module Init Updcall ..PerlinNoise
//********************************************************************
   Dtool_PyModuleClassInit_PerlinNoise(module);
//********************************************************************
//*** Module Init Updcall ..PerlinNoise2
//********************************************************************
   Dtool_PyModuleClassInit_PerlinNoise2(module);
//********************************************************************
//*** Module Init Updcall ..PerlinNoise3
//********************************************************************
   Dtool_PyModuleClassInit_PerlinNoise3(module);
//********************************************************************
//*** Module Init Updcall ..StackedPerlinNoise2
//********************************************************************
   Dtool_PyModuleClassInit_StackedPerlinNoise2(module);
//********************************************************************
//*** Module Init Updcall ..StackedPerlinNoise3
//********************************************************************
   Dtool_PyModuleClassInit_StackedPerlinNoise3(module);
//********************************************************************
//*** Module Init Updcall ..Triangulator
//********************************************************************
   Dtool_PyModuleClassInit_Triangulator(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "headsUp", (PyCFunction) &Dtool_heads_up_312, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_heads_up_312_comment},
  { "lookAt", (PyCFunction) &Dtool_look_at_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_look_at_313_comment},
  { "rotateTo", (PyCFunction) &Dtool_rotate_to_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_rotate_to_339_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libmathutil_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212826,  /* file_identifier */
  "libmathutil",  /* library_name */
  "SkjP",  /* library_hash_name */
  "panda",  /* module_name */
  "libmathutil.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  990  /* next_index */
};

Configure(_in_configure_libmathutil);
ConfigureFn(_in_configure_libmathutil) {
  interrogate_request_module(&_in_module_def);
}

