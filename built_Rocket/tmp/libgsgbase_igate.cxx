/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/gsgbase -Ipanda/src/gsgbase -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libgsgbase_igate.cxx -od built_Rocket/pandac/input/libgsgbase.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/gsgbase -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libgsgbase config_gsgbase.h displayRegionBase.h graphicsOutputBase.h graphicsStateGuardianBase.h gsgbase_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libgsgbase
#include "py_panda.h"  

#include "config_gsgbase.h"
#include "displayRegionBase.h"
#include "graphicsOutputBase.h"
#include "graphicsStateGuardianBase.h"
#include "lightMutex.h"
#include "luse.h"
#include "pandabase.h"
#include "typedReferenceCount.h"
#include "typedWritableReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. DisplayRegionBase
//********************************************************************
typedef  DisplayRegionBase  DisplayRegionBase_localtype;
Define_Module_ClassRef(panda,DisplayRegionBase,DisplayRegionBase_localtype,DisplayRegionBase);
//********************************************************************
//*** prototypes for .. GraphicsOutputBase
//********************************************************************
typedef  GraphicsOutputBase  GraphicsOutputBase_localtype;
Define_Module_ClassRef(panda,GraphicsOutputBase,GraphicsOutputBase_localtype,GraphicsOutputBase);
//********************************************************************
//*** prototypes for .. GraphicsStateGuardianBase
//********************************************************************
typedef  GraphicsStateGuardianBase  GraphicsStateGuardianBase_localtype;
Define_Module_ClassRef(panda,GraphicsStateGuardianBase,GraphicsStateGuardianBase_localtype,GraphicsStateGuardianBase);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. DisplayRegionBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void DisplayRegionBase::output(ostream &out) const = 0
 *******************************************************************/
static PyObject *Dtool_DisplayRegionBase_output_3(PyObject *self, PyObject *args,PyObject *kwds) {
    DisplayRegionBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegionBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void DisplayRegionBase::output(ostream &out) const = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DisplayRegionBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DisplayRegionBase*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DisplayRegionBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionBase_output_3_comment =
    "C++ Interface:\n"
    "output(const DisplayRegionBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_DisplayRegionBase_output_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DisplayRegionBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DisplayRegionBase_get_class_type_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DisplayRegionBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DisplayRegionBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DisplayRegionBase_get_class_type_4_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DisplayRegionBase_get_class_type_4_comment = NULL;
#endif

int  Dtool_Init_DisplayRegionBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DisplayRegionBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DisplayRegionBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DisplayRegionBase)
    {
        printf("DisplayRegionBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DisplayRegionBase * local_this = (DisplayRegionBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DisplayRegionBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DisplayRegionBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DisplayRegionBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DisplayRegionBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DisplayRegionBase*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DisplayRegionBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsOutputBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void GraphicsOutputBase::set_sort(int sort) = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsOutputBase_set_sort_7(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsOutputBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsOutputBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void GraphicsOutputBase::set_sort(int sort) = 0
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call GraphicsOutputBase.setSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSort(non-const GraphicsOutputBase this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutputBase_set_sort_7_comment =
    "C++ Interface:\n"
    "setSort(non-const GraphicsOutputBase this, int sort)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsOutputBase_set_sort_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsOutputBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsOutputBase_get_class_type_9(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsOutputBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsOutputBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsOutputBase_get_class_type_9_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsOutputBase_get_class_type_9_comment = NULL;
#endif

int  Dtool_Init_GraphicsOutputBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsOutputBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_GraphicsOutputBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsOutputBase)
    {
        printf("GraphicsOutputBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsOutputBase * local_this = (GraphicsOutputBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsOutputBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsOutputBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsOutputBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsOutputBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsOutputBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsOutputBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsOutputBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. GraphicsStateGuardianBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_incomplete_render(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_incomplete_render_12(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_incomplete_render(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIncompleteRender", key_word_list));
        else
            (PyArg_Parse(args, ":getIncompleteRender"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_incomplete_render();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIncompleteRender(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment =
    "C++ Interface:\n"
    "getIncompleteRender(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_effective_incomplete_render(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_effective_incomplete_render(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEffectiveIncompleteRender", key_word_list));
        else
            (PyArg_Parse(args, ":getEffectiveIncompleteRender"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_effective_incomplete_render();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEffectiveIncompleteRender(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment =
    "C++ Interface:\n"
    "getEffectiveIncompleteRender(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::prefers_triangle_strips(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::prefers_triangle_strips(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":prefersTriangleStrips", key_word_list));
        else
            (PyArg_Parse(args, ":prefersTriangleStrips"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->prefers_triangle_strips();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prefersTriangleStrips(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment =
    "C++ Interface:\n"
    "prefersTriangleStrips(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int GraphicsStateGuardianBase::get_max_vertices_per_array(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int GraphicsStateGuardianBase::get_max_vertices_per_array(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVerticesPerArray", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVerticesPerArray"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardianBase*)local_this)->get_max_vertices_per_array();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVerticesPerArray(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment =
    "C++ Interface:\n"
    "getMaxVerticesPerArray(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int GraphicsStateGuardianBase::get_max_vertices_per_primitive(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int GraphicsStateGuardianBase::get_max_vertices_per_primitive(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxVerticesPerPrimitive", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxVerticesPerPrimitive"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardianBase*)local_this)->get_max_vertices_per_primitive();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxVerticesPerPrimitive(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment =
    "C++ Interface:\n"
    "getMaxVerticesPerPrimitive(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int GraphicsStateGuardianBase::get_max_texture_dimension(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int GraphicsStateGuardianBase::get_max_texture_dimension(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxTextureDimension", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxTextureDimension"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardianBase*)local_this)->get_max_texture_dimension();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxTextureDimension(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment =
    "C++ Interface:\n"
    "getMaxTextureDimension(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_supports_compressed_texture_format(int compression_mode) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_supports_compressed_texture_format(int compression_mode) const = 0
        int param1;
        static char * key_word_list[] = {(char *)"compression_mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSupportsCompressedTextureFormat", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSupportsCompressedTextureFormat", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_supports_compressed_texture_format((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsCompressedTextureFormat(const GraphicsStateGuardianBase this, int compression_mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment =
    "C++ Interface:\n"
    "getSupportsCompressedTextureFormat(const GraphicsStateGuardianBase this, int compression_mode)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_supports_multisample(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_multisample_19(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_supports_multisample(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsMultisample", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsMultisample"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_supports_multisample();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsMultisample(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment =
    "C++ Interface:\n"
    "getSupportsMultisample(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual int GraphicsStateGuardianBase::get_supported_geom_rendering(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual int GraphicsStateGuardianBase::get_supported_geom_rendering(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportedGeomRendering", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportedGeomRendering"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const GraphicsStateGuardianBase*)local_this)->get_supported_geom_rendering();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportedGeomRendering(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment =
    "C++ Interface:\n"
    "getSupportedGeomRendering(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_supports_occlusion_query(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_occlusion_query_21(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_supports_occlusion_query(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsOcclusionQuery", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsOcclusionQuery"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_supports_occlusion_query();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsOcclusionQuery(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_supports_occlusion_query_21_comment =
    "C++ Interface:\n"
    "getSupportsOcclusionQuery(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_supports_occlusion_query_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool GraphicsStateGuardianBase::get_supports_shadow_filter(void) const = 0
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_22(PyObject *self, PyObject *args,PyObject *kwds) {
    GraphicsStateGuardianBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_GraphicsStateGuardianBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool GraphicsStateGuardianBase::get_supports_shadow_filter(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSupportsShadowFilter", key_word_list));
        else
            (PyArg_Parse(args, ":getSupportsShadowFilter"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const GraphicsStateGuardianBase*)local_this)->get_supports_shadow_filter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSupportsShadowFilter(const GraphicsStateGuardianBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_22_comment =
    "C++ Interface:\n"
    "getSupportsShadowFilter(const GraphicsStateGuardianBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_default_gsg(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_default_gsg_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_default_gsg(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultGsg", key_word_list))
        {
            GraphicsStateGuardianBase *return_value = GraphicsStateGuardianBase::get_default_gsg();
            if (return_value != (GraphicsStateGuardianBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsStateGuardianBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultGsg()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_default_gsg_23_comment =
    "C++ Interface:\n"
    "getDefaultGsg()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardianBase::get_default_gsg\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the \"default\" GSG.  This is\n"
    "//               typically the first GSG created in an application; in\n"
    "//               a single-window application, it will be the only GSG.\n"
    "//               This GSG is used to determine default optimization\n"
    "//               choices for loaded geometry.\n"
    "//\n"
    "//               The return value may be NULL if a GSG has not been\n"
    "//               created.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_default_gsg_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void GraphicsStateGuardianBase::set_default_gsg(GraphicsStateGuardianBase *default_gsg)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_set_default_gsg_24(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void GraphicsStateGuardianBase::set_default_gsg(GraphicsStateGuardianBase *default_gsg)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"default_gsg", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefaultGsg", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setDefaultGsg", &param0));
            if(!PyErr_Occurred())
            {
                GraphicsStateGuardianBase *param0_this = (GraphicsStateGuardianBase *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_GraphicsStateGuardianBase, 0, "GraphicsStateGuardianBase.setDefaultGsg", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    GraphicsStateGuardianBase::set_default_gsg(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultGsg(non-const GraphicsStateGuardianBase default_gsg)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_set_default_gsg_24_comment =
    "C++ Interface:\n"
    "setDefaultGsg(non-const GraphicsStateGuardianBase default_gsg)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardianBase::set_default_gsg\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies a particular GSG to use as the \"default\"\n"
    "//               GSG.  See get_default_gsg().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_set_default_gsg_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int GraphicsStateGuardianBase::get_num_gsgs(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_num_gsgs_25(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int GraphicsStateGuardianBase::get_num_gsgs(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGsgs", key_word_list))
        {
            int return_value = GraphicsStateGuardianBase::get_num_gsgs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGsgs()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_num_gsgs_25_comment =
    "C++ Interface:\n"
    "getNumGsgs()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardianBase::get_num_gsgs\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the total number of GSG's in the universe.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_num_gsgs_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_gsg(int n)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_gsg_26(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static GraphicsStateGuardianBase *GraphicsStateGuardianBase::get_gsg(int n)
        int param0;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGsg", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getGsg", &param0));
        if(!PyErr_Occurred())
        {
            GraphicsStateGuardianBase *return_value = GraphicsStateGuardianBase::get_gsg((int)param0);
            if (return_value != (GraphicsStateGuardianBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsStateGuardianBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGsg(int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_gsg_26_comment =
    "C++ Interface:\n"
    "getGsg(int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: GraphicsStateGuardianBase::get_gsg\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the nth GSG in the universe.  GSG's\n"
    "//               automatically add themselves and remove themselves\n"
    "//               from this list as they are created and destroyed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_gsg_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle GraphicsStateGuardianBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_GraphicsStateGuardianBase_get_class_type_27(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle GraphicsStateGuardianBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = GraphicsStateGuardianBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_GraphicsStateGuardianBase_get_class_type_27_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_GraphicsStateGuardianBase_get_class_type_27_comment = NULL;
#endif

int  Dtool_Init_GraphicsStateGuardianBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (GraphicsStateGuardianBase)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_GraphicsStateGuardianBase_get_gsgs(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumGsgs", "getGsg");
}
inline void  * Dtool_UpcastInterface_GraphicsStateGuardianBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_GraphicsStateGuardianBase)
    {
        printf("GraphicsStateGuardianBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    GraphicsStateGuardianBase * local_this = (GraphicsStateGuardianBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_GraphicsStateGuardianBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_GraphicsStateGuardianBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_GraphicsStateGuardianBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (GraphicsStateGuardianBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (GraphicsStateGuardianBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (GraphicsStateGuardianBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (GraphicsStateGuardianBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. DisplayRegionBase | DisplayRegionBase
//********************************************************************
PyMethodDef Dtool_Methods_DisplayRegionBase[]= {
  { "output",(PyCFunction ) &Dtool_DisplayRegionBase_output_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionBase_output_3_comment},
  { "getClassType",(PyCFunction ) &Dtool_DisplayRegionBase_get_class_type_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DisplayRegionBase_get_class_type_4_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DisplayRegionBase
//////////////////
static PyObject *  Dtool_Repr_DisplayRegionBase(PyObject * self)
{
    DisplayRegionBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DisplayRegionBase,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DisplayRegionBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DisplayRegionBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DisplayRegionBase\n"
          "// Description : An abstract base class for DisplayRegion, mainly so\n"
          "//               we can store DisplayRegion pointers in a Camera.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_DisplayRegionBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_DisplayRegionBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DisplayRegionBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DisplayRegionBase.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DisplayRegionBase.As_PyTypeObject().tp_repr = & Dtool_Repr_DisplayRegionBase;
        // __str__ Repr Proxy
        Dtool_DisplayRegionBase.As_PyTypeObject().tp_str = & Dtool_Repr_DisplayRegionBase;
        if(PyType_Ready(&Dtool_DisplayRegionBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DisplayRegionBase)");
             printf(" Error In PyType_ReadyDisplayRegionBase");
             return;
        }
        Py_INCREF(&Dtool_DisplayRegionBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DisplayRegionBase.As_PyTypeObject().tp_dict,"DisplayRegionBase",&Dtool_DisplayRegionBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DisplayRegionBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DisplayRegionBase[1],&Dtool_DisplayRegionBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DisplayRegionBase,DisplayRegionBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DisplayRegionBase.As_PyTypeObject());
        PyModule_AddObject(module, "DisplayRegionBase",(PyObject *)&Dtool_DisplayRegionBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsOutputBase | GraphicsOutputBase
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsOutputBase[]= {
  { "setSort",(PyCFunction ) &Dtool_GraphicsOutputBase_set_sort_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutputBase_set_sort_7_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsOutputBase_get_class_type_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsOutputBase_get_class_type_9_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsOutputBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsOutputBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsOutputBase\n"
          "// Description : An abstract base class for GraphicsOutput, for all\n"
          "//               the usual reasons.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_GraphicsOutputBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_GraphicsOutputBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsOutputBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsOutputBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsOutputBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsOutputBase)");
             printf(" Error In PyType_ReadyGraphicsOutputBase");
             return;
        }
        Py_INCREF(&Dtool_GraphicsOutputBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsOutputBase.As_PyTypeObject().tp_dict,"GraphicsOutputBase",&Dtool_GraphicsOutputBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsOutputBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsOutputBase[1],&Dtool_GraphicsOutputBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsOutputBase,GraphicsOutputBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsOutputBase.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsOutputBase",(PyObject *)&Dtool_GraphicsOutputBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. GraphicsStateGuardianBase | GraphicsStateGuardianBase
//********************************************************************
PyMethodDef Dtool_Methods_GraphicsStateGuardianBase[]= {
  { "getIncompleteRender",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_incomplete_render_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_incomplete_render_12_comment},
  { "getEffectiveIncompleteRender",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_effective_incomplete_render_13_comment},
  { "prefersTriangleStrips",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_prefers_triangle_strips_14_comment},
  { "getMaxVerticesPerArray",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_array_15_comment},
  { "getMaxVerticesPerPrimitive",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_max_vertices_per_primitive_16_comment},
  { "getMaxTextureDimension",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_max_texture_dimension_17_comment},
  { "getSupportsCompressedTextureFormat",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_supports_compressed_texture_format_18_comment},
  { "getSupportsMultisample",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_supports_multisample_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_supports_multisample_19_comment},
  { "getSupportedGeomRendering",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_supported_geom_rendering_20_comment},
  { "getSupportsOcclusionQuery",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_supports_occlusion_query_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_supports_occlusion_query_21_comment},
  { "getSupportsShadowFilter",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_supports_shadow_filter_22_comment},
  { "getDefaultGsg",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_default_gsg_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_default_gsg_23_comment},
  { "setDefaultGsg",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_set_default_gsg_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_set_default_gsg_24_comment},
  { "getNumGsgs",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_num_gsgs_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_num_gsgs_25_comment},
  { "getGsg",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_gsg_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_gsg_26_comment},
  { "getClassType",(PyCFunction ) &Dtool_GraphicsStateGuardianBase_get_class_type_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_GraphicsStateGuardianBase_get_class_type_27_comment},
  { "getGsgs",(PyCFunction) &MakeSeq_GraphicsStateGuardianBase_get_gsgs, METH_NOARGS|METH_CLASS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_GraphicsStateGuardianBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : GraphicsStateGuardianBase\n"
          "// Description : This is a base class for the GraphicsStateGuardian\n"
          "//               class, which is itself a base class for the various\n"
          "//               GSG's for different platforms.  This class contains\n"
          "//               all the function prototypes to support the\n"
          "//               double-dispatch of GSG to geoms, transitions, etc.  It\n"
          "//               lives in a separate class in its own package so we\n"
          "//               can avoid circular build dependency problems.\n"
          "//\n"
          "//               GraphicsStateGuardians are not actually writable to\n"
          "//               bam files, of course, but they may be passed as event\n"
          "//               parameters, so they inherit from\n"
          "//               TypedWritableReferenceCount instead of\n"
          "//               TypedReferenceCount for that convenience.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_GraphicsStateGuardianBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(GraphicsStateGuardianBase)");
             printf(" Error In PyType_ReadyGraphicsStateGuardianBase");
             return;
        }
        Py_INCREF(&Dtool_GraphicsStateGuardianBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"GraphicsStateGuardianBase",&Dtool_GraphicsStateGuardianBase.As_PyObject());
        //  Static Method getDefaultGsg
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"getDefaultGsg",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardianBase[11],&Dtool_GraphicsStateGuardianBase.As_PyObject()));
        //  Static Method setDefaultGsg
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"setDefaultGsg",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardianBase[12],&Dtool_GraphicsStateGuardianBase.As_PyObject()));
        //  Static Method getNumGsgs
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"getNumGsgs",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardianBase[13],&Dtool_GraphicsStateGuardianBase.As_PyObject()));
        //  Static Method getGsg
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"getGsg",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardianBase[14],&Dtool_GraphicsStateGuardianBase.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_GraphicsStateGuardianBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_GraphicsStateGuardianBase[15],&Dtool_GraphicsStateGuardianBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_GraphicsStateGuardianBase,GraphicsStateGuardianBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_GraphicsStateGuardianBase.As_PyTypeObject());
        PyModule_AddObject(module, "GraphicsStateGuardianBase",(PyObject *)&Dtool_GraphicsStateGuardianBase.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..DisplayRegionBase
//********************************************************************
   Dtool_PyModuleClassInit_DisplayRegionBase(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsOutputBase
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsOutputBase(module);
//********************************************************************
//*** Module Init Updcall ..GraphicsStateGuardianBase
//********************************************************************
   Dtool_PyModuleClassInit_GraphicsStateGuardianBase(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libgsgbase_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212826,  /* file_identifier */
  "libgsgbase",  /* library_name */
  "dSYD",  /* library_hash_name */
  "panda",  /* module_name */
  "libgsgbase.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  69  /* next_index */
};

Configure(_in_configure_libgsgbase);
ConfigureFn(_in_configure_libgsgbase) {
  interrogate_request_module(&_in_module_def);
}

