/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pipeline -Ipanda/src/pipeline -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpipeline_igate.cxx -od built_Rocket/pandac/input/libpipeline.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pipeline -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpipeline asyncTaskBase.h blockerSimple.h conditionVar.h conditionVarDebug.h conditionVarDirect.h conditionVarDummyImpl.h conditionVarFull.h conditionVarFullDebug.h conditionVarFullDirect.h conditionVarFullWin32Impl.h conditionVarImpl.h conditionVarPosixImpl.h conditionVarSimpleImpl.h conditionVarSpinlockImpl.h conditionVarWin32Impl.h config_pipeline.h contextSwitch.h cycleData.h cycleDataLockedReader.h cycleDataLockedStageReader.h cycleDataReader.h cycleDataStageReader.h cycleDataStageWriter.h cycleDataWriter.h cyclerHolder.h externalThread.h lightMutex.h lightMutexDirect.h lightMutexHolder.h lightReMutex.h lightReMutexDirect.h lightReMutexHolder.h mainThread.h mutexDebug.h mutexDirect.h mutexHolder.h mutexSimpleImpl.h mutexTrueImpl.h pipeline.h pipelineCycler.h pipelineCyclerBase.h pipelineCyclerDummyImpl.h pipelineCyclerLinks.h pipelineCyclerTrivialImpl.h pipelineCyclerTrueImpl.h pipeline_composite.cxx pmutex.h psemaphore.h pythonThread.h reMutex.h reMutexDirect.h reMutexHolder.h thread.h threadDummyImpl.h threadImpl.h threadPosixImpl.h threadPriority.h threadSimpleImpl.h threadSimpleManager.h threadWin32Impl.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpipeline
#include "py_panda.h"  

#include "asyncTaskBase.h"
#include "atomicAdjust.h"
#include "blockerSimple.h"
#include "conditionVar.h"
#include "conditionVarDebug.h"
#include "conditionVarDirect.h"
#include "conditionVarDummyImpl.h"
#include "conditionVarFull.h"
#include "conditionVarFullDebug.h"
#include "conditionVarFullDirect.h"
#include "conditionVarFullWin32Impl.h"
#include "conditionVarImpl.h"
#include "conditionVarPosixImpl.h"
#include "conditionVarSimpleImpl.h"
#include "conditionVarSpinlockImpl.h"
#include "conditionVarWin32Impl.h"
#include "config_pipeline.h"
#include "contextSwitch.h"
#include "cycleData.h"
#include "cycleDataLockedReader.h"
#include "cycleDataLockedStageReader.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataStageWriter.h"
#include "cycleDataWriter.h"
#include "cyclerHolder.h"
#include "externalThread.h"
#include "lightMutex.h"
#include "lightMutexDirect.h"
#include "lightMutexHolder.h"
#include "lightReMutex.h"
#include "lightReMutexDirect.h"
#include "lightReMutexHolder.h"
#include "mainThread.h"
#include "mutexDebug.h"
#include "mutexDirect.h"
#include "mutexHolder.h"
#include "mutexSimpleImpl.h"
#include "mutexTrueImpl.h"
#include "mutexWin32Impl.h"
#include "namable.h"
#include "nodeReferenceCount.h"
#include "pandabase.h"
#include "pipeline.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pipelineCyclerDummyImpl.h"
#include "pipelineCyclerLinks.h"
#include "pipelineCyclerTrivialImpl.h"
#include "pipelineCyclerTrueImpl.h"
#include "pmutex.h"
#include "pnotify.h"
#include "psemaphore.h"
#include "pset.h"
#include "pythonThread.h"
#include "reMutex.h"
#include "reMutexDirect.h"
#include "reMutexHolder.h"
#include "selectThreadImpl.h"
#include "thread.h"
#include "threadDummyImpl.h"
#include "threadImpl.h"
#include "threadPosixImpl.h"
#include "threadPriority.h"
#include "threadSimpleImpl.h"
#include "threadSimpleManager.h"
#include "threadWin32Impl.h"
#include "typeHandle.h"
#include "typedReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. AsyncTaskBase
//********************************************************************
typedef  AsyncTaskBase  AsyncTaskBase_localtype;
Define_Module_ClassRef(panda,AsyncTaskBase,AsyncTaskBase_localtype,AsyncTaskBase);
//********************************************************************
//*** prototypes for .. Thread
//********************************************************************
typedef  Thread  Thread_localtype;
Define_Module_ClassRef(panda,Thread,Thread_localtype,Thread);
//********************************************************************
//*** prototypes for .. MutexDirect
//********************************************************************
typedef  MutexDirect  MutexDirect_localtype;
Define_Module_Class_Private(panda,MutexDirect,MutexDirect_localtype,MutexDirect);
//********************************************************************
//*** prototypes for .. Mutex
//********************************************************************
typedef  Mutex  Mutex_localtype;
Define_Module_Class(panda,Mutex,Mutex_localtype,Mutex);
//********************************************************************
//*** prototypes for .. ConditionVarDirect
//********************************************************************
typedef  ConditionVarDirect  ConditionVarDirect_localtype;
Define_Module_Class(panda,ConditionVarDirect,ConditionVarDirect_localtype,ConditionVarDirect);
//********************************************************************
//*** prototypes for .. ConditionVar
//********************************************************************
typedef  ConditionVar  ConditionVar_localtype;
Define_Module_Class(panda,ConditionVar,ConditionVar_localtype,ConditionVar);
//********************************************************************
//*** prototypes for .. ConditionVarFullDirect
//********************************************************************
typedef  ConditionVarFullDirect  ConditionVarFullDirect_localtype;
Define_Module_Class(panda,ConditionVarFullDirect,ConditionVarFullDirect_localtype,ConditionVarFullDirect);
//********************************************************************
//*** prototypes for .. ConditionVarFull
//********************************************************************
typedef  ConditionVarFull  ConditionVarFull_localtype;
Define_Module_Class(panda,ConditionVarFull,ConditionVarFull_localtype,ConditionVarFull);
//********************************************************************
//*** prototypes for .. ExternalThread
//********************************************************************
typedef  ExternalThread  ExternalThread_localtype;
Define_Module_ClassRef(panda,ExternalThread,ExternalThread_localtype,ExternalThread);
//********************************************************************
//*** prototypes for .. LightMutexDirect
//********************************************************************
typedef  LightMutexDirect  LightMutexDirect_localtype;
Define_Module_Class_Private(panda,LightMutexDirect,LightMutexDirect_localtype,LightMutexDirect);
//********************************************************************
//*** prototypes for .. LightMutex
//********************************************************************
typedef  LightMutex  LightMutex_localtype;
Define_Module_Class(panda,LightMutex,LightMutex_localtype,LightMutex);
//********************************************************************
//*** prototypes for .. ReMutexDirect
//********************************************************************
typedef  ReMutexDirect  ReMutexDirect_localtype;
Define_Module_Class_Private(panda,ReMutexDirect,ReMutexDirect_localtype,ReMutexDirect);
//********************************************************************
//*** prototypes for .. LightReMutexDirect
//********************************************************************
typedef  LightReMutexDirect  LightReMutexDirect_localtype;
Define_Module_Class_Private(panda,LightReMutexDirect,LightReMutexDirect_localtype,LightReMutexDirect);
//********************************************************************
//*** prototypes for .. LightReMutex
//********************************************************************
typedef  LightReMutex  LightReMutex_localtype;
Define_Module_Class(panda,LightReMutex,LightReMutex_localtype,LightReMutex);
//********************************************************************
//*** prototypes for .. MainThread
//********************************************************************
typedef  MainThread  MainThread_localtype;
Define_Module_ClassRef(panda,MainThread,MainThread_localtype,MainThread);
//********************************************************************
//*** prototypes for .. ReMutex
//********************************************************************
typedef  ReMutex  ReMutex_localtype;
Define_Module_Class(panda,ReMutex,ReMutex_localtype,ReMutex);
//********************************************************************
//*** prototypes for .. PythonThread
//********************************************************************
typedef  PythonThread  PythonThread_localtype;
Define_Module_ClassRef(panda,PythonThread,PythonThread_localtype,PythonThread);
//********************************************************************
//*** prototypes for .. Semaphore
//********************************************************************
typedef  Semaphore  Semaphore_localtype;
Define_Module_Class(panda,Semaphore,Semaphore_localtype,Semaphore);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. AsyncTaskBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTaskBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskBase_get_class_type_9(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTaskBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTaskBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskBase_get_class_type_9_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTaskBase_get_class_type_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskBase.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const AsyncTaskBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const AsyncTaskBase this)\n"
    "\n"
    "upcast from AsyncTaskBase to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *AsyncTaskBase::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskBase_upcast_to_Namable_6(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *AsyncTaskBase::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskBase.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const AsyncTaskBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskBase_upcast_to_Namable_6_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const AsyncTaskBase this)\n"
    "\n"
    "upcast from AsyncTaskBase to Namable\n"
    "";
#else
static const char * Dtool_AsyncTaskBase_upcast_to_Namable_6_comment = NULL;
#endif

int  Dtool_Init_AsyncTaskBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AsyncTaskBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AsyncTaskBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskBase)
    {
        printf("AsyncTaskBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskBase * local_this = (AsyncTaskBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskBase)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskBase)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTaskBase*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTaskBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTaskBase*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTaskBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Thread 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static PointerTo< Thread > Thread::bind_thread(basic_string< char > const &name, basic_string< char > const &sync_name)
 *******************************************************************/
static PyObject *Dtool_Thread_bind_thread_17(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static PointerTo< Thread > Thread::bind_thread(basic_string< char > const &name, basic_string< char > const &sync_name)
        char *param0_str; int param0_len;
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", (char *)"sync_name", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:bindThread", key_word_list, &param0_str, &param0_len, &param1_str, &param1_len))
        {
            PointerTo< Thread > return_value = Thread::bind_thread(basic_string<char>(param0_str, param0_len), basic_string<char>(param1_str, param1_len));
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_Thread,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "bindThread(string name, string sync_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_bind_thread_17_comment =
    "C++ Interface:\n"
    "bindThread(string name, string sync_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::bind_thread\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a new Panda Thread object associated with the\n"
    "//               current thread (which has been created externally).\n"
    "//               This can be used to bind a unique Panda Thread object\n"
    "//               with an external thread, such as a new Python thread.\n"
    "//\n"
    "//               It is particularly useful to bind a Panda Thread\n"
    "//               object to an external thread for the purposes of\n"
    "//               PStats monitoring.  Without this call, each external\n"
    "//               thread will be assigned the same global\n"
    "//               ExternalThread object, which means they will all\n"
    "//               appear in the same PStats graph.\n"
    "//\n"
    "//               It is the caller's responsibility to save the\n"
    "//               returned Thread pointer for the lifetime of the\n"
    "//               external thread.  It is an error for the Thread\n"
    "//               pointer to destruct while the external thread is\n"
    "//               still in the system.\n"
    "//\n"
    "//               It is also an error to call this method from the main\n"
    "//               thread, or twice within a given thread, unless it is\n"
    "//               given the same name each time (in which case the same\n"
    "//               pointer will be returned each time).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_bind_thread_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Thread::get_sync_name(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_sync_name_18(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Thread::get_sync_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSyncName", key_word_list));
        else
            (PyArg_Parse(args, ":getSyncName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Thread*)local_this)->get_sync_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSyncName(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_sync_name_18_comment =
    "C++ Interface:\n"
    "getSyncName(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_sync_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the sync name of the thread.  This name\n"
    "//               collects threads into \"sync groups\", which are\n"
    "//               expected to run synchronously.  This is mainly used\n"
    "//               for the benefit of PStats; threads with the same sync\n"
    "//               name can be ticked all at once via the thread_tick()\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_sync_name_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Thread::get_pstats_index(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_pstats_index_19(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Thread::get_pstats_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPstatsIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getPstatsIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Thread*)local_this)->get_pstats_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPstatsIndex(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_pstats_index_19_comment =
    "C++ Interface:\n"
    "getPstatsIndex(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_pstats_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the PStats index associated with this thread,\n"
    "//               or -1 if no index has yet been associated with this\n"
    "//               thread.  This is used internally by the PStatClient;\n"
    "//               you should not need to call this directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_pstats_index_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > Thread::get_unique_id(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_unique_id_20(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > Thread::get_unique_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUniqueId", key_word_list));
        else
            (PyArg_Parse(args, ":getUniqueId"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Thread*)local_this)->get_unique_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUniqueId(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_unique_id_20_comment =
    "C++ Interface:\n"
    "getUniqueId(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_unique_id\n"
    "//       Access: Published\n"
    "//  Description: Returns a string that is guaranteed to be unique to\n"
    "//               this thread, across all processes on the machine,\n"
    "//               during at least the lifetime of this process.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_unique_id_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Thread::get_pipeline_stage(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_pipeline_stage_21(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Thread::get_pipeline_stage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPipelineStage", key_word_list));
        else
            (PyArg_Parse(args, ":getPipelineStage"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Thread*)local_this)->get_pipeline_stage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPipelineStage(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_pipeline_stage_21_comment =
    "C++ Interface:\n"
    "getPipelineStage(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_pipeline_stage\n"
    "//       Access: Published\n"
    "//  Description: Returns the Pipeline stage number associated with\n"
    "//               this thread.  The default stage is 0 if no stage is\n"
    "//               specified otherwise.  See set_pipeline_stage().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_pipeline_stage_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Thread::set_pipeline_stage(int pipeline_stage)
 *******************************************************************/
static PyObject *Dtool_Thread_set_pipeline_stage_22(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Thread::set_pipeline_stage(int pipeline_stage)
        int param1;
        static char * key_word_list[] = {(char *)"pipeline_stage", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPipelineStage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPipelineStage", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pipeline_stage((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.setPipelineStage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPipelineStage(non-const Thread this, int pipeline_stage)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_set_pipeline_stage_22_comment =
    "C++ Interface:\n"
    "setPipelineStage(non-const Thread this, int pipeline_stage)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::set_pipeline_stage\n"
    "//       Access: Published\n"
    "//  Description: Specifies the Pipeline stage number associated with\n"
    "//               this thread.  The default stage is 0 if no stage is\n"
    "//               specified otherwise.\n"
    "//\n"
    "//               This must be a value in the range [0\n"
    "//               .. pipeline->get_num_stages() - 1].  It specifies the\n"
    "//               values that this thread observes for all pipelined\n"
    "//               data.  Typically, an application thread will leave\n"
    "//               this at 0, but a render thread may set it to 1 or 2\n"
    "//               (to operate on the previous frame's data, or the\n"
    "//               second previous frame's data).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_set_pipeline_stage_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
 *******************************************************************/
static PyObject *Dtool_Thread_set_min_pipeline_stage_23(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Thread::set_min_pipeline_stage(int min_pipeline_stage)
        int param1;
        static char * key_word_list[] = {(char *)"min_pipeline_stage", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMinPipelineStage", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMinPipelineStage", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_min_pipeline_stage((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.setMinPipelineStage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMinPipelineStage(non-const Thread this, int min_pipeline_stage)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_set_min_pipeline_stage_23_comment =
    "C++ Interface:\n"
    "setMinPipelineStage(non-const Thread this, int min_pipeline_stage)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::set_min_pipeline_stage\n"
    "//       Access: Published\n"
    "//  Description: Sets this thread's pipeline stage number to at least\n"
    "//               the indicated value, unless it is already larger.\n"
    "//               See set_pipeline_stage().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_set_min_pipeline_stage_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Thread *Thread::get_main_thread(void)
 *******************************************************************/
static PyObject *Dtool_Thread_get_main_thread_24(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Thread *Thread::get_main_thread(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMainThread", key_word_list))
        {
            Thread *return_value = Thread::get_main_thread();
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Thread,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMainThread()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_main_thread_24_comment =
    "C++ Interface:\n"
    "getMainThread()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_main_thread\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the \"main\" Thread object--this\n"
    "//               is the Thread that started the whole process.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_main_thread_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Thread *Thread::get_external_thread(void)
 *******************************************************************/
static PyObject *Dtool_Thread_get_external_thread_25(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Thread *Thread::get_external_thread(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getExternalThread", key_word_list))
        {
            Thread *return_value = Thread::get_external_thread();
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Thread,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExternalThread()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_external_thread_25_comment =
    "C++ Interface:\n"
    "getExternalThread()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_external_thread\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the \"external\" Thread\n"
    "//               object--this is a special Thread object that\n"
    "//               corresponds to any thread spawned outside of Panda's\n"
    "//               threading interface.  Note that multiple different\n"
    "//               threads may share this same pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_external_thread_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline Thread *Thread::get_current_thread(void)
 *******************************************************************/
static PyObject *Dtool_Thread_get_current_thread_26(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline Thread *Thread::get_current_thread(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentThread", key_word_list))
        {
            Thread *return_value = Thread::get_current_thread();
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Thread,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentThread()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_current_thread_26_comment =
    "C++ Interface:\n"
    "getCurrentThread()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_current_thread\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the currently-executing Thread\n"
    "//               object.  If this is called from the main thread, this\n"
    "//               will return the same value as get_main_thread().\n"
    "//\n"
    "//               This will always return some valid Thread pointer.\n"
    "//               It will never return NULL, even if the current thread\n"
    "//               was spawned outside of Panda's threading system,\n"
    "//               although all non-Panda threads will return the exact\n"
    "//               same Thread pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_current_thread_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int Thread::get_current_pipeline_stage(void)
 *******************************************************************/
static PyObject *Dtool_Thread_get_current_pipeline_stage_27(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int Thread::get_current_pipeline_stage(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentPipelineStage", key_word_list))
        {
            int return_value = Thread::get_current_pipeline_stage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentPipelineStage()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_current_pipeline_stage_27_comment =
    "C++ Interface:\n"
    "getCurrentPipelineStage()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_current_pipeline_stage\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the integer pipeline stage associated with\n"
    "//               the current thread.  This is the same thing as\n"
    "//               get_current_thread()->get_pipeline_stage(), but it\n"
    "//               may be faster to retrieve in some contexts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_current_pipeline_stage_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Thread::is_threading_supported(void)
 *******************************************************************/
static PyObject *Dtool_Thread_is_threading_supported_28(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Thread::is_threading_supported(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":isThreadingSupported", key_word_list))
        {
            bool return_value = Thread::is_threading_supported();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isThreadingSupported()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_is_threading_supported_28_comment =
    "C++ Interface:\n"
    "isThreadingSupported()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::is_threading_supported\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if threading support has been compiled\n"
    "//               in and enabled, or false if no threading is available\n"
    "//               (and Thread::start() will always fail).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_is_threading_supported_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Thread::is_true_threads(void)
 *******************************************************************/
static PyObject *Dtool_Thread_is_true_threads_29(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Thread::is_true_threads(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":isTrueThreads", key_word_list))
        {
            bool return_value = Thread::is_true_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTrueThreads()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_is_true_threads_29_comment =
    "C++ Interface:\n"
    "isTrueThreads()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::is_true_threads\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if a real threading library is available\n"
    "//               that supports actual OS-implemented threads, or false\n"
    "//               if the only threading we can provide is simulated\n"
    "//               user-space threading.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_is_true_threads_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool Thread::is_simple_threads(void)
 *******************************************************************/
static PyObject *Dtool_Thread_is_simple_threads_30(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool Thread::is_simple_threads(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":isSimpleThreads", key_word_list))
        {
            bool return_value = Thread::is_simple_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSimpleThreads()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_is_simple_threads_30_comment =
    "C++ Interface:\n"
    "isSimpleThreads()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::is_simple_threads\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns true if Panda is currently compiled for\n"
    "//               \"simple threads\", which is to say, cooperative\n"
    "//               context switching only, reducing the need for quite\n"
    "//               so many critical section protections.  This is not\n"
    "//               necessarily the opposite of \"true threads\", since one\n"
    "//               possible implementation of simple threads is via true\n"
    "//               threads with mutex protection to ensure only one runs\n"
    "//               at a time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_is_simple_threads_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Thread::sleep(double seconds)
 *******************************************************************/
static PyObject *Dtool_Thread_sleep_31(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Thread::sleep(double seconds)
        double param0;
        static char * key_word_list[] = {(char *)"seconds", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:sleep", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:sleep", &param0));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Thread::sleep((double)param0);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sleep(float seconds)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_sleep_31_comment =
    "C++ Interface:\n"
    "sleep(float seconds)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::sleep\n"
    "//       Access: Published, Static\n"
    "//  Description: Suspends the current thread for at least the\n"
    "//               indicated amount of time.  It might be suspended for\n"
    "//               longer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_sleep_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Thread::force_yield(void)
 *******************************************************************/
static PyObject *Dtool_Thread_force_yield_32(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Thread::force_yield(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":forceYield", key_word_list))
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Thread::force_yield();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceYield()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_force_yield_32_comment =
    "C++ Interface:\n"
    "forceYield()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::field_yield\n"
    "//       Access: Published, Static\n"
    "//  Description: Suspends the current thread for the rest of the\n"
    "//               current epoch.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_force_yield_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Thread::consider_yield(void)
 *******************************************************************/
static PyObject *Dtool_Thread_consider_yield_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Thread::consider_yield(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":considerYield", key_word_list))
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            Thread::consider_yield();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "considerYield()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_consider_yield_33_comment =
    "C++ Interface:\n"
    "considerYield()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::consider_yield\n"
    "//       Access: Published, Static\n"
    "//  Description: Possibly suspends the current thread for the rest of\n"
    "//               the current epoch, if it has run for enough this\n"
    "//               epoch.  This is especially important for the simple\n"
    "//               thread implementation, which relies on cooperative\n"
    "//               yields like this.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_consider_yield_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Thread::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Thread_output_34(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void Thread::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Thread.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Thread*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Thread this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_output_34_comment =
    "C++ Interface:\n"
    "output(const Thread this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_output_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Thread::output_blocker(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Thread_output_blocker_35(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Thread::output_blocker(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputBlocker", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputBlocker", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Thread.outputBlocker", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Thread*)local_this)->output_blocker(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputBlocker(const Thread this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_output_blocker_35_comment =
    "C++ Interface:\n"
    "outputBlocker(const Thread this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::output_blocker\n"
    "//       Access: Published\n"
    "//  Description: Writes a description of the mutex or condition\n"
    "//               variable that this thread is blocked on.  Writes\n"
    "//               nothing if there is no blocker, or if we are not in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_output_blocker_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void Thread::write_status(ostream &out)
 *******************************************************************/
static PyObject *Dtool_Thread_write_status_36(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void Thread::write_status(ostream &out)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeStatus", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:writeStatus", &param0));
            if(!PyErr_Occurred())
            {
                ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ostream, 0, "Thread.writeStatus", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    Thread::write_status(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeStatus(non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_write_status_36_comment =
    "C++ Interface:\n"
    "writeStatus(non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::write_status\n"
    "//       Access: Published, Static\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_write_status_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Thread::is_started(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_is_started_37(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Thread::is_started(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStarted", key_word_list));
        else
            (PyArg_Parse(args, ":isStarted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Thread*)local_this)->is_started();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStarted(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_is_started_37_comment =
    "C++ Interface:\n"
    "isStarted(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::is_started\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the thread has been started, false if\n"
    "//               it has not, or if join() has already been called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_is_started_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Thread::is_joinable(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_is_joinable_38(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Thread::is_joinable(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isJoinable", key_word_list));
        else
            (PyArg_Parse(args, ":isJoinable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Thread*)local_this)->is_joinable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isJoinable(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_is_joinable_38_comment =
    "C++ Interface:\n"
    "isJoinable(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::is_joinable\n"
    "//       Access: Published\n"
    "//  Description: Returns the value of joinable that was passed to the\n"
    "//               start() call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_is_joinable_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Thread::start(ThreadPriority priority, bool joinable)
 *******************************************************************/
static PyObject *Dtool_Thread_start_39(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool Thread::start(ThreadPriority priority, bool joinable)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"priority", (char *)"joinable", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:start", key_word_list, &param1, &param2))
        {
            bool return_value = (local_this)->start((ThreadPriority)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.start() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "start(non-const Thread this, int priority, bool joinable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_start_39_comment =
    "C++ Interface:\n"
    "start(non-const Thread this, int priority, bool joinable)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::start\n"
    "//       Access: Public\n"
    "//  Description: Starts the thread executing.  It is only valid to\n"
    "//               call this once.\n"
    "//\n"
    "//               The thread will begin executing its thread_main()\n"
    "//               function, and will terminate when thread_main()\n"
    "//               returns.\n"
    "//\n"
    "//               priority is intended as a hint to the relative\n"
    "//               importance of this thread.  This may be ignored by\n"
    "//               the thread implementation.\n"
    "//\n"
    "//               joinable should be set true if you intend to call\n"
    "//               join() to wait for the thread to terminate, or false\n"
    "//               if you don't care and you will never call join().\n"
    "//               Note that the reference count on the Thread object is\n"
    "//               incremented while the thread itself is running, so if\n"
    "//               you just want to fire and forget a thread, you may\n"
    "//               pass joinable = false, and never store the Thread\n"
    "//               object.  It will automatically destruct itself when\n"
    "//               it finishes.\n"
    "//\n"
    "//               The return value is true if the thread is\n"
    "//               successfully started, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_start_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Thread::join(void)
 *******************************************************************/
static PyObject *Dtool_Thread_join_40(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Thread::join(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":join", key_word_list));
        else
            (PyArg_Parse(args, ":join"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->join();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.join() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "join(non-const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_join_40_comment =
    "C++ Interface:\n"
    "join(non-const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::join\n"
    "//       Access: Published\n"
    "//  Description: Blocks the calling process until the thread\n"
    "//               terminates.  If the thread has already terminated,\n"
    "//               this returns immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_join_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Thread::preempt(void)
 *******************************************************************/
static PyObject *Dtool_Thread_preempt_41(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Thread::preempt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":preempt", key_word_list));
        else
            (PyArg_Parse(args, ":preempt"));
        if(!PyErr_Occurred())
        {
            (local_this)->preempt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.preempt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "preempt(non-const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_preempt_41_comment =
    "C++ Interface:\n"
    "preempt(non-const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::preempt\n"
    "//       Access: Published\n"
    "//  Description: Indicates that this thread should run as soon as\n"
    "//               possible, preemptying any other threads that may be\n"
    "//               scheduled to run.  This may not be implemented on\n"
    "//               every platform.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_preempt_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Thread::set_python_data(PyObject *python_data)
 *******************************************************************/
static PyObject *Dtool_Thread_set_python_data_42(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Thread::set_python_data(PyObject *python_data)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"python_data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPythonData", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPythonData", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_python_data(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.setPythonData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPythonData(non-const Thread this, any python_data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_set_python_data_42_comment =
    "C++ Interface:\n"
    "setPythonData(non-const Thread this, any python_data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::set_python_data\n"
    "//       Access: Published\n"
    "//  Description: Sets an arbitrary Python object that may be\n"
    "//               associated with this thread object.  This is just for\n"
    "//               the purposes of associated arbitrary Python data with\n"
    "//               the C++ object; other than managing the reference\n"
    "//               count, the C++ code does nothing with this object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_set_python_data_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *Thread::get_python_data(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_python_data_43(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *Thread::get_python_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPythonData", key_word_list));
        else
            (PyArg_Parse(args, ":getPythonData"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const Thread*)local_this)->get_python_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPythonData(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_python_data_43_comment =
    "C++ Interface:\n"
    "getPythonData(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_python_data\n"
    "//       Access: Published\n"
    "//  Description: Returns the Python object that was set with\n"
    "//               set_python_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_python_data_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AsyncTaskBase *Thread::get_current_task(void) const
 *******************************************************************/
static PyObject *Dtool_Thread_get_current_task_44(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AsyncTaskBase *Thread::get_current_task(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentTask", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentTask"));
        if(!PyErr_Occurred())
        {
            AsyncTaskBase *return_value = ((const Thread*)local_this)->get_current_task();
            if (return_value != (AsyncTaskBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentTask(const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_current_task_44_comment =
    "C++ Interface:\n"
    "getCurrentTask(const Thread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::get_current_task\n"
    "//       Access: Published\n"
    "//  Description: Returns the task currently executing on this thread\n"
    "//               (via the AsyncTaskManager), if any, or NULL if the\n"
    "//               thread is not currently servicing a task.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_get_current_task_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void Thread::prepare_for_exit(void)
 *******************************************************************/
static PyObject *Dtool_Thread_prepare_for_exit_45(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void Thread::prepare_for_exit(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":prepareForExit", key_word_list))
        {
            Thread::prepare_for_exit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "prepareForExit()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_prepare_for_exit_45_comment =
    "C++ Interface:\n"
    "prepareForExit()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Thread::prepare_for_exit\n"
    "//       Access: Published\n"
    "//  Description: Should be called by the main thread just before\n"
    "//               exiting the program, this blocks until any remaining\n"
    "//               thread cleanup has finished.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Thread_prepare_for_exit_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Thread::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Thread_get_class_type_46(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Thread::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Thread::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_get_class_type_46_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Thread_get_class_type_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_Thread_upcast_to_TypedReferenceCount_12(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_upcast_to_TypedReferenceCount_12_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const Thread this)\n"
    "\n"
    "upcast from Thread to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_Thread_upcast_to_TypedReferenceCount_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *Thread::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_Thread_upcast_to_Namable_14(PyObject *self, PyObject *args,PyObject *kwds) {
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *Thread::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Thread.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const Thread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Thread_upcast_to_Namable_14_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const Thread this)\n"
    "\n"
    "upcast from Thread to Namable\n"
    "";
#else
static const char * Dtool_Thread_upcast_to_Namable_14_comment = NULL;
#endif

int  Dtool_Init_Thread(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Thread)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Thread(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Thread)
    {
        printf("Thread ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Thread * local_this = (Thread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Thread)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Thread(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Thread)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Thread*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Thread*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Thread*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (Thread*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MutexDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MutexDirect::acquire(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_acquire_48(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void MutexDirect::acquire(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
        else
            (PyArg_Parse(args, ":acquire"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            ((const MutexDirect*)local_this)->acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "acquire(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_acquire_48_comment =
    "C++ Interface:\n"
    "acquire(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: Grabs the mutex if it is available.  If it is not\n"
    "//               available, blocks until it becomes available, then\n"
    "//               grabs it.  In either case, the function does not\n"
    "//               return until the mutex is held; you should then call\n"
    "//               unlock().\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const mutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "//\n"
    "//               Also see MutexHolder.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_acquire_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MutexDirect::try_acquire(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_try_acquire_49(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MutexDirect::try_acquire(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tryAcquire", key_word_list));
        else
            (PyArg_Parse(args, ":tryAcquire"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((const MutexDirect*)local_this)->try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tryAcquire(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_try_acquire_49_comment =
    "C++ Interface:\n"
    "tryAcquire(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::try_acquire\n"
    "//       Access: Published\n"
    "//  Description: Returns immediately, with a true value indicating the\n"
    "//               mutex has been acquired, and false indicating it has\n"
    "//               not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_try_acquire_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MutexDirect::release(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_release_50(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void MutexDirect::release(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            ((const MutexDirect*)local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_release_50_comment =
    "C++ Interface:\n"
    "release(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::release\n"
    "//       Access: Published\n"
    "//  Description: Releases the mutex.  It is an error to call this if\n"
    "//               the mutex was not already locked.\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const mutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_release_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MutexDirect::debug_is_locked(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_debug_is_locked_51(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MutexDirect::debug_is_locked(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":debugIsLocked", key_word_list));
        else
            (PyArg_Parse(args, ":debugIsLocked"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MutexDirect*)local_this)->debug_is_locked();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "debugIsLocked(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_debug_is_locked_51_comment =
    "C++ Interface:\n"
    "debugIsLocked(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::debug_is_locked\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current thread has locked the\n"
    "//               Mutex, false otherwise.  This method is only intended\n"
    "//               for use in debugging, hence the method name; in the\n"
    "//               MutexDirect case, it always returns true, since\n"
    "//               there's not a reliable way to determine this\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_debug_is_locked_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MutexDirect::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_MutexDirect_set_name_52(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MutexDirect::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MutexDirect.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const MutexDirect this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_set_name_52_comment =
    "C++ Interface:\n"
    "setName(non-const MutexDirect this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::set_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_set_name_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MutexDirect::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_MutexDirect_clear_name_53(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MutexDirect::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MutexDirect.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_clear_name_53_comment =
    "C++ Interface:\n"
    "clearName(non-const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::clear_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_clear_name_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MutexDirect::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_has_name_54(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MutexDirect::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MutexDirect*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_has_name_54_comment =
    "C++ Interface:\n"
    "hasName(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::has_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_has_name_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > MutexDirect::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_get_name_55(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > MutexDirect::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const MutexDirect*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const MutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_get_name_55_comment =
    "C++ Interface:\n"
    "getName(const MutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::get_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_get_name_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MutexDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_MutexDirect_output_56(PyObject *self, PyObject *args,PyObject *kwds) {
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MutexDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MutexDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MutexDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const MutexDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MutexDirect_output_56_comment =
    "C++ Interface:\n"
    "output(const MutexDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MutexDirect::output\n"
    "//       Access: Public\n"
    "//  Description: This method is declared virtual in MutexDebug, but\n"
    "//               non-virtual in MutexDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MutexDirect_output_56_comment = NULL;
#endif

int  Dtool_Init_MutexDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MutexDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MutexDirect)
    {
        printf("MutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MutexDirect * local_this = (MutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MutexDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MutexDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MutexDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Mutex 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Mutex::Mutex(void)
 * inline Mutex::Mutex(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_Mutex(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Mutex::Mutex(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Mutex", key_word_list))
            {
                Mutex *return_value = new Mutex();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Mutex,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline Mutex::Mutex(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Mutex", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:Mutex", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Mutex *return_value = new Mutex(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Mutex,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Mutex() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Mutex()\n"
          "Mutex(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Mutex(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Mutex)
    {
        printf("Mutex ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Mutex * local_this = (Mutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Mutex)
        return local_this;
    if(requested_type == &Dtool_MutexDirect)
        return ( MutexDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Mutex(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Mutex)
        return from_this;
    if(from_type == &Dtool_MutexDirect)
    {
          MutexDirect* other_this = (MutexDirect*)from_this;
          return (Mutex*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConditionVarDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline MutexDirect &ConditionVarDirect::get_mutex(void) const
 *******************************************************************/
static PyObject *Dtool_ConditionVarDirect_get_mutex_62(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline MutexDirect &ConditionVarDirect::get_mutex(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMutex", key_word_list));
        else
            (PyArg_Parse(args, ":getMutex"));
        if(!PyErr_Occurred())
        {
            MutexDirect *return_value = &(((const ConditionVarDirect*)local_this)->get_mutex());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MutexDirect,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMutex(const ConditionVarDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarDirect_get_mutex_62_comment =
    "C++ Interface:\n"
    "getMutex(const ConditionVarDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarDirect::get_mutex\n"
    "//       Access: Public\n"
    "//  Description: Returns the mutex associated with this condition\n"
    "//               variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarDirect_get_mutex_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConditionVarDirect::wait(void)
 * inline void ConditionVarDirect::wait(double timeout)
 *******************************************************************/
static PyObject *Dtool_ConditionVarDirect_wait_63(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConditionVarDirect::wait(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":wait", key_word_list));
            else
                (PyArg_Parse(args, ":wait"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->wait();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConditionVarDirect.wait() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConditionVarDirect::wait(double timeout)
            double param1;
            static char * key_word_list[] = {(char *)"timeout", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:wait", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:wait", &param1));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                (local_this)->wait((double)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConditionVarDirect.wait() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "wait() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "wait(non-const ConditionVarDirect this)\n"
          "wait(non-const ConditionVarDirect this, float timeout)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarDirect_wait_63_comment =
    "C++ Interface:\n"
    "wait(non-const ConditionVarDirect this)\n"
    "wait(non-const ConditionVarDirect this, float timeout)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarDirect::wait\n"
    "//       Access: Public\n"
    "//  Description: Waits on the condition.  The caller must already be\n"
    "//               holding the lock associated with the condition\n"
    "//               variable before calling this function.\n"
    "//\n"
    "//               wait() will release the lock, then go to sleep until\n"
    "//               some other thread calls notify() on this condition\n"
    "//               variable.  At that time at least one thread waiting\n"
    "//               on the same ConditionVarDirect will grab the lock again,\n"
    "//               and then return from wait().\n"
    "//\n"
    "//               It is possible that wait() will return even if no one\n"
    "//               has called notify().  It is the responsibility of the\n"
    "//               calling process to verify the condition on return\n"
    "//               from wait, and possibly loop back to wait again if\n"
    "//               necessary.\n"
    "//\n"
    "//               Note the semantics of a condition variable: the mutex\n"
    "//               must be held before wait() is called, and it will\n"
    "//               still be held when wait() returns.  However, it will\n"
    "//               be temporarily released during the wait() call\n"
    "//               itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarDirect::wait\n"
    "//       Access: Published\n"
    "//  Description: Waits on the condition, with a timeout.  The function\n"
    "//               will return when the condition variable is notified,\n"
    "//               or the timeout occurs.  There is no way to directly\n"
    "//               tell which happened, and it is possible that neither\n"
    "//               in fact happened (spurious wakeups are possible).\n"
    "//\n"
    "//               See wait() with no parameters for more.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarDirect_wait_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConditionVarDirect::notify(void)
 *******************************************************************/
static PyObject *Dtool_ConditionVarDirect_notify_64(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConditionVarDirect::notify(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":notify", key_word_list));
        else
            (PyArg_Parse(args, ":notify"));
        if(!PyErr_Occurred())
        {
            (local_this)->notify();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConditionVarDirect.notify() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "notify(non-const ConditionVarDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarDirect_notify_64_comment =
    "C++ Interface:\n"
    "notify(non-const ConditionVarDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarDirect::notify\n"
    "//       Access: Public\n"
    "//  Description: Informs one of the other threads who are currently\n"
    "//               blocked on wait() that the relevant condition has\n"
    "//               changed.  If multiple threads are currently waiting,\n"
    "//               at least one of them will be woken up, although there\n"
    "//               is no way to predict which one.  It is possible that\n"
    "//               more than one thread will be woken up.\n"
    "//\n"
    "//               The caller must be holding the mutex associated with\n"
    "//               the condition variable before making this call, which\n"
    "//               will not release the mutex.\n"
    "//\n"
    "//               If no threads are waiting, this is a no-op: the\n"
    "//               notify event is lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarDirect_notify_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConditionVarDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConditionVarDirect_output_65(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConditionVarDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConditionVarDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConditionVarDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConditionVarDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarDirect_output_65_comment =
    "C++ Interface:\n"
    "output(const ConditionVarDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarDirect::output\n"
    "//       Access: Public\n"
    "//  Description: This method is declared virtual in ConditionVarDebug,\n"
    "//               but non-virtual in ConditionVarDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarDirect_output_65_comment = NULL;
#endif

int  Dtool_Init_ConditionVarDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConditionVarDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConditionVarDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConditionVarDirect)
    {
        printf("ConditionVarDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConditionVarDirect * local_this = (ConditionVarDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConditionVarDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConditionVarDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConditionVarDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConditionVar 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Mutex &ConditionVar::get_mutex(void) const
 *******************************************************************/
static PyObject *Dtool_ConditionVar_get_mutex_69(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVar * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVar,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Mutex &ConditionVar::get_mutex(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMutex", key_word_list));
        else
            (PyArg_Parse(args, ":getMutex"));
        if(!PyErr_Occurred())
        {
            Mutex *return_value = &(((const ConditionVar*)local_this)->get_mutex());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Mutex,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMutex(const ConditionVar this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVar_get_mutex_69_comment =
    "C++ Interface:\n"
    "getMutex(const ConditionVar this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVar::get_mutex\n"
    "//       Access: Published\n"
    "//  Description: Returns the mutex associated with this condition\n"
    "//               variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVar_get_mutex_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConditionVar::ConditionVar(Mutex &mutex)
 *******************************************************************/
int  Dtool_Init_ConditionVar(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline ConditionVar::ConditionVar(Mutex &mutex)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"mutex", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConditionVar", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConditionVar", &param0));
            if(!PyErr_Occurred())
            {
                Mutex *param0_this = (Mutex *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Mutex, 0, "ConditionVar.ConditionVar", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConditionVar *return_value = new ConditionVar(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConditionVar,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConditionVar(non-const Mutex mutex)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConditionVar(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConditionVar)
    {
        printf("ConditionVar ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConditionVar * local_this = (ConditionVar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConditionVar)
        return local_this;
    if(requested_type == &Dtool_ConditionVarDirect)
        return ( ConditionVarDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConditionVar(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConditionVar)
        return from_this;
    if(from_type == &Dtool_ConditionVarDirect)
    {
          ConditionVarDirect* other_this = (ConditionVarDirect*)from_this;
          return (ConditionVar*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConditionVarFullDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const
 *******************************************************************/
static PyObject *Dtool_ConditionVarFullDirect_get_mutex_72(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMutex", key_word_list));
        else
            (PyArg_Parse(args, ":getMutex"));
        if(!PyErr_Occurred())
        {
            MutexDirect *return_value = &(((const ConditionVarFullDirect*)local_this)->get_mutex());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MutexDirect,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMutex(const ConditionVarFullDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFullDirect_get_mutex_72_comment =
    "C++ Interface:\n"
    "getMutex(const ConditionVarFullDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::get_mutex\n"
    "//       Access: Published\n"
    "//  Description: Returns the mutex associated with this condition\n"
    "//               variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFullDirect_get_mutex_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConditionVarFullDirect::wait(void)
 * inline void ConditionVarFullDirect::wait(double timeout)
 *******************************************************************/
static PyObject *Dtool_ConditionVarFullDirect_wait_73(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConditionVarFullDirect::wait(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":wait", key_word_list));
            else
                (PyArg_Parse(args, ":wait"));
            if(!PyErr_Occurred())
            {
                (local_this)->wait();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConditionVarFullDirect.wait() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ConditionVarFullDirect::wait(double timeout)
            double param1;
            static char * key_word_list[] = {(char *)"timeout", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:wait", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:wait", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->wait((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ConditionVarFullDirect.wait() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "wait() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "wait(non-const ConditionVarFullDirect this)\n"
          "wait(non-const ConditionVarFullDirect this, float timeout)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFullDirect_wait_73_comment =
    "C++ Interface:\n"
    "wait(non-const ConditionVarFullDirect this)\n"
    "wait(non-const ConditionVarFullDirect this, float timeout)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::wait\n"
    "//       Access: Published\n"
    "//  Description: Waits on the condition.  The caller must already be\n"
    "//               holding the lock associated with the condition\n"
    "//               variable before calling this function.\n"
    "//\n"
    "//               wait() will release the lock, then go to sleep until\n"
    "//               some other thread calls notify() on this condition\n"
    "//               variable.  At that time at least one thread waiting\n"
    "//               on the same ConditionVarFullDirect will grab the lock again,\n"
    "//               and then return from wait().\n"
    "//\n"
    "//               It is possible that wait() will return even if no one\n"
    "//               has called notify().  It is the responsibility of the\n"
    "//               calling process to verify the condition on return\n"
    "//               from wait, and possibly loop back to wait again if\n"
    "//               necessary.\n"
    "//\n"
    "//               Note the semantics of a condition variable: the mutex\n"
    "//               must be held before wait() is called, and it will\n"
    "//               still be held when wait() returns.  However, it will\n"
    "//               be temporarily released during the wait() call\n"
    "//               itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::wait\n"
    "//       Access: Published\n"
    "//  Description: Waits on the condition, with a timeout.  The function\n"
    "//               will return when the condition variable is notified,\n"
    "//               or the timeout occurs.  There is no way to directly\n"
    "//               tell which happened, and it is possible that neither\n"
    "//               in fact happened (spurious wakeups are possible).\n"
    "//\n"
    "//               See wait() with no parameters for more.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFullDirect_wait_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConditionVarFullDirect::notify(void)
 *******************************************************************/
static PyObject *Dtool_ConditionVarFullDirect_notify_74(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConditionVarFullDirect::notify(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":notify", key_word_list));
        else
            (PyArg_Parse(args, ":notify"));
        if(!PyErr_Occurred())
        {
            (local_this)->notify();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConditionVarFullDirect.notify() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "notify(non-const ConditionVarFullDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFullDirect_notify_74_comment =
    "C++ Interface:\n"
    "notify(non-const ConditionVarFullDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::notify\n"
    "//       Access: Published\n"
    "//  Description: Informs one of the other threads who are currently\n"
    "//               blocked on wait() that the relevant condition has\n"
    "//               changed.  If multiple threads are currently waiting,\n"
    "//               at least one of them will be woken up, although there\n"
    "//               is no way to predict which one.  It is possible that\n"
    "//               more than one thread will be woken up.\n"
    "//\n"
    "//               The caller must be holding the mutex associated with\n"
    "//               the condition variable before making this call, which\n"
    "//               will not release the mutex.\n"
    "//\n"
    "//               If no threads are waiting, this is a no-op: the\n"
    "//               notify is lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFullDirect_notify_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ConditionVarFullDirect::notify_all(void)
 *******************************************************************/
static PyObject *Dtool_ConditionVarFullDirect_notify_all_75(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ConditionVarFullDirect::notify_all(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":notifyAll", key_word_list));
        else
            (PyArg_Parse(args, ":notifyAll"));
        if(!PyErr_Occurred())
        {
            (local_this)->notify_all();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ConditionVarFullDirect.notifyAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "notifyAll(non-const ConditionVarFullDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFullDirect_notify_all_75_comment =
    "C++ Interface:\n"
    "notifyAll(non-const ConditionVarFullDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::notify_all\n"
    "//       Access: Published\n"
    "//  Description: Informs all of the other threads who are currently\n"
    "//               blocked on wait() that the relevant condition has\n"
    "//               changed.\n"
    "//\n"
    "//               The caller must be holding the mutex associated with\n"
    "//               the condition variable before making this call, which\n"
    "//               will not release the mutex.\n"
    "//\n"
    "//               If no threads are waiting, this is a no-op: the\n"
    "//               notify event is lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFullDirect_notify_all_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ConditionVarFullDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ConditionVarFullDirect_output_76(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ConditionVarFullDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ConditionVarFullDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ConditionVarFullDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ConditionVarFullDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFullDirect_output_76_comment =
    "C++ Interface:\n"
    "output(const ConditionVarFullDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFullDirect::output\n"
    "//       Access: Public\n"
    "//  Description: This method is declared virtual in ConditionVarFullDebug,\n"
    "//               but non-virtual in ConditionVarFullDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFullDirect_output_76_comment = NULL;
#endif

int  Dtool_Init_ConditionVarFullDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ConditionVarFullDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ConditionVarFullDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConditionVarFullDirect)
    {
        printf("ConditionVarFullDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConditionVarFullDirect * local_this = (ConditionVarFullDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConditionVarFullDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConditionVarFullDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConditionVarFullDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ConditionVarFull 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Mutex &ConditionVarFull::get_mutex(void) const
 *******************************************************************/
static PyObject *Dtool_ConditionVarFull_get_mutex_80(PyObject *self, PyObject *args,PyObject *kwds) {
    ConditionVarFull * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFull,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Mutex &ConditionVarFull::get_mutex(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMutex", key_word_list));
        else
            (PyArg_Parse(args, ":getMutex"));
        if(!PyErr_Occurred())
        {
            Mutex *return_value = &(((const ConditionVarFull*)local_this)->get_mutex());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Mutex,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMutex(const ConditionVarFull this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ConditionVarFull_get_mutex_80_comment =
    "C++ Interface:\n"
    "getMutex(const ConditionVarFull this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ConditionVarFull::get_mutex\n"
    "//       Access: Published\n"
    "//  Description: Returns the mutex associated with this condition\n"
    "//               variable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ConditionVarFull_get_mutex_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
 *******************************************************************/
int  Dtool_Init_ConditionVarFull(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline ConditionVarFull::ConditionVarFull(Mutex &mutex)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"mutex", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ConditionVarFull", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ConditionVarFull", &param0));
            if(!PyErr_Occurred())
            {
                Mutex *param0_this = (Mutex *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Mutex, 0, "ConditionVarFull.ConditionVarFull", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ConditionVarFull *return_value = new ConditionVarFull(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ConditionVarFull,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ConditionVarFull(non-const Mutex mutex)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ConditionVarFull(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ConditionVarFull)
    {
        printf("ConditionVarFull ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ConditionVarFull * local_this = (ConditionVarFull *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ConditionVarFull)
        return local_this;
    if(requested_type == &Dtool_ConditionVarFullDirect)
        return ( ConditionVarFullDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ConditionVarFull(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ConditionVarFull)
        return from_this;
    if(from_type == &Dtool_ConditionVarFullDirect)
    {
          ConditionVarFullDirect* other_this = (ConditionVarFullDirect*)from_this;
          return (ConditionVarFull*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ExternalThread 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ExternalThread::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ExternalThread_get_class_type_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ExternalThread::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ExternalThread::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ExternalThread_get_class_type_82_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ExternalThread_get_class_type_82_comment = NULL;
#endif

int  Dtool_Init_ExternalThread(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ExternalThread)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ExternalThread(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ExternalThread)
    {
        printf("ExternalThread ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ExternalThread * local_this = (ExternalThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ExternalThread)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Thread *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_Thread)
        return ( Thread *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( Thread *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ExternalThread(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ExternalThread)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ExternalThread*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ExternalThread*)other_this;
    }
    if(from_type == &Dtool_Thread)
    {
          Thread* other_this = (Thread*)from_this;
          return (ExternalThread*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ExternalThread*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ExternalThread*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LightMutexDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LightMutexDirect::acquire(void) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_acquire_85(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void LightMutexDirect::acquire(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
        else
            (PyArg_Parse(args, ":acquire"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            ((const LightMutexDirect*)local_this)->acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "acquire(const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_acquire_85_comment =
    "C++ Interface:\n"
    "acquire(const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: Grabs the lightMutex if it is available.  If it is not\n"
    "//               available, blocks until it becomes available, then\n"
    "//               grabs it.  In either case, the function does not\n"
    "//               return until the lightMutex is held; you should then call\n"
    "//               unlock().\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const lightMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "//\n"
    "//               Also see LightMutexHolder.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_acquire_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightMutexDirect::release(void) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_release_86(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void LightMutexDirect::release(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            ((const LightMutexDirect*)local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_release_86_comment =
    "C++ Interface:\n"
    "release(const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::release\n"
    "//       Access: Published\n"
    "//  Description: Releases the lightMutex.  It is an error to call this if\n"
    "//               the lightMutex was not already locked.\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const lightMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_release_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LightMutexDirect::debug_is_locked(void) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_debug_is_locked_87(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LightMutexDirect::debug_is_locked(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":debugIsLocked", key_word_list));
        else
            (PyArg_Parse(args, ":debugIsLocked"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LightMutexDirect*)local_this)->debug_is_locked();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "debugIsLocked(const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_debug_is_locked_87_comment =
    "C++ Interface:\n"
    "debugIsLocked(const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::debug_is_locked\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current thread has locked the\n"
    "//               LightMutex, false otherwise.  This method is only intended\n"
    "//               for use in debugging, hence the method name; in the\n"
    "//               LightMutexDirect case, it always returns true, since\n"
    "//               there's not a reliable way to determine this\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_debug_is_locked_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightMutexDirect::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_set_name_88(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LightMutexDirect::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightMutexDirect.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const LightMutexDirect this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_set_name_88_comment =
    "C++ Interface:\n"
    "setName(non-const LightMutexDirect this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::set_name\n"
    "//       Access: Public\n"
    "//  Description: The lightMutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_set_name_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightMutexDirect::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_clear_name_89(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LightMutexDirect::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightMutexDirect.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_clear_name_89_comment =
    "C++ Interface:\n"
    "clearName(non-const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::clear_name\n"
    "//       Access: Public\n"
    "//  Description: The lightMutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_clear_name_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LightMutexDirect::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_has_name_90(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LightMutexDirect::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LightMutexDirect*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_has_name_90_comment =
    "C++ Interface:\n"
    "hasName(const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::has_name\n"
    "//       Access: Public\n"
    "//  Description: The lightMutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_has_name_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > LightMutexDirect::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_get_name_91(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > LightMutexDirect::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const LightMutexDirect*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const LightMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_get_name_91_comment =
    "C++ Interface:\n"
    "getName(const LightMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::get_name\n"
    "//       Access: Public\n"
    "//  Description: The lightMutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_get_name_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LightMutexDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_LightMutexDirect_output_92(PyObject *self, PyObject *args,PyObject *kwds) {
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void LightMutexDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightMutexDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const LightMutexDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const LightMutexDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightMutexDirect_output_92_comment =
    "C++ Interface:\n"
    "output(const LightMutexDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightMutexDirect::output\n"
    "//       Access: Public\n"
    "//  Description: This method is declared virtual in LightMutexDebug, but\n"
    "//               non-virtual in LightMutexDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightMutexDirect_output_92_comment = NULL;
#endif

int  Dtool_Init_LightMutexDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LightMutexDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LightMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightMutexDirect)
    {
        printf("LightMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightMutexDirect * local_this = (LightMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightMutexDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightMutexDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightMutexDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LightMutex 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LightMutex::LightMutex(void)
 * inline LightMutex::LightMutex(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_LightMutex(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline LightMutex::LightMutex(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LightMutex", key_word_list))
            {
                LightMutex *return_value = new LightMutex();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LightMutex,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline LightMutex::LightMutex(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LightMutex", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:LightMutex", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                LightMutex *return_value = new LightMutex(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LightMutex,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LightMutex() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LightMutex()\n"
          "LightMutex(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LightMutex(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightMutex)
    {
        printf("LightMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightMutex * local_this = (LightMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightMutex)
        return local_this;
    if(requested_type == &Dtool_LightMutexDirect)
        return ( LightMutexDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightMutex(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightMutex)
        return from_this;
    if(from_type == &Dtool_LightMutexDirect)
    {
          LightMutexDirect* other_this = (LightMutexDirect*)from_this;
          return (LightMutex*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ReMutexDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ReMutexDirect::acquire(void) const
 * inline void ReMutexDirect::acquire(Thread *current_thread) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_acquire_97(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline void ReMutexDirect::acquire(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
            else
                (PyArg_Parse(args, ":acquire"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                ((const ReMutexDirect*)local_this)->acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline void ReMutexDirect::acquire(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:acquire", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:acquire", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ReMutexDirect.acquire", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        ((const ReMutexDirect*)local_this)->acquire(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "acquire() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "acquire(const ReMutexDirect this)\n"
          "acquire(const ReMutexDirect this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_acquire_97_comment =
    "C++ Interface:\n"
    "acquire(const ReMutexDirect this)\n"
    "acquire(const ReMutexDirect this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: Grabs the reMutex if it is available.  If it is not\n"
    "//               available, blocks until it becomes available, then\n"
    "//               grabs it.  In either case, the function does not\n"
    "//               return until the reMutex is held; you should then call\n"
    "//               unlock().\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const reMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "//\n"
    "//               Also see ReMutexHolder.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: This variant on acquire() accepts the current thread as\n"
    "//               a parameter, if it is already known, as an\n"
    "//               optimization.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_acquire_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ReMutexDirect::try_acquire(void) const
 * inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_try_acquire_98(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool ReMutexDirect::try_acquire(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":tryAcquire", key_word_list));
            else
                (PyArg_Parse(args, ":tryAcquire"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                bool return_value = ((const ReMutexDirect*)local_this)->try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool ReMutexDirect::try_acquire(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:tryAcquire", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:tryAcquire", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "ReMutexDirect.tryAcquire", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        bool return_value = ((const ReMutexDirect*)local_this)->try_acquire(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "tryAcquire() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "tryAcquire(const ReMutexDirect this)\n"
          "tryAcquire(const ReMutexDirect this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_try_acquire_98_comment =
    "C++ Interface:\n"
    "tryAcquire(const ReMutexDirect this)\n"
    "tryAcquire(const ReMutexDirect this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::try_acquire\n"
    "//       Access: Published\n"
    "//  Description: Returns immediately, with a true value indicating the\n"
    "//               mutex has been acquired, and false indicating it has\n"
    "//               not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::try_acquire\n"
    "//       Access: Published\n"
    "//  Description: Returns immediately, with a true value indicating the\n"
    "//               mutex has been acquired, and false indicating it has\n"
    "//               not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_try_acquire_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ReMutexDirect::elevate_lock(void) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_elevate_lock_99(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void ReMutexDirect::elevate_lock(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":elevateLock", key_word_list));
        else
            (PyArg_Parse(args, ":elevateLock"));
        if(!PyErr_Occurred())
        {
            ((const ReMutexDirect*)local_this)->elevate_lock();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "elevateLock(const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_elevate_lock_99_comment =
    "C++ Interface:\n"
    "elevateLock(const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::elevate_lock\n"
    "//       Access: Published\n"
    "//  Description: This method increments the lock count, assuming the\n"
    "//               calling thread already holds the lock.  After this\n"
    "//               call, release() will need to be called one additional\n"
    "//               time to release the lock.\n"
    "//\n"
    "//               This method really performs the same function as\n"
    "//               acquire(), but it offers a potential (slight)\n"
    "//               performance benefit when the calling thread knows\n"
    "//               that it already holds the lock.  It is an error to\n"
    "//               call this when the calling thread does not hold the\n"
    "//               lock.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_elevate_lock_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ReMutexDirect::release(void) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_release_100(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void ReMutexDirect::release(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            ((const ReMutexDirect*)local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_release_100_comment =
    "C++ Interface:\n"
    "release(const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::release\n"
    "//       Access: Published\n"
    "//  Description: Releases the reMutex.  It is an error to call this if\n"
    "//               the reMutex was not already locked.\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const reMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_release_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ReMutexDirect::debug_is_locked(void) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_debug_is_locked_101(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ReMutexDirect::debug_is_locked(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":debugIsLocked", key_word_list));
        else
            (PyArg_Parse(args, ":debugIsLocked"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ReMutexDirect*)local_this)->debug_is_locked();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "debugIsLocked(const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_debug_is_locked_101_comment =
    "C++ Interface:\n"
    "debugIsLocked(const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::debug_is_locked\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current thread has locked the\n"
    "//               ReMutex, false otherwise.  This method is only intended\n"
    "//               for use in debugging, hence the method name; in the\n"
    "//               ReMutexDirect case, it always returns true, since\n"
    "//               there's not a reliable way to determine this\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_debug_is_locked_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ReMutexDirect::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_set_name_102(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ReMutexDirect::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ReMutexDirect.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const ReMutexDirect this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_set_name_102_comment =
    "C++ Interface:\n"
    "setName(non-const ReMutexDirect this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::set_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_set_name_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ReMutexDirect::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_clear_name_103(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ReMutexDirect::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ReMutexDirect.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_clear_name_103_comment =
    "C++ Interface:\n"
    "clearName(non-const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::clear_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_clear_name_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ReMutexDirect::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_has_name_104(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ReMutexDirect::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ReMutexDirect*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_has_name_104_comment =
    "C++ Interface:\n"
    "hasName(const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::has_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_has_name_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ReMutexDirect::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_get_name_105(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ReMutexDirect::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ReMutexDirect*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const ReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_get_name_105_comment =
    "C++ Interface:\n"
    "getName(const ReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::get_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_get_name_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ReMutexDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_ReMutexDirect_output_106(PyObject *self, PyObject *args,PyObject *kwds) {
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void ReMutexDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ReMutexDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const ReMutexDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const ReMutexDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ReMutexDirect_output_106_comment =
    "C++ Interface:\n"
    "output(const ReMutexDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ReMutexDirect::output\n"
    "//       Access: Published\n"
    "//  Description: This method is declared virtual in MutexDebug, but\n"
    "//               non-virtual in ReMutexDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ReMutexDirect_output_106_comment = NULL;
#endif

int  Dtool_Init_ReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ReMutexDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ReMutexDirect)
    {
        printf("ReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ReMutexDirect * local_this = (ReMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ReMutexDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ReMutexDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LightReMutexDirect 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LightReMutexDirect::acquire(void) const
 * inline void LightReMutexDirect::acquire(Thread *current_thread) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_acquire_108(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline void LightReMutexDirect::acquire(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
            else
                (PyArg_Parse(args, ":acquire"));
            if(!PyErr_Occurred())
            {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                PyThreadState *_save;
                Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                ((const LightReMutexDirect*)local_this)->acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline void LightReMutexDirect::acquire(Thread *current_thread) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"current_thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:acquire", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:acquire", &param1));
                if(!PyErr_Occurred())
                {
                    Thread *param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Thread, 1, "LightReMutexDirect.acquire", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        PyThreadState *_save;
                        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        ((const LightReMutexDirect*)local_this)->acquire(param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
                        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "acquire() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "acquire(const LightReMutexDirect this)\n"
          "acquire(const LightReMutexDirect this, non-const Thread current_thread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_acquire_108_comment =
    "C++ Interface:\n"
    "acquire(const LightReMutexDirect this)\n"
    "acquire(const LightReMutexDirect this, non-const Thread current_thread)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: Grabs the lightReMutex if it is available.  If it is not\n"
    "//               available, blocks until it becomes available, then\n"
    "//               grabs it.  In either case, the function does not\n"
    "//               return until the lightReMutex is held; you should then call\n"
    "//               unlock().\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const lightReMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "//\n"
    "//               Also see LightReMutexHolder.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::acquire\n"
    "//       Access: Published\n"
    "//  Description: This variant on acquire() accepts the current thread as\n"
    "//               a parameter, if it is already known, as an\n"
    "//               optimization.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_acquire_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightReMutexDirect::elevate_lock(void) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_elevate_lock_109(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void LightReMutexDirect::elevate_lock(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":elevateLock", key_word_list));
        else
            (PyArg_Parse(args, ":elevateLock"));
        if(!PyErr_Occurred())
        {
            ((const LightReMutexDirect*)local_this)->elevate_lock();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "elevateLock(const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_elevate_lock_109_comment =
    "C++ Interface:\n"
    "elevateLock(const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::elevate_lock\n"
    "//       Access: Published\n"
    "//  Description: This method increments the lock count, assuming the\n"
    "//               calling thread already holds the lock.  After this\n"
    "//               call, release() will need to be called one additional\n"
    "//               time to release the lock.\n"
    "//\n"
    "//               This method really performs the same function as\n"
    "//               acquire(), but it offers a potential (slight)\n"
    "//               performance benefit when the calling thread knows\n"
    "//               that it already holds the lock.  It is an error to\n"
    "//               call this when the calling thread does not hold the\n"
    "//               lock.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_elevate_lock_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightReMutexDirect::release(void) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_release_110(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void LightReMutexDirect::release(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            ((const LightReMutexDirect*)local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_release_110_comment =
    "C++ Interface:\n"
    "release(const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::release\n"
    "//       Access: Published\n"
    "//  Description: Releases the lightReMutex.  It is an error to call this if\n"
    "//               the lightReMutex was not already locked.\n"
    "//\n"
    "//               This method is considered const so that you can lock\n"
    "//               and unlock const lightReMutexes, mainly to allow thread-safe\n"
    "//               access to otherwise const data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_release_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LightReMutexDirect::debug_is_locked(void) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_debug_is_locked_111(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LightReMutexDirect::debug_is_locked(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":debugIsLocked", key_word_list));
        else
            (PyArg_Parse(args, ":debugIsLocked"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LightReMutexDirect*)local_this)->debug_is_locked();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "debugIsLocked(const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_debug_is_locked_111_comment =
    "C++ Interface:\n"
    "debugIsLocked(const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::debug_is_locked\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current thread has locked the\n"
    "//               LightReMutex, false otherwise.  This method is only intended\n"
    "//               for use in debugging, hence the method name; in the\n"
    "//               LightReMutexDirect case, it always returns true, since\n"
    "//               there's not a reliable way to determine this\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_debug_is_locked_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightReMutexDirect::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_set_name_112(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LightReMutexDirect::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightReMutexDirect.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const LightReMutexDirect this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_set_name_112_comment =
    "C++ Interface:\n"
    "setName(non-const LightReMutexDirect this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::set_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_set_name_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LightReMutexDirect::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_clear_name_113(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LightReMutexDirect::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LightReMutexDirect.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_clear_name_113_comment =
    "C++ Interface:\n"
    "clearName(non-const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::clear_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_clear_name_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LightReMutexDirect::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_has_name_114(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LightReMutexDirect::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LightReMutexDirect*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_has_name_114_comment =
    "C++ Interface:\n"
    "hasName(const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::has_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_has_name_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > LightReMutexDirect::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_get_name_115(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > LightReMutexDirect::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const LightReMutexDirect*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const LightReMutexDirect this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_get_name_115_comment =
    "C++ Interface:\n"
    "getName(const LightReMutexDirect this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::get_name\n"
    "//       Access: Public\n"
    "//  Description: The mutex name is only defined when compiling in\n"
    "//               DEBUG_THREADS mode.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_get_name_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LightReMutexDirect::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_LightReMutexDirect_output_116(PyObject *self, PyObject *args,PyObject *kwds) {
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void LightReMutexDirect::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LightReMutexDirect.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const LightReMutexDirect*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const LightReMutexDirect this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LightReMutexDirect_output_116_comment =
    "C++ Interface:\n"
    "output(const LightReMutexDirect this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: LightReMutexDirect::output\n"
    "//       Access: Published\n"
    "//  Description: This method is declared virtual in MutexDebug, but\n"
    "//               non-virtual in LightReMutexDirect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LightReMutexDirect_output_116_comment = NULL;
#endif

int  Dtool_Init_LightReMutexDirect(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LightReMutexDirect)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LightReMutexDirect(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightReMutexDirect)
    {
        printf("LightReMutexDirect ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightReMutexDirect * local_this = (LightReMutexDirect *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightReMutexDirect)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightReMutexDirect(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightReMutexDirect)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LightReMutex 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LightReMutex::LightReMutex(void)
 * inline LightReMutex::LightReMutex(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_LightReMutex(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline LightReMutex::LightReMutex(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LightReMutex", key_word_list))
            {
                LightReMutex *return_value = new LightReMutex();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LightReMutex,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline LightReMutex::LightReMutex(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:LightReMutex", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:LightReMutex", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                LightReMutex *return_value = new LightReMutex(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LightReMutex,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LightReMutex() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LightReMutex()\n"
          "LightReMutex(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LightReMutex(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LightReMutex)
    {
        printf("LightReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LightReMutex * local_this = (LightReMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LightReMutex)
        return local_this;
    if(requested_type == &Dtool_LightReMutexDirect)
        return ( LightReMutexDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LightReMutex(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LightReMutex)
        return from_this;
    if(from_type == &Dtool_LightReMutexDirect)
    {
          LightReMutexDirect* other_this = (LightReMutexDirect*)from_this;
          return (LightReMutex*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MainThread 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MainThread::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MainThread_get_class_type_121(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MainThread::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MainThread::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MainThread_get_class_type_121_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MainThread_get_class_type_121_comment = NULL;
#endif

int  Dtool_Init_MainThread(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MainThread)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MainThread(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MainThread)
    {
        printf("MainThread ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MainThread * local_this = (MainThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MainThread)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Thread *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_Thread)
        return ( Thread *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( Thread *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MainThread(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MainThread)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MainThread*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MainThread*)other_this;
    }
    if(from_type == &Dtool_Thread)
    {
          Thread* other_this = (Thread*)from_this;
          return (MainThread*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MainThread*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (MainThread*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ReMutex 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline ReMutex::ReMutex(void)
 * inline ReMutex::ReMutex(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_ReMutex(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline ReMutex::ReMutex(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ReMutex", key_word_list))
            {
                ReMutex *return_value = new ReMutex();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ReMutex,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline ReMutex::ReMutex(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ReMutex", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ReMutex", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ReMutex *return_value = new ReMutex(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ReMutex,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ReMutex() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ReMutex()\n"
          "ReMutex(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ReMutex(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ReMutex)
    {
        printf("ReMutex ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ReMutex * local_this = (ReMutex *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ReMutex)
        return local_this;
    if(requested_type == &Dtool_ReMutexDirect)
        return ( ReMutexDirect *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ReMutex(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ReMutex)
        return from_this;
    if(from_type == &Dtool_ReMutexDirect)
    {
          ReMutexDirect* other_this = (ReMutexDirect*)from_this;
          return (ReMutex*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PythonThread 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonThread::join(void)
 *******************************************************************/
static PyObject *Dtool_PythonThread_join_128(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonThread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonThread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonThread::join(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":join", key_word_list));
        else
            (PyArg_Parse(args, ":join"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PyObject *return_value = (local_this)->join();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonThread.join() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "join(non-const PythonThread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonThread_join_128_comment =
    "C++ Interface:\n"
    "join(non-const PythonThread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonThread::join\n"
    "//       Access: Published\n"
    "//  Description: Blocks the calling process until the thread\n"
    "//               terminates.  If the thread has already terminated,\n"
    "//               this returns immediately.\n"
    "//\n"
    "//               The PythonThread flavor of this function returns the\n"
    "//               same value returned by the thread function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonThread_join_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PythonThread::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PythonThread_get_class_type_129(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PythonThread::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PythonThread::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonThread_get_class_type_129_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PythonThread_get_class_type_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PythonThread::PythonThread(PyObject *function, PyObject *args, basic_string< char > const &name, basic_string< char > const &sync_name)
 *******************************************************************/
int  Dtool_Init_PythonThread(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PythonThread::PythonThread(PyObject *function, PyObject *args, basic_string< char > const &name, basic_string< char > const &sync_name)
        PyObject *param0;
        PyObject *param1;
        char *param2_str; int param2_len;
        char *param3_str; int param3_len;
        static char * key_word_list[] = {(char *)"function", (char *)"args", (char *)"name", (char *)"sync_name", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#s#:PythonThread", key_word_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
        {
            PythonThread *return_value = new PythonThread(param0, param1, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonThread,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PythonThread(any function, any args, string name, string sync_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PythonThread(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PythonThread)
    {
        printf("PythonThread ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PythonThread * local_this = (PythonThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PythonThread)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( Thread *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_Thread)
        return ( Thread *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( Thread *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( Thread *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PythonThread(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PythonThread)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PythonThread*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PythonThread*)other_this;
    }
    if(from_type == &Dtool_Thread)
    {
          Thread* other_this = (Thread*)from_this;
          return (PythonThread*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PythonThread*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PythonThread*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Semaphore 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Semaphore::acquire(void)
 *******************************************************************/
static PyObject *Dtool_Semaphore_acquire_133(PyObject *self, PyObject *args,PyObject *kwds) {
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Semaphore::acquire(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":acquire", key_word_list));
        else
            (PyArg_Parse(args, ":acquire"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Semaphore.acquire() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "acquire(non-const Semaphore this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Semaphore_acquire_133_comment =
    "C++ Interface:\n"
    "acquire(non-const Semaphore this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Semaphore::acquire\n"
    "//       Access: Published\n"
    "//  Description: Decrements the internal count.  If the count was\n"
    "//               already at zero, blocks until the count is nonzero,\n"
    "//               then decrements it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Semaphore_acquire_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Semaphore::try_acquire(void)
 *******************************************************************/
static PyObject *Dtool_Semaphore_try_acquire_134(PyObject *self, PyObject *args,PyObject *kwds) {
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool Semaphore::try_acquire(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":tryAcquire", key_word_list));
        else
            (PyArg_Parse(args, ":tryAcquire"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->try_acquire();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Semaphore.tryAcquire() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "tryAcquire(non-const Semaphore this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Semaphore_try_acquire_134_comment =
    "C++ Interface:\n"
    "tryAcquire(non-const Semaphore this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Semaphore::try_acquire\n"
    "//       Access: Published\n"
    "//  Description: If the semaphore can be acquired without blocking,\n"
    "//               does so and returns true.  Otherwise, returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Semaphore_try_acquire_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Semaphore::release(void)
 *******************************************************************/
static PyObject *Dtool_Semaphore_release_135(PyObject *self, PyObject *args,PyObject *kwds) {
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int Semaphore::release(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":release", key_word_list));
        else
            (PyArg_Parse(args, ":release"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->release();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Semaphore.release() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "release(non-const Semaphore this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Semaphore_release_135_comment =
    "C++ Interface:\n"
    "release(non-const Semaphore this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Semaphore::release\n"
    "//       Access: Published\n"
    "//  Description: Increments the semaphore's internal count.  This may\n"
    "//               wake up another thread blocked on acquire().\n"
    "//\n"
    "//               Returns the count of the semaphore upon release.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Semaphore_release_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Semaphore::get_count(void) const
 *******************************************************************/
static PyObject *Dtool_Semaphore_get_count_136(PyObject *self, PyObject *args,PyObject *kwds) {
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Semaphore::get_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCount", key_word_list));
        else
            (PyArg_Parse(args, ":getCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Semaphore*)local_this)->get_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCount(const Semaphore this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Semaphore_get_count_136_comment =
    "C++ Interface:\n"
    "getCount(const Semaphore this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Semaphore::get_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the current semaphore count.  Note that this\n"
    "//               call is not thread-safe (the count may change at any\n"
    "//               time).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Semaphore_get_count_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Semaphore::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Semaphore_output_137(PyObject *self, PyObject *args,PyObject *kwds) {
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Semaphore::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Semaphore.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Semaphore*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Semaphore this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Semaphore_output_137_comment =
    "C++ Interface:\n"
    "output(const Semaphore this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Semaphore::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Semaphore_output_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Semaphore::Semaphore(int initial_count)
 * inline Semaphore::Semaphore(int initial_count = (1))
 *******************************************************************/
int  Dtool_Init_Semaphore(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline Semaphore::Semaphore(int initial_count = (1))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Semaphore", key_word_list))
            {
                Semaphore *return_value = new Semaphore();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Semaphore,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline Semaphore::Semaphore(int initial_count)
            int param0;
            static char * key_word_list[] = {(char *)"initial_count", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:Semaphore", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:Semaphore", &param0));
            if(!PyErr_Occurred())
            {
                Semaphore *return_value = new Semaphore((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Semaphore,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Semaphore() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Semaphore()\n"
          "Semaphore(int initial_count)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Semaphore(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Semaphore)
    {
        printf("Semaphore ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Semaphore * local_this = (Semaphore *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Semaphore)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Semaphore(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Semaphore)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskBase | AsyncTaskBase
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskBase[]= {
  { "getClassType",(PyCFunction ) &Dtool_AsyncTaskBase_get_class_type_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskBase_get_class_type_9_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskBase_upcast_to_TypedReferenceCount_3_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_AsyncTaskBase_upcast_to_Namable_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskBase_upcast_to_Namable_6_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AsyncTaskBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskBase\n"
          "// Description : The abstract base class for AsyncTask.  This is\n"
          "//               defined here only so we can store a pointer to the\n"
          "//               current task on the Thread.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskBase.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_AsyncTaskBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AsyncTaskBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskBase)");
             printf(" Error In PyType_ReadyAsyncTaskBase");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskBase.As_PyTypeObject().tp_dict,"AsyncTaskBase",&Dtool_AsyncTaskBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTaskBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTaskBase[0],&Dtool_AsyncTaskBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTaskBase,AsyncTaskBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskBase.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskBase",(PyObject *)&Dtool_AsyncTaskBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Thread | Thread
//********************************************************************
PyMethodDef Dtool_Methods_Thread[]= {
  { "bindThread",(PyCFunction ) &Dtool_Thread_bind_thread_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_bind_thread_17_comment},
  { "getSyncName",(PyCFunction ) &Dtool_Thread_get_sync_name_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_sync_name_18_comment},
  { "getPstatsIndex",(PyCFunction ) &Dtool_Thread_get_pstats_index_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_pstats_index_19_comment},
  { "getUniqueId",(PyCFunction ) &Dtool_Thread_get_unique_id_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_unique_id_20_comment},
  { "getPipelineStage",(PyCFunction ) &Dtool_Thread_get_pipeline_stage_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_pipeline_stage_21_comment},
  { "setPipelineStage",(PyCFunction ) &Dtool_Thread_set_pipeline_stage_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_set_pipeline_stage_22_comment},
  { "setMinPipelineStage",(PyCFunction ) &Dtool_Thread_set_min_pipeline_stage_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_set_min_pipeline_stage_23_comment},
  { "getMainThread",(PyCFunction ) &Dtool_Thread_get_main_thread_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_main_thread_24_comment},
  { "getExternalThread",(PyCFunction ) &Dtool_Thread_get_external_thread_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_external_thread_25_comment},
  { "getCurrentThread",(PyCFunction ) &Dtool_Thread_get_current_thread_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_current_thread_26_comment},
  { "getCurrentPipelineStage",(PyCFunction ) &Dtool_Thread_get_current_pipeline_stage_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_current_pipeline_stage_27_comment},
  { "isThreadingSupported",(PyCFunction ) &Dtool_Thread_is_threading_supported_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_is_threading_supported_28_comment},
  { "isTrueThreads",(PyCFunction ) &Dtool_Thread_is_true_threads_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_is_true_threads_29_comment},
  { "isSimpleThreads",(PyCFunction ) &Dtool_Thread_is_simple_threads_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_is_simple_threads_30_comment},
  { "sleep",(PyCFunction ) &Dtool_Thread_sleep_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_sleep_31_comment},
  { "forceYield",(PyCFunction ) &Dtool_Thread_force_yield_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_force_yield_32_comment},
  { "considerYield",(PyCFunction ) &Dtool_Thread_consider_yield_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_consider_yield_33_comment},
  { "output",(PyCFunction ) &Dtool_Thread_output_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_output_34_comment},
  { "outputBlocker",(PyCFunction ) &Dtool_Thread_output_blocker_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_output_blocker_35_comment},
  { "writeStatus",(PyCFunction ) &Dtool_Thread_write_status_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_write_status_36_comment},
  { "isStarted",(PyCFunction ) &Dtool_Thread_is_started_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_is_started_37_comment},
  { "isJoinable",(PyCFunction ) &Dtool_Thread_is_joinable_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_is_joinable_38_comment},
  { "start",(PyCFunction ) &Dtool_Thread_start_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_start_39_comment},
  { "join",(PyCFunction ) &Dtool_Thread_join_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_join_40_comment},
  { "preempt",(PyCFunction ) &Dtool_Thread_preempt_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_preempt_41_comment},
  { "setPythonData",(PyCFunction ) &Dtool_Thread_set_python_data_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_set_python_data_42_comment},
  { "getPythonData",(PyCFunction ) &Dtool_Thread_get_python_data_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_python_data_43_comment},
  { "getCurrentTask",(PyCFunction ) &Dtool_Thread_get_current_task_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_current_task_44_comment},
  { "prepareForExit",(PyCFunction ) &Dtool_Thread_prepare_for_exit_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_prepare_for_exit_45_comment},
  { "getClassType",(PyCFunction ) &Dtool_Thread_get_class_type_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_get_class_type_46_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_Thread_upcast_to_TypedReferenceCount_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_upcast_to_TypedReferenceCount_12_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_Thread_upcast_to_Namable_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Thread_upcast_to_Namable_14_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Thread
//////////////////
static PyObject *  Dtool_Repr_Thread(PyObject * self)
{
    Thread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Thread,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Thread(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Thread.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Thread\n"
          "// Description : A thread; that is, a lightweight process.  This is an\n"
          "//               abstract base class; to use it, you must subclass\n"
          "//               from it and redefine thread_main().\n"
          "//\n"
          "//               The thread itself will keep a reference count on the\n"
          "//               Thread object while it is running; when the thread\n"
          "//               returns from its root function, the Thread object\n"
          "//               will automatically be destructed if no other pointers\n"
          "//               are referencing it.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_Thread.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_Thread.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Thread.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Thread.As_PyTypeObject().tp_repr = & Dtool_Repr_Thread;
        // __str__ Repr Proxy
        Dtool_Thread.As_PyTypeObject().tp_str = & Dtool_Repr_Thread;
        if(PyType_Ready(&Dtool_Thread.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Thread)");
             printf(" Error In PyType_ReadyThread");
             return;
        }
        Py_INCREF(&Dtool_Thread.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"Thread",&Dtool_Thread.As_PyObject());
        //  Static Method bindThread
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"bindThread",PyCFunction_New(&Dtool_Methods_Thread[0],&Dtool_Thread.As_PyObject()));
        //  Static Method getMainThread
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"getMainThread",PyCFunction_New(&Dtool_Methods_Thread[7],&Dtool_Thread.As_PyObject()));
        //  Static Method getExternalThread
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"getExternalThread",PyCFunction_New(&Dtool_Methods_Thread[8],&Dtool_Thread.As_PyObject()));
        //  Static Method getCurrentThread
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"getCurrentThread",PyCFunction_New(&Dtool_Methods_Thread[9],&Dtool_Thread.As_PyObject()));
        //  Static Method getCurrentPipelineStage
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"getCurrentPipelineStage",PyCFunction_New(&Dtool_Methods_Thread[10],&Dtool_Thread.As_PyObject()));
        //  Static Method isThreadingSupported
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"isThreadingSupported",PyCFunction_New(&Dtool_Methods_Thread[11],&Dtool_Thread.As_PyObject()));
        //  Static Method isTrueThreads
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"isTrueThreads",PyCFunction_New(&Dtool_Methods_Thread[12],&Dtool_Thread.As_PyObject()));
        //  Static Method isSimpleThreads
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"isSimpleThreads",PyCFunction_New(&Dtool_Methods_Thread[13],&Dtool_Thread.As_PyObject()));
        //  Static Method sleep
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"sleep",PyCFunction_New(&Dtool_Methods_Thread[14],&Dtool_Thread.As_PyObject()));
        //  Static Method forceYield
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"forceYield",PyCFunction_New(&Dtool_Methods_Thread[15],&Dtool_Thread.As_PyObject()));
        //  Static Method considerYield
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"considerYield",PyCFunction_New(&Dtool_Methods_Thread[16],&Dtool_Thread.As_PyObject()));
        //  Static Method writeStatus
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"writeStatus",PyCFunction_New(&Dtool_Methods_Thread[19],&Dtool_Thread.As_PyObject()));
        //  Static Method prepareForExit
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"prepareForExit",PyCFunction_New(&Dtool_Methods_Thread[28],&Dtool_Thread.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Thread.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Thread[29],&Dtool_Thread.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Thread,Thread::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Thread.As_PyTypeObject());
        PyModule_AddObject(module, "Thread",(PyObject *)&Dtool_Thread.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MutexDirect | MutexDirect
//********************************************************************
PyMethodDef Dtool_Methods_MutexDirect[]= {
  { "acquire",(PyCFunction ) &Dtool_MutexDirect_acquire_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_acquire_48_comment},
  { "tryAcquire",(PyCFunction ) &Dtool_MutexDirect_try_acquire_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_try_acquire_49_comment},
  { "release",(PyCFunction ) &Dtool_MutexDirect_release_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_release_50_comment},
  { "debugIsLocked",(PyCFunction ) &Dtool_MutexDirect_debug_is_locked_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_debug_is_locked_51_comment},
  { "setName",(PyCFunction ) &Dtool_MutexDirect_set_name_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_set_name_52_comment},
  { "clearName",(PyCFunction ) &Dtool_MutexDirect_clear_name_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_clear_name_53_comment},
  { "hasName",(PyCFunction ) &Dtool_MutexDirect_has_name_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_has_name_54_comment},
  { "getName",(PyCFunction ) &Dtool_MutexDirect_get_name_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_get_name_55_comment},
  { "output",(PyCFunction ) &Dtool_MutexDirect_output_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MutexDirect_output_56_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     MutexDirect
//////////////////
static PyObject *  Dtool_Repr_MutexDirect(PyObject * self)
{
    MutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MutexDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_MutexDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MutexDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MutexDirect\n"
          "// Description : This class implements a standard mutex by making\n"
          "//               direct calls to the underlying implementation layer.\n"
          "//               It doesn't perform any debugging operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_MutexDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_MutexDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MutexDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MutexDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_MutexDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_MutexDirect;
        // __str__ Repr Proxy
        Dtool_MutexDirect.As_PyTypeObject().tp_str = & Dtool_Repr_MutexDirect;
        if(PyType_Ready(&Dtool_MutexDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MutexDirect)");
             printf(" Error In PyType_ReadyMutexDirect");
             return;
        }
        Py_INCREF(&Dtool_MutexDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MutexDirect.As_PyTypeObject().tp_dict,"MutexDirect",&Dtool_MutexDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_MutexDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MutexDirect.As_PyTypeObject());
        PyModule_AddObject(module, "MutexDirect",(PyObject *)&Dtool_MutexDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Mutex | Mutex
//********************************************************************
PyMethodDef Dtool_Methods_Mutex[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Mutex(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_MutexDirect._Dtool_ClassInit(NULL);
        Dtool_Mutex.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MutexDirect.As_PyTypeObject());
        Dtool_Mutex.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Mutex.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Mutex.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Mutex.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Mutex)");
             printf(" Error In PyType_ReadyMutex");
             return;
        }
        Py_INCREF(&Dtool_Mutex.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Mutex.As_PyTypeObject().tp_dict,"Mutex",&Dtool_Mutex.As_PyObject());
        RegisterRuntimeClass(&Dtool_Mutex,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Mutex.As_PyTypeObject());
        PyModule_AddObject(module, "Mutex",(PyObject *)&Dtool_Mutex.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConditionVarDirect | ConditionVarDirect
//********************************************************************
PyMethodDef Dtool_Methods_ConditionVarDirect[]= {
  { "getMutex",(PyCFunction ) &Dtool_ConditionVarDirect_get_mutex_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarDirect_get_mutex_62_comment},
  { "wait",(PyCFunction ) &Dtool_ConditionVarDirect_wait_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarDirect_wait_63_comment},
  { "notify",(PyCFunction ) &Dtool_ConditionVarDirect_notify_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarDirect_notify_64_comment},
  { "output",(PyCFunction ) &Dtool_ConditionVarDirect_output_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarDirect_output_65_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConditionVarDirect
//////////////////
static PyObject *  Dtool_Repr_ConditionVarDirect(PyObject * self)
{
    ConditionVarDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConditionVarDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConditionVarDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConditionVarDirect\n"
          "// Description : A condition variable, usually used to communicate\n"
          "//               information about changing state to a thread that is\n"
          "//               waiting for something to happen.  A condition\n"
          "//               variable can be used to \"wake up\" a thread when some\n"
          "//               arbitrary condition has changed.\n"
          "//\n"
          "//               A condition variable is associated with a single\n"
          "//               mutex, and several condition variables may share the\n"
          "//               same mutex.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConditionVarDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConditionVarDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConditionVarDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConditionVarDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConditionVarDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_ConditionVarDirect;
        // __str__ Repr Proxy
        Dtool_ConditionVarDirect.As_PyTypeObject().tp_str = & Dtool_Repr_ConditionVarDirect;
        if(PyType_Ready(&Dtool_ConditionVarDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConditionVarDirect)");
             printf(" Error In PyType_ReadyConditionVarDirect");
             return;
        }
        Py_INCREF(&Dtool_ConditionVarDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConditionVarDirect.As_PyTypeObject().tp_dict,"ConditionVarDirect",&Dtool_ConditionVarDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConditionVarDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConditionVarDirect.As_PyTypeObject());
        PyModule_AddObject(module, "ConditionVarDirect",(PyObject *)&Dtool_ConditionVarDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConditionVar | ConditionVar
//********************************************************************
PyMethodDef Dtool_Methods_ConditionVar[]= {
  { "getMutex",(PyCFunction ) &Dtool_ConditionVar_get_mutex_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVar_get_mutex_69_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConditionVar(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ConditionVarDirect._Dtool_ClassInit(NULL);
        Dtool_ConditionVar.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConditionVarDirect.As_PyTypeObject());
        Dtool_ConditionVar.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConditionVar.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConditionVar.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConditionVar.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConditionVar)");
             printf(" Error In PyType_ReadyConditionVar");
             return;
        }
        Py_INCREF(&Dtool_ConditionVar.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConditionVar.As_PyTypeObject().tp_dict,"ConditionVar",&Dtool_ConditionVar.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConditionVar,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConditionVar.As_PyTypeObject());
        PyModule_AddObject(module, "ConditionVar",(PyObject *)&Dtool_ConditionVar.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConditionVarFullDirect | ConditionVarFullDirect
//********************************************************************
PyMethodDef Dtool_Methods_ConditionVarFullDirect[]= {
  { "getMutex",(PyCFunction ) &Dtool_ConditionVarFullDirect_get_mutex_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFullDirect_get_mutex_72_comment},
  { "wait",(PyCFunction ) &Dtool_ConditionVarFullDirect_wait_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFullDirect_wait_73_comment},
  { "notify",(PyCFunction ) &Dtool_ConditionVarFullDirect_notify_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFullDirect_notify_74_comment},
  { "notifyAll",(PyCFunction ) &Dtool_ConditionVarFullDirect_notify_all_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFullDirect_notify_all_75_comment},
  { "output",(PyCFunction ) &Dtool_ConditionVarFullDirect_output_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFullDirect_output_76_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ConditionVarFullDirect
//////////////////
static PyObject *  Dtool_Repr_ConditionVarFullDirect(PyObject * self)
{
    ConditionVarFullDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ConditionVarFullDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ConditionVarFullDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ConditionVarFullDirect\n"
          "// Description : A condition variable, usually used to communicate\n"
          "//               information about changing state to a thread that is\n"
          "//               waiting for something to happen.  A condition\n"
          "//               variable can be used to \"wake up\" a thread when some\n"
          "//               arbitrary condition has changed.\n"
          "//\n"
          "//               A condition variable is associated with a single\n"
          "//               mutex, and several condition variables may share the\n"
          "//               same mutex.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_ConditionVarFullDirect;
        // __str__ Repr Proxy
        Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_str = & Dtool_Repr_ConditionVarFullDirect;
        if(PyType_Ready(&Dtool_ConditionVarFullDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConditionVarFullDirect)");
             printf(" Error In PyType_ReadyConditionVarFullDirect");
             return;
        }
        Py_INCREF(&Dtool_ConditionVarFullDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConditionVarFullDirect.As_PyTypeObject().tp_dict,"ConditionVarFullDirect",&Dtool_ConditionVarFullDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConditionVarFullDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConditionVarFullDirect.As_PyTypeObject());
        PyModule_AddObject(module, "ConditionVarFullDirect",(PyObject *)&Dtool_ConditionVarFullDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ConditionVarFull | ConditionVarFull
//********************************************************************
PyMethodDef Dtool_Methods_ConditionVarFull[]= {
  { "getMutex",(PyCFunction ) &Dtool_ConditionVarFull_get_mutex_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ConditionVarFull_get_mutex_80_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ConditionVarFull(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ConditionVarFullDirect._Dtool_ClassInit(NULL);
        Dtool_ConditionVarFull.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ConditionVarFullDirect.As_PyTypeObject());
        Dtool_ConditionVarFull.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ConditionVarFull.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ConditionVarFull.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ConditionVarFull.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ConditionVarFull)");
             printf(" Error In PyType_ReadyConditionVarFull");
             return;
        }
        Py_INCREF(&Dtool_ConditionVarFull.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ConditionVarFull.As_PyTypeObject().tp_dict,"ConditionVarFull",&Dtool_ConditionVarFull.As_PyObject());
        RegisterRuntimeClass(&Dtool_ConditionVarFull,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ConditionVarFull.As_PyTypeObject());
        PyModule_AddObject(module, "ConditionVarFull",(PyObject *)&Dtool_ConditionVarFull.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ExternalThread | ExternalThread
//********************************************************************
PyMethodDef Dtool_Methods_ExternalThread[]= {
  { "getClassType",(PyCFunction ) &Dtool_ExternalThread_get_class_type_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ExternalThread_get_class_type_82_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ExternalThread(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ExternalThread.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ExternalThread\n"
          "// Description : The special \"external thread\" class.  There is one\n"
          "//               instance of these in the world, and it is returned by\n"
          "//               Thread::get_external_thread().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Thread._Dtool_ClassInit(NULL);
        Dtool_ExternalThread.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Thread.As_PyTypeObject());
        Dtool_ExternalThread.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ExternalThread.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ExternalThread.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ExternalThread.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ExternalThread)");
             printf(" Error In PyType_ReadyExternalThread");
             return;
        }
        Py_INCREF(&Dtool_ExternalThread.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ExternalThread.As_PyTypeObject().tp_dict,"ExternalThread",&Dtool_ExternalThread.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ExternalThread.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ExternalThread[0],&Dtool_ExternalThread.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ExternalThread,ExternalThread::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ExternalThread.As_PyTypeObject());
        PyModule_AddObject(module, "ExternalThread",(PyObject *)&Dtool_ExternalThread.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LightMutexDirect | LightMutexDirect
//********************************************************************
PyMethodDef Dtool_Methods_LightMutexDirect[]= {
  { "acquire",(PyCFunction ) &Dtool_LightMutexDirect_acquire_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_acquire_85_comment},
  { "release",(PyCFunction ) &Dtool_LightMutexDirect_release_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_release_86_comment},
  { "debugIsLocked",(PyCFunction ) &Dtool_LightMutexDirect_debug_is_locked_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_debug_is_locked_87_comment},
  { "setName",(PyCFunction ) &Dtool_LightMutexDirect_set_name_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_set_name_88_comment},
  { "clearName",(PyCFunction ) &Dtool_LightMutexDirect_clear_name_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_clear_name_89_comment},
  { "hasName",(PyCFunction ) &Dtool_LightMutexDirect_has_name_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_has_name_90_comment},
  { "getName",(PyCFunction ) &Dtool_LightMutexDirect_get_name_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_get_name_91_comment},
  { "output",(PyCFunction ) &Dtool_LightMutexDirect_output_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightMutexDirect_output_92_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     LightMutexDirect
//////////////////
static PyObject *  Dtool_Repr_LightMutexDirect(PyObject * self)
{
    LightMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightMutexDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LightMutexDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LightMutexDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LightMutexDirect\n"
          "// Description : This class implements a lightweight Mutex by making\n"
          "//               direct calls to the underlying implementation layer.\n"
          "//               It doesn't perform any debugging operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_LightMutexDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_LightMutexDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightMutexDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightMutexDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_LightMutexDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_LightMutexDirect;
        // __str__ Repr Proxy
        Dtool_LightMutexDirect.As_PyTypeObject().tp_str = & Dtool_Repr_LightMutexDirect;
        if(PyType_Ready(&Dtool_LightMutexDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightMutexDirect)");
             printf(" Error In PyType_ReadyLightMutexDirect");
             return;
        }
        Py_INCREF(&Dtool_LightMutexDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightMutexDirect.As_PyTypeObject().tp_dict,"LightMutexDirect",&Dtool_LightMutexDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_LightMutexDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightMutexDirect.As_PyTypeObject());
        PyModule_AddObject(module, "LightMutexDirect",(PyObject *)&Dtool_LightMutexDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LightMutex | LightMutex
//********************************************************************
PyMethodDef Dtool_Methods_LightMutex[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LightMutex(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LightMutexDirect._Dtool_ClassInit(NULL);
        Dtool_LightMutex.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightMutexDirect.As_PyTypeObject());
        Dtool_LightMutex.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightMutex.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightMutex.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LightMutex.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightMutex)");
             printf(" Error In PyType_ReadyLightMutex");
             return;
        }
        Py_INCREF(&Dtool_LightMutex.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightMutex.As_PyTypeObject().tp_dict,"LightMutex",&Dtool_LightMutex.As_PyObject());
        RegisterRuntimeClass(&Dtool_LightMutex,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightMutex.As_PyTypeObject());
        PyModule_AddObject(module, "LightMutex",(PyObject *)&Dtool_LightMutex.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ReMutexDirect | ReMutexDirect
//********************************************************************
PyMethodDef Dtool_Methods_ReMutexDirect[]= {
  { "acquire",(PyCFunction ) &Dtool_ReMutexDirect_acquire_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_acquire_97_comment},
  { "tryAcquire",(PyCFunction ) &Dtool_ReMutexDirect_try_acquire_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_try_acquire_98_comment},
  { "elevateLock",(PyCFunction ) &Dtool_ReMutexDirect_elevate_lock_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_elevate_lock_99_comment},
  { "release",(PyCFunction ) &Dtool_ReMutexDirect_release_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_release_100_comment},
  { "debugIsLocked",(PyCFunction ) &Dtool_ReMutexDirect_debug_is_locked_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_debug_is_locked_101_comment},
  { "setName",(PyCFunction ) &Dtool_ReMutexDirect_set_name_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_set_name_102_comment},
  { "clearName",(PyCFunction ) &Dtool_ReMutexDirect_clear_name_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_clear_name_103_comment},
  { "hasName",(PyCFunction ) &Dtool_ReMutexDirect_has_name_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_has_name_104_comment},
  { "getName",(PyCFunction ) &Dtool_ReMutexDirect_get_name_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_get_name_105_comment},
  { "output",(PyCFunction ) &Dtool_ReMutexDirect_output_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ReMutexDirect_output_106_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     ReMutexDirect
//////////////////
static PyObject *  Dtool_Repr_ReMutexDirect(PyObject * self)
{
    ReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ReMutexDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ReMutexDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ReMutexDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ReMutexDirect\n"
          "// Description : This class implements a standard reMutex by making\n"
          "//               direct calls to the underlying implementation layer.\n"
          "//               It doesn't perform any debugging operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ReMutexDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ReMutexDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ReMutexDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ReMutexDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_ReMutexDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_ReMutexDirect;
        // __str__ Repr Proxy
        Dtool_ReMutexDirect.As_PyTypeObject().tp_str = & Dtool_Repr_ReMutexDirect;
        if(PyType_Ready(&Dtool_ReMutexDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ReMutexDirect)");
             printf(" Error In PyType_ReadyReMutexDirect");
             return;
        }
        Py_INCREF(&Dtool_ReMutexDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ReMutexDirect.As_PyTypeObject().tp_dict,"ReMutexDirect",&Dtool_ReMutexDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_ReMutexDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ReMutexDirect.As_PyTypeObject());
        PyModule_AddObject(module, "ReMutexDirect",(PyObject *)&Dtool_ReMutexDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LightReMutexDirect | LightReMutexDirect
//********************************************************************
PyMethodDef Dtool_Methods_LightReMutexDirect[]= {
  { "acquire",(PyCFunction ) &Dtool_LightReMutexDirect_acquire_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_acquire_108_comment},
  { "elevateLock",(PyCFunction ) &Dtool_LightReMutexDirect_elevate_lock_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_elevate_lock_109_comment},
  { "release",(PyCFunction ) &Dtool_LightReMutexDirect_release_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_release_110_comment},
  { "debugIsLocked",(PyCFunction ) &Dtool_LightReMutexDirect_debug_is_locked_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_debug_is_locked_111_comment},
  { "setName",(PyCFunction ) &Dtool_LightReMutexDirect_set_name_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_set_name_112_comment},
  { "clearName",(PyCFunction ) &Dtool_LightReMutexDirect_clear_name_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_clear_name_113_comment},
  { "hasName",(PyCFunction ) &Dtool_LightReMutexDirect_has_name_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_has_name_114_comment},
  { "getName",(PyCFunction ) &Dtool_LightReMutexDirect_get_name_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_get_name_115_comment},
  { "output",(PyCFunction ) &Dtool_LightReMutexDirect_output_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LightReMutexDirect_output_116_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     LightReMutexDirect
//////////////////
static PyObject *  Dtool_Repr_LightReMutexDirect(PyObject * self)
{
    LightReMutexDirect * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LightReMutexDirect,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LightReMutexDirect(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LightReMutexDirect.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LightReMutexDirect\n"
          "// Description : This class implements a standard lightReMutex by making\n"
          "//               direct calls to the underlying implementation layer.\n"
          "//               It doesn't perform any debugging operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_LightReMutexDirect.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_LightReMutexDirect.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightReMutexDirect.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightReMutexDirect.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_LightReMutexDirect.As_PyTypeObject().tp_repr = & Dtool_Repr_LightReMutexDirect;
        // __str__ Repr Proxy
        Dtool_LightReMutexDirect.As_PyTypeObject().tp_str = & Dtool_Repr_LightReMutexDirect;
        if(PyType_Ready(&Dtool_LightReMutexDirect.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightReMutexDirect)");
             printf(" Error In PyType_ReadyLightReMutexDirect");
             return;
        }
        Py_INCREF(&Dtool_LightReMutexDirect.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightReMutexDirect.As_PyTypeObject().tp_dict,"LightReMutexDirect",&Dtool_LightReMutexDirect.As_PyObject());
        RegisterRuntimeClass(&Dtool_LightReMutexDirect,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightReMutexDirect.As_PyTypeObject());
        PyModule_AddObject(module, "LightReMutexDirect",(PyObject *)&Dtool_LightReMutexDirect.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LightReMutex | LightReMutex
//********************************************************************
PyMethodDef Dtool_Methods_LightReMutex[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LightReMutex(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LightReMutexDirect._Dtool_ClassInit(NULL);
        Dtool_LightReMutex.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LightReMutexDirect.As_PyTypeObject());
        Dtool_LightReMutex.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LightReMutex.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LightReMutex.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LightReMutex.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LightReMutex)");
             printf(" Error In PyType_ReadyLightReMutex");
             return;
        }
        Py_INCREF(&Dtool_LightReMutex.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LightReMutex.As_PyTypeObject().tp_dict,"LightReMutex",&Dtool_LightReMutex.As_PyObject());
        RegisterRuntimeClass(&Dtool_LightReMutex,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LightReMutex.As_PyTypeObject());
        PyModule_AddObject(module, "LightReMutex",(PyObject *)&Dtool_LightReMutex.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MainThread | MainThread
//********************************************************************
PyMethodDef Dtool_Methods_MainThread[]= {
  { "getClassType",(PyCFunction ) &Dtool_MainThread_get_class_type_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MainThread_get_class_type_121_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MainThread(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MainThread.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MainThread\n"
          "// Description : The special \"main thread\" class.  There is one\n"
          "//               instance of these in the world, and it is returned by\n"
          "//               Thread::get_main_thread().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Thread._Dtool_ClassInit(NULL);
        Dtool_MainThread.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Thread.As_PyTypeObject());
        Dtool_MainThread.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MainThread.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MainThread.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MainThread.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MainThread)");
             printf(" Error In PyType_ReadyMainThread");
             return;
        }
        Py_INCREF(&Dtool_MainThread.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MainThread.As_PyTypeObject().tp_dict,"MainThread",&Dtool_MainThread.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MainThread.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MainThread[0],&Dtool_MainThread.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MainThread,MainThread::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MainThread.As_PyTypeObject());
        PyModule_AddObject(module, "MainThread",(PyObject *)&Dtool_MainThread.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ReMutex | ReMutex
//********************************************************************
PyMethodDef Dtool_Methods_ReMutex[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ReMutex(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_ReMutexDirect._Dtool_ClassInit(NULL);
        Dtool_ReMutex.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReMutexDirect.As_PyTypeObject());
        Dtool_ReMutex.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ReMutex.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ReMutex.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ReMutex.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ReMutex)");
             printf(" Error In PyType_ReadyReMutex");
             return;
        }
        Py_INCREF(&Dtool_ReMutex.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ReMutex.As_PyTypeObject().tp_dict,"ReMutex",&Dtool_ReMutex.As_PyObject());
        RegisterRuntimeClass(&Dtool_ReMutex,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ReMutex.As_PyTypeObject());
        PyModule_AddObject(module, "ReMutex",(PyObject *)&Dtool_ReMutex.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PythonThread | PythonThread
//********************************************************************
PyMethodDef Dtool_Methods_PythonThread[]= {
  { "join",(PyCFunction ) &Dtool_PythonThread_join_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonThread_join_128_comment},
  { "getClassType",(PyCFunction ) &Dtool_PythonThread_get_class_type_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonThread_get_class_type_129_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PythonThread(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PythonThread.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PythonThread\n"
          "// Description : This class is exposed to Python to allow creation of\n"
          "//               a Panda thread from the Python level.  It will spawn\n"
          "//               a thread that executes an arbitrary Python functor.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Thread._Dtool_ClassInit(NULL);
        Dtool_PythonThread.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Thread.As_PyTypeObject());
        Dtool_PythonThread.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PythonThread.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PythonThread.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PythonThread.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PythonThread)");
             printf(" Error In PyType_ReadyPythonThread");
             return;
        }
        Py_INCREF(&Dtool_PythonThread.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PythonThread.As_PyTypeObject().tp_dict,"PythonThread",&Dtool_PythonThread.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PythonThread.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PythonThread[1],&Dtool_PythonThread.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PythonThread,PythonThread::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PythonThread.As_PyTypeObject());
        PyModule_AddObject(module, "PythonThread",(PyObject *)&Dtool_PythonThread.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Semaphore | Semaphore
//********************************************************************
PyMethodDef Dtool_Methods_Semaphore[]= {
  { "acquire",(PyCFunction ) &Dtool_Semaphore_acquire_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Semaphore_acquire_133_comment},
  { "tryAcquire",(PyCFunction ) &Dtool_Semaphore_try_acquire_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Semaphore_try_acquire_134_comment},
  { "release",(PyCFunction ) &Dtool_Semaphore_release_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Semaphore_release_135_comment},
  { "getCount",(PyCFunction ) &Dtool_Semaphore_get_count_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Semaphore_get_count_136_comment},
  { "output",(PyCFunction ) &Dtool_Semaphore_output_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Semaphore_output_137_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Semaphore
//////////////////
static PyObject *  Dtool_Repr_Semaphore(PyObject * self)
{
    Semaphore * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Semaphore,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Semaphore(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Semaphore.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Semaphore\n"
          "// Description : A classic semaphore synchronization primitive.  \n"
          "//\n"
          "//               A semaphore manages an internal counter which is\n"
          "//               decremented by each acquire() call and incremented by\n"
          "//               each release() call. The counter can never go below\n"
          "//               zero; when acquire() finds that it is zero, it\n"
          "//               blocks, waiting until some other thread calls\n"
          "//               release().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_Semaphore.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_Semaphore.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Semaphore.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Semaphore.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Semaphore.As_PyTypeObject().tp_repr = & Dtool_Repr_Semaphore;
        // __str__ Repr Proxy
        Dtool_Semaphore.As_PyTypeObject().tp_str = & Dtool_Repr_Semaphore;
        if(PyType_Ready(&Dtool_Semaphore.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Semaphore)");
             printf(" Error In PyType_ReadySemaphore");
             return;
        }
        Py_INCREF(&Dtool_Semaphore.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Semaphore.As_PyTypeObject().tp_dict,"Semaphore",&Dtool_Semaphore.As_PyObject());
        RegisterRuntimeClass(&Dtool_Semaphore,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Semaphore.As_PyTypeObject());
        PyModule_AddObject(module, "Semaphore",(PyObject *)&Dtool_Semaphore.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..ThreadPriority
//********************************************************************
   PyModule_AddIntConstant(module,"TPLow",0);
   PyModule_AddIntConstant(module,"TPNormal",1);
   PyModule_AddIntConstant(module,"TPHigh",2);
   PyModule_AddIntConstant(module,"TPUrgent",3);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskBase
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskBase(module);
//********************************************************************
//*** Module Init Updcall ..Thread
//********************************************************************
   Dtool_PyModuleClassInit_Thread(module);
//********************************************************************
//*** Module Init Updcall ..MutexDirect
//********************************************************************
   Dtool_PyModuleClassInit_MutexDirect(module);
//********************************************************************
//*** Module Init Updcall ..Mutex
//********************************************************************
   Dtool_PyModuleClassInit_Mutex(module);
//********************************************************************
//*** Module Init Updcall ..ConditionVarDirect
//********************************************************************
   Dtool_PyModuleClassInit_ConditionVarDirect(module);
//********************************************************************
//*** Module Init Updcall ..ConditionVar
//********************************************************************
   Dtool_PyModuleClassInit_ConditionVar(module);
//********************************************************************
//*** Module Init Updcall ..ConditionVarFullDirect
//********************************************************************
   Dtool_PyModuleClassInit_ConditionVarFullDirect(module);
//********************************************************************
//*** Module Init Updcall ..ConditionVarFull
//********************************************************************
   Dtool_PyModuleClassInit_ConditionVarFull(module);
//********************************************************************
//*** Module Init Updcall ..ExternalThread
//********************************************************************
   Dtool_PyModuleClassInit_ExternalThread(module);
//********************************************************************
//*** Module Init Updcall ..LightMutexDirect
//********************************************************************
   Dtool_PyModuleClassInit_LightMutexDirect(module);
//********************************************************************
//*** Module Init Updcall ..LightMutex
//********************************************************************
   Dtool_PyModuleClassInit_LightMutex(module);
//********************************************************************
//*** Module Init Updcall ..ReMutexDirect
//********************************************************************
   Dtool_PyModuleClassInit_ReMutexDirect(module);
//********************************************************************
//*** Module Init Updcall ..LightReMutexDirect
//********************************************************************
   Dtool_PyModuleClassInit_LightReMutexDirect(module);
//********************************************************************
//*** Module Init Updcall ..LightReMutex
//********************************************************************
   Dtool_PyModuleClassInit_LightReMutex(module);
//********************************************************************
//*** Module Init Updcall ..MainThread
//********************************************************************
   Dtool_PyModuleClassInit_MainThread(module);
//********************************************************************
//*** Module Init Updcall ..ReMutex
//********************************************************************
   Dtool_PyModuleClassInit_ReMutex(module);
//********************************************************************
//*** Module Init Updcall ..PythonThread
//********************************************************************
   Dtool_PyModuleClassInit_PythonThread(module);
//********************************************************************
//*** Module Init Updcall ..Semaphore
//********************************************************************
   Dtool_PyModuleClassInit_Semaphore(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpipeline_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212818,  /* file_identifier */
  "libpipeline",  /* library_name */
  "AkFD",  /* library_hash_name */
  "panda",  /* module_name */
  "libpipeline.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  300  /* next_index */
};

Configure(_in_configure_libpipeline);
ConfigureFn(_in_configure_libpipeline) {
  interrogate_request_module(&_in_module_def);
}

