/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/chan -Ipanda/src/chan -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libchan_igate.cxx -od built_Rocket/pandac/input/libchan.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/chan -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libchan animBundle.h animBundleNode.h animChannel.h animChannelBase.h animChannelMatrixDynamic.h animChannelMatrixFixed.h animChannelMatrixXfmTable.h animChannelScalarDynamic.h animChannelScalarTable.h animControl.h animControlCollection.h animGroup.h animPreloadTable.h auto_bind.h bindAnimRequest.h chan_composite.cxx config_chan.h movingPartBase.h movingPartMatrix.h movingPartScalar.h partBundle.h partBundleHandle.h partBundleNode.h partGroup.h partSubset.h vector_PartGroupStar.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libchan
#include "py_panda.h"  

#include "animBundle.h"
#include "animBundleNode.h"
#include "animChannel.h"
#include "animChannelBase.h"
#include "animChannelMatrixDynamic.h"
#include "animChannelMatrixFixed.h"
#include "animChannelMatrixXfmTable.h"
#include "animChannelScalarDynamic.h"
#include "animChannelScalarTable.h"
#include "animControl.h"
#include "animControlCollection.h"
#include "animGroup.h"
#include "animPreloadTable.h"
#include "auto_bind.h"
#include "bindAnimRequest.h"
#include "compose_matrix.h"
#include "config_chan.h"
#include "copyOnWriteObject.h"
#include "dcast.h"
#include "event.h"
#include "luse.h"
#include "modelLoadRequest.h"
#include "movingPartBase.h"
#include "movingPartMatrix.h"
#include "movingPartScalar.h"
#include "ordered_vector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "partBundle.h"
#include "partBundleHandle.h"
#include "partBundleNode.h"
#include "partGroup.h"
#include "partSubset.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pt_Event.h"
#include "pta_float.h"
#include "transformState.h"
#include "typedWritableReferenceCount.h"
#include "vector_PartGroupStar.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. AnimGroup
//********************************************************************
typedef  AnimGroup  AnimGroup_localtype;
Define_Module_ClassRef(panda,AnimGroup,AnimGroup_localtype,AnimGroup);
//********************************************************************
//*** prototypes for .. AnimBundle
//********************************************************************
typedef  AnimBundle  AnimBundle_localtype;
Define_Module_ClassRef(panda,AnimBundle,AnimBundle_localtype,AnimBundle);
//********************************************************************
//*** prototypes for .. AnimBundleNode
//********************************************************************
typedef  AnimBundleNode  AnimBundleNode_localtype;
Define_Module_ClassRef(panda,AnimBundleNode,AnimBundleNode_localtype,AnimBundleNode);
//********************************************************************
//*** prototypes for .. PartGroup
//********************************************************************
typedef  PartGroup  PartGroup_localtype;
Define_Module_ClassRef(panda,PartGroup,PartGroup_localtype,PartGroup);
//********************************************************************
//*** prototypes for .. AnimControl
//********************************************************************
typedef  AnimControl  AnimControl_localtype;
Define_Module_ClassRef(panda,AnimControl,AnimControl_localtype,AnimControl);
//********************************************************************
//*** prototypes for .. AnimChannelBase
//********************************************************************
typedef  AnimChannelBase  AnimChannelBase_localtype;
Define_Module_ClassRef(panda,AnimChannelBase,AnimChannelBase_localtype,AnimChannelBase);
//********************************************************************
//*** prototypes for .. AnimChannel_ACMatrixSwitchType
//********************************************************************
typedef  AnimChannel< ACMatrixSwitchType >  AnimChannel_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda,AnimChannel_ACMatrixSwitchType,AnimChannel_ACMatrixSwitchType_localtype,AnimChannelACMatrixSwitchType);
//********************************************************************
//*** prototypes for .. AnimChannel_ACScalarSwitchType
//********************************************************************
typedef  AnimChannel< ACScalarSwitchType >  AnimChannel_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda,AnimChannel_ACScalarSwitchType,AnimChannel_ACScalarSwitchType_localtype,AnimChannelACScalarSwitchType);
//********************************************************************
//*** prototypes for .. AnimChannelMatrixDynamic
//********************************************************************
typedef  AnimChannelMatrixDynamic  AnimChannelMatrixDynamic_localtype;
Define_Module_ClassRef(panda,AnimChannelMatrixDynamic,AnimChannelMatrixDynamic_localtype,AnimChannelMatrixDynamic);
//********************************************************************
//*** prototypes for .. AnimChannelMatrixXfmTable
//********************************************************************
typedef  AnimChannelMatrixXfmTable  AnimChannelMatrixXfmTable_localtype;
Define_Module_ClassRef(panda,AnimChannelMatrixXfmTable,AnimChannelMatrixXfmTable_localtype,AnimChannelMatrixXfmTable);
//********************************************************************
//*** prototypes for .. AnimChannelScalarDynamic
//********************************************************************
typedef  AnimChannelScalarDynamic  AnimChannelScalarDynamic_localtype;
Define_Module_ClassRef(panda,AnimChannelScalarDynamic,AnimChannelScalarDynamic_localtype,AnimChannelScalarDynamic);
//********************************************************************
//*** prototypes for .. AnimChannelScalarTable
//********************************************************************
typedef  AnimChannelScalarTable  AnimChannelScalarTable_localtype;
Define_Module_ClassRef(panda,AnimChannelScalarTable,AnimChannelScalarTable_localtype,AnimChannelScalarTable);
//********************************************************************
//*** prototypes for .. AnimControlCollection
//********************************************************************
typedef  AnimControlCollection  AnimControlCollection_localtype;
Define_Module_Class(panda,AnimControlCollection,AnimControlCollection_localtype,AnimControlCollection);
//********************************************************************
//*** prototypes for .. AnimPreloadTable
//********************************************************************
typedef  AnimPreloadTable  AnimPreloadTable_localtype;
Define_Module_ClassRef(panda,AnimPreloadTable,AnimPreloadTable_localtype,AnimPreloadTable);
//********************************************************************
//*** prototypes for .. PartSubset
//********************************************************************
typedef  PartSubset  PartSubset_localtype;
Define_Module_Class(panda,PartSubset,PartSubset_localtype,PartSubset);
//********************************************************************
//*** prototypes for .. BindAnimRequest
//********************************************************************
typedef  BindAnimRequest  BindAnimRequest_localtype;
Define_Module_ClassRef(panda,BindAnimRequest,BindAnimRequest_localtype,BindAnimRequest);
//********************************************************************
//*** prototypes for .. PartBundle
//********************************************************************
typedef  PartBundle  PartBundle_localtype;
Define_Module_ClassRef(panda,PartBundle,PartBundle_localtype,PartBundle);
//********************************************************************
//*** prototypes for .. PartBundleHandle
//********************************************************************
typedef  PartBundleHandle  PartBundleHandle_localtype;
Define_Module_ClassRef(panda,PartBundleHandle,PartBundleHandle_localtype,PartBundleHandle);
//********************************************************************
//*** prototypes for .. PartBundleNode
//********************************************************************
typedef  PartBundleNode  PartBundleNode_localtype;
Define_Module_ClassRef(panda,PartBundleNode,PartBundleNode_localtype,PartBundleNode);
//********************************************************************
//*** prototypes for .. MovingPartBase
//********************************************************************
typedef  MovingPartBase  MovingPartBase_localtype;
Define_Module_ClassRef(panda,MovingPartBase,MovingPartBase_localtype,MovingPartBase);
//********************************************************************
//*** prototypes for .. MovingPartMatrix
//********************************************************************
typedef  MovingPartMatrix  MovingPartMatrix_localtype;
Define_Module_ClassRef(panda,MovingPartMatrix,MovingPartMatrix_localtype,MovingPartMatrix);
//********************************************************************
//*** prototypes for .. MovingPart_ACMatrixSwitchType
//********************************************************************
typedef  MovingPart< ACMatrixSwitchType >  MovingPart_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda,MovingPart_ACMatrixSwitchType,MovingPart_ACMatrixSwitchType_localtype,MovingPartACMatrixSwitchType);
//********************************************************************
//*** prototypes for .. MovingPartScalar
//********************************************************************
typedef  MovingPartScalar  MovingPartScalar_localtype;
Define_Module_ClassRef(panda,MovingPartScalar,MovingPartScalar_localtype,MovingPartScalar);
//********************************************************************
//*** prototypes for .. MovingPart_ACScalarSwitchType
//********************************************************************
typedef  MovingPart< ACScalarSwitchType >  MovingPart_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda,MovingPart_ACScalarSwitchType,MovingPart_ACScalarSwitchType_localtype,MovingPartACScalarSwitchType);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AnimInterface;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AsyncTask;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AsyncTaskBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BitArray;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConstPointerToArray_float;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CopyOnWriteObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GlobPattern;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LQuaternionf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Loader;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LoaderOptions;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ModelLoadRequest;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TransformState;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags)
 * void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = (0))
 *******************************************************************/
static PyObject *Dtool_auto_bind_166(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = (0))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"root_node", (char *)"controls", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:autoBind", key_word_list, &param0, &param1))
                {
                    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "autoBind", 0, coerced_ptr, report_errors);
AnimControlCollection *param1_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControlCollection, 1, "autoBind", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        auto_bind(param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"root_node", (char *)"controls", (char *)"hierarchy_match_flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:autoBind", key_word_list, &param0, &param1, &param2))
                {
                    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "autoBind", 0, coerced_ptr, report_errors);
AnimControlCollection *param1_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControlCollection, 1, "autoBind", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        auto_bind(param0_this, *param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "autoBind() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "autoBind(non-const PandaNode root_node, non-const AnimControlCollection controls)\n"
          "autoBind(non-const PandaNode root_node, non-const AnimControlCollection controls, int hierarchy_match_flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_auto_bind_166_comment =
    "C++ Interface:\n"
    "autoBind(non-const PandaNode root_node, non-const AnimControlCollection controls)\n"
    "autoBind(non-const PandaNode root_node, non-const AnimControlCollection controls, int hierarchy_match_flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: auto_bind\n"
    "//  Description: Walks the scene graph or subgraph beginning at the\n"
    "//               indicated node, and attempts to bind any AnimBundles\n"
    "//               found to their matching PartBundles, when possible.\n"
    "//\n"
    "//               The list of all resulting AnimControls created is\n"
    "//               filled into controls.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: auto_bind\n"
    "//  Description: Walks the scene graph or subgraph beginning at the\n"
    "//               indicated node, and attempts to bind any AnimBundles\n"
    "//               found to their matching PartBundles, when possible.\n"
    "//\n"
    "//               The list of all resulting AnimControls created is\n"
    "//               filled into controls.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_auto_bind_166_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. AnimGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int AnimGroup::get_num_children(void) const
 *******************************************************************/
static PyObject *Dtool_AnimGroup_get_num_children_10(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AnimGroup::get_num_children(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChildren", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChildren"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimGroup*)local_this)->get_num_children();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChildren(const AnimGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_get_num_children_10_comment =
    "C++ Interface:\n"
    "getNumChildren(const AnimGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimGroup::get_num_children\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of child nodes of the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimGroup_get_num_children_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimGroup *AnimGroup::get_child(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimGroup_get_child_11(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AnimGroup *AnimGroup::get_child(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getChild", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getChild", &param1));
        if(!PyErr_Occurred())
        {
            AnimGroup *return_value = ((const AnimGroup*)local_this)->get_child((int)param1);
            if (return_value != (AnimGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChild(const AnimGroup this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_get_child_11_comment =
    "C++ Interface:\n"
    "getChild(const AnimGroup this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimGroup::get_child\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth child of the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimGroup_get_child_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimGroup *AnimGroup::find_child(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_AnimGroup_find_child_12(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AnimGroup *AnimGroup::find_child(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findChild", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findChild", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AnimGroup *return_value = ((const AnimGroup*)local_this)->find_child(basic_string<char>(param1_str, param1_len));
            if (return_value != (AnimGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findChild(const AnimGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_find_child_12_comment =
    "C++ Interface:\n"
    "findChild(const AnimGroup this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimGroup::find_child\n"
    "//       Access: Public\n"
    "//  Description: Returns the first descendant found with the indicated\n"
    "//               name, or NULL if no such descendant exists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimGroup_find_child_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimGroup::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimGroup_output_13(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimGroup::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimGroup.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimGroup*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AnimGroup this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_output_13_comment =
    "C++ Interface:\n"
    "output(const AnimGroup this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimGroup::output\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Writes a one-line description of the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimGroup_output_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimGroup::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_AnimGroup_write_14(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimGroup::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimGroup.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimGroup*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const AnimGroup this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_write_14_comment =
    "C++ Interface:\n"
    "write(const AnimGroup this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimGroup::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Writes a brief description of the group and all of\n"
    "//               its descendants.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimGroup_write_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimGroup_get_class_type_15(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_get_class_type_15_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimGroup_get_class_type_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimGroup.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const AnimGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const AnimGroup this)\n"
    "\n"
    "upcast from AnimGroup to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *AnimGroup::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_AnimGroup_upcast_to_Namable_6(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *AnimGroup::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimGroup.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const AnimGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimGroup_upcast_to_Namable_6_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const AnimGroup this)\n"
    "\n"
    "upcast from AnimGroup to Namable\n"
    "";
#else
static const char * Dtool_AnimGroup_upcast_to_Namable_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimGroup::AnimGroup(AnimGroup *parent, basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_AnimGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-AnimGroup::AnimGroup(AnimGroup *parent, basic_string< char > const &name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"parent", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:AnimGroup", key_word_list, &param0, &param1_str, &param1_len))
            {
                AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AnimGroup, 0, "AnimGroup.AnimGroup", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    AnimGroup *return_value = new AnimGroup(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimGroup,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimGroup(non-const AnimGroup parent, string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_AnimGroup_get_children(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumChildren", "getChild");
}
inline void  * Dtool_UpcastInterface_AnimGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimGroup)
    {
        printf("AnimGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimGroup * local_this = (AnimGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimGroup)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimGroup)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimGroup*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimGroup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimGroup*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimGroup*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimBundle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
 *******************************************************************/
static PyObject *Dtool_AnimBundle_copy_bundle_18(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":copyBundle", key_word_list));
        else
            (PyArg_Parse(args, ":copyBundle"));
        if(!PyErr_Occurred())
        {
            PointerTo< AnimBundle > return_value = ((const AnimBundle*)local_this)->copy_bundle();
            if (return_value != (AnimBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimBundle,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copyBundle(const AnimBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundle_copy_bundle_18_comment =
    "C++ Interface:\n"
    "copyBundle(const AnimBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimBundle::copy_bundle\n"
    "//       Access: Published\n"
    "//  Description: Returns a full copy of the bundle and its entire tree\n"
    "//               of nested AnimGroups.  However, the actual data\n"
    "//               stored in the leaves--that is, animation tables, such\n"
    "//               as those stored in an AnimChannelMatrixXfmTable--will\n"
    "//               be shared.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimBundle_copy_bundle_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AnimBundle::get_base_frame_rate(void) const
 *******************************************************************/
static PyObject *Dtool_AnimBundle_get_base_frame_rate_19(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AnimBundle::get_base_frame_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBaseFrameRate", key_word_list));
        else
            (PyArg_Parse(args, ":getBaseFrameRate"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AnimBundle*)local_this)->get_base_frame_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBaseFrameRate(const AnimBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundle_get_base_frame_rate_19_comment =
    "C++ Interface:\n"
    "getBaseFrameRate(const AnimBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimBundle::get_base_frame_rate\n"
    "//       Access: Public\n"
    "//  Description: Returns the ideal number of frames per second of the\n"
    "//               animation, when it is running at normal speed.  This\n"
    "//               may not be the same as the actual playing frame rate,\n"
    "//               as it might have been adjusted through\n"
    "//               set_play_rate() on the AnimControl object.  See\n"
    "//               AnimControl::get_effective_frame_rate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimBundle_get_base_frame_rate_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimBundle::get_num_frames(void) const
 *******************************************************************/
static PyObject *Dtool_AnimBundle_get_num_frames_20(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimBundle::get_num_frames(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFrames", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFrames"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimBundle*)local_this)->get_num_frames();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFrames(const AnimBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundle_get_num_frames_20_comment =
    "C++ Interface:\n"
    "getNumFrames(const AnimBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimBundle::get_num_frames\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of frames of animation, or 0 if\n"
    "//               the animation has no fixed number of frames.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimBundle_get_num_frames_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimBundle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimBundle_get_class_type_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimBundle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimBundle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundle_get_class_type_21_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimBundle_get_class_type_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AnimBundle::AnimBundle(basic_string< char > const &name, float fps, int num_frames)
 *******************************************************************/
int  Dtool_Init_AnimBundle(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline AnimBundle::AnimBundle(basic_string< char > const &name, float fps, int num_frames)
        char *param0_str; int param0_len;
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"name", (char *)"fps", (char *)"num_frames", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#di:AnimBundle", key_word_list, &param0_str, &param0_len, &param1, &param2))
        {
            AnimBundle *return_value = new AnimBundle(basic_string<char>(param0_str, param0_len), (float)param1, (int)param2);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimBundle,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimBundle(string name, float fps, int num_frames)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AnimBundle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimBundle)
    {
        printf("AnimBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimBundle * local_this = (AnimBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimBundle)
        return local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimBundle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimBundle)
        return from_this;
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimBundle*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimBundle*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimBundle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimBundle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimBundleNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline AnimBundle *AnimBundleNode::get_bundle(void) const
 *******************************************************************/
static PyObject *Dtool_AnimBundleNode_get_bundle_26(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimBundleNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimBundleNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AnimBundle *AnimBundleNode::get_bundle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBundle", key_word_list));
        else
            (PyArg_Parse(args, ":getBundle"));
        if(!PyErr_Occurred())
        {
            AnimBundle *return_value = ((const AnimBundleNode*)local_this)->get_bundle();
            if (return_value != (AnimBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBundle(const AnimBundleNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundleNode_get_bundle_26_comment =
    "C++ Interface:\n"
    "getBundle(const AnimBundleNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimBundleNode::get_bundle\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimBundleNode_get_bundle_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
 *******************************************************************/
static PyObject *Dtool_AnimBundleNode_find_anim_bundle_27(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findAnimBundle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:findAnimBundle", &param0));
            if(!PyErr_Occurred())
            {
                PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "AnimBundleNode.findAnimBundle", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    AnimBundle *return_value = AnimBundleNode::find_anim_bundle(param0_this);
                    if (return_value != (AnimBundle *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimBundle,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findAnimBundle(non-const PandaNode root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundleNode_find_anim_bundle_27_comment =
    "C++ Interface:\n"
    "findAnimBundle(non-const PandaNode root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimBundleNode::find_anim_bundle\n"
    "//       Access: Published, Static\n"
    "//  Description: Recursively walks the scene graph beginning at the\n"
    "//               indicated node (which need not be an AnimBundleNode),\n"
    "//               and returns the first AnimBundle found.  Returns NULL\n"
    "//               if no AnimBundle can be found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimBundleNode_find_anim_bundle_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimBundleNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimBundleNode_get_class_type_28(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimBundleNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimBundleNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimBundleNode_get_class_type_28_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimBundleNode_get_class_type_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AnimBundleNode::AnimBundleNode(basic_string< char > const &name, AnimBundle *bundle)
 *******************************************************************/
int  Dtool_Init_AnimBundleNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline AnimBundleNode::AnimBundleNode(basic_string< char > const &name, AnimBundle *bundle)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", (char *)"bundle", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:AnimBundleNode", key_word_list, &param0_str, &param0_len, &param1))
            {
                AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimBundle, 1, "AnimBundleNode.AnimBundleNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    AnimBundleNode *return_value = new AnimBundleNode(basic_string<char>(param0_str, param0_len), param1_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimBundleNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimBundleNode(string name, non-const AnimBundle bundle)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AnimBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimBundleNode)
    {
        printf("AnimBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimBundleNode * local_this = (AnimBundleNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimBundleNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimBundleNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimBundleNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimBundleNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (AnimBundleNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimBundleNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimBundleNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PartGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual bool PartGroup::is_character_joint(void) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_is_character_joint_37(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool PartGroup::is_character_joint(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isCharacterJoint", key_word_list));
        else
            (PyArg_Parse(args, ":isCharacterJoint"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartGroup*)local_this)->is_character_joint();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isCharacterJoint(const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_is_character_joint_37_comment =
    "C++ Interface:\n"
    "isCharacterJoint(const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::is_character_joint\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Returns true if this part is a CharacterJoint, false\n"
    "//               otherwise.  This is a tiny optimization over\n"
    "//               is_of_type(CharacterType::get_class_type()).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_is_character_joint_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PartGroup *PartGroup::make_copy(void) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_make_copy_38(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual PartGroup *PartGroup::make_copy(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            PartGroup *return_value = ((const PartGroup*)local_this)->make_copy();
            if (return_value != (PartGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_make_copy_38_comment =
    "C++ Interface:\n"
    "makeCopy(const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::make_copy\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Allocates and returns a new copy of the node.\n"
    "//               Children are not copied, but see copy_subgraph().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_make_copy_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartGroup *PartGroup::copy_subgraph(void) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_copy_subgraph_39(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PartGroup *PartGroup::copy_subgraph(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":copySubgraph", key_word_list));
        else
            (PyArg_Parse(args, ":copySubgraph"));
        if(!PyErr_Occurred())
        {
            PartGroup *return_value = ((const PartGroup*)local_this)->copy_subgraph();
            if (return_value != (PartGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copySubgraph(const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_copy_subgraph_39_comment =
    "C++ Interface:\n"
    "copySubgraph(const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::copy_subgraph\n"
    "//       Access: Public\n"
    "//  Description: Allocates and returns a new copy of this node and of\n"
    "//               all of its children.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_copy_subgraph_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PartGroup::get_num_children(void) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_get_num_children_40(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PartGroup::get_num_children(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChildren", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChildren"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PartGroup*)local_this)->get_num_children();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChildren(const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_get_num_children_40_comment =
    "C++ Interface:\n"
    "getNumChildren(const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::get_num_children\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of child nodes of the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_get_num_children_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartGroup *PartGroup::get_child(int n) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_get_child_41(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PartGroup *PartGroup::get_child(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getChild", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getChild", &param1));
        if(!PyErr_Occurred())
        {
            PartGroup *return_value = ((const PartGroup*)local_this)->get_child((int)param1);
            if (return_value != (PartGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChild(const PartGroup this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_get_child_41_comment =
    "C++ Interface:\n"
    "getChild(const PartGroup this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::get_child\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth child of the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_get_child_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartGroup *PartGroup::find_child(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_find_child_42(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PartGroup *PartGroup::find_child(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findChild", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findChild", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PartGroup *return_value = ((const PartGroup*)local_this)->find_child(basic_string<char>(param1_str, param1_len));
            if (return_value != (PartGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartGroup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findChild(const PartGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_find_child_42_comment =
    "C++ Interface:\n"
    "findChild(const PartGroup this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::find_child\n"
    "//       Access: Public\n"
    "//  Description: Returns the first descendant found with the indicated\n"
    "//               name, or NULL if no such descendant exists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_find_child_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartGroup::apply_freeze(TransformState const *transform)
 *******************************************************************/
static PyObject *Dtool_PartGroup_apply_freeze_43(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PartGroup::apply_freeze(TransformState const *transform)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:applyFreeze", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:applyFreeze", &param1));
            if(!PyErr_Occurred())
            {
                TransformState *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TransformState, 1, "PartGroup.applyFreeze", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->apply_freeze(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartGroup.applyFreeze() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyFreeze(non-const PartGroup this, const TransformState transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_apply_freeze_43_comment =
    "C++ Interface:\n"
    "applyFreeze(non-const PartGroup this, const TransformState transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::apply_freeze\n"
    "//       Access: Published\n"
    "//  Description: Freezes this particular joint so that it will always\n"
    "//               hold the specified transform.  Returns true if this\n"
    "//               is a joint that can be so frozen, false otherwise.\n"
    "//\n"
    "//               This is normally only called internally by\n"
    "//               PartBundle::freeze_joint(), but you may also call it\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_apply_freeze_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool PartGroup::apply_freeze_matrix(LVecBase3f const &pos, LVecBase3f const &hpr, LVecBase3f const &scale)
 *******************************************************************/
static PyObject *Dtool_PartGroup_apply_freeze_matrix_44(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool PartGroup::apply_freeze_matrix(LVecBase3f const &pos, LVecBase3f const &hpr, LVecBase3f const &scale)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"pos", (char *)"hpr", (char *)"scale", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:applyFreezeMatrix", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "PartGroup.applyFreezeMatrix", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "PartGroup.applyFreezeMatrix", 1, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "PartGroup.applyFreezeMatrix", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = (local_this)->apply_freeze_matrix(*param1_this, *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartGroup.applyFreezeMatrix() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyFreezeMatrix(non-const PartGroup this, const VBase3 pos, const VBase3 hpr, const VBase3 scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_apply_freeze_matrix_44_comment =
    "C++ Interface:\n"
    "applyFreezeMatrix(non-const PartGroup this, const VBase3 pos, const VBase3 hpr, const VBase3 scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::apply_freeze_matrix\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Freezes this particular joint so that it will always\n"
    "//               hold the specified transform.  Returns true if this\n"
    "//               is a joint that can be so frozen, false otherwise.\n"
    "//\n"
    "//               This is normally only called internally by\n"
    "//               PartBundle::freeze_joint(), but you may also call it\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_apply_freeze_matrix_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool PartGroup::apply_freeze_scalar(float value)
 *******************************************************************/
static PyObject *Dtool_PartGroup_apply_freeze_scalar_45(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool PartGroup::apply_freeze_scalar(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:applyFreezeScalar", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:applyFreezeScalar", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->apply_freeze_scalar((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartGroup.applyFreezeScalar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyFreezeScalar(non-const PartGroup this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_apply_freeze_scalar_45_comment =
    "C++ Interface:\n"
    "applyFreezeScalar(non-const PartGroup this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::apply_freeze_scalar\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Freezes this particular joint so that it will always\n"
    "//               hold the specified transform.  Returns true if this\n"
    "//               is a joint that can be so frozen, false otherwise.\n"
    "//\n"
    "//               This is normally only called internally by\n"
    "//               PartBundle::freeze_joint(), but you may also call it\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_apply_freeze_scalar_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool PartGroup::apply_control(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_PartGroup_apply_control_46(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual bool PartGroup::apply_control(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:applyControl", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:applyControl", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "PartGroup.applyControl", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->apply_control(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartGroup.applyControl() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyControl(non-const PartGroup this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_apply_control_46_comment =
    "C++ Interface:\n"
    "applyControl(non-const PartGroup this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::apply_control\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Specifies a node to influence this particular joint\n"
    "//               so that it will always hold the node's transform.\n"
    "//               Returns true if this is a joint that can be so\n"
    "//               controlled, false otherwise.\n"
    "//\n"
    "//               This is normally only called internally by\n"
    "//               PartBundle::control_joint(), but you may also call it\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_apply_control_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool PartGroup::clear_forced_channel(void)
 *******************************************************************/
static PyObject *Dtool_PartGroup_clear_forced_channel_47(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual bool PartGroup::clear_forced_channel(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearForcedChannel", key_word_list));
        else
            (PyArg_Parse(args, ":clearForcedChannel"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->clear_forced_channel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartGroup.clearForcedChannel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearForcedChannel(non-const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_clear_forced_channel_47_comment =
    "C++ Interface:\n"
    "clearForcedChannel(non-const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::clear_forced_channel\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Undoes the effect of a previous call to\n"
    "//               apply_freeze() or apply_control().  Returns true if\n"
    "//               the joint was modified, false otherwise.\n"
    "//\n"
    "//               This is normally only called internally by\n"
    "//               PartBundle::release_joint(), but you may also call it\n"
    "//               directly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_clear_forced_channel_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_get_forced_channel_48(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForcedChannel", key_word_list));
        else
            (PyArg_Parse(args, ":getForcedChannel"));
        if(!PyErr_Occurred())
        {
            AnimChannelBase *return_value = ((const PartGroup*)local_this)->get_forced_channel();
            if (return_value != (AnimChannelBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimChannelBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForcedChannel(const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_get_forced_channel_48_comment =
    "C++ Interface:\n"
    "getForcedChannel(const PartGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::get_forced_channel\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the AnimChannelBase that has been forced to\n"
    "//               this joint by a previous call to apply_freeze() or\n"
    "//               apply_control(), or NULL if no such channel has been\n"
    "//               applied.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_get_forced_channel_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PartGroup::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_write_49(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void PartGroup::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PartGroup.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PartGroup*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const PartGroup this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_write_49_comment =
    "C++ Interface:\n"
    "write(const PartGroup this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::write\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Writes a brief description of the group and all of\n"
    "//               its descendants.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_write_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PartGroup::write_with_value(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_PartGroup_write_with_value_50(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void PartGroup::write_with_value(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:writeWithValue", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PartGroup.writeWithValue", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PartGroup*)local_this)->write_with_value(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeWithValue(const PartGroup this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_write_with_value_50_comment =
    "C++ Interface:\n"
    "writeWithValue(const PartGroup this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartGroup::write_with_value\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Writes a brief description of the group, showing its\n"
    "//               current value, and that of all of its descendants.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartGroup_write_with_value_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PartGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PartGroup_get_class_type_51(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PartGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PartGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_get_class_type_51_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PartGroup_get_class_type_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_31(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartGroup.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_31_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const PartGroup this)\n"
    "\n"
    "upcast from PartGroup to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *PartGroup::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_PartGroup_upcast_to_Namable_33(PyObject *self, PyObject *args,PyObject *kwds) {
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *PartGroup::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartGroup.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const PartGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartGroup_upcast_to_Namable_33_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const PartGroup this)\n"
    "\n"
    "upcast from PartGroup to Namable\n"
    "";
#else
static const char * Dtool_PartGroup_upcast_to_Namable_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartGroup::PartGroup(PartGroup *parent, basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PartGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PartGroup::PartGroup(PartGroup *parent, basic_string< char > const &name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"parent", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:PartGroup", key_word_list, &param0, &param1_str, &param1_len))
            {
                PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PartGroup, 0, "PartGroup.PartGroup", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PartGroup *return_value = new PartGroup(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PartGroup,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PartGroup(non-const PartGroup parent, string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PartGroup_get_children(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumChildren", "getChild");
}
inline void  * Dtool_UpcastInterface_PartGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PartGroup)
    {
        printf("PartGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PartGroup * local_this = (PartGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PartGroup)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PartGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PartGroup)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PartGroup*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PartGroup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PartGroup*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PartGroup*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PartGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimControl 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControl::is_pending(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_is_pending_62(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnimControl::is_pending(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPending", key_word_list));
        else
            (PyArg_Parse(args, ":isPending"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnimControl*)local_this)->is_pending();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPending(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_is_pending_62_comment =
    "C++ Interface:\n"
    "isPending(const AnimControl this)\n"
    "\n"
    "// Filename: animControl.I\n"
    "// Created by:  drose (19Feb99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::is_pending\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the AnimControl is being bound\n"
    "//               asynchronously, and has not yet finished.  If this is\n"
    "//               true, the AnimControl's interface is still available\n"
    "//               and will be perfectly useful (though get_anim() might\n"
    "//               return NULL), but nothing visible will happen\n"
    "//               immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_is_pending_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControl::wait_pending(void)
 *******************************************************************/
static PyObject *Dtool_AnimControl_wait_pending_63(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimControl::wait_pending(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":waitPending", key_word_list));
        else
            (PyArg_Parse(args, ":waitPending"));
        if(!PyErr_Occurred())
        {
            (local_this)->wait_pending();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControl.waitPending() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "waitPending(non-const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_wait_pending_63_comment =
    "C++ Interface:\n"
    "waitPending(non-const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::wait_pending\n"
    "//       Access: Published\n"
    "//  Description: Blocks the current thread until the AnimControl has\n"
    "//               finished loading and is fully bound.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_wait_pending_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControl::has_anim(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_has_anim_64(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnimControl::has_anim(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasAnim", key_word_list));
        else
            (PyArg_Parse(args, ":hasAnim"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnimControl*)local_this)->has_anim();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasAnim(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_has_anim_64_comment =
    "C++ Interface:\n"
    "hasAnim(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::has_anim\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the AnimControl was successfully\n"
    "//               loaded, or false if there was a problem.  This may\n"
    "//               return false while is_pending() is true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_has_anim_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControl::set_pending_done_event(basic_string< char > const &done_event)
 *******************************************************************/
static PyObject *Dtool_AnimControl_set_pending_done_event_65(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimControl::set_pending_done_event(basic_string< char > const &done_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"done_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPendingDoneEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPendingDoneEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_pending_done_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControl.setPendingDoneEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPendingDoneEvent(non-const AnimControl this, string done_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_set_pending_done_event_65_comment =
    "C++ Interface:\n"
    "setPendingDoneEvent(non-const AnimControl this, string done_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::set_pending_done_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies an event name that will be thrown when the\n"
    "//               AnimControl is finished binding asynchronously.  If\n"
    "//               the AnimControl has already finished binding, the\n"
    "//               event will be thrown immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_set_pending_done_event_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > AnimControl::get_pending_done_event(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_pending_done_event_66(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > AnimControl::get_pending_done_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPendingDoneEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getPendingDoneEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AnimControl*)local_this)->get_pending_done_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPendingDoneEvent(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_pending_done_event_66_comment =
    "C++ Interface:\n"
    "getPendingDoneEvent(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_pending_done_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be thrown when the\n"
    "//               AnimControl is finished binding asynchronously.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_pending_done_event_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartBundle *AnimControl::get_part(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_part_67(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PartBundle *AnimControl::get_part(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPart", key_word_list));
        else
            (PyArg_Parse(args, ":getPart"));
        if(!PyErr_Occurred())
        {
            PartBundle *return_value = ((const AnimControl*)local_this)->get_part();
            if (return_value != (PartBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPart(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_part_67_comment =
    "C++ Interface:\n"
    "getPart(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_part\n"
    "//       Access: Published\n"
    "//  Description: Returns the PartBundle bound in with this\n"
    "//               AnimControl.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_part_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AnimBundle *AnimControl::get_anim(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_anim_68(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AnimBundle *AnimControl::get_anim(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnim", key_word_list));
        else
            (PyArg_Parse(args, ":getAnim"));
        if(!PyErr_Occurred())
        {
            AnimBundle *return_value = ((const AnimControl*)local_this)->get_anim();
            if (return_value != (AnimBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnim(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_anim_68_comment =
    "C++ Interface:\n"
    "getAnim(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_anim\n"
    "//       Access: Published\n"
    "//  Description: Returns the AnimBundle bound in with this\n"
    "//               AnimControl.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_anim_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimControl::get_channel_index(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_channel_index_69(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimControl::get_channel_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChannelIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getChannelIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimControl*)local_this)->get_channel_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChannelIndex(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_channel_index_69_comment =
    "C++ Interface:\n"
    "getChannelIndex(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_channel_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the particular channel index associated with\n"
    "//               this AnimControl.  This channel index is the slot on\n"
    "//               which each AnimGroup is bound to its associated\n"
    "//               PartGroup, for each joint in the animation.\n"
    "//\n"
    "//               It will be true that\n"
    "//               get_part()->find_child(\"n\")->get_bound(get_channel_index())\n"
    "//               == get_anim()->find_child(\"n\"), for each joint \"n\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_channel_index_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitArray const &AnimControl::get_bound_joints(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_bound_joints_70(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BitArray const &AnimControl::get_bound_joints(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBoundJoints", key_word_list));
        else
            (PyArg_Parse(args, ":getBoundJoints"));
        if(!PyErr_Occurred())
        {
            BitArray const *return_value = &(((const AnimControl*)local_this)->get_bound_joints());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitArray,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBoundJoints(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_bound_joints_70_comment =
    "C++ Interface:\n"
    "getBoundJoints(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_bound_joints\n"
    "//       Access: Published\n"
    "//  Description: Returns the subset of joints controlled by this\n"
    "//               AnimControl.  Most of the time, this will be\n"
    "//               BitArray::all_on(), for a normal full-body animation.\n"
    "//               For a subset animation, however, this will be just a\n"
    "//               subset of those bits, corresponding to the set of\n"
    "//               joints and sliders actually bound (as enumerated by\n"
    "//               bind_hierarchy() in depth-first LIFO order).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_bound_joints_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimControl::set_anim_model(PandaNode *model)
 *******************************************************************/
static PyObject *Dtool_AnimControl_set_anim_model_71(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AnimControl::set_anim_model(PandaNode *model)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"model", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnimModel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAnimModel", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "AnimControl.setAnimModel", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_anim_model(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControl.setAnimModel() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimModel(non-const AnimControl this, non-const PandaNode model)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_set_anim_model_71_comment =
    "C++ Interface:\n"
    "setAnimModel(non-const AnimControl this, non-const PandaNode model)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::set_anim_model\n"
    "//       Access: Published\n"
    "//  Description: Associates the indicated PandaNode with the\n"
    "//               AnimControl.  By convention, this node represents the\n"
    "//               root node of the model file that corresponds to this\n"
    "//               AnimControl's animation file, though nothing in this\n"
    "//               code makes this assumption or indeed does anything\n"
    "//               with this node.\n"
    "//\n"
    "//               The purpose of this is simply to allow the\n"
    "//               AnimControl to keep a reference count on the\n"
    "//               ModelRoot node that generated it, so that the model\n"
    "//               will not disappear from the model pool until it is no\n"
    "//               longer referenced.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_set_anim_model_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *AnimControl::get_anim_model(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_anim_model_72(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *AnimControl::get_anim_model(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimModel", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimModel"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const AnimControl*)local_this)->get_anim_model();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimModel(const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_anim_model_72_comment =
    "C++ Interface:\n"
    "getAnimModel(const AnimControl this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::get_anim_model\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the pointer set via set_anim_model().  See\n"
    "//               set_anim_model().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_get_anim_model_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimControl::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimControl_output_73(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimControl::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimControl.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimControl*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AnimControl this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_output_73_comment =
    "C++ Interface:\n"
    "output(const AnimControl this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControl::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControl_output_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimControl::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimControl_get_class_type_74(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimControl::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimControl::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_get_class_type_74_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimControl_get_class_type_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_AnimControl_upcast_to_TypedReferenceCount_54(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControl.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_upcast_to_TypedReferenceCount_54_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const AnimControl this)\n"
    "\n"
    "upcast from AnimControl to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_AnimControl_upcast_to_TypedReferenceCount_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimInterface *AnimControl::upcast_to_AnimInterface(void)
 *******************************************************************/
static PyObject *Dtool_AnimControl_upcast_to_AnimInterface_57(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AnimInterface *AnimControl::upcast_to_AnimInterface(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToAnimInterface", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToAnimInterface"));
        if(!PyErr_Occurred())
        {
            AnimInterface *return_value = (AnimInterface *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AnimInterface,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControl.upcastToAnimInterface() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToAnimInterface(non-const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_upcast_to_AnimInterface_57_comment =
    "C++ Interface:\n"
    "upcastToAnimInterface(non-const AnimControl this)\n"
    "\n"
    "upcast from AnimControl to AnimInterface\n"
    "";
#else
static const char * Dtool_AnimControl_upcast_to_AnimInterface_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *AnimControl::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_AnimControl_upcast_to_Namable_59(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *AnimControl::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControl.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const AnimControl this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControl_upcast_to_Namable_59_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const AnimControl this)\n"
    "\n"
    "upcast from AnimControl to Namable\n"
    "";
#else
static const char * Dtool_AnimControl_upcast_to_Namable_59_comment = NULL;
#endif

int  Dtool_Init_AnimControl(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimControl)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimControl(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimControl)
    {
        printf("AnimControl ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimControl * local_this = (AnimControl *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimControl)
        return local_this;
    if(requested_type == &Dtool_AnimInterface)
        return ( AnimInterface *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimControl(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimControl)
        return from_this;
    if(from_type == &Dtool_AnimInterface)
    {
          AnimInterface* other_this = (AnimInterface*)from_this;
          return (AnimControl*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimControl*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimControl*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimControl*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AnimControl*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannelBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle AnimChannelBase::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelBase_get_type_76(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle AnimChannelBase::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const AnimChannelBase*)local_this)->get_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const AnimChannelBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelBase_get_type_76_comment =
    "C++ Interface:\n"
    "getType(const AnimChannelBase this)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelBase_get_type_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimChannelBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelBase_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimChannelBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimChannelBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelBase_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelBase_get_class_type_77_comment = NULL;
#endif

int  Dtool_Init_AnimChannelBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannelBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannelBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannelBase)
    {
        printf("AnimChannelBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannelBase * local_this = (AnimChannelBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannelBase)
        return local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannelBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannelBase)
        return from_this;
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannelBase*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannelBase*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannelBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannelBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannelBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannelBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannel< ACMatrixSwitchType > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4f &value) = 0
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_80(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4f &value) = 0
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getValue", key_word_list, &param1, &param2))
            {
                LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "AnimChannel.getValue", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_value((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getValue() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const AnimChannel this, int frame, non-const Mat4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_80_comment =
    "C++ Interface:\n"
    "getValue(non-const AnimChannel this, int frame, non-const Mat4 value)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4f &value)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_81(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4f &value)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"value", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getValueNoScaleShear", key_word_list, &param1, &param2))
            {
                LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "AnimChannel.getValueNoScaleShear", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_value_no_scale_shear((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getValueNoScaleShear() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueNoScaleShear(non-const AnimChannel this, int frame, non-const Mat4 value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_81_comment =
    "C++ Interface:\n"
    "getValueNoScaleShear(non-const AnimChannel this, int frame, non-const Mat4 value)\n"
    "\n"
    "// These transform-component methods only have meaning for matrix types.\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3f &scale)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_82(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3f &scale)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"scale", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getScale", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getScale", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_scale((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScale(non-const AnimChannel this, int frame, non-const VBase3 scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_scale_82_comment =
    "C++ Interface:\n"
    "getScale(non-const AnimChannel this, int frame, non-const VBase3 scale)\n"
    "\n"
    "// These transform-component methods only have meaning for matrix types.\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_scale_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3f &hpr)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_83(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3f &hpr)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getHpr", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getHpr", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_hpr((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(non-const AnimChannel this, int frame, non-const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_83_comment =
    "C++ Interface:\n"
    "getHpr(non-const AnimChannel this, int frame, non-const VBase3 hpr)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternionf &quat)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_84(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternionf &quat)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"quat", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getQuat", key_word_list, &param1, &param2))
            {
                LQuaternionf *param2_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LQuaternionf, 2, "AnimChannel.getQuat", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_quat((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getQuat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuat(non-const AnimChannel this, int frame, non-const Quat quat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_quat_84_comment =
    "C++ Interface:\n"
    "getQuat(non-const AnimChannel this, int frame, non-const Quat quat)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_quat_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3f &pos)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_85(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3f &pos)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"pos", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getPos", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getPos", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_pos((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(non-const AnimChannel this, int frame, non-const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_pos_85_comment =
    "C++ Interface:\n"
    "getPos(non-const AnimChannel this, int frame, non-const VBase3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_pos_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3f &shear)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_86(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3f &shear)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"shear", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getShear", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getShear", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_shear((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getShear() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShear(non-const AnimChannel this, int frame, non-const VBase3 shear)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_shear_86_comment =
    "C++ Interface:\n"
    "getShear(non-const AnimChannel this, int frame, non-const VBase3 shear)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_shear_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle ::AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_87(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle ::AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueType", key_word_list));
        else
            (PyArg_Parse(args, ":getValueType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const AnimChannel< ACMatrixSwitchType >*)local_this)->get_value_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueType(const AnimChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_87_comment =
    "C++ Interface:\n"
    "getValueType(const AnimChannel this)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::AnimChannel< ACMatrixSwitchType >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_88(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::AnimChannel< ACMatrixSwitchType >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::AnimChannel< ACMatrixSwitchType >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_88_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_88_comment = NULL;
#endif

int  Dtool_Init_AnimChannel_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannel< ACMatrixSwitchType >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannel_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannel_ACMatrixSwitchType)
    {
        printf("AnimChannel_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannel< ACMatrixSwitchType > * local_this = (AnimChannel< ACMatrixSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannel_ACMatrixSwitchType)
        return local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannel_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannel_ACMatrixSwitchType)
        return from_this;
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannel< ACMatrixSwitchType >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannel< ACScalarSwitchType > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3f &scale)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_scale_92(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3f &scale)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"scale", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getScale", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getScale", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_scale((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScale(non-const AnimChannel this, int frame, non-const VBase3 scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_scale_92_comment =
    "C++ Interface:\n"
    "getScale(non-const AnimChannel this, int frame, non-const VBase3 scale)\n"
    "\n"
    "// These transform-component methods only have meaning for matrix types.\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_scale_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3f &hpr)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_93(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3f &hpr)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getHpr", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getHpr", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_hpr((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(non-const AnimChannel this, int frame, non-const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_hpr_93_comment =
    "C++ Interface:\n"
    "getHpr(non-const AnimChannel this, int frame, non-const VBase3 hpr)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_hpr_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternionf &quat)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_quat_94(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternionf &quat)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"quat", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getQuat", key_word_list, &param1, &param2))
            {
                LQuaternionf *param2_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LQuaternionf, 2, "AnimChannel.getQuat", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_quat((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getQuat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuat(non-const AnimChannel this, int frame, non-const Quat quat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_quat_94_comment =
    "C++ Interface:\n"
    "getQuat(non-const AnimChannel this, int frame, non-const Quat quat)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_quat_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3f &pos)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_pos_95(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3f &pos)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"pos", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getPos", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getPos", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_pos((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(non-const AnimChannel this, int frame, non-const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_pos_95_comment =
    "C++ Interface:\n"
    "getPos(non-const AnimChannel this, int frame, non-const VBase3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_pos_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ::AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3f &shear)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_shear_96(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void ::AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3f &shear)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"frame", (char *)"shear", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:getShear", key_word_list, &param1, &param2))
            {
                LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "AnimChannel.getShear", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->get_shear((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannel.getShear() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShear(non-const AnimChannel this, int frame, non-const VBase3 shear)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_shear_96_comment =
    "C++ Interface:\n"
    "getShear(non-const AnimChannel this, int frame, non-const VBase3 shear)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_shear_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle ::AnimChannel< ACScalarSwitchType >::get_value_type(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_97(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannel< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannel_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle ::AnimChannel< ACScalarSwitchType >::get_value_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueType", key_word_list));
        else
            (PyArg_Parse(args, ":getValueType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const AnimChannel< ACScalarSwitchType >*)local_this)->get_value_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueType(const AnimChannel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_value_type_97_comment =
    "C++ Interface:\n"
    "getValueType(const AnimChannel this)\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_value_type_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::AnimChannel< ACScalarSwitchType >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_98(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::AnimChannel< ACScalarSwitchType >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::AnimChannel< ACScalarSwitchType >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_class_type_98_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannel_ACScalarSwitchType_get_class_type_98_comment = NULL;
#endif

int  Dtool_Init_AnimChannel_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannel< ACScalarSwitchType >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannel_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannel_ACScalarSwitchType)
    {
        printf("AnimChannel_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannel< ACScalarSwitchType > * local_this = (AnimChannel< ACScalarSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannel_ACScalarSwitchType)
        return local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannel_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannel_ACScalarSwitchType)
        return from_this;
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannel< ACScalarSwitchType >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannelMatrixDynamic 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AnimChannelMatrixDynamic::set_value(LMatrix4f const &value)
 * void AnimChannelMatrixDynamic::set_value(TransformState const *value)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_100(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void AnimChannelMatrixDynamic::set_value(LMatrix4f const &value)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValue", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "AnimChannelMatrixDynamic.setValue", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void AnimChannelMatrixDynamic::set_value(TransformState const *value)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValue", &param1));
            if(!PyErr_Occurred())
            {
                TransformState *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TransformState, 1, "AnimChannelMatrixDynamic.setValue", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const AnimChannelMatrixDynamic this, const Mat4 value)\n"
          "setValue(non-const AnimChannelMatrixDynamic this, const TransformState value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixDynamic_set_value_100_comment =
    "C++ Interface:\n"
    "setValue(non-const AnimChannelMatrixDynamic this, const Mat4 value)\n"
    "setValue(non-const AnimChannelMatrixDynamic this, const TransformState value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixDynamic::set_value\n"
    "//       Access: Published\n"
    "//  Description: Explicitly sets the matrix value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixDynamic::set_value\n"
    "//       Access: Published\n"
    "//  Description: Explicitly sets the matrix value, using the indicated\n"
    "//               TransformState object as a convenience.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixDynamic_set_value_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_node_101(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValueNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValueNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "AnimChannelMatrixDynamic.setValueNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannelMatrixDynamic.setValueNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValueNode(non-const AnimChannelMatrixDynamic this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixDynamic_set_value_node_101_comment =
    "C++ Interface:\n"
    "setValueNode(non-const AnimChannelMatrixDynamic this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixDynamic::set_value_node\n"
    "//       Access: Published\n"
    "//  Description: Specifies a node whose transform will be queried each\n"
    "//               frame to implicitly specify the transform of this\n"
    "//               joint.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixDynamic_set_value_node_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_transform_102(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueTransform", key_word_list));
        else
            (PyArg_Parse(args, ":getValueTransform"));
        if(!PyErr_Occurred())
        {
            TransformState const *return_value = ((const AnimChannelMatrixDynamic*)local_this)->get_value_transform();
            if (return_value != (TransformState const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TransformState,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueTransform(const AnimChannelMatrixDynamic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixDynamic_get_value_transform_102_comment =
    "C++ Interface:\n"
    "getValueTransform(const AnimChannelMatrixDynamic this)\n"
    "\n"
    "// Filename: animChannelMatrixDynamic.I\n"
    "// Created by:  drose (20Oct03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixDynamic::get_value_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns the explicit TransformState value that was\n"
    "//               set via set_value(), if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixDynamic_get_value_transform_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_node_103(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueNode", key_word_list));
        else
            (PyArg_Parse(args, ":getValueNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const AnimChannelMatrixDynamic*)local_this)->get_value_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueNode(const AnimChannelMatrixDynamic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixDynamic_get_value_node_103_comment =
    "C++ Interface:\n"
    "getValueNode(const AnimChannelMatrixDynamic this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixDynamic::get_value_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that was set via set_value_node(),\n"
    "//               if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixDynamic_get_value_node_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixDynamic_get_class_type_104(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimChannelMatrixDynamic::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixDynamic_get_class_type_104_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixDynamic_get_class_type_104_comment = NULL;
#endif

int  Dtool_Init_AnimChannelMatrixDynamic(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannelMatrixDynamic)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannelMatrixDynamic(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannelMatrixDynamic)
    {
        printf("AnimChannelMatrixDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannelMatrixDynamic * local_this = (AnimChannelMatrixDynamic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannelMatrixDynamic)
        return local_this;
    if(requested_type == &Dtool_AnimChannel_ACMatrixSwitchType)
        return ( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannelMatrixDynamic(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannelMatrixDynamic)
        return from_this;
    if(from_type == &Dtool_AnimChannel_ACMatrixSwitchType)
    {
          AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannelMatrixDynamic*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannelMatrixXfmTable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_is_valid_id_108(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
        int param0;
        static char * key_word_list[] = {(char *)"table_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isValidId", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:isValidId", &param0));
        if(!PyErr_Occurred())
        {
            bool return_value = AnimChannelMatrixXfmTable::is_valid_id((char)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValidId(int table_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_is_valid_id_108_comment =
    "C++ Interface:\n"
    "isValidId(int table_id)\n"
    "\n"
    "// Filename: animChannelMatrixXfmTable.I\n"
    "// Created by:  drose (21Feb99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::is_valid_id\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns true if the given letter is one of the nine\n"
    "//               valid table id's.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_is_valid_id_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimChannelMatrixXfmTable::set_table(char table_id, ConstPointerToArray< float > const &table)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_set_table_109(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixXfmTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixXfmTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimChannelMatrixXfmTable::set_table(char table_id, ConstPointerToArray< float > const &table)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"table_id", (char *)"table", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setTable", key_word_list, &param1, &param2))
            {
                ConstPointerToArray< float > *param2_this = (ConstPointerToArray< float > *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ConstPointerToArray_float, 2, "AnimChannelMatrixXfmTable.setTable", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_table((char)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannelMatrixXfmTable.setTable() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTable(non-const AnimChannelMatrixXfmTable this, int table_id, const ConstPointerToArray table)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_set_table_109_comment =
    "C++ Interface:\n"
    "setTable(non-const AnimChannelMatrixXfmTable this, int table_id, const ConstPointerToArray table)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::set_table\n"
    "//       Access: Public\n"
    "//  Description: Assigns the indicated table.  table_id is one of 'i',\n"
    "//               'j', 'k', for scale, 'a', 'b', 'c' for shear, 'h',\n"
    "//               'p', 'r', for rotation, and 'x', 'y', 'z', for\n"
    "//               translation.  The new table must have either zero,\n"
    "//               one, or get_num_frames() frames.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_set_table_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerToArray< float > AnimChannelMatrixXfmTable::get_table(char table_id) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_table_110(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixXfmTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixXfmTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerToArray< float > AnimChannelMatrixXfmTable::get_table(char table_id) const
        int param1;
        static char * key_word_list[] = {(char *)"table_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTable", &param1));
        if(!PyErr_Occurred())
        {
            ConstPointerToArray< float > result = ((const AnimChannelMatrixXfmTable*)local_this)->get_table((char)param1);
            ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConstPointerToArray_float,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTable(const AnimChannelMatrixXfmTable this, int table_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_get_table_110_comment =
    "C++ Interface:\n"
    "getTable(const AnimChannelMatrixXfmTable this, int table_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::get_table\n"
    "//       Access: Public\n"
    "//  Description: Returns a pointer to the indicated subtable's data,\n"
    "//               if it exists, or NULL if it does not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_get_table_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimChannelMatrixXfmTable::clear_all_tables(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_111(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixXfmTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixXfmTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimChannelMatrixXfmTable::clear_all_tables(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAllTables", key_word_list));
        else
            (PyArg_Parse(args, ":clearAllTables"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_all_tables();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimChannelMatrixXfmTable.clearAllTables() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAllTables(non-const AnimChannelMatrixXfmTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_clear_all_tables_111_comment =
    "C++ Interface:\n"
    "clearAllTables(non-const AnimChannelMatrixXfmTable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::clear_all_tables\n"
    "//       Access: Published\n"
    "//  Description: Removes all the tables from the channel, and resets\n"
    "//               it to its initial state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_clear_all_tables_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_has_table_112(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixXfmTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixXfmTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
        int param1;
        static char * key_word_list[] = {(char *)"table_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasTable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasTable", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnimChannelMatrixXfmTable*)local_this)->has_table((char)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTable(const AnimChannelMatrixXfmTable this, int table_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_has_table_112_comment =
    "C++ Interface:\n"
    "hasTable(const AnimChannelMatrixXfmTable this, int table_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::has_table\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated subtable has been\n"
    "//               assigned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_has_table_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_table_113(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelMatrixXfmTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelMatrixXfmTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
        int param1;
        static char * key_word_list[] = {(char *)"table_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:clearTable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:clearTable", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_table((char)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimChannelMatrixXfmTable.clearTable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTable(non-const AnimChannelMatrixXfmTable this, int table_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_clear_table_113_comment =
    "C++ Interface:\n"
    "clearTable(non-const AnimChannelMatrixXfmTable this, int table_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelMatrixXfmTable::clear_table\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated table from the definition.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_clear_table_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_class_type_114(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimChannelMatrixXfmTable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelMatrixXfmTable_get_class_type_114_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelMatrixXfmTable_get_class_type_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_AnimChannelMatrixXfmTable(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, basic_string< char > const &name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"parent", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:AnimChannelMatrixXfmTable", key_word_list, &param0, &param1_str, &param1_len))
            {
                AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AnimGroup, 0, "AnimChannelMatrixXfmTable.AnimChannelMatrixXfmTable", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    AnimChannelMatrixXfmTable *return_value = new AnimChannelMatrixXfmTable(param0_this, basic_string<char>(param1_str, param1_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimChannelMatrixXfmTable,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimChannelMatrixXfmTable(non-const AnimGroup parent, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AnimChannelMatrixXfmTable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannelMatrixXfmTable)
    {
        printf("AnimChannelMatrixXfmTable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannelMatrixXfmTable * local_this = (AnimChannelMatrixXfmTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannelMatrixXfmTable)
        return local_this;
    if(requested_type == &Dtool_AnimChannel_ACMatrixSwitchType)
        return ( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACMatrixSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannelMatrixXfmTable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannelMatrixXfmTable)
        return from_this;
    if(from_type == &Dtool_AnimChannel_ACMatrixSwitchType)
    {
          AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannelMatrixXfmTable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannelScalarDynamic 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AnimChannelScalarDynamic::set_value(float value)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_116(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimChannelScalarDynamic::set_value(float value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimChannelScalarDynamic.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const AnimChannelScalarDynamic this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarDynamic_set_value_116_comment =
    "C++ Interface:\n"
    "setValue(non-const AnimChannelScalarDynamic this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarDynamic::set_value\n"
    "//       Access: Published\n"
    "//  Description: Explicitly sets the value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarDynamic_set_value_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_node_117(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarDynamic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarDynamic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValueNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValueNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "AnimChannelScalarDynamic.setValueNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannelScalarDynamic.setValueNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValueNode(non-const AnimChannelScalarDynamic this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarDynamic_set_value_node_117_comment =
    "C++ Interface:\n"
    "setValueNode(non-const AnimChannelScalarDynamic this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarDynamic::set_value_node\n"
    "//       Access: Published\n"
    "//  Description: Specifies a node whose transform will be queried each\n"
    "//               frame to implicitly specify the transform of this\n"
    "//               joint.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarDynamic_set_value_node_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarDynamic_get_class_type_118(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimChannelScalarDynamic::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarDynamic_get_class_type_118_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelScalarDynamic_get_class_type_118_comment = NULL;
#endif

int  Dtool_Init_AnimChannelScalarDynamic(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannelScalarDynamic)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannelScalarDynamic(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannelScalarDynamic)
    {
        printf("AnimChannelScalarDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannelScalarDynamic * local_this = (AnimChannelScalarDynamic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannelScalarDynamic)
        return local_this;
    if(requested_type == &Dtool_AnimChannel_ACScalarSwitchType)
        return ( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannelScalarDynamic(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannelScalarDynamic)
        return from_this;
    if(from_type == &Dtool_AnimChannel_ACScalarSwitchType)
    {
          AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannelScalarDynamic*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimChannelScalarTable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AnimChannelScalarTable::set_table(ConstPointerToArray< float > const &table)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarTable_set_table_121(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimChannelScalarTable::set_table(ConstPointerToArray< float > const &table)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"table", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTable", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTable", &param1));
            if(!PyErr_Occurred())
            {
                ConstPointerToArray< float > *param1_this = (ConstPointerToArray< float > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ConstPointerToArray_float, 1, "AnimChannelScalarTable.setTable", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_table(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimChannelScalarTable.setTable() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTable(non-const AnimChannelScalarTable this, const ConstPointerToArray table)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarTable_set_table_121_comment =
    "C++ Interface:\n"
    "setTable(non-const AnimChannelScalarTable this, const ConstPointerToArray table)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarTable::set_table\n"
    "//       Access: Public\n"
    "//  Description: Assigns the data table.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarTable_set_table_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerToArray< float > AnimChannelScalarTable::get_table(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarTable_get_table_122(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerToArray< float > AnimChannelScalarTable::get_table(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTable", key_word_list));
        else
            (PyArg_Parse(args, ":getTable"));
        if(!PyErr_Occurred())
        {
            ConstPointerToArray< float > result = ((const AnimChannelScalarTable*)local_this)->get_table();
            ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConstPointerToArray_float,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTable(const AnimChannelScalarTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarTable_get_table_122_comment =
    "C++ Interface:\n"
    "getTable(const AnimChannelScalarTable this)\n"
    "\n"
    "// Filename: animChannelScalarTable.I\n"
    "// Created by:  drose (22Feb99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarTable::get_table\n"
    "//       Access: Public\n"
    "//  Description: Returns a pointer to the table's data,\n"
    "//               if it exists, or NULL if it does not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarTable_get_table_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimChannelScalarTable::has_table(void) const
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarTable_has_table_123(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AnimChannelScalarTable::has_table(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasTable", key_word_list));
        else
            (PyArg_Parse(args, ":hasTable"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AnimChannelScalarTable*)local_this)->has_table();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTable(const AnimChannelScalarTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarTable_has_table_123_comment =
    "C++ Interface:\n"
    "hasTable(const AnimChannelScalarTable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarTable::has_table\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the data table has been assigned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarTable_has_table_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AnimChannelScalarTable::clear_table(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarTable_clear_table_124(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimChannelScalarTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimChannelScalarTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AnimChannelScalarTable::clear_table(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTable", key_word_list));
        else
            (PyArg_Parse(args, ":clearTable"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_table();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimChannelScalarTable.clearTable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTable(non-const AnimChannelScalarTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarTable_clear_table_124_comment =
    "C++ Interface:\n"
    "clearTable(non-const AnimChannelScalarTable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimChannelScalarTable::clear_table\n"
    "//       Access: Published\n"
    "//  Description: Empties the data table.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimChannelScalarTable_clear_table_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimChannelScalarTable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimChannelScalarTable_get_class_type_125(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimChannelScalarTable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimChannelScalarTable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimChannelScalarTable_get_class_type_125_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimChannelScalarTable_get_class_type_125_comment = NULL;
#endif

int  Dtool_Init_AnimChannelScalarTable(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AnimChannelScalarTable)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AnimChannelScalarTable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimChannelScalarTable)
    {
        printf("AnimChannelScalarTable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimChannelScalarTable * local_this = (AnimChannelScalarTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimChannelScalarTable)
        return local_this;
    if(requested_type == &Dtool_AnimChannel_ACScalarSwitchType)
        return ( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimChannelBase)
        return ( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_AnimGroup)
        return ( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( AnimGroup *)( AnimChannelBase *)( AnimChannel< ACScalarSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimChannelScalarTable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimChannelScalarTable)
        return from_this;
    if(from_type == &Dtool_AnimChannel_ACScalarSwitchType)
    {
          AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_AnimChannelBase)
    {
          AnimChannelBase* other_this = (AnimChannelBase*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_AnimGroup)
    {
          AnimGroup* other_this = (AnimGroup*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimChannelScalarTable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimControlCollection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::store_anim(AnimControl *control, basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_store_anim_130(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimControlCollection::store_anim(AnimControl *control, basic_string< char > const &name)
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"control", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:storeAnim", key_word_list, &param1, &param2_str, &param2_len))
            {
                AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControl, 1, "AnimControlCollection.storeAnim", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->store_anim(param1_this, basic_string<char>(param2_str, param2_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.storeAnim() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeAnim(non-const AnimControlCollection this, non-const AnimControl control, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_store_anim_130_comment =
    "C++ Interface:\n"
    "storeAnim(non-const AnimControlCollection this, non-const AnimControl control, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::store_anim\n"
    "//       Access: Published\n"
    "//  Description: Associates the given AnimControl with this collection\n"
    "//               under the given name.  The AnimControl will remain\n"
    "//               associated until a new AnimControl is associated with\n"
    "//               the same name later, or until unbind_anim() is called\n"
    "//               with this name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_store_anim_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimControl *AnimControlCollection::find_anim(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_find_anim_131(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AnimControl *AnimControlCollection::find_anim(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findAnim", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findAnim", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AnimControl *return_value = ((const AnimControlCollection*)local_this)->find_anim(basic_string<char>(param1_str, param1_len));
            if (return_value != (AnimControl *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimControl,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findAnim(const AnimControlCollection this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_find_anim_131_comment =
    "C++ Interface:\n"
    "findAnim(const AnimControlCollection this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::find_anim\n"
    "//       Access: Published\n"
    "//  Description: Returns the AnimControl associated with the given\n"
    "//               name, or NULL if no such control has been associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_find_anim_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AnimControlCollection::unbind_anim(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_unbind_anim_132(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool AnimControlCollection::unbind_anim(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:unbindAnim", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:unbindAnim", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->unbind_anim(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.unbindAnim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unbindAnim(non-const AnimControlCollection this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_unbind_anim_132_comment =
    "C++ Interface:\n"
    "unbindAnim(non-const AnimControlCollection this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::unbind_anim\n"
    "//       Access: Published\n"
    "//  Description: Removes the AnimControl associated with the given\n"
    "//               name, if any.  Returns true if an AnimControl was\n"
    "//               removed, false if there was no AnimControl with the\n"
    "//               indicated name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_unbind_anim_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AnimControlCollection::get_num_anims(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_get_num_anims_133(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AnimControlCollection::get_num_anims(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAnims", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAnims"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimControlCollection*)local_this)->get_num_anims();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAnims(const AnimControlCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_get_num_anims_133_comment =
    "C++ Interface:\n"
    "getNumAnims(const AnimControlCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_num_anims\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of AnimControls associated with\n"
    "//               this collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_get_num_anims_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimControl *AnimControlCollection::get_anim(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_get_anim_134(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AnimControl *AnimControlCollection::get_anim(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAnim", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAnim", &param1));
        if(!PyErr_Occurred())
        {
            AnimControl *return_value = ((const AnimControlCollection*)local_this)->get_anim((int)param1);
            if (return_value != (AnimControl *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimControl,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnim(const AnimControlCollection this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_get_anim_134_comment =
    "C++ Interface:\n"
    "getAnim(const AnimControlCollection this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_anim\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth AnimControl associated with\n"
    "//               this collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_get_anim_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > AnimControlCollection::get_anim_name(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_get_anim_name_135(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > AnimControlCollection::get_anim_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAnimName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAnimName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AnimControlCollection*)local_this)->get_anim_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimName(const AnimControlCollection this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_get_anim_name_135_comment =
    "C++ Interface:\n"
    "getAnimName(const AnimControlCollection this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_anim_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the nth AnimControl associated\n"
    "//               with this collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_get_anim_name_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::clear_anims(void)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_clear_anims_136(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimControlCollection::clear_anims(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAnims", key_word_list));
        else
            (PyArg_Parse(args, ":clearAnims"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_anims();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.clearAnims() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAnims(non-const AnimControlCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_clear_anims_136_comment =
    "C++ Interface:\n"
    "clearAnims(non-const AnimControlCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::clear_anims\n"
    "//       Access: Published\n"
    "//  Description: Disassociates all anims from this collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_clear_anims_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControlCollection::play(basic_string< char > const &anim_name)
 * inline bool AnimControlCollection::play(basic_string< char > const &anim_name, int from, int to)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_play_137(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool AnimControlCollection::play(basic_string< char > const &anim_name)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"anim_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:play", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:play", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->play(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.play() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool AnimControlCollection::play(basic_string< char > const &anim_name, int from, int to)
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"anim_name", (char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:play", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                bool return_value = (local_this)->play(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.play() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "play() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "play(non-const AnimControlCollection this, string anim_name)\n"
          "play(non-const AnimControlCollection this, string anim_name, int from, int to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_play_137_comment =
    "C++ Interface:\n"
    "play(non-const AnimControlCollection this, string anim_name)\n"
    "play(non-const AnimControlCollection this, string anim_name, int from, int to)\n"
    "\n"
    "// The following functions are convenience functions that vector\n"
    "// directly into the AnimControl's functionality by anim name.\n"
    "\n"
    "// Filename: animControlCollection.I\n"
    "// Created by:  drose (22Feb00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::play\n"
    "//       Access: Public\n"
    "//  Description: Starts the named animation playing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::play\n"
    "//       Access: Public\n"
    "//  Description: Starts the named animation playing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_play_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControlCollection::loop(basic_string< char > const &anim_name, bool restart)
 * inline bool AnimControlCollection::loop(basic_string< char > const &anim_name, bool restart, int from, int to)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_loop_138(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool AnimControlCollection::loop(basic_string< char > const &anim_name, bool restart)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"anim_name", (char *)"restart", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:loop", key_word_list, &param1_str, &param1_len, &param2))
            {
                bool return_value = (local_this)->loop(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool AnimControlCollection::loop(basic_string< char > const &anim_name, bool restart, int from, int to)
            char *param1_str; int param1_len;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"anim_name", (char *)"restart", (char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oii:loop", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
            {
                bool return_value = (local_this)->loop(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0), (int)param3, (int)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loop() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loop(non-const AnimControlCollection this, string anim_name, bool restart)\n"
          "loop(non-const AnimControlCollection this, string anim_name, bool restart, int from, int to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_loop_138_comment =
    "C++ Interface:\n"
    "loop(non-const AnimControlCollection this, string anim_name, bool restart)\n"
    "loop(non-const AnimControlCollection this, string anim_name, bool restart, int from, int to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::loop\n"
    "//       Access: Public\n"
    "//  Description: Starts the named animation looping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::loop\n"
    "//       Access: Public\n"
    "//  Description: Starts the named animation looping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_loop_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControlCollection::stop(basic_string< char > const &anim_name)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_stop_139(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool AnimControlCollection::stop(basic_string< char > const &anim_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"anim_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:stop", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:stop", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->stop(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.stop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stop(non-const AnimControlCollection this, string anim_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_stop_139_comment =
    "C++ Interface:\n"
    "stop(non-const AnimControlCollection this, string anim_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::stop\n"
    "//       Access: Public\n"
    "//  Description: Stops the named animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_stop_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControlCollection::pose(basic_string< char > const &anim_name, int frame)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_pose_140(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool AnimControlCollection::pose(basic_string< char > const &anim_name, int frame)
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"anim_name", (char *)"frame", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:pose", key_word_list, &param1_str, &param1_len, &param2))
        {
            bool return_value = (local_this)->pose(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.pose() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pose(non-const AnimControlCollection this, string anim_name, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_pose_140_comment =
    "C++ Interface:\n"
    "pose(non-const AnimControlCollection this, string anim_name, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::pose\n"
    "//       Access: Public\n"
    "//  Description: Sets to a particular frame in the named animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_pose_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::play_all(void)
 * void AnimControlCollection::play_all(int from, int to)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_play_all_141(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimControlCollection::play_all(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":playAll", key_word_list));
            else
                (PyArg_Parse(args, ":playAll"));
            if(!PyErr_Occurred())
            {
                (local_this)->play_all();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.playAll() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimControlCollection::play_all(int from, int to)
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:playAll", key_word_list, &param1, &param2))
            {
                (local_this)->play_all((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.playAll() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "playAll() takes 1 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "playAll(non-const AnimControlCollection this)\n"
          "playAll(non-const AnimControlCollection this, int from, int to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_play_all_141_comment =
    "C++ Interface:\n"
    "playAll(non-const AnimControlCollection this)\n"
    "playAll(non-const AnimControlCollection this, int from, int to)\n"
    "\n"
    "// These functions operate on all anims at once.\n"
    "\n"
    "// These functions operate on all anims at once.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::play_all\n"
    "//       Access: Published\n"
    "//  Description: Starts all animations playing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::play_all\n"
    "//       Access: Published\n"
    "//  Description: Starts all animations playing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_play_all_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::loop_all(bool restart)
 * void AnimControlCollection::loop_all(bool restart, int from, int to)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_loop_all_142(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimControlCollection::loop_all(bool restart)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"restart", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:loopAll", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:loopAll", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->loop_all((PyObject_IsTrue(param1)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.loopAll() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimControlCollection::loop_all(bool restart, int from, int to)
            PyObject *param1;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"restart", (char *)"from", (char *)"to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oii:loopAll", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->loop_all((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimControlCollection.loopAll() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loopAll() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loopAll(non-const AnimControlCollection this, bool restart)\n"
          "loopAll(non-const AnimControlCollection this, bool restart, int from, int to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_loop_all_142_comment =
    "C++ Interface:\n"
    "loopAll(non-const AnimControlCollection this, bool restart)\n"
    "loopAll(non-const AnimControlCollection this, bool restart, int from, int to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::loop_all\n"
    "//       Access: Published\n"
    "//  Description: Starts all animations looping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::loop_all\n"
    "//       Access: Published\n"
    "//  Description: Starts all animations looping.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_loop_all_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AnimControlCollection::stop_all(void)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_stop_all_143(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool AnimControlCollection::stop_all(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stopAll", key_word_list));
        else
            (PyArg_Parse(args, ":stopAll"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->stop_all();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.stopAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stopAll(non-const AnimControlCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_stop_all_143_comment =
    "C++ Interface:\n"
    "stopAll(non-const AnimControlCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::stop_all\n"
    "//       Access: Published\n"
    "//  Description: Stops all currently playing animations.  Returns true\n"
    "//               if any animations were stopped, false if none were\n"
    "//               playing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_stop_all_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::pose_all(int frame)
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_pose_all_144(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimControlCollection::pose_all(int frame)
        int param1;
        static char * key_word_list[] = {(char *)"frame", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:poseAll", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:poseAll", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->pose_all((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimControlCollection.poseAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "poseAll(non-const AnimControlCollection this, int frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_pose_all_144_comment =
    "C++ Interface:\n"
    "poseAll(non-const AnimControlCollection this, int frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::pose_all\n"
    "//       Access: Published\n"
    "//  Description: Sets all animations to the indicated frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_pose_all_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimControlCollection::get_frame(void) const
 * inline int AnimControlCollection::get_frame(basic_string< char > const &anim_name) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_get_frame_145(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline int AnimControlCollection::get_frame(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
            else
                (PyArg_Parse(args, ":getFrame"));
            if(!PyErr_Occurred())
            {
                int return_value = ((const AnimControlCollection*)local_this)->get_frame();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline int AnimControlCollection::get_frame(basic_string< char > const &anim_name) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"anim_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getFrame", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:getFrame", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                int return_value = ((const AnimControlCollection*)local_this)->get_frame(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getFrame() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getFrame(const AnimControlCollection this)\n"
          "getFrame(const AnimControlCollection this, string anim_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_get_frame_145_comment =
    "C++ Interface:\n"
    "getFrame(const AnimControlCollection this)\n"
    "getFrame(const AnimControlCollection this, string anim_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_frame\n"
    "//       Access: Public\n"
    "//  Description: Returns the current frame in the named animation, or\n"
    "//               0 if the animation is not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_frame\n"
    "//       Access: Public\n"
    "//  Description: Returns the current frame in the last-started\n"
    "//               animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_get_frame_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimControlCollection::get_num_frames(void) const
 * inline int AnimControlCollection::get_num_frames(basic_string< char > const &anim_name) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_get_num_frames_146(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline int AnimControlCollection::get_num_frames(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFrames", key_word_list));
            else
                (PyArg_Parse(args, ":getNumFrames"));
            if(!PyErr_Occurred())
            {
                int return_value = ((const AnimControlCollection*)local_this)->get_num_frames();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline int AnimControlCollection::get_num_frames(basic_string< char > const &anim_name) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"anim_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getNumFrames", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:getNumFrames", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                int return_value = ((const AnimControlCollection*)local_this)->get_num_frames(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getNumFrames() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getNumFrames(const AnimControlCollection this)\n"
          "getNumFrames(const AnimControlCollection this, string anim_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_get_num_frames_146_comment =
    "C++ Interface:\n"
    "getNumFrames(const AnimControlCollection this)\n"
    "getNumFrames(const AnimControlCollection this, string anim_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_num_frames\n"
    "//       Access: Public\n"
    "//  Description: Returns the total number of frames in the named\n"
    "//               animation, or 0 if the animation is not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::get_num_frames\n"
    "//       Access: Public\n"
    "//  Description: Returns the total number of frames in the\n"
    "//               last-started animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_get_num_frames_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AnimControlCollection::is_playing(void) const
 * inline bool AnimControlCollection::is_playing(basic_string< char > const &anim_name) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_is_playing_147(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool AnimControlCollection::is_playing(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
            else
                (PyArg_Parse(args, ":isPlaying"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const AnimControlCollection*)local_this)->is_playing();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline bool AnimControlCollection::is_playing(basic_string< char > const &anim_name) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"anim_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:isPlaying", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:isPlaying", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const AnimControlCollection*)local_this)->is_playing(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isPlaying() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isPlaying(const AnimControlCollection this)\n"
          "isPlaying(const AnimControlCollection this, string anim_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_is_playing_147_comment =
    "C++ Interface:\n"
    "isPlaying(const AnimControlCollection this)\n"
    "isPlaying(const AnimControlCollection this, string anim_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::is_playing\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the named animation is currently\n"
    "//               playing, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::is_playing\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the last-started animation is\n"
    "//               currently playing, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_is_playing_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > AnimControlCollection::which_anim_playing(void) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_which_anim_playing_148(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > AnimControlCollection::which_anim_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":whichAnimPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":whichAnimPlaying"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AnimControlCollection*)local_this)->which_anim_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "whichAnimPlaying(const AnimControlCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_which_anim_playing_148_comment =
    "C++ Interface:\n"
    "whichAnimPlaying(const AnimControlCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::which_anim_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the bound AnimControl currently\n"
    "//               playing, if any.  If more than one AnimControl is\n"
    "//               currently playing, returns all of the names separated\n"
    "//               by spaces.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_which_anim_playing_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_output_149(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void AnimControlCollection::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimControlCollection.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimControlCollection*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AnimControlCollection this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_output_149_comment =
    "C++ Interface:\n"
    "output(const AnimControlCollection this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_output_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimControlCollection::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimControlCollection_write_150(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void AnimControlCollection::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimControlCollection.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimControlCollection*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const AnimControlCollection this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimControlCollection_write_150_comment =
    "C++ Interface:\n"
    "write(const AnimControlCollection this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimControlCollection::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimControlCollection_write_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimControlCollection::AnimControlCollection(void)
 *******************************************************************/
int  Dtool_Init_AnimControlCollection(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AnimControlCollection::AnimControlCollection(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":AnimControlCollection", key_word_list))
        {
            AnimControlCollection *return_value = new AnimControlCollection();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimControlCollection,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimControlCollection()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_AnimControlCollection_get_anims(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAnims", "getAnim");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_AnimControlCollection_get_anim_names(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAnims", "getAnimName");
}
inline void  * Dtool_UpcastInterface_AnimControlCollection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimControlCollection)
    {
        printf("AnimControlCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimControlCollection * local_this = (AnimControlCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimControlCollection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimControlCollection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimControlCollection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AnimPreloadTable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int AnimPreloadTable::get_num_anims(void) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_get_num_anims_154(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AnimPreloadTable::get_num_anims(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAnims", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAnims"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimPreloadTable*)local_this)->get_num_anims();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAnims(const AnimPreloadTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_get_num_anims_154_comment =
    "C++ Interface:\n"
    "getNumAnims(const AnimPreloadTable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::get_num_anims\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of animation records in the table.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_get_num_anims_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AnimPreloadTable::find_anim(basic_string< char > const &basename) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_find_anim_155(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AnimPreloadTable::find_anim(basic_string< char > const &basename) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"basename", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findAnim", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findAnim", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimPreloadTable*)local_this)->find_anim(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findAnim(const AnimPreloadTable this, string basename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_find_anim_155_comment =
    "C++ Interface:\n"
    "findAnim(const AnimPreloadTable this, string basename)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::find_anim\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number in the table of the\n"
    "//               animation record with the indicated name, or -1 if\n"
    "//               the name is not present.  By convention, the basename\n"
    "//               is the filename of the egg or bam file, without the\n"
    "//               directory part and without the extension.  That is,\n"
    "//               it is Filename::get_basename_wo_extension().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_find_anim_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > AnimPreloadTable::get_basename(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_get_basename_156(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > AnimPreloadTable::get_basename(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBasename", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBasename", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AnimPreloadTable*)local_this)->get_basename((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBasename(const AnimPreloadTable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_get_basename_156_comment =
    "C++ Interface:\n"
    "getBasename(const AnimPreloadTable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::get_basename\n"
    "//       Access: Published\n"
    "//  Description: Returns the basename stored for the nth animation\n"
    "//               record.  See find_anim().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_get_basename_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float AnimPreloadTable::get_base_frame_rate(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_get_base_frame_rate_157(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float AnimPreloadTable::get_base_frame_rate(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBaseFrameRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBaseFrameRate", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AnimPreloadTable*)local_this)->get_base_frame_rate((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBaseFrameRate(const AnimPreloadTable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_get_base_frame_rate_157_comment =
    "C++ Interface:\n"
    "getBaseFrameRate(const AnimPreloadTable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::get_base_frame_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the frame rate stored for the nth animation\n"
    "//               record.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_get_base_frame_rate_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AnimPreloadTable::get_num_frames(int n) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_get_num_frames_158(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AnimPreloadTable::get_num_frames(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNumFrames", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNumFrames", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AnimPreloadTable*)local_this)->get_num_frames((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFrames(const AnimPreloadTable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_get_num_frames_158_comment =
    "C++ Interface:\n"
    "getNumFrames(const AnimPreloadTable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::get_num_frames\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of frames stored for the nth\n"
    "//               animation record.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_get_num_frames_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimPreloadTable::clear_anims(void)
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_clear_anims_159(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimPreloadTable::clear_anims(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAnims", key_word_list));
        else
            (PyArg_Parse(args, ":clearAnims"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_anims();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimPreloadTable.clearAnims() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAnims(non-const AnimPreloadTable this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_clear_anims_159_comment =
    "C++ Interface:\n"
    "clearAnims(non-const AnimPreloadTable this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::clear_anims\n"
    "//       Access: Published\n"
    "//  Description: Removes all animation records from the table.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_clear_anims_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimPreloadTable::remove_anim(int n)
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_remove_anim_160(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimPreloadTable::remove_anim(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeAnim", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeAnim", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_anim((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimPreloadTable.removeAnim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAnim(non-const AnimPreloadTable this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_remove_anim_160_comment =
    "C++ Interface:\n"
    "removeAnim(non-const AnimPreloadTable this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::remove_anim\n"
    "//       Access: Published\n"
    "//  Description: Removes the nth animation records from the table.\n"
    "//               This renumbers indexes for following animations.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_remove_anim_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimPreloadTable::add_anim(basic_string< char > const &basename, float base_frame_rate, int num_frames)
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_add_anim_161(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AnimPreloadTable::add_anim(basic_string< char > const &basename, float base_frame_rate, int num_frames)
        char *param1_str; int param1_len;
        double param2;
        int param3;
        static char * key_word_list[] = {(char *)"basename", (char *)"base_frame_rate", (char *)"num_frames", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#di:addAnim", key_word_list, &param1_str, &param1_len, &param2, &param3))
        {
            (local_this)->add_anim(basic_string<char>(param1_str, param1_len), (float)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AnimPreloadTable.addAnim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAnim(non-const AnimPreloadTable this, string basename, float base_frame_rate, int num_frames)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_add_anim_161_comment =
    "C++ Interface:\n"
    "addAnim(non-const AnimPreloadTable this, string basename, float base_frame_rate, int num_frames)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::add_anim\n"
    "//       Access: Published\n"
    "//  Description: Adds a new animation record to the table.  If there\n"
    "//               is already a record of this name, no operation is\n"
    "//               performed (the original record is unchanged).  See\n"
    "//               find_anim().  This will invalidate existing index\n"
    "//               numbers.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_add_anim_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_add_anims_from_162(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addAnimsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addAnimsFrom", &param1));
            if(!PyErr_Occurred())
            {
                AnimPreloadTable *param1_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimPreloadTable, 1, "AnimPreloadTable.addAnimsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_anims_from(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AnimPreloadTable.addAnimsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAnimsFrom(non-const AnimPreloadTable this, const AnimPreloadTable other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_add_anims_from_162_comment =
    "C++ Interface:\n"
    "addAnimsFrom(non-const AnimPreloadTable this, const AnimPreloadTable other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::add_anims_from\n"
    "//       Access: Published\n"
    "//  Description: Copies the animation records from the other table\n"
    "//               into this one.  If a given record name exists in both\n"
    "//               tables, the record in this one supercedes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_add_anims_from_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimPreloadTable::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_output_163(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimPreloadTable::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimPreloadTable.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimPreloadTable*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AnimPreloadTable this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_output_163_comment =
    "C++ Interface:\n"
    "output(const AnimPreloadTable this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_output_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AnimPreloadTable::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_write_164(PyObject *self, PyObject *args,PyObject *kwds) {
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AnimPreloadTable::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AnimPreloadTable.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AnimPreloadTable*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const AnimPreloadTable this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_write_164_comment =
    "C++ Interface:\n"
    "write(const AnimPreloadTable this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AnimPreloadTable::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_write_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AnimPreloadTable::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AnimPreloadTable_get_class_type_165(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AnimPreloadTable::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AnimPreloadTable::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AnimPreloadTable_get_class_type_165_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AnimPreloadTable_get_class_type_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AnimPreloadTable::AnimPreloadTable(void)
 *******************************************************************/
int  Dtool_Init_AnimPreloadTable(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AnimPreloadTable::AnimPreloadTable(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":AnimPreloadTable", key_word_list))
        {
            AnimPreloadTable *return_value = new AnimPreloadTable();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AnimPreloadTable,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AnimPreloadTable()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AnimPreloadTable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AnimPreloadTable)
    {
        printf("AnimPreloadTable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AnimPreloadTable * local_this = (AnimPreloadTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AnimPreloadTable)
        return local_this;
    if(requested_type == &Dtool_CachedTypedWritableReferenceCount)
        return ( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_CopyOnWriteObject)
        return ( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( CachedTypedWritableReferenceCount *)( CopyOnWriteObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AnimPreloadTable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AnimPreloadTable)
        return from_this;
    if(from_type == &Dtool_CachedTypedWritableReferenceCount)
    {
          CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    if(from_type == &Dtool_CopyOnWriteObject)
    {
          CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (AnimPreloadTable*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PartSubset 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PartSubset::operator =(PartSubset const &copy)
 *******************************************************************/
static PyObject *Dtool_PartSubset_operator_169(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PartSubset::operator =(PartSubset const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PartSubset *param1_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartSubset, 1, "PartSubset.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PartSubset *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PartSubset,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartSubset.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PartSubset this, const PartSubset copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_operator_169_comment =
    "C++ Interface:\n"
    "assign(non-const PartSubset this, const PartSubset copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_operator_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartSubset::add_include_joint(GlobPattern const &name)
 *******************************************************************/
static PyObject *Dtool_PartSubset_add_include_joint_170(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PartSubset::add_include_joint(GlobPattern const &name)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addIncludeJoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addIncludeJoint", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "PartSubset.addIncludeJoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_include_joint(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartSubset.addIncludeJoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addIncludeJoint(non-const PartSubset this, const GlobPattern name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_add_include_joint_170_comment =
    "C++ Interface:\n"
    "addIncludeJoint(non-const PartSubset this, const GlobPattern name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::add_include_joint\n"
    "//       Access: Published\n"
    "//  Description: Adds the named joint to the list of joints that will\n"
    "//               be explicitly included in the subset.  Any joint at\n"
    "//               or below a named node will be included in the subset\n"
    "//               (unless a lower node is also listed in the exclude\n"
    "//               list).\n"
    "//\n"
    "//               Since the name is a GlobPattern, it may of course\n"
    "//               include filename globbing characters like * and ?.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_add_include_joint_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartSubset::add_exclude_joint(GlobPattern const &name)
 *******************************************************************/
static PyObject *Dtool_PartSubset_add_exclude_joint_171(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PartSubset::add_exclude_joint(GlobPattern const &name)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addExcludeJoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addExcludeJoint", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "PartSubset.addExcludeJoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_exclude_joint(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartSubset.addExcludeJoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addExcludeJoint(non-const PartSubset this, const GlobPattern name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_add_exclude_joint_171_comment =
    "C++ Interface:\n"
    "addExcludeJoint(non-const PartSubset this, const GlobPattern name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::add_exclude_joint\n"
    "//       Access: Published\n"
    "//  Description: Adds the named joint to the list of joints that will\n"
    "//               be explicitly exlcluded from the subset.  Any joint at\n"
    "//               or below a named node will not be included in the\n"
    "//               subset (unless a lower node is also listed in the\n"
    "//               include list).\n"
    "//\n"
    "//               Since the name is a GlobPattern, it may of course\n"
    "//               include filename globbing characters like * and ?.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_add_exclude_joint_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartSubset::append(PartSubset const &other)
 *******************************************************************/
static PyObject *Dtool_PartSubset_append_172(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PartSubset::append(PartSubset const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:append", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:append", &param1));
            if(!PyErr_Occurred())
            {
                PartSubset *param1_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartSubset, 1, "PartSubset.append", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->append(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartSubset.append() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "append(non-const PartSubset this, const PartSubset other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_append_172_comment =
    "C++ Interface:\n"
    "append(non-const PartSubset this, const PartSubset other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::append\n"
    "//       Access: Published\n"
    "//  Description: Appends the include and exclude list from the other\n"
    "//               object onto this object's lists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_append_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartSubset::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PartSubset_output_173(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PartSubset::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PartSubset.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PartSubset*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PartSubset this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_output_173_comment =
    "C++ Interface:\n"
    "output(const PartSubset this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_output_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartSubset::is_include_empty(void) const
 *******************************************************************/
static PyObject *Dtool_PartSubset_is_include_empty_174(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PartSubset::is_include_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isIncludeEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isIncludeEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartSubset*)local_this)->is_include_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isIncludeEmpty(const PartSubset this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_is_include_empty_174_comment =
    "C++ Interface:\n"
    "isIncludeEmpty(const PartSubset this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::is_include_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the include list is completely empty,\n"
    "//               false otherwise.  If it is empty, it is the same\n"
    "//               thing as including all joints.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_is_include_empty_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartSubset::matches_include(basic_string< char > const &joint_name) const
 *******************************************************************/
static PyObject *Dtool_PartSubset_matches_include_175(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PartSubset::matches_include(basic_string< char > const &joint_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"joint_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:matchesInclude", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:matchesInclude", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartSubset*)local_this)->matches_include(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matchesInclude(const PartSubset this, string joint_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_matches_include_175_comment =
    "C++ Interface:\n"
    "matchesInclude(const PartSubset this, string joint_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::matches_include\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated name matches a name on\n"
    "//               the include list, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_matches_include_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartSubset::matches_exclude(basic_string< char > const &joint_name) const
 *******************************************************************/
static PyObject *Dtool_PartSubset_matches_exclude_176(PyObject *self, PyObject *args,PyObject *kwds) {
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PartSubset::matches_exclude(basic_string< char > const &joint_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"joint_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:matchesExclude", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:matchesExclude", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartSubset*)local_this)->matches_exclude(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matchesExclude(const PartSubset this, string joint_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartSubset_matches_exclude_176_comment =
    "C++ Interface:\n"
    "matchesExclude(const PartSubset this, string joint_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartSubset::matches_exclude\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated name matches a name on\n"
    "//               the exclude list, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartSubset_matches_exclude_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartSubset::PartSubset(void)
 * PartSubset::PartSubset(PartSubset const &copy)
 *******************************************************************/
int  Dtool_Init_PartSubset(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PartSubset::PartSubset(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PartSubset", key_word_list))
            {
                PartSubset *return_value = new PartSubset();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PartSubset,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PartSubset::PartSubset(PartSubset const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PartSubset", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PartSubset", &param0));
                if(!PyErr_Occurred())
                {
                    PartSubset *param0_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PartSubset, 0, "PartSubset.PartSubset", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PartSubset *return_value = new PartSubset(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PartSubset,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PartSubset() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PartSubset()\n"
          "PartSubset(const PartSubset copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PartSubset(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PartSubset)
    {
        printf("PartSubset ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PartSubset * local_this = (PartSubset *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PartSubset)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PartSubset(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PartSubset)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BindAnimRequest 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BindAnimRequest::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BindAnimRequest_get_class_type_181(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BindAnimRequest::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BindAnimRequest::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BindAnimRequest_get_class_type_181_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BindAnimRequest_get_class_type_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * BindAnimRequest::BindAnimRequest(basic_string< char > const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
 *******************************************************************/
int  Dtool_Init_BindAnimRequest(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-BindAnimRequest::BindAnimRequest(basic_string< char > const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
            char *param0_str; int param0_len;
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            int param5;
            PyObject *param6;
            static char * key_word_list[] = {(char *)"name", (char *)"filename", (char *)"options", (char *)"loader", (char *)"control", (char *)"hierarchy_match_flags", (char *)"subset", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OOOOiO:BindAnimRequest", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "BindAnimRequest.BindAnimRequest", 1, coerced_ptr, report_errors);
LoaderOptions *param2_this = (LoaderOptions *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LoaderOptions, 2, "BindAnimRequest.BindAnimRequest", 1, coerced_ptr, report_errors);
Loader *param3_this = (Loader *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Loader, 3, "BindAnimRequest.BindAnimRequest", 0, coerced_ptr, report_errors);
AnimControl *param4_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_AnimControl, 4, "BindAnimRequest.BindAnimRequest", 0, coerced_ptr, report_errors);
PartSubset *param6_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_PartSubset, 6, "BindAnimRequest.BindAnimRequest", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)|| (param6_this == NULL)))
                {
                    BindAnimRequest *return_value = new BindAnimRequest(basic_string<char>(param0_str, param0_len), *param1_this, *param2_this, param3_this, param4_this, (int)param5, *param6_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_BindAnimRequest,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "BindAnimRequest(string name, const Filename filename, const LoaderOptions options, non-const PandaLoader loader, non-const AnimControl control, int hierarchy_match_flags, const PartSubset subset)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BindAnimRequest(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BindAnimRequest)
    {
        printf("BindAnimRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BindAnimRequest * local_this = (BindAnimRequest *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BindAnimRequest)
        return local_this;
    if(requested_type == &Dtool_AsyncTask)
        return ( AsyncTask *)( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_AsyncTaskBase)
        return ( AsyncTaskBase *)( AsyncTask *)( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_ModelLoadRequest)
        return ( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AsyncTaskBase *)( AsyncTask *)( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *)( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *)( ModelLoadRequest *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *)( ModelLoadRequest *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BindAnimRequest(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BindAnimRequest)
        return from_this;
    if(from_type == &Dtool_AsyncTask)
    {
          AsyncTask* other_this = (AsyncTask*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_AsyncTaskBase)
    {
          AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_ModelLoadRequest)
    {
          ModelLoadRequest* other_this = (ModelLoadRequest*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BindAnimRequest*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BindAnimRequest*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PartBundle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_anim_preload_185(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimPreload", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimPreload"));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< AnimPreloadTable > return_value = ((const PartBundle*)local_this)->get_anim_preload();
            if (return_value != (AnimPreloadTable const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimPreloadTable,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimPreload(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_anim_preload_185_comment =
    "C++ Interface:\n"
    "getAnimPreload(const PartBundle this)\n"
    "\n"
    "// Filename: partBundle.I\n"
    "// Created by:  drose (22Feb99)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_anim_preload\n"
    "//       Access: Published\n"
    "//  Description: Returns the AnimPreloadTable associated with\n"
    "//               the PartBundle.  This table, if present, can be used\n"
    "//               for the benefit of load_bind_anim() to allow\n"
    "//               asynchronous binding.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_anim_preload_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_modify_anim_preload_186(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":modifyAnimPreload", key_word_list));
        else
            (PyArg_Parse(args, ":modifyAnimPreload"));
        if(!PyErr_Occurred())
        {
            PointerTo< AnimPreloadTable > return_value = (local_this)->modify_anim_preload();
            if (return_value != (AnimPreloadTable *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimPreloadTable,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.modifyAnimPreload() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "modifyAnimPreload(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_modify_anim_preload_186_comment =
    "C++ Interface:\n"
    "modifyAnimPreload(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::modify_anim_preload\n"
    "//       Access: Published\n"
    "//  Description: Returns a modifiable pointer to the AnimPreloadTable\n"
    "//               associated with the PartBundle, if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_modify_anim_preload_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_anim_preload_187(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"table", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnimPreload", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAnimPreload", &param1));
            if(!PyErr_Occurred())
            {
                AnimPreloadTable *param1_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimPreloadTable, 1, "PartBundle.setAnimPreload", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_anim_preload(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.setAnimPreload() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimPreload(non-const PartBundle this, non-const AnimPreloadTable table)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_anim_preload_187_comment =
    "C++ Interface:\n"
    "setAnimPreload(non-const PartBundle this, non-const AnimPreloadTable table)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_anim_preload\n"
    "//       Access: Published\n"
    "//  Description: Replaces the AnimPreloadTable associated with\n"
    "//               the PartBundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_anim_preload_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::clear_anim_preload(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_clear_anim_preload_188(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PartBundle::clear_anim_preload(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAnimPreload", key_word_list));
        else
            (PyArg_Parse(args, ":clearAnimPreload"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_anim_preload();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.clearAnimPreload() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAnimPreload(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_clear_anim_preload_188_comment =
    "C++ Interface:\n"
    "clearAnimPreload(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::clear_anim_preload\n"
    "//       Access: Published\n"
    "//  Description: Removes any AnimPreloadTable associated with\n"
    "//               the PartBundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_clear_anim_preload_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartBundle::merge_anim_preloads(PartBundle const *other)
 *******************************************************************/
static PyObject *Dtool_PartBundle_merge_anim_preloads_189(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PartBundle::merge_anim_preloads(PartBundle const *other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:mergeAnimPreloads", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:mergeAnimPreloads", &param1));
            if(!PyErr_Occurred())
            {
                PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "PartBundle.mergeAnimPreloads", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->merge_anim_preloads(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.mergeAnimPreloads() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mergeAnimPreloads(non-const PartBundle this, const PartBundle other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_merge_anim_preloads_189_comment =
    "C++ Interface:\n"
    "mergeAnimPreloads(non-const PartBundle this, const PartBundle other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::merge_anim_preloads\n"
    "//       Access: Published\n"
    "//  Description: Copies the contents of the other PartBundle's preload\n"
    "//               table into this one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_merge_anim_preloads_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_blend_type_191(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
        int param1;
        static char * key_word_list[] = {(char *)"bt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setBlendType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setBlendType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_blend_type((PartBundle::BlendType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.setBlendType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBlendType(non-const PartBundle this, int bt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_blend_type_191_comment =
    "C++ Interface:\n"
    "setBlendType(non-const PartBundle this, int bt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_blend_type\n"
    "//       Access: Published\n"
    "//  Description: Defines the algorithm that is used when blending\n"
    "//               multiple frames or multiple animations together, when\n"
    "//               either anim_blend_flag or frame_blend_flag is set\n"
    "//               to true.\n"
    "//\n"
    "//               See partBundle.h for a description of the meaning of\n"
    "//               each of the BlendType values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_blend_type_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundle::BlendType PartBundle::get_blend_type(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_blend_type_192(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PartBundle::BlendType PartBundle::get_blend_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlendType", key_word_list));
        else
            (PyArg_Parse(args, ":getBlendType"));
        if(!PyErr_Occurred())
        {
            PartBundle::BlendType return_value = ((const PartBundle*)local_this)->get_blend_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlendType(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_blend_type_192_comment =
    "C++ Interface:\n"
    "getBlendType(const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_blend_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the algorithm that is used when blending\n"
    "//               multiple frames or multiple animations together, when\n"
    "//               either anim_blend_flag or frame_blend_flag is set\n"
    "//               to true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_blend_type_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_anim_blend_flag_193(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"anim_blend_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnimBlendFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAnimBlendFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_anim_blend_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.setAnimBlendFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnimBlendFlag(non-const PartBundle this, bool anim_blend_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_anim_blend_flag_193_comment =
    "C++ Interface:\n"
    "setAnimBlendFlag(non-const PartBundle this, bool anim_blend_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_anim_blend_flag\n"
    "//       Access: Published\n"
    "//  Description: Defines the way the character responds to multiple\n"
    "//               calls to set_control_effect()).  By default, this\n"
    "//               flag is set false, which disallows multiple\n"
    "//               animations.  When this flag is false, it is not\n"
    "//               necessary to explicitly set the control_effect when\n"
    "//               starting an animation; starting the animation will\n"
    "//               implicitly remove the control_effect from the\n"
    "//               previous animation and set it on the current one.\n"
    "//\n"
    "//               However, if this flag is set true, the control_effect\n"
    "//               must be explicitly set via set_control_effect()\n"
    "//               whenever an animation is to affect the character.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_anim_blend_flag_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PartBundle::get_anim_blend_flag(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_anim_blend_flag_194(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PartBundle::get_anim_blend_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnimBlendFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getAnimBlendFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartBundle*)local_this)->get_anim_blend_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnimBlendFlag(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_anim_blend_flag_194_comment =
    "C++ Interface:\n"
    "getAnimBlendFlag(const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_anim_blend_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the character allows multiple\n"
    "//               different animations to be bound simultaneously.  See\n"
    "//               set_anim_blend_flag().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_anim_blend_flag_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_frame_blend_flag_195(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"frame_blend_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameBlendFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFrameBlendFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_blend_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.setFrameBlendFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameBlendFlag(non-const PartBundle this, bool frame_blend_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_frame_blend_flag_195_comment =
    "C++ Interface:\n"
    "setFrameBlendFlag(non-const PartBundle this, bool frame_blend_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_frame_blend_flag\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether the character interpolates (blends)\n"
    "//               between two sequential frames of an active animation,\n"
    "//               showing a smooth intra-frame motion, or whether it\n"
    "//               holds each frame until the next frame is ready,\n"
    "//               showing precisely the specified animation.\n"
    "//\n"
    "//               When this value is false, the character holds each\n"
    "//               frame until the next is ready.  When this is true,\n"
    "//               the character will interpolate between two\n"
    "//               consecutive frames of animation for each frame the\n"
    "//               animation is onscreen, according to the amount of\n"
    "//               time elapsed between the frames.\n"
    "//\n"
    "//               The default value of this flag is determined by the\n"
    "//               interpolate-frames Config.prc variable.\n"
    "//\n"
    "//               Use set_blend_type() to change the algorithm that the\n"
    "//               character uses to interpolate matrix positions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_frame_blend_flag_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PartBundle::get_frame_blend_flag(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_frame_blend_flag_196(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PartBundle::get_frame_blend_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameBlendFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameBlendFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PartBundle*)local_this)->get_frame_blend_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameBlendFlag(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_frame_blend_flag_196_comment =
    "C++ Interface:\n"
    "getFrameBlendFlag(const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_frame_blend_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the character interpolates (blends)\n"
    "//               between two sequential animation frames, or whether\n"
    "//               it holds the current frame until the next one is\n"
    "//               ready.  See set_frame_blend_flag().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_frame_blend_flag_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::set_root_xform(LMatrix4f const &root_xform)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_root_xform_197(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PartBundle::set_root_xform(LMatrix4f const &root_xform)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root_xform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRootXform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRootXform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "PartBundle.setRootXform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_root_xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.setRootXform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRootXform(non-const PartBundle this, const Mat4 root_xform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_root_xform_197_comment =
    "C++ Interface:\n"
    "setRootXform(non-const PartBundle this, const Mat4 root_xform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_root_xform\n"
    "//       Access: Published\n"
    "//  Description: Specifies the transform matrix which is implicitly\n"
    "//               applied at the root of the animated hierarchy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_root_xform_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::xform(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_PartBundle_xform_198(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PartBundle::xform(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:xform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:xform", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "PartBundle.xform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->xform(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.xform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "xform(non-const PartBundle this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_xform_198_comment =
    "C++ Interface:\n"
    "xform(non-const PartBundle this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::xform\n"
    "//       Access: Published\n"
    "//  Description: Applies the indicated transform to the root of the\n"
    "//               animated hierarchy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_xform_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f const &PartBundle::get_root_xform(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_root_xform_199(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f const &PartBundle::get_root_xform(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRootXform", key_word_list));
        else
            (PyArg_Parse(args, ":getRootXform"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const PartBundle*)local_this)->get_root_xform());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRootXform(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_root_xform_199_comment =
    "C++ Interface:\n"
    "getRootXform(const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_root_xform\n"
    "//       Access: Published\n"
    "//  Description: Returns the transform matrix which is implicitly\n"
    "//               applied at the root of the animated hierarchy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_root_xform_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
 *******************************************************************/
static PyObject *Dtool_PartBundle_apply_transform_200(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"transform", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:applyTransform", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:applyTransform", &param1));
            if(!PyErr_Occurred())
            {
                TransformState *param1_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TransformState, 1, "PartBundle.applyTransform", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< PartBundle > return_value = (local_this)->apply_transform(param1_this);
                    if (return_value != (PartBundle *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PartBundle,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.applyTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyTransform(non-const PartBundle this, const TransformState transform)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_apply_transform_200_comment =
    "C++ Interface:\n"
    "applyTransform(non-const PartBundle this, const TransformState transform)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::apply_transform\n"
    "//       Access: Published\n"
    "//  Description: Returns a PartBundle that is a duplicate of this one,\n"
    "//               but with the indicated transform applied.  If this is\n"
    "//               called multiple times with the same TransformState\n"
    "//               pointer, it returns the same PartBundle each time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_apply_transform_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PartBundle::get_num_nodes(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_num_nodes_201(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PartBundle::get_num_nodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNodes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNodes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PartBundle*)local_this)->get_num_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNodes(const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_num_nodes_201_comment =
    "C++ Interface:\n"
    "getNumNodes(const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_num_nodes\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of PartBundleNodes that contain a\n"
    "//               pointer to this PartBundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_num_nodes_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundleNode *PartBundle::get_node(int n) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_node_202(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PartBundleNode *PartBundle::get_node(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNode", &param1));
        if(!PyErr_Occurred())
        {
            PartBundleNode *return_value = ((const PartBundle*)local_this)->get_node((int)param1);
            if (return_value != (PartBundleNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartBundleNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const PartBundle this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_node_202_comment =
    "C++ Interface:\n"
    "getNode(const PartBundle this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth PartBundleNode associated with\n"
    "//               this PartBundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_node_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartBundle::clear_control_effects(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_clear_control_effects_203(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PartBundle::clear_control_effects(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearControlEffects", key_word_list));
        else
            (PyArg_Parse(args, ":clearControlEffects"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_control_effects();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.clearControlEffects() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearControlEffects(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_clear_control_effects_203_comment =
    "C++ Interface:\n"
    "clearControlEffects(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::clear_control_effects\n"
    "//       Access: Published\n"
    "//  Description: Sets the control effect of all AnimControls to zero\n"
    "//               (but does not \"stop\" the AnimControls).  The\n"
    "//               character will no longer be affected by any\n"
    "//               animation, and will return to its default\n"
    "//               pose (unless restore-initial-pose is false).\n"
    "//\n"
    "//               The AnimControls which are no longer associated will\n"
    "//               not be using any CPU cycles, but they may still be in\n"
    "//               the \"playing\" state; if they are later reassociated\n"
    "//               with the PartBundle they will resume at their current\n"
    "//               frame as if they'd been running all along.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_clear_control_effects_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundle::set_control_effect(AnimControl *control, float effect)
 *******************************************************************/
static PyObject *Dtool_PartBundle_set_control_effect_204(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PartBundle::set_control_effect(AnimControl *control, float effect)
            PyObject *param1;
            double param2;
            static char * key_word_list[] = {(char *)"control", (char *)"effect", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setControlEffect", key_word_list, &param1, &param2))
            {
                AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControl, 1, "PartBundle.setControlEffect", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_control_effect(param1_this, (float)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.setControlEffect() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setControlEffect(non-const PartBundle this, non-const AnimControl control, float effect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_set_control_effect_204_comment =
    "C++ Interface:\n"
    "setControlEffect(non-const PartBundle this, non-const AnimControl control, float effect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::set_control_effect\n"
    "//       Access: Published\n"
    "//  Description: Sets the amount by which the character is affected by\n"
    "//               the indicated AnimControl (and its associated\n"
    "//               animation).  Normally, this will only be zero or one.\n"
    "//               Zero indicates the animation does not affect the\n"
    "//               character, and one means it does.\n"
    "//\n"
    "//               If the _anim_blend_flag is not false (see\n"
    "//               set_anim_blend_flag()), it is possible to have\n"
    "//               multiple AnimControls in effect simultaneously.  In\n"
    "//               this case, the effect is a weight that indicates the\n"
    "//               relative importance of each AnimControl to the final\n"
    "//               animation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_set_control_effect_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PartBundle::get_control_effect(AnimControl *control) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_control_effect_205(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline float PartBundle::get_control_effect(AnimControl *control) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"control", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getControlEffect", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getControlEffect", &param1));
            if(!PyErr_Occurred())
            {
                AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControl, 1, "PartBundle.getControlEffect", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    float return_value = ((const PartBundle*)local_this)->get_control_effect(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getControlEffect(const PartBundle this, non-const AnimControl control)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_control_effect_205_comment =
    "C++ Interface:\n"
    "getControlEffect(const PartBundle this, non-const AnimControl control)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::get_control_effect\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount by which the character is affected\n"
    "//               by the indicated AnimControl and its associated\n"
    "//               animation.  See set_control_effect().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_get_control_effect_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PartBundle::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PartBundle_output_206(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void PartBundle::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PartBundle.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PartBundle*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PartBundle this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_output_206_comment =
    "C++ Interface:\n"
    "output(const PartBundle this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Writes a one-line description of the bundle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_output_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset)
 * PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset = ((())))
 * PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = (0), PartSubset const &subset = ((())))
 *******************************************************************/
static PyObject *Dtool_PartBundle_bind_anim_207(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = (0), PartSubset const &subset = ((())))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anim", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:bindAnim", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:bindAnim", &param1));
                if(!PyErr_Occurred())
                {
                    AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimBundle, 1, "PartBundle.bindAnim", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< AnimControl > return_value = (local_this)->bind_anim(param1_this);
                        if (return_value != (AnimControl *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimControl,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PartBundle.bindAnim() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset = ((())))
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"anim", (char *)"hierarchy_match_flags", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:bindAnim", key_word_list, &param1, &param2))
                {
                    AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimBundle, 1, "PartBundle.bindAnim", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< AnimControl > return_value = (local_this)->bind_anim(param1_this, (int)param2);
                        if (return_value != (AnimControl *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimControl,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PartBundle.bindAnim() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags, PartSubset const &subset)
                PyObject *param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"anim", (char *)"hierarchy_match_flags", (char *)"subset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OiO:bindAnim", key_word_list, &param1, &param2, &param3))
                {
                    AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimBundle, 1, "PartBundle.bindAnim", 0, coerced_ptr, report_errors);
PartSubset *param3_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_PartSubset, 3, "PartBundle.bindAnim", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param3_this == NULL)))
                    {
                        PointerTo< AnimControl > return_value = (local_this)->bind_anim(param1_this, (int)param2, *param3_this);
                        if (return_value != (AnimControl *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimControl,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PartBundle.bindAnim() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "bindAnim() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "bindAnim(non-const PartBundle this, non-const AnimBundle anim)\n"
          "bindAnim(non-const PartBundle this, non-const AnimBundle anim, int hierarchy_match_flags)\n"
          "bindAnim(non-const PartBundle this, non-const AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_bind_anim_207_comment =
    "C++ Interface:\n"
    "bindAnim(non-const PartBundle this, non-const AnimBundle anim)\n"
    "bindAnim(non-const PartBundle this, non-const AnimBundle anim, int hierarchy_match_flags)\n"
    "bindAnim(non-const PartBundle this, non-const AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::bind_anim\n"
    "//       Access: Published\n"
    "//  Description: Binds the animation to the bundle, if possible, and\n"
    "//               returns a new AnimControl that can be used to start\n"
    "//               and stop the animation.  If the anim hierarchy does\n"
    "//               not match the part hierarchy, returns NULL.\n"
    "//\n"
    "//               If hierarchy_match_flags is 0, only an exact match is\n"
    "//               accepted; otherwise, it may contain a union of\n"
    "//               PartGroup::HierarchyMatchFlags values indicating\n"
    "//               conditions that will be tolerated (but warnings will\n"
    "//               still be issued).\n"
    "//\n"
    "//               If subset is specified, it restricts the binding only\n"
    "//               to the named subtree of joints.\n"
    "//\n"
    "//               The AnimControl is not stored within the PartBundle;\n"
    "//               it is the user's responsibility to maintain the\n"
    "//               pointer.  The animation will automatically unbind\n"
    "//               itself when the AnimControl destructs (i.e. its\n"
    "//               reference count goes to zero).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_bind_anim_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
 *******************************************************************/
static PyObject *Dtool_PartBundle_load_bind_anim_208(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
            PyObject *param1;
            PyObject *param2;
            int param3;
            PyObject *param4;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"loader", (char *)"filename", (char *)"hierarchy_match_flags", (char *)"subset", (char *)"allow_async", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOiOO:loadBindAnim", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                Loader *param1_this = (Loader *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Loader, 1, "PartBundle.loadBindAnim", 0, coerced_ptr, report_errors);
Filename *param2_this = (Filename *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Filename, 2, "PartBundle.loadBindAnim", 1, coerced_ptr, report_errors);
PartSubset *param4_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_PartSubset, 4, "PartBundle.loadBindAnim", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param4_this == NULL)))
                {
                    PointerTo< AnimControl > return_value = (local_this)->load_bind_anim(param1_this, *param2_this, (int)param3, *param4_this, (PyObject_IsTrue(param5)!=0));
                    if (return_value != (AnimControl *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AnimControl,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.loadBindAnim() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "loadBindAnim(non-const PartBundle this, non-const PandaLoader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_load_bind_anim_208_comment =
    "C++ Interface:\n"
    "loadBindAnim(non-const PartBundle this, non-const PandaLoader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::load_bind_anim\n"
    "//       Access: Published\n"
    "//  Description: Binds an animation to the bundle.  The animation is\n"
    "//               loaded from the disk via the indicated Loader object.\n"
    "//               In other respects, this behaves similarly to\n"
    "//               bind_anim(), with the addition of asynchronous\n"
    "//               support.\n"
    "//\n"
    "//               If allow_aysnc is true, the load will be asynchronous\n"
    "//               if possible.  This requires that the animation\n"
    "//               basename can be found in the PartBundle's preload\n"
    "//               table (see get_anim_preload()).\n"
    "//\n"
    "//               In an asynchronous load, the animation file will be\n"
    "//               loaded and bound in a sub-thread.  This means that\n"
    "//               the animation will not necessarily be available at\n"
    "//               the time this method returns.  You may still use the\n"
    "//               returned AnimControl immediately, though, but no\n"
    "//               visible effect will occur until the animation\n"
    "//               eventually becomes available.\n"
    "//\n"
    "//               You can test AnimControl::is_pending() to see if the\n"
    "//               animation has been loaded yet, or wait for it to\n"
    "//               finish with AnimControl::wait_pending() or even\n"
    "//               PartBundle::wait_pending().  You can also set an\n"
    "//               event to be triggered when the animation finishes\n"
    "//               loading with AnimControl::set_pending_done_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_load_bind_anim_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PartBundle::wait_pending(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_wait_pending_209(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PartBundle::wait_pending(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":waitPending", key_word_list));
        else
            (PyArg_Parse(args, ":waitPending"));
        if(!PyErr_Occurred())
        {
            (local_this)->wait_pending();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.waitPending() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "waitPending(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_wait_pending_209_comment =
    "C++ Interface:\n"
    "waitPending(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::wait_pending\n"
    "//       Access: Published\n"
    "//  Description: Blocks the current thread until all currently-pending\n"
    "//               AnimControls, with a nonzero control effect, have\n"
    "//               been loaded and are properly bound.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_wait_pending_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartBundle::freeze_joint(basic_string< char > const &joint_name, LVecBase3f const &pos, LVecBase3f const &hpr, LVecBase3f const &scale)
 * bool PartBundle::freeze_joint(basic_string< char > const &joint_name, TransformState const *transform)
 * bool PartBundle::freeze_joint(basic_string< char > const &joint_name, float value)
 *******************************************************************/
static PyObject *Dtool_PartBundle_freeze_joint_210(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PartBundle::freeze_joint(basic_string< char > const &joint_name, TransformState const *transform)
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"joint_name", (char *)"transform", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:freezeJoint", key_word_list, &param1_str, &param1_len, &param2))
                {
                    TransformState *param2_this = (TransformState *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TransformState, 2, "PartBundle.freezeJoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->freeze_joint(basic_string<char>(param1_str, param1_len), param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool PartBundle::freeze_joint(basic_string< char > const &joint_name, float value)
                char *param1_str; int param1_len;
                double param2;
                static char * key_word_list[] = {(char *)"joint_name", (char *)"value", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:freezeJoint", key_word_list, &param1_str, &param1_len, &param2))
                {
                    bool return_value = (local_this)->freeze_joint(basic_string<char>(param1_str, param1_len), (float)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool PartBundle::freeze_joint(basic_string< char > const &joint_name, LVecBase3f const &pos, LVecBase3f const &hpr, LVecBase3f const &scale)
                char *param1_str; int param1_len;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"joint_name", (char *)"pos", (char *)"hpr", (char *)"scale", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OOO:freezeJoint", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "PartBundle.freezeJoint", 1, coerced_ptr, report_errors);
LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "PartBundle.freezeJoint", 1, coerced_ptr, report_errors);
LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase3f, 4, "PartBundle.freezeJoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        bool return_value = (local_this)->freeze_joint(basic_string<char>(param1_str, param1_len), *param2_this, *param3_this, *param4_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PartBundle.freezeJoint() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "freezeJoint() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "freezeJoint(non-const PartBundle this, string joint_name, const TransformState transform)\n"
          "freezeJoint(non-const PartBundle this, string joint_name, float value)\n"
          "freezeJoint(non-const PartBundle this, string joint_name, const VBase3 pos, const VBase3 hpr, const VBase3 scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_freeze_joint_210_comment =
    "C++ Interface:\n"
    "freezeJoint(non-const PartBundle this, string joint_name, const TransformState transform)\n"
    "freezeJoint(non-const PartBundle this, string joint_name, float value)\n"
    "freezeJoint(non-const PartBundle this, string joint_name, const VBase3 pos, const VBase3 hpr, const VBase3 scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::freeze_joint\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the joint with the indicated name\n"
    "//               should be frozen with the specified transform.  It\n"
    "//               will henceforth always hold this fixed transform,\n"
    "//               regardless of any animations that may subsequently be\n"
    "//               bound to the joint.\n"
    "//\n"
    "//               Returns true if the joint is successfully frozen, or\n"
    "//               false if the named child is not a joint (or slider)\n"
    "//               or does not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::freeze_joint\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the joint with the indicated name\n"
    "//               should be frozen with the specified transform.  It\n"
    "//               will henceforth always hold this fixed transform,\n"
    "//               regardless of any animations that may subsequently be\n"
    "//               bound to the joint.\n"
    "//\n"
    "//               Returns true if the joint is successfully frozen, or\n"
    "//               false if the named child is not a joint (or slider)\n"
    "//               or does not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::freeze_joint\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the joint with the indicated name\n"
    "//               should be frozen with the specified transform.  It\n"
    "//               will henceforth always hold this fixed transform,\n"
    "//               regardless of any animations that may subsequently be\n"
    "//               bound to the joint.\n"
    "//\n"
    "//               Returns true if the joint is successfully frozen, or\n"
    "//               false if the named child is not a joint (or slider)\n"
    "//               or does not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_freeze_joint_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartBundle::control_joint(basic_string< char > const &joint_name, PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_PartBundle_control_joint_211(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PartBundle::control_joint(basic_string< char > const &joint_name, PandaNode *node)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"joint_name", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:controlJoint", key_word_list, &param1_str, &param1_len, &param2))
            {
                PandaNode *param2_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_PandaNode, 2, "PartBundle.controlJoint", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    bool return_value = (local_this)->control_joint(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundle.controlJoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "controlJoint(non-const PartBundle this, string joint_name, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_control_joint_211_comment =
    "C++ Interface:\n"
    "controlJoint(non-const PartBundle this, string joint_name, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::control_joint\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the joint with the indicated name\n"
    "//               should be animated with the transform on the\n"
    "//               indicated node.  It will henceforth always follow the\n"
    "//               node's transform, regardless of any animations that\n"
    "//               may subsequently be bound to the joint.\n"
    "//\n"
    "//               Returns true if the joint is successfully controlled,\n"
    "//               or false if the named child is not a joint (or\n"
    "//               slider) or does not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_control_joint_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartBundle::release_joint(basic_string< char > const &joint_name)
 *******************************************************************/
static PyObject *Dtool_PartBundle_release_joint_212(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool PartBundle::release_joint(basic_string< char > const &joint_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"joint_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:releaseJoint", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:releaseJoint", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->release_joint(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.releaseJoint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "releaseJoint(non-const PartBundle this, string joint_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_release_joint_212_comment =
    "C++ Interface:\n"
    "releaseJoint(non-const PartBundle this, string joint_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::release_joint\n"
    "//       Access: Published\n"
    "//  Description: Releases the named joint from the effects of a\n"
    "//               previous call to freeze_joint() or control_joint().\n"
    "//               It will henceforth once again follow whatever\n"
    "//               transforms are dictated by the animation.\n"
    "//\n"
    "//               Returns true if the joint is released, or false if\n"
    "//               the named child was not previously controlled or\n"
    "//               frozen, or it does not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_release_joint_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartBundle::update(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_update_213(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool PartBundle::update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":update", key_word_list));
        else
            (PyArg_Parse(args, ":update"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.update() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "update(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_update_213_comment =
    "C++ Interface:\n"
    "update(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::update\n"
    "//       Access: Published\n"
    "//  Description: Updates all the parts in the bundle to reflect the\n"
    "//               data for the current frame (as set in each of the\n"
    "//               AnimControls).\n"
    "//\n"
    "//               Returns true if any part has changed as a result of\n"
    "//               this, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_update_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PartBundle::force_update(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_force_update_214(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool PartBundle::force_update(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":forceUpdate", key_word_list));
        else
            (PyArg_Parse(args, ":forceUpdate"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->force_update();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundle.forceUpdate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceUpdate(non-const PartBundle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_force_update_214_comment =
    "C++ Interface:\n"
    "forceUpdate(non-const PartBundle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundle::force_update\n"
    "//       Access: Published\n"
    "//  Description: Updates all the parts in the bundle to reflect the\n"
    "//               data for the current frame, whether we believe it\n"
    "//               needs it or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundle_force_update_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PartBundle::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PartBundle_get_class_type_215(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PartBundle::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PartBundle::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundle_get_class_type_215_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PartBundle_get_class_type_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PartBundle::PartBundle(basic_string< char > const &name)
 * PartBundle::PartBundle(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_PartBundle(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PartBundle::PartBundle(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PartBundle", key_word_list))
            {
                PartBundle *return_value = new PartBundle();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PartBundle,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PartBundle::PartBundle(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PartBundle", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PartBundle", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PartBundle *return_value = new PartBundle(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PartBundle,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PartBundle() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PartBundle()\n"
          "PartBundle(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PartBundle_get_nodes(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumNodes", "getNode");
}
inline void  * Dtool_UpcastInterface_PartBundle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PartBundle)
    {
        printf("PartBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PartBundle * local_this = (PartBundle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PartBundle)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PartBundle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PartBundle)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PartBundle*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (PartBundle*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PartBundle*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PartBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PartBundle*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PartBundle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PartBundleHandle 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PartBundle *PartBundleHandle::get_bundle(void)
 *******************************************************************/
static PyObject *Dtool_PartBundleHandle_get_bundle_220(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundleHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundleHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PartBundle *PartBundleHandle::get_bundle(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBundle", key_word_list));
        else
            (PyArg_Parse(args, ":getBundle"));
        if(!PyErr_Occurred())
        {
            PartBundle *return_value = (local_this)->get_bundle();
            if (return_value != (PartBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PartBundleHandle.getBundle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBundle(non-const PartBundleHandle this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleHandle_get_bundle_220_comment =
    "C++ Interface:\n"
    "getBundle(non-const PartBundleHandle this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundleHandle::get_bundle\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual PartBundle embedded within the\n"
    "//               handle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundleHandle_get_bundle_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PartBundleHandle::set_bundle(PartBundle *bundle)
 *******************************************************************/
static PyObject *Dtool_PartBundleHandle_set_bundle_221(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundleHandle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundleHandle,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PartBundleHandle::set_bundle(PartBundle *bundle)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bundle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBundle", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setBundle", &param1));
            if(!PyErr_Occurred())
            {
                PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "PartBundleHandle.setBundle", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_bundle(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PartBundleHandle.setBundle() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBundle(non-const PartBundleHandle this, non-const PartBundle bundle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleHandle_set_bundle_221_comment =
    "C++ Interface:\n"
    "setBundle(non-const PartBundleHandle this, non-const PartBundle bundle)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundleHandle::set_bundle\n"
    "//       Access: Published\n"
    "//  Description: Changes the actual PartBundle embedded within the\n"
    "//               handle.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundleHandle_set_bundle_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
 *******************************************************************/
int  Dtool_Init_PartBundleHandle(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"bundle", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PartBundleHandle", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PartBundleHandle", &param0));
            if(!PyErr_Occurred())
            {
                PartBundle *param0_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PartBundle, 0, "PartBundleHandle.PartBundleHandle", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PartBundleHandle *return_value = new PartBundleHandle(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PartBundleHandle,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PartBundleHandle(non-const PartBundle bundle)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PartBundleHandle(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PartBundleHandle)
    {
        printf("PartBundleHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PartBundleHandle * local_this = (PartBundleHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PartBundleHandle)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PartBundleHandle(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PartBundleHandle)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PartBundleHandle*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PartBundleNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int PartBundleNode::get_num_bundles(void) const
 *******************************************************************/
static PyObject *Dtool_PartBundleNode_get_num_bundles_224(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundleNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundleNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PartBundleNode::get_num_bundles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBundles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBundles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PartBundleNode*)local_this)->get_num_bundles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBundles(const PartBundleNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleNode_get_num_bundles_224_comment =
    "C++ Interface:\n"
    "getNumBundles(const PartBundleNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundleNode::get_num_bundles\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundleNode_get_num_bundles_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundle *PartBundleNode::get_bundle(int n) const
 *******************************************************************/
static PyObject *Dtool_PartBundleNode_get_bundle_225(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundleNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundleNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PartBundle *PartBundleNode::get_bundle(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBundle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBundle", &param1));
        if(!PyErr_Occurred())
        {
            PartBundle *return_value = ((const PartBundleNode*)local_this)->get_bundle((int)param1);
            if (return_value != (PartBundle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PartBundle,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBundle(const PartBundleNode this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleNode_get_bundle_225_comment =
    "C++ Interface:\n"
    "getBundle(const PartBundleNode this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundleNode::get_bundle\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundleNode_get_bundle_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
 *******************************************************************/
static PyObject *Dtool_PartBundleNode_get_bundle_handle_226(PyObject *self, PyObject *args,PyObject *kwds) {
    PartBundleNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundleNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBundleHandle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBundleHandle", &param1));
        if(!PyErr_Occurred())
        {
            PartBundleHandle *return_value = ((const PartBundleNode*)local_this)->get_bundle_handle((int)param1);
            if (return_value != (PartBundleHandle *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PartBundleHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBundleHandle(const PartBundleNode this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleNode_get_bundle_handle_226_comment =
    "C++ Interface:\n"
    "getBundleHandle(const PartBundleNode this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PartBundleNode::get_bundle_handle\n"
    "//       Access: Public\n"
    "//  Description: Returns the PartBundleHandle that wraps around the\n"
    "//               actual nth PartBundle.  While the PartBundle pointer\n"
    "//               might later change due to a future flatten operation,\n"
    "//               the PartBundleHandle will not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PartBundleNode_get_bundle_handle_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PartBundleNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PartBundleNode_get_class_type_227(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PartBundleNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PartBundleNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PartBundleNode_get_class_type_227_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PartBundleNode_get_class_type_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PartBundleNode::PartBundleNode(basic_string< char > const &name, PartBundle *bundle)
 *******************************************************************/
int  Dtool_Init_PartBundleNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline PartBundleNode::PartBundleNode(basic_string< char > const &name, PartBundle *bundle)
            char *param0_str; int param0_len;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"name", (char *)"bundle", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:PartBundleNode", key_word_list, &param0_str, &param0_len, &param1))
            {
                PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PartBundle, 1, "PartBundleNode.PartBundleNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PartBundleNode *return_value = new PartBundleNode(basic_string<char>(param0_str, param0_len), param1_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PartBundleNode,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PartBundleNode(string name, non-const PartBundle bundle)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PartBundleNode_get_bundles(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumBundles", "getBundle");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PartBundleNode_get_bundle_handles(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumBundles", "getBundleHandle");
}
inline void  * Dtool_UpcastInterface_PartBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PartBundleNode)
    {
        printf("PartBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PartBundleNode * local_this = (PartBundleNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PartBundleNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PartBundleNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PartBundleNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PartBundleNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PartBundleNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PartBundleNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PartBundleNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovingPartBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int MovingPartBase::get_max_bound(void) const
 *******************************************************************/
static PyObject *Dtool_MovingPartBase_get_max_bound_229(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPartBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPartBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MovingPartBase::get_max_bound(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxBound", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxBound"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MovingPartBase*)local_this)->get_max_bound();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxBound(const MovingPartBase this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartBase_get_max_bound_229_comment =
    "C++ Interface:\n"
    "getMaxBound(const MovingPartBase this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovingPartBase::get_max_bound\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of channels that might be bound to\n"
    "//               this PartGroup.  This might not be the actual number\n"
    "//               of channels, since there might be holes in the list;\n"
    "//               it is one more than the index number of the highest\n"
    "//               bound channel.  Thus, it is called get_max_bound()\n"
    "//               instead of get_num_bound().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovingPartBase_get_max_bound_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AnimChannelBase *MovingPartBase::get_bound(int n) const
 *******************************************************************/
static PyObject *Dtool_MovingPartBase_get_bound_230(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPartBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPartBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AnimChannelBase *MovingPartBase::get_bound(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBound", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBound", &param1));
        if(!PyErr_Occurred())
        {
            AnimChannelBase *return_value = ((const MovingPartBase*)local_this)->get_bound((int)param1);
            if (return_value != (AnimChannelBase *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AnimChannelBase,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBound(const MovingPartBase this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartBase_get_bound_230_comment =
    "C++ Interface:\n"
    "getBound(const MovingPartBase this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MovingPartBase::get_bound\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth bound channel on this PartGroup.  n\n"
    "//               can be determined by iterating from 0 to one less\n"
    "//               than get_max_bound(); or n might be\n"
    "//               AnimControl::get_channel_index().\n"
    "//\n"
    "//               This will return NULL if there is no channel bound on\n"
    "//               the indicated index.  It is an error to call this if\n"
    "//               n is less than zero or greater than or equal to\n"
    "//               get_max_bound().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MovingPartBase_get_bound_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void MovingPartBase::output_value(ostream &out) const = 0
 *******************************************************************/
static PyObject *Dtool_MovingPartBase_output_value_231(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPartBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPartBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void MovingPartBase::output_value(ostream &out) const = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:outputValue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:outputValue", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MovingPartBase.outputValue", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MovingPartBase*)local_this)->output_value(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "outputValue(const MovingPartBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartBase_output_value_231_comment =
    "C++ Interface:\n"
    "outputValue(const MovingPartBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPartBase_output_value_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovingPartBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovingPartBase_get_class_type_232(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovingPartBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovingPartBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartBase_get_class_type_232_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPartBase_get_class_type_232_comment = NULL;
#endif

int  Dtool_Init_MovingPartBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MovingPartBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MovingPartBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovingPartBase)
    {
        printf("MovingPartBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovingPartBase * local_this = (MovingPartBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovingPartBase)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovingPartBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovingPartBase)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovingPartBase*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (MovingPartBase*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovingPartBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovingPartBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovingPartBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovingPartBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovingPartMatrix 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovingPartMatrix::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovingPartMatrix_get_class_type_240(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovingPartMatrix::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovingPartMatrix::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartMatrix_get_class_type_240_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPartMatrix_get_class_type_240_comment = NULL;
#endif

int  Dtool_Init_MovingPartMatrix(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MovingPartMatrix)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MovingPartMatrix(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovingPartMatrix)
    {
        printf("MovingPartMatrix ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovingPartMatrix * local_this = (MovingPartMatrix *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovingPartMatrix)
        return local_this;
    if(requested_type == &Dtool_MovingPart_ACMatrixSwitchType)
        return ( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACMatrixSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovingPartMatrix(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovingPartMatrix)
        return from_this;
    if(from_type == &Dtool_MovingPart_ACMatrixSwitchType)
    {
          MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovingPartMatrix*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovingPart< ACMatrixSwitchType > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::MovingPart< ACMatrixSwitchType >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_236(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::MovingPart< ACMatrixSwitchType >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::MovingPart< ACMatrixSwitchType >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_class_type_236_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_class_type_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f ::MovingPart< ACMatrixSwitchType >::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_value_237(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPart< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPart_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f ::MovingPart< ACMatrixSwitchType >::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const MovingPart< ACMatrixSwitchType >*)local_this)->get_value();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const MovingPart this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_value_237_comment =
    "C++ Interface:\n"
    "getValue(const MovingPart this)\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_value_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix4f ::MovingPart< ACMatrixSwitchType >::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_238(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPart< ACMatrixSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPart_ACMatrixSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix4f ::MovingPart< ACMatrixSwitchType >::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const MovingPart< ACMatrixSwitchType >*)local_this)->get_default_value();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const MovingPart this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_default_value_238_comment =
    "C++ Interface:\n"
    "getDefaultValue(const MovingPart this)\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACMatrixSwitchType_get_default_value_238_comment = NULL;
#endif

int  Dtool_Init_MovingPart_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MovingPart< ACMatrixSwitchType >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MovingPart_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovingPart_ACMatrixSwitchType)
    {
        printf("MovingPart_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovingPart< ACMatrixSwitchType > * local_this = (MovingPart< ACMatrixSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovingPart_ACMatrixSwitchType)
        return local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovingPart_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovingPart_ACMatrixSwitchType)
        return from_this;
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovingPart< ACMatrixSwitchType >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovingPartScalar 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MovingPartScalar::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovingPartScalar_get_class_type_247(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MovingPartScalar::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MovingPartScalar::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPartScalar_get_class_type_247_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPartScalar_get_class_type_247_comment = NULL;
#endif

int  Dtool_Init_MovingPartScalar(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MovingPartScalar)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MovingPartScalar(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovingPartScalar)
    {
        printf("MovingPartScalar ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovingPartScalar * local_this = (MovingPartScalar *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovingPartScalar)
        return local_this;
    if(requested_type == &Dtool_MovingPart_ACScalarSwitchType)
        return ( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *)( MovingPart< ACScalarSwitchType > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovingPartScalar(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovingPartScalar)
        return from_this;
    if(from_type == &Dtool_MovingPart_ACScalarSwitchType)
    {
          MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovingPartScalar*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovingPartScalar*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MovingPart< ACScalarSwitchType > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::MovingPart< ACScalarSwitchType >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_class_type_243(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::MovingPart< ACScalarSwitchType >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::MovingPart< ACScalarSwitchType >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACScalarSwitchType_get_class_type_243_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACScalarSwitchType_get_class_type_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ::MovingPart< ACScalarSwitchType >::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_value_244(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPart< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPart_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ::MovingPart< ACScalarSwitchType >::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MovingPart< ACScalarSwitchType >*)local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const MovingPart this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACScalarSwitchType_get_value_244_comment =
    "C++ Interface:\n"
    "getValue(const MovingPart this)\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACScalarSwitchType_get_value_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float ::MovingPart< ACScalarSwitchType >::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_default_value_245(PyObject *self, PyObject *args,PyObject *kwds) {
    MovingPart< ACScalarSwitchType > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MovingPart_ACScalarSwitchType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float ::MovingPart< ACScalarSwitchType >::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MovingPart< ACScalarSwitchType >*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const MovingPart this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MovingPart_ACScalarSwitchType_get_default_value_245_comment =
    "C++ Interface:\n"
    "getDefaultValue(const MovingPart this)\n"
    "\n"
    "";
#else
static const char * Dtool_MovingPart_ACScalarSwitchType_get_default_value_245_comment = NULL;
#endif

int  Dtool_Init_MovingPart_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MovingPart< ACScalarSwitchType >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MovingPart_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MovingPart_ACScalarSwitchType)
    {
        printf("MovingPart_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MovingPart< ACScalarSwitchType > * local_this = (MovingPart< ACScalarSwitchType > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MovingPart_ACScalarSwitchType)
        return local_this;
    if(requested_type == &Dtool_MovingPartBase)
        return ( MovingPartBase *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_PartGroup)
        return ( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( PartGroup *)( MovingPartBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MovingPart_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MovingPart_ACScalarSwitchType)
        return from_this;
    if(from_type == &Dtool_MovingPartBase)
    {
          MovingPartBase* other_this = (MovingPartBase*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_PartGroup)
    {
          PartGroup* other_this = (PartGroup*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MovingPart< ACScalarSwitchType >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. AnimGroup | AnimGroup
//********************************************************************
PyMethodDef Dtool_Methods_AnimGroup[]= {
  { "getNumChildren",(PyCFunction ) &Dtool_AnimGroup_get_num_children_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_get_num_children_10_comment},
  { "getChild",(PyCFunction ) &Dtool_AnimGroup_get_child_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_get_child_11_comment},
  { "findChild",(PyCFunction ) &Dtool_AnimGroup_find_child_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_find_child_12_comment},
  { "output",(PyCFunction ) &Dtool_AnimGroup_output_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_output_13_comment},
  { "write",(PyCFunction ) &Dtool_AnimGroup_write_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_write_14_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimGroup_get_class_type_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_get_class_type_15_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_AnimGroup_upcast_to_Namable_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimGroup_upcast_to_Namable_6_comment},
  { "getChildren",(PyCFunction) &MakeSeq_AnimGroup_get_children, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AnimGroup
//////////////////
static PyObject *  Dtool_Repr_AnimGroup(PyObject * self)
{
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AnimGroup
//////////////////
static PyObject *  Dtool_Str_AnimGroup(PyObject * self)
{
    AnimGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimGroup,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AnimGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimGroup\n"
          "// Description : This is the base class for AnimChannel and\n"
          "//               AnimBundle.  It implements a hierarchy of\n"
          "//               AnimChannels.  The root of the hierarchy must be an\n"
          "//               AnimBundle.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_AnimGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_AnimGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimGroup.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AnimGroup.As_PyTypeObject().tp_repr = & Dtool_Repr_AnimGroup;
        // __str__
        Dtool_AnimGroup.As_PyTypeObject().tp_str = & Dtool_Str_AnimGroup;
        if(PyType_Ready(&Dtool_AnimGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimGroup)");
             printf(" Error In PyType_ReadyAnimGroup");
             return;
        }
        Py_INCREF(&Dtool_AnimGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimGroup.As_PyTypeObject().tp_dict,"AnimGroup",&Dtool_AnimGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimGroup[5],&Dtool_AnimGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimGroup,AnimGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimGroup.As_PyTypeObject());
        PyModule_AddObject(module, "AnimGroup",(PyObject *)&Dtool_AnimGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimBundle | AnimBundle
//********************************************************************
PyMethodDef Dtool_Methods_AnimBundle[]= {
  { "copyBundle",(PyCFunction ) &Dtool_AnimBundle_copy_bundle_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundle_copy_bundle_18_comment},
  { "getBaseFrameRate",(PyCFunction ) &Dtool_AnimBundle_get_base_frame_rate_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundle_get_base_frame_rate_19_comment},
  { "getNumFrames",(PyCFunction ) &Dtool_AnimBundle_get_num_frames_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundle_get_num_frames_20_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimBundle_get_class_type_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundle_get_class_type_21_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimBundle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimBundle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimBundle\n"
          "// Description : This is the root of an AnimChannel hierarchy.  It\n"
          "//               knows the frame rate and number of frames of all the\n"
          "//               channels in the hierarchy (which must all match).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimGroup._Dtool_ClassInit(NULL);
        Dtool_AnimBundle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimGroup.As_PyTypeObject());
        Dtool_AnimBundle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimBundle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimBundle.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimBundle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimBundle)");
             printf(" Error In PyType_ReadyAnimBundle");
             return;
        }
        Py_INCREF(&Dtool_AnimBundle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimBundle.As_PyTypeObject().tp_dict,"AnimBundle",&Dtool_AnimBundle.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimBundle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimBundle[3],&Dtool_AnimBundle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimBundle,AnimBundle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimBundle.As_PyTypeObject());
        PyModule_AddObject(module, "AnimBundle",(PyObject *)&Dtool_AnimBundle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimBundleNode | AnimBundleNode
//********************************************************************
PyMethodDef Dtool_Methods_AnimBundleNode[]= {
  { "getBundle",(PyCFunction ) &Dtool_AnimBundleNode_get_bundle_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundleNode_get_bundle_26_comment},
  { "findAnimBundle",(PyCFunction ) &Dtool_AnimBundleNode_find_anim_bundle_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundleNode_find_anim_bundle_27_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimBundleNode_get_class_type_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimBundleNode_get_class_type_28_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimBundleNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimBundleNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimBundleNode\n"
          "// Description : This is a node that contains a pointer to an\n"
          "//               AnimBundle.  Like PartBundleNode, it exists solely to\n"
          "//               make it easy to store AnimBundles in the scene graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_AnimBundleNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_AnimBundleNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimBundleNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimBundleNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimBundleNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimBundleNode)");
             printf(" Error In PyType_ReadyAnimBundleNode");
             return;
        }
        Py_INCREF(&Dtool_AnimBundleNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimBundleNode.As_PyTypeObject().tp_dict,"AnimBundleNode",&Dtool_AnimBundleNode.As_PyObject());
        //  Static Method findAnimBundle
        PyDict_SetItemString(Dtool_AnimBundleNode.As_PyTypeObject().tp_dict,"findAnimBundle",PyCFunction_New(&Dtool_Methods_AnimBundleNode[1],&Dtool_AnimBundleNode.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimBundleNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimBundleNode[2],&Dtool_AnimBundleNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimBundleNode,AnimBundleNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimBundleNode.As_PyTypeObject());
        PyModule_AddObject(module, "AnimBundleNode",(PyObject *)&Dtool_AnimBundleNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PartGroup | PartGroup
//********************************************************************
PyMethodDef Dtool_Methods_PartGroup[]= {
  { "isCharacterJoint",(PyCFunction ) &Dtool_PartGroup_is_character_joint_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_is_character_joint_37_comment},
  { "makeCopy",(PyCFunction ) &Dtool_PartGroup_make_copy_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_make_copy_38_comment},
  { "copySubgraph",(PyCFunction ) &Dtool_PartGroup_copy_subgraph_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_copy_subgraph_39_comment},
  { "getNumChildren",(PyCFunction ) &Dtool_PartGroup_get_num_children_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_get_num_children_40_comment},
  { "getChild",(PyCFunction ) &Dtool_PartGroup_get_child_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_get_child_41_comment},
  { "findChild",(PyCFunction ) &Dtool_PartGroup_find_child_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_find_child_42_comment},
  { "applyFreeze",(PyCFunction ) &Dtool_PartGroup_apply_freeze_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_apply_freeze_43_comment},
  { "applyFreezeMatrix",(PyCFunction ) &Dtool_PartGroup_apply_freeze_matrix_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_apply_freeze_matrix_44_comment},
  { "applyFreezeScalar",(PyCFunction ) &Dtool_PartGroup_apply_freeze_scalar_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_apply_freeze_scalar_45_comment},
  { "applyControl",(PyCFunction ) &Dtool_PartGroup_apply_control_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_apply_control_46_comment},
  { "clearForcedChannel",(PyCFunction ) &Dtool_PartGroup_clear_forced_channel_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_clear_forced_channel_47_comment},
  { "getForcedChannel",(PyCFunction ) &Dtool_PartGroup_get_forced_channel_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_get_forced_channel_48_comment},
  { "write",(PyCFunction ) &Dtool_PartGroup_write_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_write_49_comment},
  { "writeWithValue",(PyCFunction ) &Dtool_PartGroup_write_with_value_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_write_with_value_50_comment},
  { "getClassType",(PyCFunction ) &Dtool_PartGroup_get_class_type_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_get_class_type_51_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_31_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_PartGroup_upcast_to_Namable_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartGroup_upcast_to_Namable_33_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getChildren",(PyCFunction) &MakeSeq_PartGroup_get_children, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     PartGroup
//////////////////
static PyObject *  Dtool_Str_PartGroup(PyObject * self)
{
    PartGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartGroup,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PartGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PartGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PartGroup\n"
          "// Description : This is the base class for PartRoot and\n"
          "//               MovingPart.  It defines a hierarchy of MovingParts.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_PartGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_PartGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PartGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PartGroup.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_PartGroup.As_PyTypeObject().tp_str = & Dtool_Str_PartGroup;
        if(PyType_Ready(&Dtool_PartGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PartGroup)");
             printf(" Error In PyType_ReadyPartGroup");
             return;
        }
        Py_INCREF(&Dtool_PartGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PartGroup.As_PyTypeObject().tp_dict,"PartGroup",&Dtool_PartGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PartGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PartGroup[14],&Dtool_PartGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PartGroup,PartGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PartGroup.As_PyTypeObject());
        PyModule_AddObject(module, "PartGroup",(PyObject *)&Dtool_PartGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimControl | AnimControl
//********************************************************************
PyMethodDef Dtool_Methods_AnimControl[]= {
  { "isPending",(PyCFunction ) &Dtool_AnimControl_is_pending_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_is_pending_62_comment},
  { "waitPending",(PyCFunction ) &Dtool_AnimControl_wait_pending_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_wait_pending_63_comment},
  { "hasAnim",(PyCFunction ) &Dtool_AnimControl_has_anim_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_has_anim_64_comment},
  { "setPendingDoneEvent",(PyCFunction ) &Dtool_AnimControl_set_pending_done_event_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_set_pending_done_event_65_comment},
  { "getPendingDoneEvent",(PyCFunction ) &Dtool_AnimControl_get_pending_done_event_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_pending_done_event_66_comment},
  { "getPart",(PyCFunction ) &Dtool_AnimControl_get_part_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_part_67_comment},
  { "getAnim",(PyCFunction ) &Dtool_AnimControl_get_anim_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_anim_68_comment},
  { "getChannelIndex",(PyCFunction ) &Dtool_AnimControl_get_channel_index_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_channel_index_69_comment},
  { "getBoundJoints",(PyCFunction ) &Dtool_AnimControl_get_bound_joints_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_bound_joints_70_comment},
  { "setAnimModel",(PyCFunction ) &Dtool_AnimControl_set_anim_model_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_set_anim_model_71_comment},
  { "getAnimModel",(PyCFunction ) &Dtool_AnimControl_get_anim_model_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_anim_model_72_comment},
  { "output",(PyCFunction ) &Dtool_AnimControl_output_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_output_73_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimControl_get_class_type_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_get_class_type_74_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_AnimControl_upcast_to_TypedReferenceCount_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_upcast_to_TypedReferenceCount_54_comment},
  { "upcastToAnimInterface",(PyCFunction ) &Dtool_AnimControl_upcast_to_AnimInterface_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_upcast_to_AnimInterface_57_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_AnimControl_upcast_to_Namable_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControl_upcast_to_Namable_59_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AnimControl
//////////////////
static PyObject *  Dtool_Repr_AnimControl(PyObject * self)
{
    AnimControl * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControl,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AnimControl(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimControl.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimControl\n"
          "// Description : Controls the timing of a character animation.  An\n"
          "//               AnimControl object is created for each\n"
          "//               character/bundle binding and manages the state of the\n"
          "//               animation: whether started, stopped, or looping, and\n"
          "//               the current frame number and play rate.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_AnimInterface._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_AnimControl.As_PyTypeObject().tp_bases = Py_BuildValue("(OOO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_AnimInterface.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_AnimControl.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimControl.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimControl.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AnimControl.As_PyTypeObject().tp_repr = & Dtool_Repr_AnimControl;
        // __str__ Repr Proxy
        Dtool_AnimControl.As_PyTypeObject().tp_str = & Dtool_Repr_AnimControl;
        if(PyType_Ready(&Dtool_AnimControl.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimControl)");
             printf(" Error In PyType_ReadyAnimControl");
             return;
        }
        Py_INCREF(&Dtool_AnimControl.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimControl.As_PyTypeObject().tp_dict,"AnimControl",&Dtool_AnimControl.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimControl.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimControl[12],&Dtool_AnimControl.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimControl,AnimControl::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimControl.As_PyTypeObject());
        PyModule_AddObject(module, "AnimControl",(PyObject *)&Dtool_AnimControl.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannelBase | AnimChannelBase
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannelBase[]= {
  { "getType",(PyCFunction ) &Dtool_AnimChannelBase_get_type_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelBase_get_type_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannelBase_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelBase_get_class_type_77_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannelBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimChannelBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimChannelBase\n"
          "// Description : Parent class for all animation channels.  An\n"
          "//               AnimChannel is an arbitrary function that changes\n"
          "//               over time (actually, over frames), usually defined by\n"
          "//               a table read from an egg file (but possibly computed\n"
          "//               or generated in any other way).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimGroup._Dtool_ClassInit(NULL);
        Dtool_AnimChannelBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimGroup.As_PyTypeObject());
        Dtool_AnimChannelBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannelBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannelBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannelBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannelBase)");
             printf(" Error In PyType_ReadyAnimChannelBase");
             return;
        }
        Py_INCREF(&Dtool_AnimChannelBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannelBase.As_PyTypeObject().tp_dict,"AnimChannelBase",&Dtool_AnimChannelBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannelBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannelBase[1],&Dtool_AnimChannelBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannelBase,AnimChannelBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannelBase.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelBase",(PyObject *)&Dtool_AnimChannelBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannel_ACMatrixSwitchType | AnimChannelACMatrixSwitchType
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannel_ACMatrixSwitchType[]= {
  { "getValue",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_80_comment},
  { "getValueNoScaleShear",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_81_comment},
  { "getScale",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_scale_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_scale_82_comment},
  { "getHpr",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_83_comment},
  { "getQuat",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_quat_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_quat_84_comment},
  { "getPos",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_pos_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_pos_85_comment},
  { "getShear",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_shear_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_shear_86_comment},
  { "getValueType",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_87_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_88_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_AnimChannelBase._Dtool_ClassInit(NULL);
        Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannelBase.As_PyTypeObject());
        Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannel_ACMatrixSwitchType)");
             printf(" Error In PyType_ReadyAnimChannel_ACMatrixSwitchType");
             return;
        }
        Py_INCREF(&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"AnimChannelACMatrixSwitchType",&Dtool_AnimChannel_ACMatrixSwitchType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannel_ACMatrixSwitchType[8],&Dtool_AnimChannel_ACMatrixSwitchType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannel_ACMatrixSwitchType,AnimChannel< ACMatrixSwitchType >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelACMatrixSwitchType",(PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannel_ACScalarSwitchType | AnimChannelACScalarSwitchType
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannel_ACScalarSwitchType[]= {
  { "getScale",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_scale_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_scale_92_comment},
  { "getHpr",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_hpr_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_hpr_93_comment},
  { "getQuat",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_quat_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_quat_94_comment},
  { "getPos",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_pos_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_pos_95_comment},
  { "getShear",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_shear_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_shear_96_comment},
  { "getValueType",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_value_type_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_value_type_97_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannel_ACScalarSwitchType_get_class_type_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannel_ACScalarSwitchType_get_class_type_98_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_AnimChannelBase._Dtool_ClassInit(NULL);
        Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannelBase.As_PyTypeObject());
        Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannel_ACScalarSwitchType)");
             printf(" Error In PyType_ReadyAnimChannel_ACScalarSwitchType");
             return;
        }
        Py_INCREF(&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_dict,"AnimChannelACScalarSwitchType",&Dtool_AnimChannel_ACScalarSwitchType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannel_ACScalarSwitchType[6],&Dtool_AnimChannel_ACScalarSwitchType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannel_ACScalarSwitchType,AnimChannel< ACScalarSwitchType >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelACScalarSwitchType",(PyObject *)&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannelMatrixDynamic | AnimChannelMatrixDynamic
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannelMatrixDynamic[]= {
  { "setValue",(PyCFunction ) &Dtool_AnimChannelMatrixDynamic_set_value_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixDynamic_set_value_100_comment},
  { "setValueNode",(PyCFunction ) &Dtool_AnimChannelMatrixDynamic_set_value_node_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixDynamic_set_value_node_101_comment},
  { "getValueTransform",(PyCFunction ) &Dtool_AnimChannelMatrixDynamic_get_value_transform_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixDynamic_get_value_transform_102_comment},
  { "getValueNode",(PyCFunction ) &Dtool_AnimChannelMatrixDynamic_get_value_node_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixDynamic_get_value_node_103_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannelMatrixDynamic_get_class_type_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixDynamic_get_class_type_104_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimChannelMatrixDynamic\n"
          "// Description : An animation channel that accepts a matrix each frame\n"
          "//               from some dynamic input provided by code.\n"
          "//\n"
          "//               This object operates in two modes: in explicit mode,\n"
          "//               the programmer should call set_value() each frame to\n"
          "//               indicate the new value; in implicit mode, the\n"
          "//               programmer should call set_value_node() to indicate\n"
          "//               the node whose transform will be copied to the joint\n"
          "//               each frame.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimChannel_ACMatrixSwitchType._Dtool_ClassInit(NULL);
        Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject());
        Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannelMatrixDynamic.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannelMatrixDynamic)");
             printf(" Error In PyType_ReadyAnimChannelMatrixDynamic");
             return;
        }
        Py_INCREF(&Dtool_AnimChannelMatrixDynamic.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_dict,"AnimChannelMatrixDynamic",&Dtool_AnimChannelMatrixDynamic.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannelMatrixDynamic.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannelMatrixDynamic[4],&Dtool_AnimChannelMatrixDynamic.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannelMatrixDynamic,AnimChannelMatrixDynamic::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannelMatrixDynamic.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelMatrixDynamic",(PyObject *)&Dtool_AnimChannelMatrixDynamic.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannelMatrixXfmTable | AnimChannelMatrixXfmTable
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannelMatrixXfmTable[]= {
  { "isValidId",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_is_valid_id_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_is_valid_id_108_comment},
  { "setTable",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_set_table_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_set_table_109_comment},
  { "getTable",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_get_table_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_get_table_110_comment},
  { "clearAllTables",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_clear_all_tables_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_clear_all_tables_111_comment},
  { "hasTable",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_has_table_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_has_table_112_comment},
  { "clearTable",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_clear_table_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_clear_table_113_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannelMatrixXfmTable_get_class_type_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelMatrixXfmTable_get_class_type_114_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimChannelMatrixXfmTable\n"
          "// Description : An animation channel that issues a matrix each frame,\n"
          "//               read from a table such as might have been read from\n"
          "//               an egg file.  The table actually consists of nine\n"
          "//               sub-tables, each representing one component of the\n"
          "//               transform: scale, rotate, translate.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimChannel_ACMatrixSwitchType._Dtool_ClassInit(NULL);
        Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannel_ACMatrixSwitchType.As_PyTypeObject());
        Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannelMatrixXfmTable)");
             printf(" Error In PyType_ReadyAnimChannelMatrixXfmTable");
             return;
        }
        Py_INCREF(&Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict,"AnimChannelMatrixXfmTable",&Dtool_AnimChannelMatrixXfmTable.As_PyObject());
        //  Static Method isValidId
        PyDict_SetItemString(Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict,"isValidId",PyCFunction_New(&Dtool_Methods_AnimChannelMatrixXfmTable[0],&Dtool_AnimChannelMatrixXfmTable.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannelMatrixXfmTable[6],&Dtool_AnimChannelMatrixXfmTable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannelMatrixXfmTable,AnimChannelMatrixXfmTable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelMatrixXfmTable",(PyObject *)&Dtool_AnimChannelMatrixXfmTable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannelScalarDynamic | AnimChannelScalarDynamic
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannelScalarDynamic[]= {
  { "setValue",(PyCFunction ) &Dtool_AnimChannelScalarDynamic_set_value_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarDynamic_set_value_116_comment},
  { "setValueNode",(PyCFunction ) &Dtool_AnimChannelScalarDynamic_set_value_node_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarDynamic_set_value_node_117_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannelScalarDynamic_get_class_type_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarDynamic_get_class_type_118_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannelScalarDynamic(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimChannelScalarDynamic\n"
          "// Description : An animation channel that accepts a scalar each frame\n"
          "//               from some dynamic input provided by code.\n"
          "//\n"
          "//               This object operates in two modes: in explicit mode,\n"
          "//               the programmer should call set_value() each frame to\n"
          "//               indicate the new value; in implicit mode, the\n"
          "//               programmer should call set_value_node() to indicate\n"
          "//               the node whose X component will be copied to the\n"
          "//               scalar each frame.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimChannel_ACScalarSwitchType._Dtool_ClassInit(NULL);
        Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject());
        Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannelScalarDynamic.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannelScalarDynamic)");
             printf(" Error In PyType_ReadyAnimChannelScalarDynamic");
             return;
        }
        Py_INCREF(&Dtool_AnimChannelScalarDynamic.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_dict,"AnimChannelScalarDynamic",&Dtool_AnimChannelScalarDynamic.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannelScalarDynamic.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannelScalarDynamic[2],&Dtool_AnimChannelScalarDynamic.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannelScalarDynamic,AnimChannelScalarDynamic::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannelScalarDynamic.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelScalarDynamic",(PyObject *)&Dtool_AnimChannelScalarDynamic.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimChannelScalarTable | AnimChannelScalarTable
//********************************************************************
PyMethodDef Dtool_Methods_AnimChannelScalarTable[]= {
  { "setTable",(PyCFunction ) &Dtool_AnimChannelScalarTable_set_table_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarTable_set_table_121_comment},
  { "getTable",(PyCFunction ) &Dtool_AnimChannelScalarTable_get_table_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarTable_get_table_122_comment},
  { "hasTable",(PyCFunction ) &Dtool_AnimChannelScalarTable_has_table_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarTable_has_table_123_comment},
  { "clearTable",(PyCFunction ) &Dtool_AnimChannelScalarTable_clear_table_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarTable_clear_table_124_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimChannelScalarTable_get_class_type_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimChannelScalarTable_get_class_type_125_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AnimChannelScalarTable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimChannelScalarTable\n"
          "// Description : An animation channel that issues a scalar each frame,\n"
          "//               read from a table such as might have been read from\n"
          "//               an egg file.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AnimChannel_ACScalarSwitchType._Dtool_ClassInit(NULL);
        Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AnimChannel_ACScalarSwitchType.As_PyTypeObject());
        Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AnimChannelScalarTable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimChannelScalarTable)");
             printf(" Error In PyType_ReadyAnimChannelScalarTable");
             return;
        }
        Py_INCREF(&Dtool_AnimChannelScalarTable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_dict,"AnimChannelScalarTable",&Dtool_AnimChannelScalarTable.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimChannelScalarTable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimChannelScalarTable[4],&Dtool_AnimChannelScalarTable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimChannelScalarTable,AnimChannelScalarTable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimChannelScalarTable.As_PyTypeObject());
        PyModule_AddObject(module, "AnimChannelScalarTable",(PyObject *)&Dtool_AnimChannelScalarTable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimControlCollection | AnimControlCollection
//********************************************************************
PyMethodDef Dtool_Methods_AnimControlCollection[]= {
  { "storeAnim",(PyCFunction ) &Dtool_AnimControlCollection_store_anim_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_store_anim_130_comment},
  { "findAnim",(PyCFunction ) &Dtool_AnimControlCollection_find_anim_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_find_anim_131_comment},
  { "unbindAnim",(PyCFunction ) &Dtool_AnimControlCollection_unbind_anim_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_unbind_anim_132_comment},
  { "getNumAnims",(PyCFunction ) &Dtool_AnimControlCollection_get_num_anims_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_get_num_anims_133_comment},
  { "getAnim",(PyCFunction ) &Dtool_AnimControlCollection_get_anim_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_get_anim_134_comment},
  { "getAnimName",(PyCFunction ) &Dtool_AnimControlCollection_get_anim_name_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_get_anim_name_135_comment},
  { "clearAnims",(PyCFunction ) &Dtool_AnimControlCollection_clear_anims_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_clear_anims_136_comment},
  { "play",(PyCFunction ) &Dtool_AnimControlCollection_play_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_play_137_comment},
  { "loop",(PyCFunction ) &Dtool_AnimControlCollection_loop_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_loop_138_comment},
  { "stop",(PyCFunction ) &Dtool_AnimControlCollection_stop_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_stop_139_comment},
  { "pose",(PyCFunction ) &Dtool_AnimControlCollection_pose_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_pose_140_comment},
  { "playAll",(PyCFunction ) &Dtool_AnimControlCollection_play_all_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_play_all_141_comment},
  { "loopAll",(PyCFunction ) &Dtool_AnimControlCollection_loop_all_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_loop_all_142_comment},
  { "stopAll",(PyCFunction ) &Dtool_AnimControlCollection_stop_all_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_stop_all_143_comment},
  { "poseAll",(PyCFunction ) &Dtool_AnimControlCollection_pose_all_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_pose_all_144_comment},
  { "getFrame",(PyCFunction ) &Dtool_AnimControlCollection_get_frame_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_get_frame_145_comment},
  { "getNumFrames",(PyCFunction ) &Dtool_AnimControlCollection_get_num_frames_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_get_num_frames_146_comment},
  { "isPlaying",(PyCFunction ) &Dtool_AnimControlCollection_is_playing_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_is_playing_147_comment},
  { "whichAnimPlaying",(PyCFunction ) &Dtool_AnimControlCollection_which_anim_playing_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_which_anim_playing_148_comment},
  { "output",(PyCFunction ) &Dtool_AnimControlCollection_output_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_output_149_comment},
  { "write",(PyCFunction ) &Dtool_AnimControlCollection_write_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimControlCollection_write_150_comment},
  { "getAnims",(PyCFunction) &MakeSeq_AnimControlCollection_get_anims, METH_NOARGS, NULL},
  { "getAnimNames",(PyCFunction) &MakeSeq_AnimControlCollection_get_anim_names, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AnimControlCollection
//////////////////
static PyObject *  Dtool_Repr_AnimControlCollection(PyObject * self)
{
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AnimControlCollection
//////////////////
static PyObject *  Dtool_Str_AnimControlCollection(PyObject * self)
{
    AnimControlCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimControlCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AnimControlCollection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimControlCollection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimControlCollection\n"
          "// Description : This is a named collection of AnimControl pointers.\n"
          "//               An AnimControl may be added to the collection by\n"
          "//               name.  While an AnimControl is associated, its\n"
          "//               reference count is maintained; associating a new\n"
          "//               AnimControl with the same name will decrement the\n"
          "//               previous control's reference count (and possibly\n"
          "//               delete it, unbinding its animation).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_AnimControlCollection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_AnimControlCollection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimControlCollection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimControlCollection.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AnimControlCollection.As_PyTypeObject().tp_repr = & Dtool_Repr_AnimControlCollection;
        // __str__
        Dtool_AnimControlCollection.As_PyTypeObject().tp_str = & Dtool_Str_AnimControlCollection;
        if(PyType_Ready(&Dtool_AnimControlCollection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimControlCollection)");
             printf(" Error In PyType_ReadyAnimControlCollection");
             return;
        }
        Py_INCREF(&Dtool_AnimControlCollection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimControlCollection.As_PyTypeObject().tp_dict,"AnimControlCollection",&Dtool_AnimControlCollection.As_PyObject());
        RegisterRuntimeClass(&Dtool_AnimControlCollection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimControlCollection.As_PyTypeObject());
        PyModule_AddObject(module, "AnimControlCollection",(PyObject *)&Dtool_AnimControlCollection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AnimPreloadTable | AnimPreloadTable
//********************************************************************
PyMethodDef Dtool_Methods_AnimPreloadTable[]= {
  { "getNumAnims",(PyCFunction ) &Dtool_AnimPreloadTable_get_num_anims_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_get_num_anims_154_comment},
  { "findAnim",(PyCFunction ) &Dtool_AnimPreloadTable_find_anim_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_find_anim_155_comment},
  { "getBasename",(PyCFunction ) &Dtool_AnimPreloadTable_get_basename_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_get_basename_156_comment},
  { "getBaseFrameRate",(PyCFunction ) &Dtool_AnimPreloadTable_get_base_frame_rate_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_get_base_frame_rate_157_comment},
  { "getNumFrames",(PyCFunction ) &Dtool_AnimPreloadTable_get_num_frames_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_get_num_frames_158_comment},
  { "clearAnims",(PyCFunction ) &Dtool_AnimPreloadTable_clear_anims_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_clear_anims_159_comment},
  { "removeAnim",(PyCFunction ) &Dtool_AnimPreloadTable_remove_anim_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_remove_anim_160_comment},
  { "addAnim",(PyCFunction ) &Dtool_AnimPreloadTable_add_anim_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_add_anim_161_comment},
  { "addAnimsFrom",(PyCFunction ) &Dtool_AnimPreloadTable_add_anims_from_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_add_anims_from_162_comment},
  { "output",(PyCFunction ) &Dtool_AnimPreloadTable_output_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_output_163_comment},
  { "write",(PyCFunction ) &Dtool_AnimPreloadTable_write_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_write_164_comment},
  { "getClassType",(PyCFunction ) &Dtool_AnimPreloadTable_get_class_type_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AnimPreloadTable_get_class_type_165_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AnimPreloadTable
//////////////////
static PyObject *  Dtool_Repr_AnimPreloadTable(PyObject * self)
{
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AnimPreloadTable
//////////////////
static PyObject *  Dtool_Str_AnimPreloadTable(PyObject * self)
{
    AnimPreloadTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AnimPreloadTable,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AnimPreloadTable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AnimPreloadTable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AnimPreloadTable\n"
          "// Description : This table records data about a list of animations\n"
          "//               for a particular model, such as number of frames and\n"
          "//               frame rate.  It's used for implementating\n"
          "//               asynchronous binding.\n"
          "//\n"
          "//               This table is normally built by an offline tool, such\n"
          "//               as egg-optchar.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CopyOnWriteObject._Dtool_ClassInit(NULL);
        Dtool_AnimPreloadTable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CopyOnWriteObject.As_PyTypeObject());
        Dtool_AnimPreloadTable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AnimPreloadTable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AnimPreloadTable.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AnimPreloadTable.As_PyTypeObject().tp_repr = & Dtool_Repr_AnimPreloadTable;
        // __str__
        Dtool_AnimPreloadTable.As_PyTypeObject().tp_str = & Dtool_Str_AnimPreloadTable;
        if(PyType_Ready(&Dtool_AnimPreloadTable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AnimPreloadTable)");
             printf(" Error In PyType_ReadyAnimPreloadTable");
             return;
        }
        Py_INCREF(&Dtool_AnimPreloadTable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AnimPreloadTable.As_PyTypeObject().tp_dict,"AnimPreloadTable",&Dtool_AnimPreloadTable.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AnimPreloadTable.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AnimPreloadTable[11],&Dtool_AnimPreloadTable.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AnimPreloadTable,AnimPreloadTable::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AnimPreloadTable.As_PyTypeObject());
        PyModule_AddObject(module, "AnimPreloadTable",(PyObject *)&Dtool_AnimPreloadTable.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PartSubset | PartSubset
//********************************************************************
PyMethodDef Dtool_Methods_PartSubset[]= {
  { "assign",(PyCFunction ) &Dtool_PartSubset_operator_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_operator_169_comment},
  { "addIncludeJoint",(PyCFunction ) &Dtool_PartSubset_add_include_joint_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_add_include_joint_170_comment},
  { "addExcludeJoint",(PyCFunction ) &Dtool_PartSubset_add_exclude_joint_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_add_exclude_joint_171_comment},
  { "append",(PyCFunction ) &Dtool_PartSubset_append_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_append_172_comment},
  { "output",(PyCFunction ) &Dtool_PartSubset_output_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_output_173_comment},
  { "isIncludeEmpty",(PyCFunction ) &Dtool_PartSubset_is_include_empty_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_is_include_empty_174_comment},
  { "matchesInclude",(PyCFunction ) &Dtool_PartSubset_matches_include_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_matches_include_175_comment},
  { "matchesExclude",(PyCFunction ) &Dtool_PartSubset_matches_exclude_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartSubset_matches_exclude_176_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PartSubset
//////////////////
static PyObject *  Dtool_Repr_PartSubset(PyObject * self)
{
    PartSubset * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartSubset,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PartSubset(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PartSubset.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PartSubset\n"
          "// Description : This class is used to define a subset of part names\n"
          "//               to apply to the PartBundle::bind_anim() operation.\n"
          "//               Only those part names within the subset will be\n"
          "//               included in the bind.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PartSubset.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PartSubset.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PartSubset.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PartSubset.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PartSubset.As_PyTypeObject().tp_repr = & Dtool_Repr_PartSubset;
        // __str__ Repr Proxy
        Dtool_PartSubset.As_PyTypeObject().tp_str = & Dtool_Repr_PartSubset;
        if(PyType_Ready(&Dtool_PartSubset.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PartSubset)");
             printf(" Error In PyType_ReadyPartSubset");
             return;
        }
        Py_INCREF(&Dtool_PartSubset.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PartSubset.As_PyTypeObject().tp_dict,"PartSubset",&Dtool_PartSubset.As_PyObject());
        RegisterRuntimeClass(&Dtool_PartSubset,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PartSubset.As_PyTypeObject());
        PyModule_AddObject(module, "PartSubset",(PyObject *)&Dtool_PartSubset.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BindAnimRequest | BindAnimRequest
//********************************************************************
PyMethodDef Dtool_Methods_BindAnimRequest[]= {
  { "getClassType",(PyCFunction ) &Dtool_BindAnimRequest_get_class_type_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BindAnimRequest_get_class_type_181_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BindAnimRequest(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BindAnimRequest.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BindAnimRequest\n"
          "// Description : This class object manages an asynchronous\n"
          "//               load-and-bind animation request, as issued through\n"
          "//               PartBundle::load_bind_anim().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ModelLoadRequest._Dtool_ClassInit(NULL);
        Dtool_BindAnimRequest.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ModelLoadRequest.As_PyTypeObject());
        Dtool_BindAnimRequest.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BindAnimRequest.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BindAnimRequest.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BindAnimRequest.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BindAnimRequest)");
             printf(" Error In PyType_ReadyBindAnimRequest");
             return;
        }
        Py_INCREF(&Dtool_BindAnimRequest.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BindAnimRequest.As_PyTypeObject().tp_dict,"BindAnimRequest",&Dtool_BindAnimRequest.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BindAnimRequest.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BindAnimRequest[0],&Dtool_BindAnimRequest.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BindAnimRequest,BindAnimRequest::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BindAnimRequest.As_PyTypeObject());
        PyModule_AddObject(module, "BindAnimRequest",(PyObject *)&Dtool_BindAnimRequest.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PartBundle | PartBundle
//********************************************************************
PyMethodDef Dtool_Methods_PartBundle[]= {
  { "getAnimPreload",(PyCFunction ) &Dtool_PartBundle_get_anim_preload_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_anim_preload_185_comment},
  { "modifyAnimPreload",(PyCFunction ) &Dtool_PartBundle_modify_anim_preload_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_modify_anim_preload_186_comment},
  { "setAnimPreload",(PyCFunction ) &Dtool_PartBundle_set_anim_preload_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_anim_preload_187_comment},
  { "clearAnimPreload",(PyCFunction ) &Dtool_PartBundle_clear_anim_preload_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_clear_anim_preload_188_comment},
  { "mergeAnimPreloads",(PyCFunction ) &Dtool_PartBundle_merge_anim_preloads_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_merge_anim_preloads_189_comment},
  { "setBlendType",(PyCFunction ) &Dtool_PartBundle_set_blend_type_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_blend_type_191_comment},
  { "getBlendType",(PyCFunction ) &Dtool_PartBundle_get_blend_type_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_blend_type_192_comment},
  { "setAnimBlendFlag",(PyCFunction ) &Dtool_PartBundle_set_anim_blend_flag_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_anim_blend_flag_193_comment},
  { "getAnimBlendFlag",(PyCFunction ) &Dtool_PartBundle_get_anim_blend_flag_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_anim_blend_flag_194_comment},
  { "setFrameBlendFlag",(PyCFunction ) &Dtool_PartBundle_set_frame_blend_flag_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_frame_blend_flag_195_comment},
  { "getFrameBlendFlag",(PyCFunction ) &Dtool_PartBundle_get_frame_blend_flag_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_frame_blend_flag_196_comment},
  { "setRootXform",(PyCFunction ) &Dtool_PartBundle_set_root_xform_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_root_xform_197_comment},
  { "xform",(PyCFunction ) &Dtool_PartBundle_xform_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_xform_198_comment},
  { "getRootXform",(PyCFunction ) &Dtool_PartBundle_get_root_xform_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_root_xform_199_comment},
  { "applyTransform",(PyCFunction ) &Dtool_PartBundle_apply_transform_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_apply_transform_200_comment},
  { "getNumNodes",(PyCFunction ) &Dtool_PartBundle_get_num_nodes_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_num_nodes_201_comment},
  { "getNode",(PyCFunction ) &Dtool_PartBundle_get_node_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_node_202_comment},
  { "clearControlEffects",(PyCFunction ) &Dtool_PartBundle_clear_control_effects_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_clear_control_effects_203_comment},
  { "setControlEffect",(PyCFunction ) &Dtool_PartBundle_set_control_effect_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_set_control_effect_204_comment},
  { "getControlEffect",(PyCFunction ) &Dtool_PartBundle_get_control_effect_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_control_effect_205_comment},
  { "output",(PyCFunction ) &Dtool_PartBundle_output_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_output_206_comment},
  { "bindAnim",(PyCFunction ) &Dtool_PartBundle_bind_anim_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_bind_anim_207_comment},
  { "loadBindAnim",(PyCFunction ) &Dtool_PartBundle_load_bind_anim_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_load_bind_anim_208_comment},
  { "waitPending",(PyCFunction ) &Dtool_PartBundle_wait_pending_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_wait_pending_209_comment},
  { "freezeJoint",(PyCFunction ) &Dtool_PartBundle_freeze_joint_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_freeze_joint_210_comment},
  { "controlJoint",(PyCFunction ) &Dtool_PartBundle_control_joint_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_control_joint_211_comment},
  { "releaseJoint",(PyCFunction ) &Dtool_PartBundle_release_joint_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_release_joint_212_comment},
  { "update",(PyCFunction ) &Dtool_PartBundle_update_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_update_213_comment},
  { "forceUpdate",(PyCFunction ) &Dtool_PartBundle_force_update_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_force_update_214_comment},
  { "getClassType",(PyCFunction ) &Dtool_PartBundle_get_class_type_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundle_get_class_type_215_comment},
  { "getNodes",(PyCFunction) &MakeSeq_PartBundle_get_nodes, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PartBundle
//////////////////
static PyObject *  Dtool_Repr_PartBundle(PyObject * self)
{
    PartBundle * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PartBundle,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PartBundle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PartBundle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PartBundle\n"
          "// Description : This is the root of a MovingPart hierarchy.  It\n"
          "//               defines the hierarchy of moving parts that make up an\n"
          "//               animatable object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PartGroup._Dtool_ClassInit(NULL);
        Dtool_PartBundle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PartGroup.As_PyTypeObject());
        Dtool_PartBundle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PartBundle.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PartBundle.As_PyTypeObject().tp_repr = & Dtool_Repr_PartBundle;
        // __str__ Repr Proxy
        Dtool_PartBundle.As_PyTypeObject().tp_str = & Dtool_Repr_PartBundle;
        // Enum  PartBundle::BlendType;
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"BTLinear",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"BTNormalizedLinear",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"BTComponentwise",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"BTComponentwiseQuat",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_PartBundle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PartBundle)");
             printf(" Error In PyType_ReadyPartBundle");
             return;
        }
        Py_INCREF(&Dtool_PartBundle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"PartBundle",&Dtool_PartBundle.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PartBundle.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PartBundle[29],&Dtool_PartBundle.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PartBundle,PartBundle::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PartBundle.As_PyTypeObject());
        PyModule_AddObject(module, "PartBundle",(PyObject *)&Dtool_PartBundle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PartBundleHandle | PartBundleHandle
//********************************************************************
PyMethodDef Dtool_Methods_PartBundleHandle[]= {
  { "getBundle",(PyCFunction ) &Dtool_PartBundleHandle_get_bundle_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleHandle_get_bundle_220_comment},
  { "setBundle",(PyCFunction ) &Dtool_PartBundleHandle_set_bundle_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleHandle_set_bundle_221_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PartBundleHandle(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PartBundleHandle.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PartBundleHandle\n"
          "// Description : This is a trivial class returned by\n"
          "//               PartBundleNode::get_bundle().  Its purpose is to hold\n"
          "//               the actual PartBundle pointer contained within the\n"
          "//               PartBundleNode, so that scene graph flatten\n"
          "//               operations can safely combine or duplicate\n"
          "//               PartBundles as necessary without affecting high-level\n"
          "//               bundle operations.\n"
          "//\n"
          "//               The high-level Actor class defined in\n"
          "//               direct/src/actor, for instance, will store a list of\n"
          "//               PartBundleHandles instead of on actual PartBundles,\n"
          "//               so that it will be immune to changes from these\n"
          "//               flatten operations.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_PartBundleHandle.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_PartBundleHandle.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PartBundleHandle.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PartBundleHandle.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PartBundleHandle.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PartBundleHandle)");
             printf(" Error In PyType_ReadyPartBundleHandle");
             return;
        }
        Py_INCREF(&Dtool_PartBundleHandle.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PartBundleHandle.As_PyTypeObject().tp_dict,"PartBundleHandle",&Dtool_PartBundleHandle.As_PyObject());
        RegisterRuntimeClass(&Dtool_PartBundleHandle,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PartBundleHandle.As_PyTypeObject());
        PyModule_AddObject(module, "PartBundleHandle",(PyObject *)&Dtool_PartBundleHandle.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PartBundleNode | PartBundleNode
//********************************************************************
PyMethodDef Dtool_Methods_PartBundleNode[]= {
  { "getNumBundles",(PyCFunction ) &Dtool_PartBundleNode_get_num_bundles_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleNode_get_num_bundles_224_comment},
  { "getBundle",(PyCFunction ) &Dtool_PartBundleNode_get_bundle_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleNode_get_bundle_225_comment},
  { "getBundleHandle",(PyCFunction ) &Dtool_PartBundleNode_get_bundle_handle_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleNode_get_bundle_handle_226_comment},
  { "getClassType",(PyCFunction ) &Dtool_PartBundleNode_get_class_type_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PartBundleNode_get_class_type_227_comment},
  { "getBundles",(PyCFunction) &MakeSeq_PartBundleNode_get_bundles, METH_NOARGS, NULL},
  { "getBundleHandles",(PyCFunction) &MakeSeq_PartBundleNode_get_bundle_handles, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PartBundleNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PartBundleNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PartBundleNode\n"
          "// Description : This is a node that contains a pointer to an\n"
          "//               PartBundle.  Like AnimBundleNode, it exists to make\n"
          "//               it easy to store PartBundles in the scene graph.\n"
          "//\n"
          "//               (Unlike AnimBundleNode, however, PartBundleNode has\n"
          "//               an additional function: it is also the base class of\n"
          "//               the Character node type, which adds additional\n"
          "//               functionality.)\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_PartBundleNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_PartBundleNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PartBundleNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PartBundleNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PartBundleNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PartBundleNode)");
             printf(" Error In PyType_ReadyPartBundleNode");
             return;
        }
        Py_INCREF(&Dtool_PartBundleNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PartBundleNode.As_PyTypeObject().tp_dict,"PartBundleNode",&Dtool_PartBundleNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PartBundleNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PartBundleNode[3],&Dtool_PartBundleNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PartBundleNode,PartBundleNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PartBundleNode.As_PyTypeObject());
        PyModule_AddObject(module, "PartBundleNode",(PyObject *)&Dtool_PartBundleNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovingPartBase | MovingPartBase
//********************************************************************
PyMethodDef Dtool_Methods_MovingPartBase[]= {
  { "getMaxBound",(PyCFunction ) &Dtool_MovingPartBase_get_max_bound_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartBase_get_max_bound_229_comment},
  { "getBound",(PyCFunction ) &Dtool_MovingPartBase_get_bound_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartBase_get_bound_230_comment},
  { "outputValue",(PyCFunction ) &Dtool_MovingPartBase_output_value_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartBase_output_value_231_comment},
  { "getClassType",(PyCFunction ) &Dtool_MovingPartBase_get_class_type_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartBase_get_class_type_232_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovingPartBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovingPartBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovingPartBase\n"
          "// Description : This is the base class for a single animatable piece\n"
          "//               that may be bound to one channel (or more, if\n"
          "//               blending is in effect).  It corresponds to, for\n"
          "//               instance, a single joint or slider of a character.\n"
          "//\n"
          "//               MovingPartBase does not have a particular value type.\n"
          "//               See the derived template class, MovingPart, for this.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PartGroup._Dtool_ClassInit(NULL);
        Dtool_MovingPartBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PartGroup.As_PyTypeObject());
        Dtool_MovingPartBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovingPartBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovingPartBase.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovingPartBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovingPartBase)");
             printf(" Error In PyType_ReadyMovingPartBase");
             return;
        }
        Py_INCREF(&Dtool_MovingPartBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovingPartBase.As_PyTypeObject().tp_dict,"MovingPartBase",&Dtool_MovingPartBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovingPartBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovingPartBase[3],&Dtool_MovingPartBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovingPartBase,MovingPartBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovingPartBase.As_PyTypeObject());
        PyModule_AddObject(module, "MovingPartBase",(PyObject *)&Dtool_MovingPartBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovingPartMatrix | MovingPartMatrix
//********************************************************************
PyMethodDef Dtool_Methods_MovingPartMatrix[]= {
  { "getClassType",(PyCFunction ) &Dtool_MovingPartMatrix_get_class_type_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartMatrix_get_class_type_240_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovingPartMatrix(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovingPartMatrix.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovingPartMatrix\n"
          "// Description : This is a particular kind of MovingPart that accepts\n"
          "//               a matrix each frame.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovingPart_ACMatrixSwitchType._Dtool_ClassInit(NULL);
        Dtool_MovingPartMatrix.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject());
        Dtool_MovingPartMatrix.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovingPartMatrix.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovingPartMatrix.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovingPartMatrix.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovingPartMatrix)");
             printf(" Error In PyType_ReadyMovingPartMatrix");
             return;
        }
        Py_INCREF(&Dtool_MovingPartMatrix.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovingPartMatrix.As_PyTypeObject().tp_dict,"MovingPartMatrix",&Dtool_MovingPartMatrix.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovingPartMatrix.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovingPartMatrix[0],&Dtool_MovingPartMatrix.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovingPartMatrix,MovingPartMatrix::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovingPartMatrix.As_PyTypeObject());
        PyModule_AddObject(module, "MovingPartMatrix",(PyObject *)&Dtool_MovingPartMatrix.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovingPart_ACMatrixSwitchType | MovingPartACMatrixSwitchType
//********************************************************************
PyMethodDef Dtool_Methods_MovingPart_ACMatrixSwitchType[]= {
  { "getClassType",(PyCFunction ) &Dtool_MovingPart_ACMatrixSwitchType_get_class_type_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACMatrixSwitchType_get_class_type_236_comment},
  { "getValue",(PyCFunction ) &Dtool_MovingPart_ACMatrixSwitchType_get_value_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACMatrixSwitchType_get_value_237_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_MovingPart_ACMatrixSwitchType_get_default_value_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACMatrixSwitchType_get_default_value_238_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_MovingPartBase._Dtool_ClassInit(NULL);
        Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPartBase.As_PyTypeObject());
        Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovingPart_ACMatrixSwitchType)");
             printf(" Error In PyType_ReadyMovingPart_ACMatrixSwitchType");
             return;
        }
        Py_INCREF(&Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"MovingPartACMatrixSwitchType",&Dtool_MovingPart_ACMatrixSwitchType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovingPart_ACMatrixSwitchType[0],&Dtool_MovingPart_ACMatrixSwitchType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovingPart_ACMatrixSwitchType,MovingPart< ACMatrixSwitchType >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject());
        PyModule_AddObject(module, "MovingPartACMatrixSwitchType",(PyObject *)&Dtool_MovingPart_ACMatrixSwitchType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovingPartScalar | MovingPartScalar
//********************************************************************
PyMethodDef Dtool_Methods_MovingPartScalar[]= {
  { "getClassType",(PyCFunction ) &Dtool_MovingPartScalar_get_class_type_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPartScalar_get_class_type_247_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovingPartScalar(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MovingPartScalar.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MovingPartScalar\n"
          "// Description : This is a particular kind of MovingPart that accepts\n"
          "//               a scalar each frame.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MovingPart_ACScalarSwitchType._Dtool_ClassInit(NULL);
        Dtool_MovingPartScalar.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject());
        Dtool_MovingPartScalar.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovingPartScalar.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovingPartScalar.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovingPartScalar.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovingPartScalar)");
             printf(" Error In PyType_ReadyMovingPartScalar");
             return;
        }
        Py_INCREF(&Dtool_MovingPartScalar.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovingPartScalar.As_PyTypeObject().tp_dict,"MovingPartScalar",&Dtool_MovingPartScalar.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovingPartScalar.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovingPartScalar[0],&Dtool_MovingPartScalar.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovingPartScalar,MovingPartScalar::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovingPartScalar.As_PyTypeObject());
        PyModule_AddObject(module, "MovingPartScalar",(PyObject *)&Dtool_MovingPartScalar.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MovingPart_ACScalarSwitchType | MovingPartACScalarSwitchType
//********************************************************************
PyMethodDef Dtool_Methods_MovingPart_ACScalarSwitchType[]= {
  { "getClassType",(PyCFunction ) &Dtool_MovingPart_ACScalarSwitchType_get_class_type_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACScalarSwitchType_get_class_type_243_comment},
  { "getValue",(PyCFunction ) &Dtool_MovingPart_ACScalarSwitchType_get_value_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACScalarSwitchType_get_value_244_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_MovingPart_ACScalarSwitchType_get_default_value_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MovingPart_ACScalarSwitchType_get_default_value_245_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_MovingPartBase._Dtool_ClassInit(NULL);
        Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MovingPartBase.As_PyTypeObject());
        Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MovingPart_ACScalarSwitchType)");
             printf(" Error In PyType_ReadyMovingPart_ACScalarSwitchType");
             return;
        }
        Py_INCREF(&Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_dict,"MovingPartACScalarSwitchType",&Dtool_MovingPart_ACScalarSwitchType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MovingPart_ACScalarSwitchType[0],&Dtool_MovingPart_ACScalarSwitchType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MovingPart_ACScalarSwitchType,MovingPart< ACScalarSwitchType >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject());
        PyModule_AddObject(module, "MovingPartACScalarSwitchType",(PyObject *)&Dtool_MovingPart_ACScalarSwitchType.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..AnimGroup
//********************************************************************
   Dtool_PyModuleClassInit_AnimGroup(module);
//********************************************************************
//*** Module Init Updcall ..AnimBundle
//********************************************************************
   Dtool_PyModuleClassInit_AnimBundle(module);
//********************************************************************
//*** Module Init Updcall ..AnimBundleNode
//********************************************************************
   Dtool_PyModuleClassInit_AnimBundleNode(module);
//********************************************************************
//*** Module Init Updcall ..PartGroup
//********************************************************************
   Dtool_PyModuleClassInit_PartGroup(module);
//********************************************************************
//*** Module Init Updcall ..AnimControl
//********************************************************************
   Dtool_PyModuleClassInit_AnimControl(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannelBase
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannelBase(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannel< ACMatrixSwitchType >
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannel< ACScalarSwitchType >
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannelMatrixDynamic
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannelMatrixXfmTable
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannelScalarDynamic
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannelScalarDynamic(module);
//********************************************************************
//*** Module Init Updcall ..AnimChannelScalarTable
//********************************************************************
   Dtool_PyModuleClassInit_AnimChannelScalarTable(module);
//********************************************************************
//*** Module Init Updcall ..AnimControlCollection
//********************************************************************
   Dtool_PyModuleClassInit_AnimControlCollection(module);
//********************************************************************
//*** Module Init Updcall ..AnimPreloadTable
//********************************************************************
   Dtool_PyModuleClassInit_AnimPreloadTable(module);
//********************************************************************
//*** Module Init Updcall ..PartSubset
//********************************************************************
   Dtool_PyModuleClassInit_PartSubset(module);
//********************************************************************
//*** Module Init Updcall ..BindAnimRequest
//********************************************************************
   Dtool_PyModuleClassInit_BindAnimRequest(module);
//********************************************************************
//*** Module Init Updcall ..PartBundle
//********************************************************************
   Dtool_PyModuleClassInit_PartBundle(module);
//********************************************************************
//*** Module Init Updcall ..PartBundleHandle
//********************************************************************
   Dtool_PyModuleClassInit_PartBundleHandle(module);
//********************************************************************
//*** Module Init Updcall ..PartBundleNode
//********************************************************************
   Dtool_PyModuleClassInit_PartBundleNode(module);
//********************************************************************
//*** Module Init Updcall ..MovingPartBase
//********************************************************************
   Dtool_PyModuleClassInit_MovingPartBase(module);
//********************************************************************
//*** Module Init Updcall ..MovingPartMatrix
//********************************************************************
   Dtool_PyModuleClassInit_MovingPartMatrix(module);
//********************************************************************
//*** Module Init Updcall ..MovingPart< ACMatrixSwitchType >
//********************************************************************
   Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(module);
//********************************************************************
//*** Module Init Updcall ..MovingPartScalar
//********************************************************************
   Dtool_PyModuleClassInit_MovingPartScalar(module);
//********************************************************************
//*** Module Init Updcall ..MovingPart< ACScalarSwitchType >
//********************************************************************
   Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "autoBind", (PyCFunction) &Dtool_auto_bind_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_auto_bind_166_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libchan_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212859,  /* file_identifier */
  "libchan",  /* library_name */
  "n9gM",  /* library_hash_name */
  "panda",  /* module_name */
  "libchan.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  574  /* next_index */
};

Configure(_in_configure_libchan);
ConfigureFn(_in_configure_libchan) {
  interrogate_request_module(&_in_module_def);
}

