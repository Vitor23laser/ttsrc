/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/skel -Ipanda/src/skel -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libskel_igate.cxx -od built_Rocket/pandac/input/libskel.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/skel -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDASKEL -module pandaskel -library libskel basicSkel.h config_skel.h skel_composite.cxx typedSkel.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libskel
#include "py_panda.h"  

#include "basicSkel.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_skel.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "typedSkel.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. BasicSkel
//********************************************************************
typedef  BasicSkel  BasicSkel_localtype;
Define_Module_Class(pandaskel,BasicSkel,BasicSkel_localtype,BasicSkel);
//********************************************************************
//*** prototypes for .. TypedSkel
//********************************************************************
typedef  TypedSkel  TypedSkel_localtype;
Define_Module_Class(pandaskel,TypedSkel,TypedSkel_localtype,TypedSkel);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. BasicSkel 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void BasicSkel::set_value(int n)
 *******************************************************************/
static PyObject *Dtool_BasicSkel_set_value_4(PyObject *self, PyObject *args,PyObject *kwds) {
    BasicSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BasicSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BasicSkel::set_value(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BasicSkel.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const BasicSkel this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BasicSkel_set_value_4_comment =
    "C++ Interface:\n"
    "setValue(non-const BasicSkel this, int n)\n"
    "\n"
    "// These inline functions allow you to get and set _value.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BasicSkel::set_value\n"
    "//       Access: Public\n"
    "//  Description: Stores an integer value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BasicSkel_set_value_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int BasicSkel::get_value(void)
 *******************************************************************/
static PyObject *Dtool_BasicSkel_get_value_5(PyObject *self, PyObject *args,PyObject *kwds) {
    BasicSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BasicSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int BasicSkel::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BasicSkel.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const BasicSkel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BasicSkel_get_value_5_comment =
    "C++ Interface:\n"
    "getValue(non-const BasicSkel this)\n"
    "\n"
    "// These inline functions allow you to get and set _value.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BasicSkel::get_value\n"
    "//       Access: Public\n"
    "//  Description: Retreives a value that was previously stored.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BasicSkel_get_value_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void BasicSkel::set_value_alt(int n)
 *******************************************************************/
static PyObject *Dtool_BasicSkel_set_value_alt_6(PyObject *self, PyObject *args,PyObject *kwds) {
    BasicSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BasicSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void BasicSkel::set_value_alt(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setValueAlt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setValueAlt", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value_alt((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BasicSkel.setValueAlt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValueAlt(non-const BasicSkel this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BasicSkel_set_value_alt_6_comment =
    "C++ Interface:\n"
    "setValueAlt(non-const BasicSkel this, int n)\n"
    "\n"
    "// These do the same thing as the functions above.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BasicSkel::set_value_alt\n"
    "//       Access: Public\n"
    "//  Description: Stores an integer value.  Exact same functionality\n"
    "//               as set_value, except that this isn't an inline\n"
    "//               function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BasicSkel_set_value_alt_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int BasicSkel::get_value_alt(void)
 *******************************************************************/
static PyObject *Dtool_BasicSkel_get_value_alt_7(PyObject *self, PyObject *args,PyObject *kwds) {
    BasicSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BasicSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int BasicSkel::get_value_alt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueAlt", key_word_list));
        else
            (PyArg_Parse(args, ":getValueAlt"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_value_alt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BasicSkel.getValueAlt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueAlt(non-const BasicSkel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BasicSkel_get_value_alt_7_comment =
    "C++ Interface:\n"
    "getValueAlt(non-const BasicSkel this)\n"
    "\n"
    "// These do the same thing as the functions above.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: BasicSkel::get_value\n"
    "//       Access: Public\n"
    "//  Description: Retreives a value that was previously stored.\n"
    "//               Exact same functionality as get_value, except\n"
    "//               that this isn't an inline function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BasicSkel_get_value_alt_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BasicSkel::BasicSkel(void)
 *******************************************************************/
int  Dtool_Init_BasicSkel(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline BasicSkel::BasicSkel(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":BasicSkel", key_word_list))
        {
            BasicSkel *return_value = new BasicSkel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_BasicSkel,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "BasicSkel()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_BasicSkel(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BasicSkel)
    {
        printf("BasicSkel ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BasicSkel * local_this = (BasicSkel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BasicSkel)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BasicSkel(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BasicSkel)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. TypedSkel 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void TypedSkel::set_value(int n)
 *******************************************************************/
static PyObject *Dtool_TypedSkel_set_value_11(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void TypedSkel::set_value(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setValue", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedSkel.setValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const TypedSkel this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedSkel_set_value_11_comment =
    "C++ Interface:\n"
    "setValue(non-const TypedSkel this, int n)\n"
    "\n"
    "// These inline functions allow you to get and set _value.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedSkel::set_value\n"
    "//       Access: Public\n"
    "//  Description: Stores an integer value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedSkel_set_value_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int TypedSkel::get_value(void)
 *******************************************************************/
static PyObject *Dtool_TypedSkel_get_value_12(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int TypedSkel::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedSkel.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const TypedSkel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedSkel_get_value_12_comment =
    "C++ Interface:\n"
    "getValue(non-const TypedSkel this)\n"
    "\n"
    "// These inline functions allow you to get and set _value.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedSkel::get_value\n"
    "//       Access: Public\n"
    "//  Description: Retreives a value that was previously stored.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedSkel_get_value_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TypedSkel::set_value_alt(int n)
 *******************************************************************/
static PyObject *Dtool_TypedSkel_set_value_alt_13(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void TypedSkel::set_value_alt(int n)
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setValueAlt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setValueAlt", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_value_alt((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedSkel.setValueAlt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValueAlt(non-const TypedSkel this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedSkel_set_value_alt_13_comment =
    "C++ Interface:\n"
    "setValueAlt(non-const TypedSkel this, int n)\n"
    "\n"
    "// These do the same thing as the functions above.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedSkel::set_value_alt\n"
    "//       Access: Public\n"
    "//  Description: Stores an integer value.  Exact same functionality\n"
    "//               as set_value, except that this isn't an inline\n"
    "//               function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedSkel_set_value_alt_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int TypedSkel::get_value_alt(void)
 *******************************************************************/
static PyObject *Dtool_TypedSkel_get_value_alt_14(PyObject *self, PyObject *args,PyObject *kwds) {
    TypedSkel * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_TypedSkel,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int TypedSkel::get_value_alt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValueAlt", key_word_list));
        else
            (PyArg_Parse(args, ":getValueAlt"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_value_alt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call TypedSkel.getValueAlt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValueAlt(non-const TypedSkel this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedSkel_get_value_alt_14_comment =
    "C++ Interface:\n"
    "getValueAlt(non-const TypedSkel this)\n"
    "\n"
    "// These do the same thing as the functions above.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: TypedSkel::get_value\n"
    "//       Access: Public\n"
    "//  Description: Retreives a value that was previously stored.\n"
    "//               Exact same functionality as get_value, except\n"
    "//               that this isn't an inline function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_TypedSkel_get_value_alt_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle TypedSkel::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_TypedSkel_get_class_type_15(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle TypedSkel::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = TypedSkel::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_TypedSkel_get_class_type_15_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_TypedSkel_get_class_type_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypedSkel::TypedSkel(void)
 *******************************************************************/
int  Dtool_Init_TypedSkel(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline TypedSkel::TypedSkel(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":TypedSkel", key_word_list))
        {
            TypedSkel *return_value = new TypedSkel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_TypedSkel,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "TypedSkel()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_TypedSkel(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_TypedSkel)
    {
        printf("TypedSkel ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    TypedSkel * local_this = (TypedSkel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_TypedSkel)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_TypedSkel(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_TypedSkel)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (TypedSkel*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. BasicSkel | BasicSkel
//********************************************************************
PyMethodDef Dtool_Methods_BasicSkel[]= {
  { "setValue",(PyCFunction ) &Dtool_BasicSkel_set_value_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BasicSkel_set_value_4_comment},
  { "getValue",(PyCFunction ) &Dtool_BasicSkel_get_value_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BasicSkel_get_value_5_comment},
  { "setValueAlt",(PyCFunction ) &Dtool_BasicSkel_set_value_alt_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BasicSkel_set_value_alt_6_comment},
  { "getValueAlt",(PyCFunction ) &Dtool_BasicSkel_get_value_alt_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BasicSkel_get_value_alt_7_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_BasicSkel(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BasicSkel.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BasicSkel\n"
          "// Description : This is the most basic of the skeleton classes.\n"
          "//               It stores an integer, and will return it on request.\n"
          "//\n"
          "//               The skeleton classes are intended to help you learn\n"
          "//               how to add C++ classes to panda.  See also the manual,\n"
          "//               \"Adding C++ Classes to Panda.\"\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_BasicSkel.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_BasicSkel.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BasicSkel.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BasicSkel.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_BasicSkel.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BasicSkel)");
             printf(" Error In PyType_ReadyBasicSkel");
             return;
        }
        Py_INCREF(&Dtool_BasicSkel.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BasicSkel.As_PyTypeObject().tp_dict,"BasicSkel",&Dtool_BasicSkel.As_PyObject());
        RegisterRuntimeClass(&Dtool_BasicSkel,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BasicSkel.As_PyTypeObject());
        PyModule_AddObject(module, "BasicSkel",(PyObject *)&Dtool_BasicSkel.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. TypedSkel | TypedSkel
//********************************************************************
PyMethodDef Dtool_Methods_TypedSkel[]= {
  { "setValue",(PyCFunction ) &Dtool_TypedSkel_set_value_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedSkel_set_value_11_comment},
  { "getValue",(PyCFunction ) &Dtool_TypedSkel_get_value_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedSkel_get_value_12_comment},
  { "setValueAlt",(PyCFunction ) &Dtool_TypedSkel_set_value_alt_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedSkel_set_value_alt_13_comment},
  { "getValueAlt",(PyCFunction ) &Dtool_TypedSkel_get_value_alt_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedSkel_get_value_alt_14_comment},
  { "getClassType",(PyCFunction ) &Dtool_TypedSkel_get_class_type_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_TypedSkel_get_class_type_15_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_TypedSkel(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_TypedSkel.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : TypedSkel\n"
          "// Description : Skeleton object that inherits from TypedObject.\n"
          "//               Stores an integer, and will return it on request.\n"
          "//\n"
          "//               The skeleton classes are intended to help you learn\n"
          "//               how to add C++ classes to panda.  See also the manual,\n"
          "//               \"Adding C++ Classes to Panda.\"\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_TypedSkel.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_TypedSkel.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_TypedSkel.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_TypedSkel.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_TypedSkel.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(TypedSkel)");
             printf(" Error In PyType_ReadyTypedSkel");
             return;
        }
        Py_INCREF(&Dtool_TypedSkel.As_PyTypeObject());
        PyDict_SetItemString(Dtool_TypedSkel.As_PyTypeObject().tp_dict,"TypedSkel",&Dtool_TypedSkel.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_TypedSkel.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_TypedSkel[4],&Dtool_TypedSkel.As_PyObject()));
        RegisterRuntimeClass(&Dtool_TypedSkel,TypedSkel::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_TypedSkel.As_PyTypeObject());
        PyModule_AddObject(module, "TypedSkel",(PyObject *)&Dtool_TypedSkel.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..BasicSkel
//********************************************************************
   Dtool_PyModuleClassInit_BasicSkel(module);
//********************************************************************
//*** Module Init Updcall ..TypedSkel
//********************************************************************
   Dtool_PyModuleClassInit_TypedSkel(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libskel_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212930,  /* file_identifier */
  "libskel",  /* library_name */
  "0pMs",  /* library_hash_name */
  "pandaskel",  /* module_name */
  "libskel.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  33  /* next_index */
};

Configure(_in_configure_libskel);
ConfigureFn(_in_configure_libskel) {
  interrogate_request_module(&_in_module_def);
}

