/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/event -Ipanda/src/event -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libevent_igate.cxx -od built_Rocket/pandac/input/libevent.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/event -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libevent asyncTask.h asyncTaskChain.h asyncTaskCollection.h asyncTaskManager.h asyncTaskPause.h asyncTaskSequence.h buttonEvent.h buttonEventList.h config_event.h event.h eventHandler.h eventParameter.h eventQueue.h eventReceiver.h event_composite.cxx genericAsyncTask.h pointerEvent.h pointerEventList.h pt_Event.h pythonTask.h throw_event.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libevent
#include "py_panda.h"  

#include <Python.h>
#include "asyncTask.h"
#include "asyncTaskBase.h"
#include "asyncTaskChain.h"
#include "asyncTaskCollection.h"
#include "asyncTaskManager.h"
#include "asyncTaskPause.h"
#include "asyncTaskSequence.h"
#include "buttonEvent.h"
#include "buttonEventList.h"
#include "buttonHandle.h"
#include "clockObject.h"
#include "conditionVar.h"
#include "conditionVarFull.h"
#include "config_event.h"
#include "event.h"
#include "eventHandler.h"
#include "eventParameter.h"
#include "eventQueue.h"
#include "eventReceiver.h"
#include "genericAsyncTask.h"
#include "indirectCompareNames.h"
#include "lightMutex.h"
#include "modifierButtons.h"
#include "mutexHolder.h"
#include "notifyCategoryProxy.h"
#include "ordered_vector.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "pdeque.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerEvent.h"
#include "pointerEventList.h"
#include "pset.h"
#include "pt_Event.h"
#include "pvector.h"
#include "pythonTask.h"
#include "thread.h"
#include "throw_event.h"
#include "typedObject.h"
#include "typedReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. AsyncTask
//********************************************************************
typedef  AsyncTask  AsyncTask_localtype;
Define_Module_ClassRef(panda,AsyncTask,AsyncTask_localtype,AsyncTask);
//********************************************************************
//*** prototypes for .. AsyncTaskCollection
//********************************************************************
typedef  AsyncTaskCollection  AsyncTaskCollection_localtype;
Define_Module_Class(panda,AsyncTaskCollection,AsyncTaskCollection_localtype,AsyncTaskCollection);
//********************************************************************
//*** prototypes for .. AsyncTaskChain
//********************************************************************
typedef  AsyncTaskChain  AsyncTaskChain_localtype;
Define_Module_ClassRef(panda,AsyncTaskChain,AsyncTaskChain_localtype,AsyncTaskChain);
//********************************************************************
//*** prototypes for .. AsyncTaskManager
//********************************************************************
typedef  AsyncTaskManager  AsyncTaskManager_localtype;
Define_Module_ClassRef(panda,AsyncTaskManager,AsyncTaskManager_localtype,AsyncTaskManager);
//********************************************************************
//*** prototypes for .. AsyncTaskPause
//********************************************************************
typedef  AsyncTaskPause  AsyncTaskPause_localtype;
Define_Module_ClassRef(panda,AsyncTaskPause,AsyncTaskPause_localtype,AsyncTaskPause);
//********************************************************************
//*** prototypes for .. AsyncTaskSequence
//********************************************************************
typedef  AsyncTaskSequence  AsyncTaskSequence_localtype;
Define_Module_ClassRef(panda,AsyncTaskSequence,AsyncTaskSequence_localtype,AsyncTaskSequence);
//********************************************************************
//*** prototypes for .. EventParameter
//********************************************************************
typedef  EventParameter  EventParameter_localtype;
Define_Module_Class(panda,EventParameter,EventParameter_localtype,EventParameter);
//********************************************************************
//*** prototypes for .. EventStoreValueBase
//********************************************************************
typedef  EventStoreValueBase  EventStoreValueBase_localtype;
Define_Module_ClassRef(panda,EventStoreValueBase,EventStoreValueBase_localtype,EventStoreValueBase);
//********************************************************************
//*** prototypes for .. EventStoreTypedRefCount
//********************************************************************
typedef  EventStoreTypedRefCount  EventStoreTypedRefCount_localtype;
Define_Module_ClassRef(panda,EventStoreTypedRefCount,EventStoreTypedRefCount_localtype,EventStoreTypedRefCount);
//********************************************************************
//*** prototypes for .. Event
//********************************************************************
typedef  Event  Event_localtype;
Define_Module_ClassRef(panda,Event,Event_localtype,Event);
//********************************************************************
//*** prototypes for .. EventHandler
//********************************************************************
typedef  EventHandler  EventHandler_localtype;
Define_Module_Class(panda,EventHandler,EventHandler_localtype,EventHandler);
//********************************************************************
//*** prototypes for .. EventQueue
//********************************************************************
typedef  EventQueue  EventQueue_localtype;
Define_Module_Class(panda,EventQueue,EventQueue_localtype,EventQueue);
//********************************************************************
//*** prototypes for .. PointerEventList
//********************************************************************
typedef  PointerEventList  PointerEventList_localtype;
Define_Module_ClassRef(panda,PointerEventList,PointerEventList_localtype,PointerEventList);
//********************************************************************
//*** prototypes for .. PythonTask
//********************************************************************
typedef  PythonTask  PythonTask_localtype;
Define_Module_ClassRef(panda,PythonTask,PythonTask_localtype,PythonTask);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AsyncTaskBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ClockObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GlobPattern;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. AsyncTask 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline AsyncTask::State AsyncTask::get_state(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_state_5(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AsyncTask::State AsyncTask::get_state(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getState", key_word_list));
        else
            (PyArg_Parse(args, ":getState"));
        if(!PyErr_Occurred())
        {
            AsyncTask::State return_value = ((const AsyncTask*)local_this)->get_state();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getState(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_state_5_comment =
    "C++ Interface:\n"
    "getState(const AsyncTask this)\n"
    "\n"
    "// Filename: asyncTask.I\n"
    "// Created by:  drose (23Aug06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_state\n"
    "//       Access: Published\n"
    "//  Description: Returns the current state of the task.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_state_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AsyncTask::is_alive(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_is_alive_6(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AsyncTask::is_alive(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAlive", key_word_list));
        else
            (PyArg_Parse(args, ":isAlive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTask*)local_this)->is_alive();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAlive(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_is_alive_6_comment =
    "C++ Interface:\n"
    "isAlive(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::is_alive\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the task is currently active or\n"
    "//               sleeping on some task chain, meaning that it will be\n"
    "//               executed in its turn, or false if it is not active.\n"
    "//               If the task has recently been removed while it is in\n"
    "//               the middle of execution, this will return false,\n"
    "//               because the task will not run again once it finishes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_is_alive_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AsyncTaskManager *AsyncTask::get_manager(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_manager_7(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline AsyncTaskManager *AsyncTask::get_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManager", key_word_list));
        else
            (PyArg_Parse(args, ":getManager"));
        if(!PyErr_Occurred())
        {
            AsyncTaskManager *return_value = ((const AsyncTask*)local_this)->get_manager();
            if (return_value != (AsyncTaskManager *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskManager,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManager(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_manager_7_comment =
    "C++ Interface:\n"
    "getManager(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_manager\n"
    "//       Access: Published\n"
    "//  Description: Returns the AsyncTaskManager that this task is active\n"
    "//               on.  This will be NULL if the state is S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_manager_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::remove(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_remove_8(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::remove(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":remove", key_word_list));
        else
            (PyArg_Parse(args, ":remove"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.remove() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remove(non-const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_remove_8_comment =
    "C++ Interface:\n"
    "remove(non-const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::remove\n"
    "//       Access: Published\n"
    "//  Description: Removes the task from its active manager, if any, and\n"
    "//               makes the state S_inactive (or possible\n"
    "//               S_servicing_removed).  This is a no-op if the state\n"
    "//               is already S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_remove_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTask::set_delay(double delay)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_delay_9(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTask::set_delay(double delay)
        double param1;
        static char * key_word_list[] = {(char *)"delay", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDelay", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDelay", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_delay((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setDelay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDelay(non-const AsyncTask this, float delay)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_delay_9_comment =
    "C++ Interface:\n"
    "setDelay(non-const AsyncTask this, float delay)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_delay\n"
    "//       Access: Published\n"
    "//  Description: Specifies the amount of time, in seconds, by which\n"
    "//               this task will be delayed after it has been added to\n"
    "//               the AsyncTaskManager.  At least the specified amount\n"
    "//               of time (and possibly more) will elapse before the\n"
    "//               task begins.\n"
    "//\n"
    "//               You may specify a delay of 0.0 to guarantee that the\n"
    "//               task will run in the next epoch following the one in\n"
    "//               which it is added.\n"
    "//\n"
    "//               Setting this value after the task has already been\n"
    "//               added will not affect the task's wake time; it will\n"
    "//               only affect the task if it is re-added to the queue\n"
    "//               in the future, for instance if the task returns\n"
    "//               DS_again.  Howver, see recalc_wake_time() if you wish\n"
    "//               to apply the delay effect immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_delay_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTask::clear_delay(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_clear_delay_10(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTask::clear_delay(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDelay", key_word_list));
        else
            (PyArg_Parse(args, ":clearDelay"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_delay();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.clearDelay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDelay(non-const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_clear_delay_10_comment =
    "C++ Interface:\n"
    "clearDelay(non-const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::clear_delay\n"
    "//       Access: Published\n"
    "//  Description: Removes any delay specified for the task.  The next\n"
    "//               time the task is added to the queue, it will run\n"
    "//               immediately.  This does not affect the task's wake\n"
    "//               time if it has already been added to the queue.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_clear_delay_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AsyncTask::has_delay(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_has_delay_11(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AsyncTask::has_delay(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasDelay", key_word_list));
        else
            (PyArg_Parse(args, ":hasDelay"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTask*)local_this)->has_delay();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDelay(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_has_delay_11_comment =
    "C++ Interface:\n"
    "hasDelay(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::has_delay\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a delay has been set for this task\n"
    "//               via set_delay(), or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_has_delay_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AsyncTask::get_delay(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_delay_12(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AsyncTask::get_delay(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDelay", key_word_list));
        else
            (PyArg_Parse(args, ":getDelay"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_delay();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDelay(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_delay_12_comment =
    "C++ Interface:\n"
    "getDelay(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_delay\n"
    "//       Access: Published\n"
    "//  Description: Returns the delay value that has been set via\n"
    "//               set_delay, if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_delay_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double AsyncTask::get_wake_time(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_wake_time_13(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double AsyncTask::get_wake_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWakeTime", key_word_list));
        else
            (PyArg_Parse(args, ":getWakeTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_wake_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWakeTime(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_wake_time_13_comment =
    "C++ Interface:\n"
    "getWakeTime(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_wake_time\n"
    "//       Access: Published\n"
    "//  Description: If this task has been added to an AsyncTaskManager\n"
    "//               with a delay in effect, this returns the time at\n"
    "//               which the task is expected to awaken.  It has no\n"
    "//               meaning if the task has not yet been added to a\n"
    "//               queue, or if there was no delay in effect at the time\n"
    "//               the task was added.\n"
    "//\n"
    "//               If the task's status is not S_sleeping, this returns\n"
    "//               0.0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_wake_time_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::recalc_wake_time(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_recalc_wake_time_14(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::recalc_wake_time(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recalcWakeTime", key_word_list));
        else
            (PyArg_Parse(args, ":recalcWakeTime"));
        if(!PyErr_Occurred())
        {
            (local_this)->recalc_wake_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.recalcWakeTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recalcWakeTime(non-const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_recalc_wake_time_14_comment =
    "C++ Interface:\n"
    "recalcWakeTime(non-const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::recalc_wake_time\n"
    "//       Access: Published\n"
    "//  Description: If the task is currently sleeping on a task\n"
    "//               chain, this resets its wake time to the current time\n"
    "//               + get_delay().  It is as if the task had suddenly\n"
    "//               returned DS_again.  The task will sleep for its\n"
    "//               current delay seconds before running again.  This\n"
    "//               method may therefore be used to make the task wake up\n"
    "//               sooner or later than it would have otherwise.\n"
    "//\n"
    "//               If the task is not already sleeping, this method has\n"
    "//               no effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_recalc_wake_time_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AsyncTask::get_start_time(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_start_time_15(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AsyncTask::get_start_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartTime", key_word_list));
        else
            (PyArg_Parse(args, ":getStartTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_start_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartTime(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_start_time_15_comment =
    "C++ Interface:\n"
    "getStartTime(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_start_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the time at which the task was started,\n"
    "//               according to the task manager's clock.\n"
    "//\n"
    "//               It is only valid to call this if the task's status is\n"
    "//               not S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_start_time_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double AsyncTask::get_elapsed_time(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_elapsed_time_16(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double AsyncTask::get_elapsed_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getElapsedTime", key_word_list));
        else
            (PyArg_Parse(args, ":getElapsedTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_elapsed_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElapsedTime(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_elapsed_time_16_comment =
    "C++ Interface:\n"
    "getElapsedTime(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_elapsed_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time that has elapsed since\n"
    "//               the task was started, according to the task manager's\n"
    "//               clock.\n"
    "//\n"
    "//               It is only valid to call this if the task's status is\n"
    "//               not S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_elapsed_time_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTask::get_start_frame(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_start_frame_17(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTask::get_start_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getStartFrame"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTask*)local_this)->get_start_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartFrame(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_start_frame_17_comment =
    "C++ Interface:\n"
    "getStartFrame(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_start_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the frame number at which the task was\n"
    "//               started, according to the task manager's clock.\n"
    "//\n"
    "//               It is only valid to call this if the task's status is\n"
    "//               not S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_start_frame_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTask::get_elapsed_frames(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_elapsed_frames_18(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTask::get_elapsed_frames(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getElapsedFrames", key_word_list));
        else
            (PyArg_Parse(args, ":getElapsedFrames"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTask*)local_this)->get_elapsed_frames();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElapsedFrames(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_elapsed_frames_18_comment =
    "C++ Interface:\n"
    "getElapsedFrames(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_elapsed_frames\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of frames that have elapsed since\n"
    "//               the task was started, according to the task manager's\n"
    "//               clock.\n"
    "//\n"
    "//               It is only valid to call this if the task's status is\n"
    "//               not S_inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_elapsed_frames_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_name_19(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const AsyncTask this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_name_19_comment =
    "C++ Interface:\n"
    "setName(non-const AsyncTask this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_name\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_name_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTask::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_clear_name_20(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTask::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_clear_name_20_comment =
    "C++ Interface:\n"
    "clearName(non-const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::clear_name\n"
    "//       Access: Public\n"
    "//  Description: Resets the task's name to empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_clear_name_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > AsyncTask::get_name_prefix(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_name_prefix_21(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > AsyncTask::get_name_prefix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNamePrefix", key_word_list));
        else
            (PyArg_Parse(args, ":getNamePrefix"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AsyncTask*)local_this)->get_name_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNamePrefix(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_name_prefix_21_comment =
    "C++ Interface:\n"
    "getNamePrefix(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_name_prefix\n"
    "//       Access: Published\n"
    "//  Description: Returns the initial part of the name, up to but not\n"
    "//               including any trailing digits following a hyphen or\n"
    "//               underscore.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_name_prefix_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline long int AsyncTask::get_task_id(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_task_id_22(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline long int AsyncTask::get_task_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTaskId", key_word_list));
        else
            (PyArg_Parse(args, ":getTaskId"));
        if(!PyErr_Occurred())
        {
            long int return_value = ((const AsyncTask*)local_this)->get_task_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTaskId(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_task_id_22_comment =
    "C++ Interface:\n"
    "getTaskId(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_task_id\n"
    "//       Access: Public\n"
    "//  Description: Returns a number guaranteed to be unique for each\n"
    "//               different AsyncTask object in the universe.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_task_id_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::set_task_chain(basic_string< char > const &chain_name)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_task_chain_23(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::set_task_chain(basic_string< char > const &chain_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"chain_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setTaskChain", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setTaskChain", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_task_chain(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setTaskChain() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTaskChain(non-const AsyncTask this, string chain_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_task_chain_23_comment =
    "C++ Interface:\n"
    "setTaskChain(non-const AsyncTask this, string chain_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_task_chain\n"
    "//       Access: Published\n"
    "//  Description: Specifies the AsyncTaskChain on which this task will\n"
    "//               be running.  Each task chain runs tasks independently\n"
    "//               of the others.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_task_chain_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &AsyncTask::get_task_chain(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_task_chain_24(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &AsyncTask::get_task_chain(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTaskChain", key_word_list));
        else
            (PyArg_Parse(args, ":getTaskChain"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const AsyncTask*)local_this)->get_task_chain();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTaskChain(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_task_chain_24_comment =
    "C++ Interface:\n"
    "getTaskChain(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_task_chain\n"
    "//       Access: Published\n"
    "//  Description: Returns the AsyncTaskChain on which this task will\n"
    "//               be running.  Each task chain runs tasks independently\n"
    "//               of the others.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_task_chain_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::set_sort(int sort)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_sort_25(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::set_sort(int sort)
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSort(non-const AsyncTask this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_sort_25_comment =
    "C++ Interface:\n"
    "setSort(non-const AsyncTask this, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_sort\n"
    "//       Access: Published\n"
    "//  Description: Specifies a sort value for this task.  Within a given\n"
    "//               AsyncTaskManager, all of the tasks with a given sort\n"
    "//               value are guaranteed to be completed before any tasks\n"
    "//               with a higher sort value are begun.\n"
    "//\n"
    "//               To put it another way, two tasks might execute in\n"
    "//               parallel with each other only if they both have the\n"
    "//               same sort value.  Tasks with a lower sort value are\n"
    "//               executed first.\n"
    "//\n"
    "//               This is different from the priority, which makes no\n"
    "//               such exclusion guarantees.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_sort_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTask::get_sort(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_sort_26(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTask::get_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSort", key_word_list));
        else
            (PyArg_Parse(args, ":getSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTask*)local_this)->get_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSort(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_sort_26_comment =
    "C++ Interface:\n"
    "getSort(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the task's current sort value.  See\n"
    "//               set_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_sort_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTask::set_priority(int priority)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_priority_27(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTask::set_priority(int priority)
        int param1;
        static char * key_word_list[] = {(char *)"priority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPriority", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPriority", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_priority((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setPriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPriority(non-const AsyncTask this, int priority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_priority_27_comment =
    "C++ Interface:\n"
    "setPriority(non-const AsyncTask this, int priority)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_priority\n"
    "//       Access: Published\n"
    "//  Description: Specifies a priority value for this task.  In\n"
    "//               general, tasks with a higher priority value are\n"
    "//               executed before tasks with a lower priority value\n"
    "//               (but only for tasks with the same sort value).\n"
    "//\n"
    "//               Unlike the sort value, tasks with different\n"
    "//               priorities may execute at the same time, if the\n"
    "//               AsyncTaskManager has more than one thread servicing\n"
    "//               tasks.\n"
    "//\n"
    "//               Also see AsyncTaskChain::set_timeslice_priority(),\n"
    "//               which changes the meaning of this value.  In the\n"
    "//               default mode, when the timeslice_priority flag is\n"
    "//               false, all tasks always run once per epoch,\n"
    "//               regardless of their priority values (that is, the\n"
    "//               priority controls the order of the task execution\n"
    "//               only, not the number of times it runs).  On the other\n"
    "//               hand, if you set the timeslice_priority flag to true,\n"
    "//               then changing a task's priority has an effect on the\n"
    "//               number of times it runs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_priority_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTask::get_priority(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_priority_28(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTask::get_priority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPriority", key_word_list));
        else
            (PyArg_Parse(args, ":getPriority"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTask*)local_this)->get_priority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPriority(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_priority_28_comment =
    "C++ Interface:\n"
    "getPriority(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_priority\n"
    "//       Access: Published\n"
    "//  Description: Returns the task's current priority value.  See\n"
    "//               set_priority().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_priority_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTask::set_done_event(basic_string< char > const &done_event)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_done_event_29(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTask::set_done_event(basic_string< char > const &done_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"done_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDoneEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDoneEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_done_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setDoneEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDoneEvent(non-const AsyncTask this, string done_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_done_event_29_comment =
    "C++ Interface:\n"
    "setDoneEvent(non-const AsyncTask this, string done_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_done_event\n"
    "//       Access: Published\n"
    "//  Description: Sets the event name that will be triggered\n"
    "//               when the task finishes.  This should only be called\n"
    "//               before the task has been started, or after it has\n"
    "//               finished and before it is about to be restarted\n"
    "//               (i.e. when get_state() returns S_inactive).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_done_event_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &AsyncTask::get_done_event(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_done_event_30(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &AsyncTask::get_done_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDoneEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getDoneEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const AsyncTask*)local_this)->get_done_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoneEvent(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_done_event_30_comment =
    "C++ Interface:\n"
    "getDoneEvent(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_done_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event name that will be triggered\n"
    "//               when the task finishes.  See set_done_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_done_event_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTask::set_python_object(PyObject *python_object)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_set_python_object_31(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTask::set_python_object(PyObject *python_object)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"python_object", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPythonObject", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setPythonObject", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_python_object(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.setPythonObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPythonObject(non-const AsyncTask this, any python_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_set_python_object_31_comment =
    "C++ Interface:\n"
    "setPythonObject(non-const AsyncTask this, any python_object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::set_python_object\n"
    "//       Access: Published\n"
    "//  Description: Specifies an arbitrary Python object that will be\n"
    "//               piggybacked on the task object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_set_python_object_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PyObject *AsyncTask::get_python_object(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_python_object_32(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PyObject *AsyncTask::get_python_object(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPythonObject", key_word_list));
        else
            (PyArg_Parse(args, ":getPythonObject"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const AsyncTask*)local_this)->get_python_object();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPythonObject(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_python_object_32_comment =
    "C++ Interface:\n"
    "getPythonObject(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_python_object\n"
    "//       Access: Published\n"
    "//  Description: Returns the Python object that was specified to\n"
    "//               set_python_object(), if any, or None if no object was\n"
    "//               specified.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_python_object_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AsyncTask::get_dt(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_dt_33(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AsyncTask::get_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDt", key_word_list));
        else
            (PyArg_Parse(args, ":getDt"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDt(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_dt_33_comment =
    "C++ Interface:\n"
    "getDt(const AsyncTask this)\n"
    "\n"
    "// HAVE_PYTHON\n"
    "\n"
    "// HAVE_PYTHON\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time elapsed during the task's\n"
    "//               previous run cycle, in seconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_dt_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AsyncTask::get_max_dt(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_max_dt_34(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AsyncTask::get_max_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxDt", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxDt"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_max_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxDt(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_max_dt_34_comment =
    "C++ Interface:\n"
    "getMaxDt(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_max_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum amount of time elapsed during any\n"
    "//               one of the task's previous run cycles, in seconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_max_dt_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double AsyncTask::get_average_dt(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_average_dt_35(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double AsyncTask::get_average_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAverageDt", key_word_list));
        else
            (PyArg_Parse(args, ":getAverageDt"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTask*)local_this)->get_average_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAverageDt(const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_average_dt_35_comment =
    "C++ Interface:\n"
    "getAverageDt(const AsyncTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::get_average_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns the average amount of time elapsed during\n"
    "//               each of the task's previous run cycles, in seconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_get_average_dt_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AsyncTask::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AsyncTask_output_36(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AsyncTask::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTask.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AsyncTask*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AsyncTask this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_output_36_comment =
    "C++ Interface:\n"
    "output(const AsyncTask this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTask::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTask_output_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTask::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_get_class_type_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTask::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTask::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_get_class_type_37_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTask_get_class_type_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTask_downcast_to_AsyncTaskSequence_136(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToAsyncTaskSequence", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToAsyncTaskSequence"));
        if(!PyErr_Occurred())
        {
            AsyncTaskSequence *return_value = (AsyncTaskSequence *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskSequence,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTask.downcastToAsyncTaskSequence() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToAsyncTaskSequence(non-const AsyncTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTask_downcast_to_AsyncTaskSequence_136_comment =
    "C++ Interface:\n"
    "downcastToAsyncTaskSequence(non-const AsyncTask this)\n"
    "\n"
    "downcast from AsyncTask to AsyncTaskSequence\n"
    "";
#else
static const char * Dtool_AsyncTask_downcast_to_AsyncTaskSequence_136_comment = NULL;
#endif

int  Dtool_Init_AsyncTask(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AsyncTask)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AsyncTask(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTask)
    {
        printf("AsyncTask ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTask * local_this = (AsyncTask *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTask)
        return local_this;
    if(requested_type == &Dtool_AsyncTaskBase)
        return ( AsyncTaskBase *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AsyncTaskBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( AsyncTaskBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( AsyncTaskBase *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( AsyncTaskBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTask(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTask)
        return from_this;
    if(from_type == &Dtool_AsyncTaskBase)
    {
          AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
          return (AsyncTask*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTask*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTask*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTask*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTask*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AsyncTaskCollection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_operator_40(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskCollection.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    AsyncTaskCollection *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskCollection.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const AsyncTaskCollection this, const AsyncTaskCollection copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_operator_40_comment =
    "C++ Interface:\n"
    "assign(non-const AsyncTaskCollection this, const AsyncTaskCollection copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_operator_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::add_task(AsyncTask *task)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_add_task_42(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AsyncTaskCollection::add_task(AsyncTask *task)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addTask", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskCollection.addTask", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_task(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskCollection.addTask() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTask(non-const AsyncTaskCollection this, non-const AsyncTask task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_add_task_42_comment =
    "C++ Interface:\n"
    "addTask(non-const AsyncTaskCollection this, non-const AsyncTask task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::add_task\n"
    "//       Access: Published\n"
    "//  Description: Adds a new AsyncTask to the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_add_task_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskCollection::remove_task(AsyncTask *task)
 * void AsyncTaskCollection::remove_task(int index)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_remove_task_43(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool AsyncTaskCollection::remove_task(AsyncTask *task)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeTask", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskCollection.removeTask", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_task(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void AsyncTaskCollection::remove_task(int index)
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:removeTask", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->remove_task((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeTask(non-const AsyncTaskCollection this, non-const AsyncTask task)\n"
          "removeTask(non-const AsyncTaskCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_remove_task_43_comment =
    "C++ Interface:\n"
    "removeTask(non-const AsyncTaskCollection this, non-const AsyncTask task)\n"
    "removeTask(non-const AsyncTaskCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::remove_task\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated AsyncTask from the collection.\n"
    "//               Returns true if the task was removed, false if it was\n"
    "//               not a member of the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::remove_task\n"
    "//       Access: Published\n"
    "//  Description: Removes the nth AsyncTask from the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_remove_task_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_add_tasks_from_44(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addTasksFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addTasksFrom", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskCollection.addTasksFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_tasks_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskCollection.addTasksFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTasksFrom(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_add_tasks_from_44_comment =
    "C++ Interface:\n"
    "addTasksFrom(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::add_tasks_from\n"
    "//       Access: Published\n"
    "//  Description: Adds all the AsyncTasks indicated in the other\n"
    "//               collection to this task.  The other tasks are simply\n"
    "//               appended to the end of the tasks in this list;\n"
    "//               duplicates are not automatically removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_add_tasks_from_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_remove_tasks_from_45(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeTasksFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeTasksFrom", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskCollection.removeTasksFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_tasks_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskCollection.removeTasksFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeTasksFrom(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_remove_tasks_from_45_comment =
    "C++ Interface:\n"
    "removeTasksFrom(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::remove_tasks_from\n"
    "//       Access: Published\n"
    "//  Description: Removes from this collection all of the AsyncTasks\n"
    "//               listed in the other collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_remove_tasks_from_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::remove_duplicate_tasks(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_remove_duplicate_tasks_46(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskCollection::remove_duplicate_tasks(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeDuplicateTasks", key_word_list));
        else
            (PyArg_Parse(args, ":removeDuplicateTasks"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_duplicate_tasks();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskCollection.removeDuplicateTasks() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDuplicateTasks(non-const AsyncTaskCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_remove_duplicate_tasks_46_comment =
    "C++ Interface:\n"
    "removeDuplicateTasks(non-const AsyncTaskCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::remove_duplicate_tasks\n"
    "//       Access: Published\n"
    "//  Description: Removes any duplicate entries of the same AsyncTasks\n"
    "//               on this collection.  If a AsyncTask appears multiple\n"
    "//               times, the first appearance is retained; subsequent\n"
    "//               appearances are removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_remove_duplicate_tasks_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskCollection::has_task(AsyncTask *task) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_has_task_47(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool AsyncTaskCollection::has_task(AsyncTask *task) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasTask", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskCollection.hasTask", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const AsyncTaskCollection*)local_this)->has_task(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTask(const AsyncTaskCollection this, non-const AsyncTask task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_has_task_47_comment =
    "C++ Interface:\n"
    "hasTask(const AsyncTaskCollection this, non-const AsyncTask task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::has_task\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated AsyncTask appears in\n"
    "//               this collection, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_has_task_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::clear(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_clear_48(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskCollection::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskCollection.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const AsyncTaskCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_clear_48_comment =
    "C++ Interface:\n"
    "clear(non-const AsyncTaskCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all AsyncTasks from the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_clear_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTask *AsyncTaskCollection::find_task(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_find_task_49(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTask *AsyncTaskCollection::find_task(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findTask", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findTask", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AsyncTask *return_value = ((const AsyncTaskCollection*)local_this)->find_task(basic_string<char>(param1_str, param1_len));
            if (return_value != (AsyncTask *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTask,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTask(const AsyncTaskCollection this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_find_task_49_comment =
    "C++ Interface:\n"
    "findTask(const AsyncTaskCollection this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::find_task\n"
    "//       Access: Published\n"
    "//  Description: Returns the task in the collection with the\n"
    "//               indicated name, if any, or NULL if no task has\n"
    "//               that name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_find_task_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskCollection::get_num_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_get_num_tasks_50(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskCollection::get_num_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTasks"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskCollection*)local_this)->get_num_tasks();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTasks(const AsyncTaskCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_get_num_tasks_50_comment =
    "C++ Interface:\n"
    "getNumTasks(const AsyncTaskCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::get_num_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of AsyncTasks in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_get_num_tasks_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTask *AsyncTaskCollection::get_task(int index) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_get_task_51(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTask *AsyncTaskCollection::get_task(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTask", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTask", &param1));
        if(!PyErr_Occurred())
        {
            AsyncTask *return_value = ((const AsyncTaskCollection*)local_this)->get_task((int)param1);
            if (return_value != (AsyncTask *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTask,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTask(const AsyncTaskCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_get_task_51_comment =
    "C++ Interface:\n"
    "getTask(const AsyncTaskCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::get_task\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth AsyncTask in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_get_task_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTask *AsyncTaskCollection::operator [](int index) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_operator_52(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTask *AsyncTaskCollection::operator [](int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const AsyncTaskCollection*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            AsyncTask *return_value = ((const AsyncTaskCollection*)local_this)->operator []((int)param1);
            if (return_value != (AsyncTask *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTask,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const AsyncTaskCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_operator_52_comment =
    "C++ Interface:\n"
    "__getitem__(const AsyncTaskCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth AsyncTask in the collection.  This is\n"
    "//               the same as get_task(), but it may be a more\n"
    "//               convenient way to access it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_operator_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskCollection::size(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_size_53(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskCollection::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskCollection*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const AsyncTaskCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_size_53_comment =
    "C++ Interface:\n"
    "size(const AsyncTaskCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of tasks in the collection.  This\n"
    "//               is the same thing as get_num_tasks().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_size_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_operator_54(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskCollection.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskCollection.__iadd__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_operator_54_comment =
    "C++ Interface:\n"
    "__iadd__(non-const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Appends the other list onto the end of this one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_operator_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_operator_55(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskCollection.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    AsyncTaskCollection result = ((const AsyncTaskCollection*)local_this)->operator +(*param1_this);
                    AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_operator_55_comment =
    "C++ Interface:\n"
    "__add__(const AsyncTaskCollection this, const AsyncTaskCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a AsyncTaskCollection representing the\n"
    "//               concatenation of the two lists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_operator_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_output_56(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void AsyncTaskCollection::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskCollection.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AsyncTaskCollection*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AsyncTaskCollection this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_output_56_comment =
    "C++ Interface:\n"
    "output(const AsyncTaskCollection this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::output\n"
    "//       Access: Published\n"
    "//  Description: Writes a brief one-line description of the\n"
    "//               AsyncTaskCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_output_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskCollection::write(ostream &out, int indent_level) const
 * void AsyncTaskCollection::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_write_57(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void AsyncTaskCollection::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskCollection*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void AsyncTaskCollection::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskCollection*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const AsyncTaskCollection this, non-const Ostream out)\n"
          "write(const AsyncTaskCollection this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_write_57_comment =
    "C++ Interface:\n"
    "write(const AsyncTaskCollection this, non-const Ostream out)\n"
    "write(const AsyncTaskCollection this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskCollection::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a complete multi-line description of the\n"
    "//               AsyncTaskCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_write_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_138(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToAsyncTaskSequence", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToAsyncTaskSequence"));
        if(!PyErr_Occurred())
        {
            AsyncTaskSequence *return_value = (AsyncTaskSequence *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskSequence,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskCollection.downcastToAsyncTaskSequence() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToAsyncTaskSequence(non-const AsyncTaskCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_138_comment =
    "C++ Interface:\n"
    "downcastToAsyncTaskSequence(non-const AsyncTaskCollection this)\n"
    "\n"
    "downcast from AsyncTaskCollection to AsyncTaskSequence\n"
    "";
#else
static const char * Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection::AsyncTaskCollection(void)
 * AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
 *******************************************************************/
int  Dtool_Init_AsyncTaskCollection(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-AsyncTaskCollection::AsyncTaskCollection(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":AsyncTaskCollection", key_word_list))
            {
                AsyncTaskCollection *return_value = new AsyncTaskCollection();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_AsyncTaskCollection,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:AsyncTaskCollection", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:AsyncTaskCollection", &param0));
                if(!PyErr_Occurred())
                {
                    AsyncTaskCollection *param0_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AsyncTaskCollection, 0, "AsyncTaskCollection.AsyncTaskCollection", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        AsyncTaskCollection *return_value = new AsyncTaskCollection(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AsyncTaskCollection,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "AsyncTaskCollection() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "AsyncTaskCollection()\n"
          "AsyncTaskCollection(const AsyncTaskCollection copy)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_AsyncTaskCollection_get_tasks(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumTasks", "getTask");
}
inline void  * Dtool_UpcastInterface_AsyncTaskCollection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskCollection)
    {
        printf("AsyncTaskCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskCollection * local_this = (AsyncTaskCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskCollection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskCollection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskCollection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AsyncTaskChain 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_tick_clock(bool tick_clock)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_tick_clock_66(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_tick_clock(bool tick_clock)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"tick_clock", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTickClock", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTickClock", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_tick_clock((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setTickClock() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTickClock(non-const AsyncTaskChain this, bool tick_clock)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_tick_clock_66_comment =
    "C++ Interface:\n"
    "setTickClock(non-const AsyncTaskChain this, bool tick_clock)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_tick_clock\n"
    "//       Access: Published\n"
    "//  Description: Sets the tick_clock flag.  When this is true,\n"
    "//               get_clock()->tick() will be called automatically at\n"
    "//               each task epoch.  This is false by default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_tick_clock_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskChain::get_tick_clock(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_tick_clock_67(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool AsyncTaskChain::get_tick_clock(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTickClock", key_word_list));
        else
            (PyArg_Parse(args, ":getTickClock"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTaskChain*)local_this)->get_tick_clock();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTickClock(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_tick_clock_67_comment =
    "C++ Interface:\n"
    "getTickClock(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_tick_clock\n"
    "//       Access: Published\n"
    "//  Description: Returns the tick_clock flag.  See set_tick_clock().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_tick_clock_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_num_threads(int num_threads)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_num_threads_68(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_num_threads(int num_threads)
        int param1;
        static char * key_word_list[] = {(char *)"num_threads", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumThreads", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumThreads", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->set_num_threads((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setNumThreads() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumThreads(non-const AsyncTaskChain this, int num_threads)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_num_threads_68_comment =
    "C++ Interface:\n"
    "setNumThreads(non-const AsyncTaskChain this, int num_threads)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_num_threads\n"
    "//       Access: Published\n"
    "//  Description: Changes the number of threads for this task chain.\n"
    "//               This may require stopping the threads if they are\n"
    "//               already running.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_num_threads_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskChain::get_num_threads(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_num_threads_69(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskChain::get_num_threads(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumThreads", key_word_list));
        else
            (PyArg_Parse(args, ":getNumThreads"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskChain*)local_this)->get_num_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumThreads(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_num_threads_69_comment =
    "C++ Interface:\n"
    "getNumThreads(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_num_threads\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of threads that will be servicing\n"
    "//               tasks for this chain.  Also see\n"
    "//               get_num_running_threads().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_num_threads_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskChain::get_num_running_threads(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_num_running_threads_70(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskChain::get_num_running_threads(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRunningThreads", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRunningThreads"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskChain*)local_this)->get_num_running_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRunningThreads(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_num_running_threads_70_comment =
    "C++ Interface:\n"
    "getNumRunningThreads(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_num_running_threads\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of threads that have been created\n"
    "//               and are actively running.  This will return 0 before\n"
    "//               the threads have been started; it will also return 0\n"
    "//               if thread support is not available.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_num_running_threads_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_thread_priority_71(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
        int param1;
        static char * key_word_list[] = {(char *)"priority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setThreadPriority", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setThreadPriority", &param1));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->set_thread_priority((ThreadPriority)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setThreadPriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThreadPriority(non-const AsyncTaskChain this, int priority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_thread_priority_71_comment =
    "C++ Interface:\n"
    "setThreadPriority(non-const AsyncTaskChain this, int priority)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_thread_priority\n"
    "//       Access: Published\n"
    "//  Description: Changes the priority associated with threads that\n"
    "//               serve this task chain.  This may require stopping the\n"
    "//               threads if they are already running.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_thread_priority_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ThreadPriority AsyncTaskChain::get_thread_priority(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_thread_priority_72(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-ThreadPriority AsyncTaskChain::get_thread_priority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThreadPriority", key_word_list));
        else
            (PyArg_Parse(args, ":getThreadPriority"));
        if(!PyErr_Occurred())
        {
            ThreadPriority return_value = ((const AsyncTaskChain*)local_this)->get_thread_priority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThreadPriority(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_thread_priority_72_comment =
    "C++ Interface:\n"
    "getThreadPriority(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_thread_priority\n"
    "//       Access: Published\n"
    "//  Description: Returns the priority associated with threads that\n"
    "//               serve this task chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_thread_priority_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_frame_budget(double frame_budget)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_frame_budget_73(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_frame_budget(double frame_budget)
        double param1;
        static char * key_word_list[] = {(char *)"frame_budget", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFrameBudget", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFrameBudget", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_budget((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setFrameBudget() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameBudget(non-const AsyncTaskChain this, float frame_budget)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_frame_budget_73_comment =
    "C++ Interface:\n"
    "setFrameBudget(non-const AsyncTaskChain this, float frame_budget)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_frame_budget\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum amount of time per frame the tasks\n"
    "//               on this chain are granted for execution.  If this is\n"
    "//               less than zero, there is no limit; if it is >= 0, it\n"
    "//               represents a maximum amount of time (in seconds) that\n"
    "//               will be used to execute tasks.  If this time is\n"
    "//               exceeded in any one frame, the task chain will stop\n"
    "//               executing tasks until the next frame, as defined by\n"
    "//               the TaskManager's clock.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_frame_budget_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double AsyncTaskChain::get_frame_budget(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_frame_budget_74(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double AsyncTaskChain::get_frame_budget(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameBudget", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameBudget"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTaskChain*)local_this)->get_frame_budget();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameBudget(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_frame_budget_74_comment =
    "C++ Interface:\n"
    "getFrameBudget(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_frame_budget\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum amount of time per frame the\n"
    "//               tasks on this chain are granted for execution.  See\n"
    "//               set_frame_budget().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_frame_budget_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_frame_sync(bool frame_sync)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_frame_sync_75(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_frame_sync(bool frame_sync)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"frame_sync", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameSync", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFrameSync", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_frame_sync((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setFrameSync() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameSync(non-const AsyncTaskChain this, bool frame_sync)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_frame_sync_75_comment =
    "C++ Interface:\n"
    "setFrameSync(non-const AsyncTaskChain this, bool frame_sync)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_frame_sync\n"
    "//       Access: Published\n"
    "//  Description: Sets the frame_sync flag.  When this flag is true,\n"
    "//               this task chain will be forced to sync with the\n"
    "//               TaskManager's clock.  It will run no faster than one\n"
    "//               epoch per clock frame.\n"
    "//\n"
    "//               When this flag is false, the default, the task chain\n"
    "//               will finish all of its tasks and then immediately\n"
    "//               start from the first task again, regardless of the\n"
    "//               clock frame.  When it is true, the task chain will\n"
    "//               finish all of its tasks and then wait for the clock\n"
    "//               to tick to the next frame before resuming the first\n"
    "//               task.\n"
    "//\n"
    "//               This only makes sense for threaded task chains.\n"
    "//               Non-threaded task chains are automatically\n"
    "//               synchronous.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_frame_sync_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskChain::get_frame_sync(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_frame_sync_76(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool AsyncTaskChain::get_frame_sync(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameSync", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameSync"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTaskChain*)local_this)->get_frame_sync();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameSync(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_frame_sync_76_comment =
    "C++ Interface:\n"
    "getFrameSync(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_frame_sync\n"
    "//       Access: Published\n"
    "//  Description: Returns the frame_sync flag.  See set_frame_sync().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_frame_sync_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_set_timeslice_priority_77(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"timeslice_priority", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTimeslicePriority", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTimeslicePriority", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_timeslice_priority((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.setTimeslicePriority() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimeslicePriority(non-const AsyncTaskChain this, bool timeslice_priority)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_set_timeslice_priority_77_comment =
    "C++ Interface:\n"
    "setTimeslicePriority(non-const AsyncTaskChain this, bool timeslice_priority)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::set_timeslice_priority\n"
    "//       Access: Published\n"
    "//  Description: Sets the timeslice_priority flag.  This changes\n"
    "//               the interpretation of priority, and the number of\n"
    "//               times per epoch each task will run.  \n"
    "//\n"
    "//               When this flag is true, some tasks might not run in\n"
    "//               any given epoch.  Instead, tasks with priority higher\n"
    "//               than 1 will be given precedence, in proportion to the\n"
    "//               amount of time they have already used.  This gives\n"
    "//               higher-priority tasks more runtime than\n"
    "//               lower-priority tasks.  Each task gets the amount of\n"
    "//               time proportional to its priority value, so a task\n"
    "//               with priority 100 will get five times as much\n"
    "//               processing time as a task with priority 20.  For\n"
    "//               these purposes, priority values less than 1 are\n"
    "//               deemed to be equal to 1.\n"
    "//\n"
    "//               When this flag is false (the default), all tasks are\n"
    "//               run exactly once each epoch, round-robin style.\n"
    "//               Priority is only used to determine which task runs\n"
    "//               first within tasks of the same sort value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_set_timeslice_priority_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskChain::get_timeslice_priority(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_timeslice_priority_78(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool AsyncTaskChain::get_timeslice_priority(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimeslicePriority", key_word_list));
        else
            (PyArg_Parse(args, ":getTimeslicePriority"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTaskChain*)local_this)->get_timeslice_priority();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimeslicePriority(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_timeslice_priority_78_comment =
    "C++ Interface:\n"
    "getTimeslicePriority(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_timeslice_priority\n"
    "//       Access: Published\n"
    "//  Description: Returns the timeslice_priority flag.  This changes\n"
    "//               the interpretation of priority, and the number of\n"
    "//               times per epoch each task will run.  See\n"
    "//               set_timeslice_priority().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_timeslice_priority_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::stop_threads(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_stop_threads_79(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::stop_threads(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stopThreads", key_word_list));
        else
            (PyArg_Parse(args, ":stopThreads"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->stop_threads();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.stopThreads() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stopThreads(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_stop_threads_79_comment =
    "C++ Interface:\n"
    "stopThreads(non-const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::stop_threads\n"
    "//       Access: Published\n"
    "//  Description: Stops any threads that are currently running.  If any\n"
    "//               tasks are still pending and have not yet been picked\n"
    "//               up by a thread, they will not be serviced unless\n"
    "//               poll() or start_threads() is later called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_stop_threads_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::start_threads(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_start_threads_80(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::start_threads(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":startThreads", key_word_list));
        else
            (PyArg_Parse(args, ":startThreads"));
        if(!PyErr_Occurred())
        {
            (local_this)->start_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.startThreads() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "startThreads(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_start_threads_80_comment =
    "C++ Interface:\n"
    "startThreads(non-const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::start_threads\n"
    "//       Access: Published\n"
    "//  Description: Starts any requested threads to service the tasks on\n"
    "//               the queue.  This is normally not necessary, since\n"
    "//               adding a task will start the threads automatically.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_start_threads_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool AsyncTaskChain::is_started(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_is_started_81(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool AsyncTaskChain::is_started(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStarted", key_word_list));
        else
            (PyArg_Parse(args, ":isStarted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AsyncTaskChain*)local_this)->is_started();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStarted(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_is_started_81_comment =
    "C++ Interface:\n"
    "isStarted(const AsyncTaskChain this)\n"
    "\n"
    "// Filename: asyncTaskChain.I\n"
    "// Created by:  drose (23Aug06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::is_started\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the thread(s) have been started and\n"
    "//               are ready to service requests, false otherwise.  If\n"
    "//               this is false, the next call to add() or add_and_do()\n"
    "//               will automatically start the threads.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_is_started_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskChain::has_task(AsyncTask *task) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_has_task_82(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool AsyncTaskChain::has_task(AsyncTask *task) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasTask", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskChain.hasTask", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const AsyncTaskChain*)local_this)->has_task(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTask(const AsyncTaskChain this, non-const AsyncTask task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_has_task_82_comment =
    "C++ Interface:\n"
    "hasTask(const AsyncTaskChain this, non-const AsyncTask task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::has_task\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated task has been added to\n"
    "//               this AsyncTaskChain, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_has_task_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::wait_for_tasks(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_wait_for_tasks_83(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::wait_for_tasks(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":waitForTasks", key_word_list));
        else
            (PyArg_Parse(args, ":waitForTasks"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->wait_for_tasks();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.waitForTasks() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "waitForTasks(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_wait_for_tasks_83_comment =
    "C++ Interface:\n"
    "waitForTasks(non-const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::wait_for_tasks\n"
    "//       Access: Published\n"
    "//  Description: Blocks until the task list is empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_wait_for_tasks_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskChain::get_num_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_num_tasks_84(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskChain::get_num_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTasks"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskChain*)local_this)->get_num_tasks();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTasks(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_num_tasks_84_comment =
    "C++ Interface:\n"
    "getNumTasks(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_num_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of tasks that are currently active\n"
    "//               or sleeping within the task chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_num_tasks_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_tasks_85(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskChain*)local_this)->get_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTasks(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_tasks_85_comment =
    "C++ Interface:\n"
    "getTasks(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are active or sleeping\n"
    "//               on the task chain, at the time of the call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_tasks_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_active_tasks_86(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActiveTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getActiveTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskChain*)local_this)->get_active_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActiveTasks(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_active_tasks_86_comment =
    "C++ Interface:\n"
    "getActiveTasks(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_active_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are active (and not\n"
    "//               sleeping) on the task chain, at the time of the\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_active_tasks_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_sleeping_tasks_87(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSleepingTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getSleepingTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskChain*)local_this)->get_sleeping_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSleepingTasks(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_sleeping_tasks_87_comment =
    "C++ Interface:\n"
    "getSleepingTasks(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_sleeping_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are sleeping (and not\n"
    "//               active) on the task chain, at the time of the\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_sleeping_tasks_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskChain::poll(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_poll_88(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskChain::poll(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":poll", key_word_list));
        else
            (PyArg_Parse(args, ":poll"));
        if(!PyErr_Occurred())
        {
            (local_this)->poll();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.poll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "poll(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_poll_88_comment =
    "C++ Interface:\n"
    "poll(non-const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::poll\n"
    "//       Access: Published\n"
    "//  Description: Runs through all the tasks in the task list, once, if\n"
    "//               the task chain is running in single-threaded mode\n"
    "//               (no threads available).  This method does nothing in\n"
    "//               threaded mode, so it may safely be called in either\n"
    "//               case.\n"
    "//\n"
    "//               Normally, you would not call this function directly;\n"
    "//               instead, call AsyncTaskManager::poll(), which polls\n"
    "//               all of the task chains in sequence.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_poll_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double AsyncTaskChain::get_next_wake_time(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_next_wake_time_89(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double AsyncTaskChain::get_next_wake_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNextWakeTime", key_word_list));
        else
            (PyArg_Parse(args, ":getNextWakeTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTaskChain*)local_this)->get_next_wake_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextWakeTime(const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_next_wake_time_89_comment =
    "C++ Interface:\n"
    "getNextWakeTime(const AsyncTaskChain this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::get_next_wake_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the scheduled time (on the manager's clock)\n"
    "//               of the next sleeping task, on any task chain, to\n"
    "//               awaken.  Returns -1 if there are no sleeping tasks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_next_wake_time_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AsyncTaskChain::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_output_90(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AsyncTaskChain::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskChain.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AsyncTaskChain*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AsyncTaskChain this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_output_90_comment =
    "C++ Interface:\n"
    "output(const AsyncTaskChain this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_output_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AsyncTaskChain::write(ostream &out, int indent_level) const
 * virtual void AsyncTaskChain::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_write_91(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AsyncTaskChain::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskChain.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskChain*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AsyncTaskChain::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskChain.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskChain*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const AsyncTaskChain this, non-const Ostream out)\n"
          "write(const AsyncTaskChain this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_write_91_comment =
    "C++ Interface:\n"
    "write(const AsyncTaskChain this, non-const Ostream out)\n"
    "write(const AsyncTaskChain this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskChain::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_write_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTaskChain::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_get_class_type_92(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTaskChain::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTaskChain::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_get_class_type_92_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_get_class_type_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_60(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_60_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const AsyncTaskChain this)\n"
    "\n"
    "upcast from AsyncTaskChain to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *AsyncTaskChain::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskChain_upcast_to_Namable_63(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *AsyncTaskChain::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskChain.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const AsyncTaskChain this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskChain_upcast_to_Namable_63_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const AsyncTaskChain this)\n"
    "\n"
    "upcast from AsyncTaskChain to Namable\n"
    "";
#else
static const char * Dtool_AsyncTaskChain_upcast_to_Namable_63_comment = NULL;
#endif

int  Dtool_Init_AsyncTaskChain(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AsyncTaskChain)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AsyncTaskChain(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskChain)
    {
        printf("AsyncTaskChain ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskChain * local_this = (AsyncTaskChain *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskChain)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskChain(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskChain)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTaskChain*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTaskChain*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTaskChain*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTaskChain*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AsyncTaskManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::cleanup(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_cleanup_100(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskManager::cleanup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":cleanup", key_word_list));
        else
            (PyArg_Parse(args, ":cleanup"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->cleanup();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.cleanup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "cleanup(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_cleanup_100_comment =
    "C++ Interface:\n"
    "cleanup(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::cleanup\n"
    "//       Access: Published\n"
    "//  Description: Stops all threads and messily empties the task list.\n"
    "//               This is intended to be called on destruction only.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_cleanup_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTaskManager::set_clock(ClockObject *clock)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_set_clock_101(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AsyncTaskManager::set_clock(ClockObject *clock)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"clock", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClock", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setClock", &param1));
            if(!PyErr_Occurred())
            {
                ClockObject *param1_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ClockObject, 1, "AsyncTaskManager.setClock", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_clock(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskManager.setClock() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClock(non-const AsyncTaskManager this, non-const ClockObject clock)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_set_clock_101_comment =
    "C++ Interface:\n"
    "setClock(non-const AsyncTaskManager this, non-const ClockObject clock)\n"
    "\n"
    "// Filename: asyncTaskManager.I\n"
    "// Created by:  drose (23Aug06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::set_clock\n"
    "//       Access: Published\n"
    "//  Description: Replaces the clock pointer used within the\n"
    "//               AsyncTaskManager.  This is used to control when tasks\n"
    "//               with a set_delay() specified will be scheduled.  It\n"
    "//               can also be ticked automatically each epoch, if\n"
    "//               set_tick_clock() is true.\n"
    "//\n"
    "//               The default is the global clock pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_set_clock_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ClockObject *AsyncTaskManager::get_clock(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_clock_102(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline ClockObject *AsyncTaskManager::get_clock(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClock", key_word_list));
        else
            (PyArg_Parse(args, ":getClock"));
        if(!PyErr_Occurred())
        {
            ClockObject *return_value = (local_this)->get_clock();
            if (return_value != (ClockObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ClockObject,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.getClock() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClock(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_clock_102_comment =
    "C++ Interface:\n"
    "getClock(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_clock\n"
    "//       Access: Published\n"
    "//  Description: Returns the clock pointer used within the\n"
    "//               AsyncTaskManager.  See set_clock().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_clock_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int AsyncTaskManager::get_num_task_chains(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_num_task_chains_103(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int AsyncTaskManager::get_num_task_chains(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTaskChains", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTaskChains"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskManager*)local_this)->get_num_task_chains();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTaskChains(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_num_task_chains_103_comment =
    "C++ Interface:\n"
    "getNumTaskChains(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_num_task_chains\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of different task chains.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_num_task_chains_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_task_chain_104(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTaskChain", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTaskChain", &param1));
        if(!PyErr_Occurred())
        {
            AsyncTaskChain *return_value = ((const AsyncTaskManager*)local_this)->get_task_chain((int)param1);
            if (return_value != (AsyncTaskChain *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskChain,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTaskChain(const AsyncTaskManager this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_task_chain_104_comment =
    "C++ Interface:\n"
    "getTaskChain(const AsyncTaskManager this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_task_chain\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth task chain.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_task_chain_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskChain *AsyncTaskManager::make_task_chain(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_make_task_chain_105(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTaskChain *AsyncTaskManager::make_task_chain(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:makeTaskChain", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:makeTaskChain", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AsyncTaskChain *return_value = (local_this)->make_task_chain(basic_string<char>(param1_str, param1_len));
            if (return_value != (AsyncTaskChain *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskChain,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.makeTaskChain() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeTaskChain(non-const AsyncTaskManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_make_task_chain_105_comment =
    "C++ Interface:\n"
    "makeTaskChain(non-const AsyncTaskManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::make_task_chain\n"
    "//       Access: Published\n"
    "//  Description: Creates a new AsyncTaskChain of the indicated name\n"
    "//               and stores it within the AsyncTaskManager.  If a task\n"
    "//               chain with this name already exists, returns it\n"
    "//               instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_make_task_chain_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskChain *AsyncTaskManager::find_task_chain(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_find_task_chain_106(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTaskChain *AsyncTaskManager::find_task_chain(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findTaskChain", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findTaskChain", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AsyncTaskChain *return_value = (local_this)->find_task_chain(basic_string<char>(param1_str, param1_len));
            if (return_value != (AsyncTaskChain *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskChain,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.findTaskChain() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTaskChain(non-const AsyncTaskManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_find_task_chain_106_comment =
    "C++ Interface:\n"
    "findTaskChain(non-const AsyncTaskManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::find_task_chain\n"
    "//       Access: Protected\n"
    "//  Description: Searches a new AsyncTaskChain of the indicated name\n"
    "//               and returns it if it exists, or NULL otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_find_task_chain_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskManager::remove_task_chain(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_remove_task_chain_107(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool AsyncTaskManager::remove_task_chain(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeTaskChain", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeTaskChain", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = (local_this)->remove_task_chain(basic_string<char>(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.removeTaskChain() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeTaskChain(non-const AsyncTaskManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_remove_task_chain_107_comment =
    "C++ Interface:\n"
    "removeTaskChain(non-const AsyncTaskManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::remove_task_chain\n"
    "//       Access: Protected\n"
    "//  Description: Removes the AsyncTaskChain of the indicated name.\n"
    "//               If the chain still has tasks, this will block until\n"
    "//               all tasks are finished.\n"
    "//\n"
    "//               Returns true if successful, or false if the chain did\n"
    "//               not exist.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_remove_task_chain_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::add(AsyncTask *task)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_add_108(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void AsyncTaskManager::add(AsyncTask *task)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskManager.add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AsyncTaskManager.add() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add(non-const AsyncTaskManager this, non-const AsyncTask task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_add_108_comment =
    "C++ Interface:\n"
    "add(non-const AsyncTaskManager this, non-const AsyncTask task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::add\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated task to the active queue.  It is\n"
    "//               an error if the task is already added to this or any\n"
    "//               other active queue.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_add_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskManager::has_task(AsyncTask *task) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_has_task_109(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool AsyncTaskManager::has_task(AsyncTask *task) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasTask", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasTask", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskManager.hasTask", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const AsyncTaskManager*)local_this)->has_task(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasTask(const AsyncTaskManager this, non-const AsyncTask task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_has_task_109_comment =
    "C++ Interface:\n"
    "hasTask(const AsyncTaskManager this, non-const AsyncTask task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::has_task\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated task has been added to\n"
    "//               this AsyncTaskManager, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_has_task_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTask *AsyncTaskManager::find_task(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_find_task_110(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTask *AsyncTaskManager::find_task(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findTask", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findTask", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AsyncTask *return_value = ((const AsyncTaskManager*)local_this)->find_task(basic_string<char>(param1_str, param1_len));
            if (return_value != (AsyncTask *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTask,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTask(const AsyncTaskManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_find_task_110_comment =
    "C++ Interface:\n"
    "findTask(const AsyncTaskManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::find_task\n"
    "//       Access: Published\n"
    "//  Description: Returns the first task found with the indicated name,\n"
    "//               or NULL if there is no task with the indicated name.\n"
    "//\n"
    "//               If there are multiple tasks with the same name,\n"
    "//               returns one of them arbitrarily.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_find_task_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskManager::find_tasks(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_find_tasks_111(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskManager::find_tasks(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findTasks", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findTasks", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskManager*)local_this)->find_tasks(basic_string<char>(param1_str, param1_len));
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTasks(const AsyncTaskManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_find_tasks_111_comment =
    "C++ Interface:\n"
    "findTasks(const AsyncTaskManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::find_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the list of tasks found with the indicated\n"
    "//               name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_find_tasks_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_find_tasks_matching_112(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pattern", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findTasksMatching", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findTasksMatching", &param1));
            if(!PyErr_Occurred())
            {
                GlobPattern *param1_this = (GlobPattern *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_GlobPattern, 1, "AsyncTaskManager.findTasksMatching", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    AsyncTaskCollection result = ((const AsyncTaskManager*)local_this)->find_tasks_matching(*param1_this);
                    AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTasksMatching(const AsyncTaskManager this, const GlobPattern pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_find_tasks_matching_112_comment =
    "C++ Interface:\n"
    "findTasksMatching(const AsyncTaskManager this, const GlobPattern pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::find_tasks_matching\n"
    "//       Access: Published\n"
    "//  Description: Returns the list of tasks found whose name matches\n"
    "//               the indicated glob pattern, e.g. \"my_task_*\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_find_tasks_matching_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AsyncTaskManager::remove(AsyncTask *task)
 * int AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_remove_113(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool AsyncTaskManager::remove(AsyncTask *task)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"task", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remove", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTask *param1_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTask, 1, "AsyncTaskManager.remove", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tasks", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remove", &param1));
            if(!PyErr_Occurred())
            {
                AsyncTaskCollection *param1_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AsyncTaskCollection, 1, "AsyncTaskManager.remove", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remove(non-const AsyncTaskManager this, non-const AsyncTask task)\n"
          "remove(non-const AsyncTaskManager this, const AsyncTaskCollection tasks)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_remove_113_comment =
    "C++ Interface:\n"
    "remove(non-const AsyncTaskManager this, non-const AsyncTask task)\n"
    "remove(non-const AsyncTaskManager this, const AsyncTaskCollection tasks)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::remove\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated task from the active queue.\n"
    "//               Returns true if the task is successfully removed, or\n"
    "//               false if it wasn't there.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::remove\n"
    "//       Access: Published\n"
    "//  Description: Removes all of the tasks in the AsyncTaskCollection.\n"
    "//               Returns the number of tasks removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_remove_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::wait_for_tasks(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_wait_for_tasks_114(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskManager::wait_for_tasks(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":waitForTasks", key_word_list));
        else
            (PyArg_Parse(args, ":waitForTasks"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->wait_for_tasks();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.waitForTasks() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "waitForTasks(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_wait_for_tasks_114_comment =
    "C++ Interface:\n"
    "waitForTasks(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::wait_for_tasks\n"
    "//       Access: Published\n"
    "//  Description: Blocks until the task list is empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_wait_for_tasks_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::stop_threads(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_stop_threads_115(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskManager::stop_threads(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stopThreads", key_word_list));
        else
            (PyArg_Parse(args, ":stopThreads"));
        if(!PyErr_Occurred())
        {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            (local_this)->stop_threads();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.stopThreads() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stopThreads(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_stop_threads_115_comment =
    "C++ Interface:\n"
    "stopThreads(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::stop_threads\n"
    "//       Access: Published\n"
    "//  Description: Stops any threads that are currently running.  If any\n"
    "//               tasks are still pending and have not yet been picked\n"
    "//               up by a thread, they will not be serviced unless\n"
    "//               poll() or start_threads() is later called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_stop_threads_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::start_threads(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_start_threads_116(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskManager::start_threads(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":startThreads", key_word_list));
        else
            (PyArg_Parse(args, ":startThreads"));
        if(!PyErr_Occurred())
        {
            (local_this)->start_threads();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.startThreads() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "startThreads(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_start_threads_116_comment =
    "C++ Interface:\n"
    "startThreads(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::start_threads\n"
    "//       Access: Published\n"
    "//  Description: Starts any requested threads to service the tasks on\n"
    "//               the queue.  This is normally not necessary, since\n"
    "//               adding a task will start the threads automatically.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_start_threads_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTaskManager::get_num_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_num_tasks_117(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTaskManager::get_num_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTasks"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskManager*)local_this)->get_num_tasks();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTasks(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_num_tasks_117_comment =
    "C++ Interface:\n"
    "getNumTasks(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_num_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of tasks that are currently active\n"
    "//               or sleeping within the task manager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_num_tasks_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_tasks_118(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskManager*)local_this)->get_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTasks(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_tasks_118_comment =
    "C++ Interface:\n"
    "getTasks(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are active or sleeping\n"
    "//               on the task manager, at the time of the call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_tasks_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_active_tasks_119(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActiveTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getActiveTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskManager*)local_this)->get_active_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActiveTasks(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_active_tasks_119_comment =
    "C++ Interface:\n"
    "getActiveTasks(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_active_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are active (and not\n"
    "//               sleeping) on the task manager, at the time of the\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_active_tasks_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_sleeping_tasks_120(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSleepingTasks", key_word_list));
        else
            (PyArg_Parse(args, ":getSleepingTasks"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection result = ((const AsyncTaskManager*)local_this)->get_sleeping_tasks();
            AsyncTaskCollection *return_value = new AsyncTaskCollection(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSleepingTasks(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_sleeping_tasks_120_comment =
    "C++ Interface:\n"
    "getSleepingTasks(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_sleeping_tasks\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of tasks that are sleeping (and not\n"
    "//               active) on the task manager, at the time of the\n"
    "//               call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_sleeping_tasks_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AsyncTaskManager::poll(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_poll_121(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AsyncTaskManager::poll(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":poll", key_word_list));
        else
            (PyArg_Parse(args, ":poll"));
        if(!PyErr_Occurred())
        {
            (local_this)->poll();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.poll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "poll(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_poll_121_comment =
    "C++ Interface:\n"
    "poll(non-const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::poll\n"
    "//       Access: Published\n"
    "//  Description: Runs through all the tasks in the task list, once, if\n"
    "//               the task manager is running in single-threaded mode\n"
    "//               (no threads available).  This method does nothing in\n"
    "//               threaded mode, so it may safely be called in either\n"
    "//               case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_poll_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double AsyncTaskManager::get_next_wake_time(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_next_wake_time_122(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double AsyncTaskManager::get_next_wake_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNextWakeTime", key_word_list));
        else
            (PyArg_Parse(args, ":getNextWakeTime"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const AsyncTaskManager*)local_this)->get_next_wake_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextWakeTime(const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_next_wake_time_122_comment =
    "C++ Interface:\n"
    "getNextWakeTime(const AsyncTaskManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_next_wake_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the scheduled time (on the manager's clock)\n"
    "//               of the next sleeping task, on any task chain, to\n"
    "//               awaken.  Returns -1 if there are no sleeping tasks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_next_wake_time_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AsyncTaskManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_output_123(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void AsyncTaskManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const AsyncTaskManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const AsyncTaskManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_output_123_comment =
    "C++ Interface:\n"
    "output(const AsyncTaskManager this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_output_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AsyncTaskManager::write(ostream &out, int indent_level) const
 * virtual void AsyncTaskManager::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_write_124(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AsyncTaskManager::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskManager*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AsyncTaskManager::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AsyncTaskManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AsyncTaskManager*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const AsyncTaskManager this, non-const Ostream out)\n"
          "write(const AsyncTaskManager this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_write_124_comment =
    "C++ Interface:\n"
    "write(const AsyncTaskManager this, non-const Ostream out)\n"
    "write(const AsyncTaskManager this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_write_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_global_ptr_125(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            AsyncTaskManager *return_value = AsyncTaskManager::get_global_ptr();
            if (return_value != (AsyncTaskManager *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTaskManager,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_global_ptr_125_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskManager::get_global_ptr\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the global AsyncTaskManager.\n"
    "//               This is the AsyncTaskManager that most code should\n"
    "//               use for queueing tasks and suchlike.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_global_ptr_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTaskManager::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_get_class_type_126(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTaskManager::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTaskManager::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_get_class_type_126_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_get_class_type_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_94(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_94_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const AsyncTaskManager this)\n"
    "\n"
    "upcast from AsyncTaskManager to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *AsyncTaskManager::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskManager_upcast_to_Namable_96(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *AsyncTaskManager::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskManager.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const AsyncTaskManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskManager_upcast_to_Namable_96_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const AsyncTaskManager this)\n"
    "\n"
    "upcast from AsyncTaskManager to Namable\n"
    "";
#else
static const char * Dtool_AsyncTaskManager_upcast_to_Namable_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskManager::AsyncTaskManager(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_AsyncTaskManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AsyncTaskManager::AsyncTaskManager(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:AsyncTaskManager", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:AsyncTaskManager", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            AsyncTaskManager *return_value = new AsyncTaskManager(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AsyncTaskManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AsyncTaskManager(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_AsyncTaskManager_get_task_chains(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumTaskChains", "getTaskChain");
}
inline void  * Dtool_UpcastInterface_AsyncTaskManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskManager)
    {
        printf("AsyncTaskManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskManager * local_this = (AsyncTaskManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskManager)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskManager)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTaskManager*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTaskManager*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTaskManager*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTaskManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AsyncTaskPause 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTaskPause::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskPause_get_class_type_132(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTaskPause::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTaskPause::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskPause_get_class_type_132_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTaskPause_get_class_type_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskPause::AsyncTaskPause(double delay)
 *******************************************************************/
int  Dtool_Init_AsyncTaskPause(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AsyncTaskPause::AsyncTaskPause(double delay)
        double param0;
        static char * key_word_list[] = {(char *)"delay", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:AsyncTaskPause", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:AsyncTaskPause", &param0));
        if(!PyErr_Occurred())
        {
            AsyncTaskPause *return_value = new AsyncTaskPause((double)param0);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AsyncTaskPause,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AsyncTaskPause(float delay)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AsyncTaskPause(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskPause)
    {
        printf("AsyncTaskPause ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskPause * local_this = (AsyncTaskPause *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskPause)
        return local_this;
    if(requested_type == &Dtool_AsyncTask)
        return ( AsyncTask *) local_this;
    if(requested_type == &Dtool_AsyncTaskBase)
        return ( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskPause(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskPause)
        return from_this;
    if(from_type == &Dtool_AsyncTask)
    {
          AsyncTask* other_this = (AsyncTask*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    if(from_type == &Dtool_AsyncTaskBase)
    {
          AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTaskPause*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AsyncTaskSequence 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_set_repeat_count_144(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskSequence * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskSequence,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
        int param1;
        static char * key_word_list[] = {(char *)"repeat_count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setRepeatCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setRepeatCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_repeat_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskSequence.setRepeatCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRepeatCount(non-const AsyncTaskSequence this, int repeat_count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_set_repeat_count_144_comment =
    "C++ Interface:\n"
    "setRepeatCount(non-const AsyncTaskSequence this, int repeat_count)\n"
    "\n"
    "// Filename: asyncTaskSequence.I\n"
    "// Created by:  drose (04Oct08)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskSequence::set_repeat_count\n"
    "//       Access: Published\n"
    "//  Description: Sets the repeat count of the sequence.  If the count\n"
    "//               is 0 or 1, the sequence will run exactly once.  If it\n"
    "//               is greater than 0, it will run that number of times.\n"
    "//               If it is negative, it will run forever until it is\n"
    "//               explicitly removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_set_repeat_count_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTaskSequence::get_repeat_count(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_get_repeat_count_145(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskSequence * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskSequence,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTaskSequence::get_repeat_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRepeatCount", key_word_list));
        else
            (PyArg_Parse(args, ":getRepeatCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskSequence*)local_this)->get_repeat_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRepeatCount(const AsyncTaskSequence this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_get_repeat_count_145_comment =
    "C++ Interface:\n"
    "getRepeatCount(const AsyncTaskSequence this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskSequence::get_repeat_count\n"
    "//       Access: Published\n"
    "//  Description: Returns the repeat count of the sequence.  See\n"
    "//               set_repeat_count().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_get_repeat_count_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int AsyncTaskSequence::get_current_task_index(void) const
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_get_current_task_index_146(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskSequence * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskSequence,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int AsyncTaskSequence::get_current_task_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentTaskIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentTaskIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const AsyncTaskSequence*)local_this)->get_current_task_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentTaskIndex(const AsyncTaskSequence this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_get_current_task_index_146_comment =
    "C++ Interface:\n"
    "getCurrentTaskIndex(const AsyncTaskSequence this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: AsyncTaskSequence::get_current_task_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the index of the task within the sequence\n"
    "//               that is currently being executed (or that will be\n"
    "//               executed at the next epoch).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_get_current_task_index_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AsyncTaskSequence::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_get_class_type_147(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AsyncTaskSequence::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AsyncTaskSequence::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_get_class_type_147_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_get_class_type_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_135(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskSequence * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskSequence,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToAsyncTask", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToAsyncTask"));
        if(!PyErr_Occurred())
        {
            AsyncTask *return_value = (AsyncTask *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AsyncTask,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskSequence.upcastToAsyncTask() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToAsyncTask(non-const AsyncTaskSequence this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_upcast_to_AsyncTask_135_comment =
    "C++ Interface:\n"
    "upcastToAsyncTask(non-const AsyncTaskSequence this)\n"
    "\n"
    "upcast from AsyncTaskSequence to AsyncTask\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_upcast_to_AsyncTask_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
 *******************************************************************/
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_137(PyObject *self, PyObject *args,PyObject *kwds) {
    AsyncTaskSequence * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskSequence,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToAsyncTaskCollection", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToAsyncTaskCollection"));
        if(!PyErr_Occurred())
        {
            AsyncTaskCollection *return_value = (AsyncTaskCollection *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_AsyncTaskCollection,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AsyncTaskSequence.upcastToAsyncTaskCollection() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToAsyncTaskCollection(non-const AsyncTaskSequence this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_137_comment =
    "C++ Interface:\n"
    "upcastToAsyncTaskCollection(non-const AsyncTaskSequence this)\n"
    "\n"
    "upcast from AsyncTaskSequence to AsyncTaskCollection\n"
    "";
#else
static const char * Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AsyncTaskSequence::AsyncTaskSequence(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_AsyncTaskSequence(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AsyncTaskSequence::AsyncTaskSequence(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:AsyncTaskSequence", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:AsyncTaskSequence", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            AsyncTaskSequence *return_value = new AsyncTaskSequence(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AsyncTaskSequence,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AsyncTaskSequence(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AsyncTaskSequence(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AsyncTaskSequence)
    {
        printf("AsyncTaskSequence ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AsyncTaskSequence * local_this = (AsyncTaskSequence *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AsyncTaskSequence)
        return local_this;
    if(requested_type == &Dtool_AsyncTask)
        return ( AsyncTask *) local_this;
    if(requested_type == &Dtool_AsyncTaskBase)
        return ( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_AsyncTaskCollection)
        return ( AsyncTaskCollection *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AsyncTaskSequence(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AsyncTaskSequence)
        return from_this;
    if(from_type == &Dtool_AsyncTask)
    {
          AsyncTask* other_this = (AsyncTask*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_AsyncTaskBase)
    {
          AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_AsyncTaskCollection)
    {
          AsyncTaskCollection* other_this = (AsyncTaskCollection*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AsyncTaskSequence*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EventParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline EventParameter &EventParameter::operator =(EventParameter const &copy)
 *******************************************************************/
static PyObject *Dtool_EventParameter_operator_150(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline EventParameter &EventParameter::operator =(EventParameter const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                EventParameter *param1_this = (EventParameter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_EventParameter, 1, "EventParameter.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    EventParameter *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_EventParameter,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call EventParameter.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const EventParameter this, const EventParameter copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_operator_150_comment =
    "C++ Interface:\n"
    "assign(non-const EventParameter this, const EventParameter copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::Copy assignment operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_operator_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_empty_152(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_empty_152_comment =
    "C++ Interface:\n"
    "isEmpty(const EventParameter this)\n"
    "\n"
    "// These functions are conveniences to easily determine if the\n"
    "// EventParameter is one of the predefined parameter types, and\n"
    "// retrieve the corresponding value.  Of course, it is possible that\n"
    "// the EventParameter is some user-defined type, and is none of\n"
    "// these.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter is the empty\n"
    "//               parameter, storing nothing, or false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_empty_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_int(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_int_153(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_int(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isInt", key_word_list));
        else
            (PyArg_Parse(args, ":isInt"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_int();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isInt(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_int_153_comment =
    "C++ Interface:\n"
    "isInt(const EventParameter this)\n"
    "\n"
    "// These functions are conveniences to easily determine if the\n"
    "// EventParameter is one of the predefined parameter types, and\n"
    "// retrieve the corresponding value.  Of course, it is possible that\n"
    "// the EventParameter is some user-defined type, and is none of\n"
    "// these.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_int\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter stores an integer\n"
    "//               value, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_int_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int EventParameter::get_int_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_int_value_154(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int EventParameter::get_int_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIntValue", key_word_list));
        else
            (PyArg_Parse(args, ":getIntValue"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const EventParameter*)local_this)->get_int_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntValue(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_int_value_154_comment =
    "C++ Interface:\n"
    "getIntValue(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_int_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the EventParameter.  It\n"
    "//               is only valid to call this if is_int() has already\n"
    "//               returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_int_value_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_double(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_double_155(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_double(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDouble", key_word_list));
        else
            (PyArg_Parse(args, ":isDouble"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_double();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDouble(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_double_155_comment =
    "C++ Interface:\n"
    "isDouble(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_double\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter stores a double\n"
    "//               floating-point value, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_double_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double EventParameter::get_double_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_double_value_156(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double EventParameter::get_double_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDoubleValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDoubleValue"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const EventParameter*)local_this)->get_double_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoubleValue(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_double_value_156_comment =
    "C++ Interface:\n"
    "getDoubleValue(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_double_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the EventParameter.  It\n"
    "//               is only valid to call this if is_double() has already\n"
    "//               returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_double_value_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_string(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_string_157(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isString", key_word_list));
        else
            (PyArg_Parse(args, ":isString"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isString(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_string_157_comment =
    "C++ Interface:\n"
    "isString(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_string\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter stores a string\n"
    "//               value, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_string_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > EventParameter::get_string_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_string_value_158(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > EventParameter::get_string_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStringValue", key_word_list));
        else
            (PyArg_Parse(args, ":getStringValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const EventParameter*)local_this)->get_string_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStringValue(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_string_value_158_comment =
    "C++ Interface:\n"
    "getStringValue(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_string_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the EventParameter.  It\n"
    "//               is only valid to call this if is_string() has already\n"
    "//               returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_string_value_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_wstring(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_wstring_159(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_wstring(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isWstring", key_word_list));
        else
            (PyArg_Parse(args, ":isWstring"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_wstring();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isWstring(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_wstring_159_comment =
    "C++ Interface:\n"
    "isWstring(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_wstring\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter stores a wstring\n"
    "//               value, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_wstring_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< wchar_t > EventParameter::get_wstring_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_wstring_value_160(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< wchar_t > EventParameter::get_wstring_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWstringValue", key_word_list));
        else
            (PyArg_Parse(args, ":getWstringValue"));
        if(!PyErr_Occurred())
        {
            basic_string< wchar_t > return_value = ((const EventParameter*)local_this)->get_wstring_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyUnicode_FromWideChar(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWstringValue(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_wstring_value_160_comment =
    "C++ Interface:\n"
    "getWstringValue(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_wstring_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the EventParameter.  It\n"
    "//               is only valid to call this if is_wstring() has already\n"
    "//               returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_wstring_value_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool EventParameter::is_typed_ref_count(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_is_typed_ref_count_161(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool EventParameter::is_typed_ref_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isTypedRefCount", key_word_list));
        else
            (PyArg_Parse(args, ":isTypedRefCount"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventParameter*)local_this)->is_typed_ref_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTypedRefCount(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_is_typed_ref_count_161_comment =
    "C++ Interface:\n"
    "isTypedRefCount(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::is_typed_ref_count\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the EventParameter stores a\n"
    "//               TypedReferenceCount pointer, false otherwise.  Note\n"
    "//               that a TypedReferenceCount is not exactly the same\n"
    "//               kind of pointer as a TypedWritableReferenceCount,\n"
    "//               hence the need for this separate call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_is_typed_ref_count_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_typed_ref_count_value_162(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTypedRefCountValue", key_word_list));
        else
            (PyArg_Parse(args, ":getTypedRefCountValue"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = ((const EventParameter*)local_this)->get_typed_ref_count_value();
            if (return_value != (TypedReferenceCount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypedRefCountValue(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_typed_ref_count_value_162_comment =
    "C++ Interface:\n"
    "getTypedRefCountValue(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_typed_ref_count_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the EventParameter.  It\n"
    "//               is only valid to call this if is_typed_ref_count()\n"
    "//               has already returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_typed_ref_count_value_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_get_ptr_163(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPtr", key_word_list));
        else
            (PyArg_Parse(args, ":getPtr"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = ((const EventParameter*)local_this)->get_ptr();
            if (return_value != (TypedWritableReferenceCount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPtr(const EventParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_get_ptr_163_comment =
    "C++ Interface:\n"
    "getPtr(const EventParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::get_ptr\n"
    "//       Access: Published\n"
    "//  Description: Retrieves a pointer to the actual value stored in the\n"
    "//               parameter.  The TypeHandle of this pointer may be\n"
    "//               examined to determine the actual type of parameter it\n"
    "//               contains.  This is the only way to retrieve the value\n"
    "//               when it is not one of the above predefined types.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_get_ptr_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void EventParameter::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_EventParameter_output_164(PyObject *self, PyObject *args,PyObject *kwds) {
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void EventParameter::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "EventParameter.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const EventParameter*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const EventParameter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventParameter_output_164_comment =
    "C++ Interface:\n"
    "output(const EventParameter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventParameter::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventParameter_output_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline EventParameter::EventParameter(void)
 * inline EventParameter::EventParameter(EventParameter const &copy)
 * inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
 * inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
 * inline EventParameter::EventParameter(basic_string< char > const &value)
 * inline EventParameter::EventParameter(basic_string< wchar_t > const &value)
 * inline EventParameter::EventParameter(double value)
 * inline EventParameter::EventParameter(int value)
 *******************************************************************/
int  Dtool_Init_EventParameter(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline EventParameter::EventParameter(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":EventParameter", key_word_list))
            {
                EventParameter *return_value = new EventParameter();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"ptr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                    TypedWritableReferenceCount *param0_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypedWritableReferenceCount, 0, "EventParameter.EventParameter", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        EventParameter *return_value = new EventParameter(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"ptr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                    TypedReferenceCount *param0_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypedReferenceCount, 0, "EventParameter.EventParameter", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        EventParameter *return_value = new EventParameter(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(EventParameter const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                    EventParameter *param0_this = (EventParameter *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_EventParameter, 0, "EventParameter.EventParameter", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        EventParameter *return_value = new EventParameter(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(basic_string< char > const &value)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:EventParameter", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:EventParameter", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    EventParameter *return_value = new EventParameter(basic_string<char>(param0_str, param0_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(basic_string< wchar_t > const &value)
                PyUnicodeObject *param0
;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "U:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "U:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                     int param0_len = PyUnicode_GetSize((PyObject *)param0); wchar_t *param0_str = new wchar_t[param0_len]; PyUnicode_AsWideChar(param0, param0_str, param0_len);
                    EventParameter *return_value = new EventParameter(basic_string<wchar_t>((wchar_t *)param0_str, param0_len));
                     delete[] param0_str;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(double value)
                double param0;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                    EventParameter *return_value = new EventParameter((double)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline EventParameter::EventParameter(int value)
                int param0;
                static char * key_word_list[] = {(char *)"value", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:EventParameter", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:EventParameter", &param0));
                if(!PyErr_Occurred())
                {
                    EventParameter *return_value = new EventParameter((int)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventParameter,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "EventParameter() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "EventParameter()\n"
          "EventParameter(const TypedWritableReferenceCount ptr)\n"
          "EventParameter(const TypedReferenceCount ptr)\n"
          "EventParameter(const EventParameter copy)\n"
          "EventParameter(string value)\n"
          "EventParameter(string value)\n"
          "EventParameter(float value)\n"
          "EventParameter(int value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EventParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EventParameter)
    {
        printf("EventParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EventParameter * local_this = (EventParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EventParameter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EventParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EventParameter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EventStoreValueBase 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void EventStoreValueBase::output(ostream &out) const = 0
 *******************************************************************/
static PyObject *Dtool_EventStoreValueBase_output_167(PyObject *self, PyObject *args,PyObject *kwds) {
    EventStoreValueBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventStoreValueBase,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void EventStoreValueBase::output(ostream &out) const = 0
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "EventStoreValueBase.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const EventStoreValueBase*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const EventStoreValueBase this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventStoreValueBase_output_167_comment =
    "C++ Interface:\n"
    "output(const EventStoreValueBase this, non-const Ostream out)\n"
    "\n"
    "";
#else
static const char * Dtool_EventStoreValueBase_output_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EventStoreValueBase::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EventStoreValueBase_get_class_type_168(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EventStoreValueBase::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EventStoreValueBase::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventStoreValueBase_get_class_type_168_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_EventStoreValueBase_get_class_type_168_comment = NULL;
#endif

int  Dtool_Init_EventStoreValueBase(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (EventStoreValueBase)");
       return -1;
}
inline void  * Dtool_UpcastInterface_EventStoreValueBase(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EventStoreValueBase)
    {
        printf("EventStoreValueBase ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EventStoreValueBase * local_this = (EventStoreValueBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EventStoreValueBase)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EventStoreValueBase(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EventStoreValueBase)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (EventStoreValueBase*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EventStoreValueBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (EventStoreValueBase*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (EventStoreValueBase*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EventStoreTypedRefCount 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void EventStoreTypedRefCount::set_value(TypedReferenceCount const *value)
 *******************************************************************/
static PyObject *Dtool_EventStoreTypedRefCount_set_value_171(PyObject *self, PyObject *args,PyObject *kwds) {
    EventStoreTypedRefCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventStoreTypedRefCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void EventStoreTypedRefCount::set_value(TypedReferenceCount const *value)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setValue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setValue", &param1));
            if(!PyErr_Occurred())
            {
                TypedReferenceCount *param1_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TypedReferenceCount, 1, "EventStoreTypedRefCount.setValue", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_value(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call EventStoreTypedRefCount.setValue() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setValue(non-const EventStoreTypedRefCount this, const TypedReferenceCount value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventStoreTypedRefCount_set_value_171_comment =
    "C++ Interface:\n"
    "setValue(non-const EventStoreTypedRefCount this, const TypedReferenceCount value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventStoreTypedRefCount::set_value\n"
    "//       Access: Published\n"
    "//  Description: Changes the value stored in the parameter.  It is\n"
    "//               dangerous to do this for a parameter already added to\n"
    "//               an event, since the parameters may be shared.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventStoreTypedRefCount_set_value_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TypedReferenceCount *EventStoreTypedRefCount::get_value(void) const
 *******************************************************************/
static PyObject *Dtool_EventStoreTypedRefCount_get_value_172(PyObject *self, PyObject *args,PyObject *kwds) {
    EventStoreTypedRefCount * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventStoreTypedRefCount,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TypedReferenceCount *EventStoreTypedRefCount::get_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = ((const EventStoreTypedRefCount*)local_this)->get_value();
            if (return_value != (TypedReferenceCount *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const EventStoreTypedRefCount this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventStoreTypedRefCount_get_value_172_comment =
    "C++ Interface:\n"
    "getValue(const EventStoreTypedRefCount this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventStoreTypedRefCount::get_value\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the value stored in the parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventStoreTypedRefCount_get_value_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EventStoreTypedRefCount::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EventStoreTypedRefCount_get_class_type_173(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EventStoreTypedRefCount::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EventStoreTypedRefCount::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventStoreTypedRefCount_get_class_type_173_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_EventStoreTypedRefCount_get_class_type_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline EventStoreTypedRefCount::EventStoreTypedRefCount(TypedReferenceCount const *value)
 *******************************************************************/
int  Dtool_Init_EventStoreTypedRefCount(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline EventStoreTypedRefCount::EventStoreTypedRefCount(TypedReferenceCount const *value)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"value", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:EventStoreTypedRefCount", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:EventStoreTypedRefCount", &param0));
            if(!PyErr_Occurred())
            {
                TypedReferenceCount *param0_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_TypedReferenceCount, 0, "EventStoreTypedRefCount.EventStoreTypedRefCount", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    EventStoreTypedRefCount *return_value = new EventStoreTypedRefCount(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventStoreTypedRefCount,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EventStoreTypedRefCount(const TypedReferenceCount value)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EventStoreTypedRefCount(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EventStoreTypedRefCount)
    {
        printf("EventStoreTypedRefCount ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EventStoreTypedRefCount * local_this = (EventStoreTypedRefCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EventStoreTypedRefCount)
        return local_this;
    if(requested_type == &Dtool_EventStoreValueBase)
        return ( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EventStoreTypedRefCount(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EventStoreTypedRefCount)
        return from_this;
    if(from_type == &Dtool_EventStoreValueBase)
    {
          EventStoreValueBase* other_this = (EventStoreValueBase*)from_this;
          return (EventStoreTypedRefCount*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (EventStoreTypedRefCount*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EventStoreTypedRefCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (EventStoreTypedRefCount*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (EventStoreTypedRefCount*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Event 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void Event::operator =(Event const &copy)
 *******************************************************************/
static PyObject *Dtool_Event_operator_176(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Event::operator =(Event const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Event *param1_this = (Event *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Event, 1, "Event.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Event *return_value = local_this;
                    if (return_value != (Event *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Event,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Event.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Event this, const Event copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_operator_176_comment =
    "C++ Interface:\n"
    "assign(non-const Event this, const Event copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_operator_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Event::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_Event_set_name_177(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Event::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Event.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const Event this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_set_name_177_comment =
    "C++ Interface:\n"
    "setName(non-const Event this, string name)\n"
    "\n"
    "// Filename: event.I\n"
    "// Created by:  drose (15May01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::set_name\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_set_name_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Event::clear_name(void)
 *******************************************************************/
static PyObject *Dtool_Event_clear_name_178(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Event::clear_name(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearName", key_word_list));
        else
            (PyArg_Parse(args, ":clearName"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Event.clearName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearName(non-const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_clear_name_178_comment =
    "C++ Interface:\n"
    "clearName(non-const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::clear_name\n"
    "//       Access: Public\n"
    "//  Description: Resets the Event's name to empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_clear_name_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Event::has_name(void) const
 *******************************************************************/
static PyObject *Dtool_Event_has_name_179(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Event::has_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasName", key_word_list));
        else
            (PyArg_Parse(args, ":hasName"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Event*)local_this)->has_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasName(const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_has_name_179_comment =
    "C++ Interface:\n"
    "hasName(const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::has_name\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the Event has a nonempty name set,\n"
    "//               false if the name is empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_has_name_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &Event::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_Event_get_name_180(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &Event::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const Event*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_get_name_180_comment =
    "C++ Interface:\n"
    "getName(const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::get_name\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_get_name_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Event::add_parameter(EventParameter const &obj)
 *******************************************************************/
static PyObject *Dtool_Event_add_parameter_181(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Event::add_parameter(EventParameter const &obj)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"obj", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addParameter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addParameter", &param1));
            if(!PyErr_Occurred())
            {
                EventParameter *param1_this = (EventParameter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_EventParameter, 1, "Event.addParameter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_parameter(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Event.addParameter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addParameter(non-const Event this, const EventParameter obj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_add_parameter_181_comment =
    "C++ Interface:\n"
    "addParameter(non-const Event this, const EventParameter obj)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::add_parameter\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_add_parameter_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int Event::get_num_parameters(void) const
 *******************************************************************/
static PyObject *Dtool_Event_get_num_parameters_182(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int Event::get_num_parameters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumParameters", key_word_list));
        else
            (PyArg_Parse(args, ":getNumParameters"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Event*)local_this)->get_num_parameters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumParameters(const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_get_num_parameters_182_comment =
    "C++ Interface:\n"
    "getNumParameters(const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::get_num_parameters\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_get_num_parameters_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EventParameter Event::get_parameter(int n) const
 *******************************************************************/
static PyObject *Dtool_Event_get_parameter_183(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-EventParameter Event::get_parameter(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParameter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParameter", &param1));
        if(!PyErr_Occurred())
        {
            EventParameter result = ((const Event*)local_this)->get_parameter((int)param1);
            EventParameter *return_value = new EventParameter(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_EventParameter,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParameter(const Event this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_get_parameter_183_comment =
    "C++ Interface:\n"
    "getParameter(const Event this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::get_parameter\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_get_parameter_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Event::has_receiver(void) const
 *******************************************************************/
static PyObject *Dtool_Event_has_receiver_184(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Event::has_receiver(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasReceiver", key_word_list));
        else
            (PyArg_Parse(args, ":hasReceiver"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Event*)local_this)->has_receiver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasReceiver(const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_has_receiver_184_comment =
    "C++ Interface:\n"
    "hasReceiver(const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::has_receiver\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_has_receiver_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Event::clear_receiver(void)
 *******************************************************************/
static PyObject *Dtool_Event_clear_receiver_187(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Event::clear_receiver(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearReceiver", key_word_list));
        else
            (PyArg_Parse(args, ":clearReceiver"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_receiver();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Event.clearReceiver() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearReceiver(non-const Event this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_clear_receiver_187_comment =
    "C++ Interface:\n"
    "clearReceiver(non-const Event this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::clear_receiver\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_clear_receiver_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Event::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_Event_output_188(PyObject *self, PyObject *args,PyObject *kwds) {
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void Event::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Event.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const Event*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const Event this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_output_188_comment =
    "C++ Interface:\n"
    "output(const Event this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Event::output\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Event_output_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Event::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Event_get_class_type_189(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Event::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Event::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Event_get_class_type_189_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Event_get_class_type_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Event::Event(Event const &copy)
 * Rejected Remap [Event::Event(basic_string< char > const &event_name, EventReceiver *receiver)]
 * Event::Event(basic_string< char > const &event_name, EventReceiver *receiver = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_Event(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 Event::Event(Event const &copy)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:Event", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:Event", &param0));
            if(!PyErr_Occurred())
            {
                Event *param0_this = (Event *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Event, 0, "Event.Event", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    Event *return_value = new Event(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Event,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 Event::Event(basic_string< char > const &event_name, EventReceiver *receiver = ((void *)(0)))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"event_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Event", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:Event", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                Event *return_value = new Event(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Event,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Event(const Event copy)\n"
          "Event(string event_name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_Event_get_parameters(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumParameters", "getParameter");
}
inline void  * Dtool_UpcastInterface_Event(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Event)
    {
        printf("Event ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Event * local_this = (Event *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Event)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Event(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Event)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Event*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Event*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (Event*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EventHandler 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void EventHandler::process_events(void)
 *******************************************************************/
static PyObject *Dtool_EventHandler_process_events_193(PyObject *self, PyObject *args,PyObject *kwds) {
    EventHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void EventHandler::process_events(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":processEvents", key_word_list));
        else
            (PyArg_Parse(args, ":processEvents"));
        if(!PyErr_Occurred())
        {
            (local_this)->process_events();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call EventHandler.processEvents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "processEvents(non-const EventHandler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventHandler_process_events_193_comment =
    "C++ Interface:\n"
    "processEvents(non-const EventHandler this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventHandler::process_events\n"
    "//       Access: Public\n"
    "//  Description: The main processing loop of the EventHandler.  This\n"
    "//               function must be called periodically to service\n"
    "//               events.  Walks through each pending event and calls\n"
    "//               its assigned hooks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventHandler_process_events_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void EventHandler::dispatch_event(Event const *)
 *******************************************************************/
static PyObject *Dtool_EventHandler_dispatch_event_194(PyObject *self, PyObject *args,PyObject *kwds) {
    EventHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void EventHandler::dispatch_event(Event const *)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:dispatchEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:dispatchEvent", &param1));
            if(!PyErr_Occurred())
            {
                Event *param1_this = (Event *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Event, 1, "EventHandler.dispatchEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->dispatch_event(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call EventHandler.dispatchEvent() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dispatchEvent(non-const EventHandler this, const Event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventHandler_dispatch_event_194_comment =
    "C++ Interface:\n"
    "dispatchEvent(non-const EventHandler this, const Event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventHandler::dispatch_event\n"
    "//       Access: Public, Virtual\n"
    "//  Description: Calls the hooks assigned to the indicated single\n"
    "//               event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventHandler_dispatch_event_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void EventHandler::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_EventHandler_write_195(PyObject *self, PyObject *args,PyObject *kwds) {
    EventHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void EventHandler::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "EventHandler.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const EventHandler*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const EventHandler this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventHandler_write_195_comment =
    "C++ Interface:\n"
    "write(const EventHandler this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventHandler::write\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventHandler_write_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue)
 * static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = ((void *)(0)))
 *******************************************************************/
static PyObject *Dtool_EventHandler_get_global_event_handler_196(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = ((void *)(0)))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalEventHandler", key_word_list))
            {
                EventHandler *return_value = EventHandler::get_global_event_handler();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_EventHandler,false, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"queue", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getGlobalEventHandler", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:getGlobalEventHandler", &param0));
                if(!PyErr_Occurred())
                {
                    EventQueue *param0_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_EventQueue, 0, "EventHandler.getGlobalEventHandler", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        EventHandler *return_value = EventHandler::get_global_event_handler(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_EventHandler,false, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getGlobalEventHandler() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getGlobalEventHandler()\n"
          "getGlobalEventHandler(non-const EventQueue queue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventHandler_get_global_event_handler_196_comment =
    "C++ Interface:\n"
    "getGlobalEventHandler()\n"
    "getGlobalEventHandler(non-const EventQueue queue)\n"
    "\n"
    "// Filename: eventHandler.I\n"
    "// Created by:  skyler (27Jan04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::get_global_event_handler\n"
    "//       Access: Public\n"
    "//  Description: Returns a pointer to the one global EventHandler\n"
    "//               object.  If the global object has not yet been\n"
    "//               created, this will create it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventHandler_get_global_event_handler_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EventHandler::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EventHandler_get_class_type_197(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EventHandler::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EventHandler::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventHandler_get_class_type_197_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_EventHandler_get_class_type_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EventHandler::EventHandler(EventQueue *ev_queue)
 *******************************************************************/
int  Dtool_Init_EventHandler(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-EventHandler::EventHandler(EventQueue *ev_queue)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"ev_queue", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:EventHandler", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:EventHandler", &param0));
            if(!PyErr_Occurred())
            {
                EventQueue *param0_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_EventQueue, 0, "EventHandler.EventHandler", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    EventHandler *return_value = new EventHandler(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_EventHandler,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EventHandler(non-const EventQueue ev_queue)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EventHandler(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EventHandler)
    {
        printf("EventHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EventHandler * local_this = (EventHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EventHandler)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EventHandler(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EventHandler)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EventHandler*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EventQueue 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void EventQueue::queue_event(ConstPointerTo< Event > event)
 *******************************************************************/
static PyObject *Dtool_EventQueue_queue_event_202(PyObject *self, PyObject *args,PyObject *kwds) {
    EventQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void EventQueue::queue_event(ConstPointerTo< Event > event)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"event", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:queueEvent", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:queueEvent", &param1));
            if(!PyErr_Occurred())
            {
                Event *param1_this = (Event *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Event, 1, "EventQueue.queueEvent", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->queue_event(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call EventQueue.queueEvent() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "queueEvent(non-const EventQueue this, const Event event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_queue_event_202_comment =
    "C++ Interface:\n"
    "queueEvent(non-const EventQueue this, const Event event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::queue_event\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_queue_event_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void EventQueue::clear(void)
 *******************************************************************/
static PyObject *Dtool_EventQueue_clear_203(PyObject *self, PyObject *args,PyObject *kwds) {
    EventQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void EventQueue::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call EventQueue.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const EventQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_clear_203_comment =
    "C++ Interface:\n"
    "clear(non-const EventQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::clear\n"
    "//       Access: Published\n"
    "//  Description: Empties all events on the queue, throwing them on the\n"
    "//               floor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_clear_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool EventQueue::is_queue_empty(void) const
 *******************************************************************/
static PyObject *Dtool_EventQueue_is_queue_empty_204(PyObject *self, PyObject *args,PyObject *kwds) {
    EventQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool EventQueue::is_queue_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isQueueEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isQueueEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventQueue*)local_this)->is_queue_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isQueueEmpty(const EventQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_is_queue_empty_204_comment =
    "C++ Interface:\n"
    "isQueueEmpty(const EventQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::is_queue_empty\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_is_queue_empty_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool EventQueue::is_queue_full(void) const
 *******************************************************************/
static PyObject *Dtool_EventQueue_is_queue_full_205(PyObject *self, PyObject *args,PyObject *kwds) {
    EventQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool EventQueue::is_queue_full(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isQueueFull", key_word_list));
        else
            (PyArg_Parse(args, ":isQueueFull"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const EventQueue*)local_this)->is_queue_full();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isQueueFull(const EventQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_is_queue_full_205_comment =
    "C++ Interface:\n"
    "isQueueFull(const EventQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::is_queue_full\n"
    "//       Access: Published\n"
    "//  Description: This function is deprecated--the queue is never full\n"
    "//               these days.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_is_queue_full_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ConstPointerTo< Event > EventQueue::dequeue_event(void)
 *******************************************************************/
static PyObject *Dtool_EventQueue_dequeue_event_206(PyObject *self, PyObject *args,PyObject *kwds) {
    EventQueue * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventQueue,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ConstPointerTo< Event > EventQueue::dequeue_event(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":dequeueEvent", key_word_list));
        else
            (PyArg_Parse(args, ":dequeueEvent"));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< Event > return_value = (local_this)->dequeue_event();
            if (return_value != (Event const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_Event,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call EventQueue.dequeueEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "dequeueEvent(non-const EventQueue this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_dequeue_event_206_comment =
    "C++ Interface:\n"
    "dequeueEvent(non-const EventQueue this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::dequeue_event\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_dequeue_event_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline EventQueue *EventQueue::get_global_event_queue(void)
 *******************************************************************/
static PyObject *Dtool_EventQueue_get_global_event_queue_207(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline EventQueue *EventQueue::get_global_event_queue(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalEventQueue", key_word_list))
        {
            EventQueue *return_value = EventQueue::get_global_event_queue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_EventQueue,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalEventQueue()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EventQueue_get_global_event_queue_207_comment =
    "C++ Interface:\n"
    "getGlobalEventQueue()\n"
    "\n"
    "// Filename: eventQueue.I\n"
    "// Created by:  drose (05May00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: EventQueue::get_global_event_queue\n"
    "//       Access: Public\n"
    "//  Description: Returns a pointer to the one global EventQueue\n"
    "//               object.  If the global object has not yet been\n"
    "//               created, this will create it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_EventQueue_get_global_event_queue_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EventQueue::EventQueue(void)
 *******************************************************************/
int  Dtool_Init_EventQueue(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-EventQueue::EventQueue(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":EventQueue", key_word_list))
        {
            EventQueue *return_value = new EventQueue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_EventQueue,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EventQueue()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EventQueue(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EventQueue)
    {
        printf("EventQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EventQueue * local_this = (EventQueue *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EventQueue)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EventQueue(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EventQueue)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PointerEventList 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_num_events(void) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_num_events_210(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_num_events(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumEvents", key_word_list));
        else
            (PyArg_Parse(args, ":getNumEvents"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_num_events();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumEvents(const PointerEventList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_num_events_210_comment =
    "C++ Interface:\n"
    "getNumEvents(const PointerEventList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_num_events\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of events in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_num_events_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PointerEventList::get_in_window(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_in_window_211(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PointerEventList::get_in_window(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getInWindow", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getInWindow", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PointerEventList*)local_this)->get_in_window((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInWindow(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_in_window_211_comment =
    "C++ Interface:\n"
    "getInWindow(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_in_window\n"
    "//       Access: Published\n"
    "//  Description: Get the in-window flag of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_in_window_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_xpos(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_xpos_212(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_xpos(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getXpos", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getXpos", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_xpos((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getXpos(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_xpos_212_comment =
    "C++ Interface:\n"
    "getXpos(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_xpos\n"
    "//       Access: Published\n"
    "//  Description: Get the x-coordinate of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_xpos_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_ypos(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_ypos_213(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_ypos(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getYpos", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getYpos", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_ypos((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getYpos(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_ypos_213_comment =
    "C++ Interface:\n"
    "getYpos(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_ypos\n"
    "//       Access: Published\n"
    "//  Description: Get the y-coordinate of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_ypos_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_dx(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_dx_214(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_dx(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDx", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDx", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_dx((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDx(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_dx_214_comment =
    "C++ Interface:\n"
    "getDx(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_dx\n"
    "//       Access: Published\n"
    "//  Description: Get the x-coordinate of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_dx_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_dy(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_dy_215(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_dy(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDy", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDy", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_dy((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDy(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_dy_215_comment =
    "C++ Interface:\n"
    "getDy(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_dy\n"
    "//       Access: Published\n"
    "//  Description: Get the y-coordinate of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_dy_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PointerEventList::get_sequence(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_sequence_216(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PointerEventList::get_sequence(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSequence", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSequence", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PointerEventList*)local_this)->get_sequence((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSequence(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_sequence_216_comment =
    "C++ Interface:\n"
    "getSequence(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_sequence\n"
    "//       Access: Published\n"
    "//  Description: Get the sequence number of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_sequence_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PointerEventList::get_length(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_length_217(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PointerEventList::get_length(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getLength", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PointerEventList*)local_this)->get_length((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_length_217_comment =
    "C++ Interface:\n"
    "getLength(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_length\n"
    "//       Access: Published\n"
    "//  Description: Get the length of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_length_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PointerEventList::get_direction(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_direction_218(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PointerEventList::get_direction(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDirection", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDirection", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PointerEventList*)local_this)->get_direction((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirection(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_direction_218_comment =
    "C++ Interface:\n"
    "getDirection(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_direction\n"
    "//       Access: Published\n"
    "//  Description: Get the direction of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_direction_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PointerEventList::get_rotation(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_rotation_219(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PointerEventList::get_rotation(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRotation", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getRotation", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PointerEventList*)local_this)->get_rotation((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotation(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_rotation_219_comment =
    "C++ Interface:\n"
    "getRotation(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_rotation\n"
    "//       Access: Published\n"
    "//  Description: Get the rotation of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_rotation_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PointerEventList::get_time(int n) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_time_220(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double PointerEventList::get_time(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTime", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PointerEventList*)local_this)->get_time((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTime(const PointerEventList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_time_220_comment =
    "C++ Interface:\n"
    "getTime(const PointerEventList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::get_time\n"
    "//       Access: Published\n"
    "//  Description: Get the timestamp of the nth event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_get_time_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointerEventList::clear(void)
 *******************************************************************/
static PyObject *Dtool_PointerEventList_clear_221(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PointerEventList::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerEventList.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PointerEventList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_clear_221_comment =
    "C++ Interface:\n"
    "clear(non-const PointerEventList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::clear\n"
    "//       Access: Public\n"
    "//  Description: Empties all the events from the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_clear_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PointerEventList::pop_front(void)
 *******************************************************************/
static PyObject *Dtool_PointerEventList_pop_front_222(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PointerEventList::pop_front(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popFront", key_word_list));
        else
            (PyArg_Parse(args, ":popFront"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_front();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerEventList.popFront() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popFront(non-const PointerEventList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_pop_front_222_comment =
    "C++ Interface:\n"
    "popFront(non-const PointerEventList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::pop_front\n"
    "//       Access: Public\n"
    "//  Description: Discards the first event on the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_pop_front_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
 *******************************************************************/
static PyObject *Dtool_PointerEventList_add_event_223(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
        PyObject *param1;
        int param2;
        int param3;
        int param4;
        double param5;
        static char * key_word_list[] = {(char *)"in_win", (char *)"xpos", (char *)"ypos", (char *)"seq", (char *)"time", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "Oiiid:addEvent", key_word_list, &param1, &param2, &param3, &param4, &param5))
        {
            (local_this)->add_event((PyObject_IsTrue(param1)!=0), (int)param2, (int)param3, (int)param4, (double)param5);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerEventList.addEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addEvent(non-const PointerEventList this, bool in_win, int xpos, int ypos, int seq, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_add_event_223_comment =
    "C++ Interface:\n"
    "addEvent(non-const PointerEventList this, bool in_win, int xpos, int ypos, int seq, float time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::add_event\n"
    "//       Access: Published\n"
    "//  Description: Adds a new event to the end of the list.\n"
    "//               Automatically calculates the dx, dy, length,\n"
    "//               direction, and rotation for all but the first event.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_add_event_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PointerEventList::encircles(int x, int y) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_encircles_224(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PointerEventList::encircles(int x, int y) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:encircles", key_word_list, &param1, &param2))
        {
            bool return_value = ((const PointerEventList*)local_this)->encircles((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "encircles(const PointerEventList this, int x, int y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_encircles_224_comment =
    "C++ Interface:\n"
    "encircles(const PointerEventList this, int x, int y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::encircles\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the trail loops around the\n"
    "//               specified point.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_encircles_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double PointerEventList::total_turns(double sec) const
 *******************************************************************/
static PyObject *Dtool_PointerEventList_total_turns_225(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double PointerEventList::total_turns(double sec) const
        double param1;
        static char * key_word_list[] = {(char *)"sec", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:totalTurns", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:totalTurns", &param1));
        if(!PyErr_Occurred())
        {
            double return_value = ((const PointerEventList*)local_this)->total_turns((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "totalTurns(const PointerEventList this, float sec)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_total_turns_225_comment =
    "C++ Interface:\n"
    "totalTurns(const PointerEventList this, float sec)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::total_turns\n"
    "//       Access: Published\n"
    "//  Description: returns the total angular deviation that the trail\n"
    "//               has made in the specified time period.  A small\n"
    "//               number means that the trail is moving in a relatively\n"
    "//               straight line, a large number means that the trail\n"
    "//               is zig-zagging or spinning.  The result is in degrees.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_total_turns_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double PointerEventList::match_pattern(basic_string< char > const &pattern, double rot, double seglen)
 *******************************************************************/
static PyObject *Dtool_PointerEventList_match_pattern_226(PyObject *self, PyObject *args,PyObject *kwds) {
    PointerEventList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PointerEventList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double PointerEventList::match_pattern(basic_string< char > const &pattern, double rot, double seglen)
        char *param1_str; int param1_len;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"pattern", (char *)"rot", (char *)"seglen", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dd:matchPattern", key_word_list, &param1_str, &param1_len, &param2, &param3))
        {
            double return_value = (local_this)->match_pattern(basic_string<char>(param1_str, param1_len), (double)param2, (double)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PointerEventList.matchPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "matchPattern(non-const PointerEventList this, string pattern, float rot, float seglen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_match_pattern_226_comment =
    "C++ Interface:\n"
    "matchPattern(non-const PointerEventList this, string pattern, float rot, float seglen)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PointerEventList::match_pattern\n"
    "//       Access: Published\n"
    "//  Description: This function is not implemented yet.  It is a work\n"
    "//               in progress.  The intent is as follows:\n"
    "//\n"
    "//               Returns a nonzero value if the mouse movements \n"
    "//               match the specified pattern.  The higher the value,\n"
    "//               the better the match.  The pattern is a sequence\n"
    "//               of compass directions (ie, \"E\", \"NE\", etc) separated\n"
    "//               by spaces.  If rot is nonzero, then the pattern is\n"
    "//               rotated counterclockwise by the specified amount \n"
    "//               before testing.  Seglen is the minimum length a\n"
    "//               mouse movement needs to be in order to be considered\n"
    "//               significant.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PointerEventList_match_pattern_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PointerEventList::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PointerEventList_get_class_type_227(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PointerEventList::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PointerEventList::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PointerEventList_get_class_type_227_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PointerEventList_get_class_type_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerEventList::PointerEventList(void)
 *******************************************************************/
int  Dtool_Init_PointerEventList(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline PointerEventList::PointerEventList(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PointerEventList", key_word_list))
        {
            PointerEventList *return_value = new PointerEventList();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PointerEventList,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PointerEventList()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PointerEventList(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PointerEventList)
    {
        printf("PointerEventList ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PointerEventList * local_this = (PointerEventList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PointerEventList)
        return local_this;
    if(requested_type == &Dtool_EventStoreValueBase)
        return ( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( EventStoreValueBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PointerEventList(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PointerEventList)
        return from_this;
    if(from_type == &Dtool_EventStoreValueBase)
    {
          EventStoreValueBase* other_this = (EventStoreValueBase*)from_this;
          return (PointerEventList*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PointerEventList*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PointerEventList*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PointerEventList*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PointerEventList*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PythonTask 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PythonTask::set_function(PyObject *function)
 *******************************************************************/
static PyObject *Dtool_PythonTask_set_function_234(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PythonTask::set_function(PyObject *function)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"function", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFunction", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setFunction", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_function(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.setFunction() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFunction(non-const PythonTask this, any function)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_set_function_234_comment =
    "C++ Interface:\n"
    "setFunction(non-const PythonTask this, any function)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::set_function\n"
    "//       Access: Published\n"
    "//  Description: Replaces the function that is called when the task\n"
    "//               runs.  The parameter should be a Python callable\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_set_function_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonTask::get_function(void)
 *******************************************************************/
static PyObject *Dtool_PythonTask_get_function_235(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonTask::get_function(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFunction", key_word_list));
        else
            (PyArg_Parse(args, ":getFunction"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->get_function();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.getFunction() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFunction(non-const PythonTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_get_function_235_comment =
    "C++ Interface:\n"
    "getFunction(non-const PythonTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::get_function\n"
    "//       Access: Published\n"
    "//  Description: Returns the function that is called when the task\n"
    "//               runs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_get_function_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PythonTask::set_args(PyObject *args, bool append_task)
 *******************************************************************/
static PyObject *Dtool_PythonTask_set_args_236(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PythonTask::set_args(PyObject *args, bool append_task)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"args", (char *)"append_task", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setArgs", key_word_list, &param1, &param2))
        {
            (local_this)->set_args(param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.setArgs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setArgs(non-const PythonTask this, any args, bool append_task)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_set_args_236_comment =
    "C++ Interface:\n"
    "setArgs(non-const PythonTask this, any args, bool append_task)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::set_args\n"
    "//       Access: Published\n"
    "//  Description: Replaces the argument list that is passed to the task\n"
    "//               function.  The parameter should be a tuple or list of\n"
    "//               arguments, or None to indicate the empty list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_set_args_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonTask::get_args(void)
 *******************************************************************/
static PyObject *Dtool_PythonTask_get_args_237(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonTask::get_args(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getArgs", key_word_list));
        else
            (PyArg_Parse(args, ":getArgs"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->get_args();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.getArgs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArgs(non-const PythonTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_get_args_237_comment =
    "C++ Interface:\n"
    "getArgs(non-const PythonTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::get_args\n"
    "//       Access: Published\n"
    "//  Description: Returns the argument list that is passed to the task\n"
    "//               function.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_get_args_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PythonTask::set_upon_death(PyObject *upon_death)
 *******************************************************************/
static PyObject *Dtool_PythonTask_set_upon_death_238(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PythonTask::set_upon_death(PyObject *upon_death)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"upon_death", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setUponDeath", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setUponDeath", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_upon_death(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.setUponDeath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUponDeath(non-const PythonTask this, any upon_death)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_set_upon_death_238_comment =
    "C++ Interface:\n"
    "setUponDeath(non-const PythonTask this, any upon_death)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::set_upon_death\n"
    "//       Access: Published\n"
    "//  Description: Replaces the function that is called when the task\n"
    "//               finishes.  The parameter should be a Python callable\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_set_upon_death_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonTask::get_upon_death(void)
 *******************************************************************/
static PyObject *Dtool_PythonTask_get_upon_death_239(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonTask::get_upon_death(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUponDeath", key_word_list));
        else
            (PyArg_Parse(args, ":getUponDeath"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->get_upon_death();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.getUponDeath() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUponDeath(non-const PythonTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_get_upon_death_239_comment =
    "C++ Interface:\n"
    "getUponDeath(non-const PythonTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::get_upon_death\n"
    "//       Access: Published\n"
    "//  Description: Returns the function that is called when the task\n"
    "//               finishes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_get_upon_death_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PythonTask::set_owner(PyObject *owner)
 *******************************************************************/
static PyObject *Dtool_PythonTask_set_owner_240(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PythonTask::set_owner(PyObject *owner)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"owner", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOwner", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOwner", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_owner(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.setOwner() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOwner(non-const PythonTask this, any owner)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_set_owner_240_comment =
    "C++ Interface:\n"
    "setOwner(non-const PythonTask this, any owner)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::set_owner\n"
    "//       Access: Published\n"
    "//  Description: Specifies a Python object that serves as the \"owner\"\n"
    "//               for the task.  This owner object must have two\n"
    "//               methods: _addTask() and _clearTask(), which will be\n"
    "//               called with one parameter, the task object.\n"
    "//\n"
    "//               owner._addTask() is called when the task is added\n"
    "//               into the active task list, and owner._clearTask() is\n"
    "//               called when it is removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_set_owner_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonTask::get_owner(void)
 *******************************************************************/
static PyObject *Dtool_PythonTask_get_owner_241(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *PythonTask::get_owner(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOwner", key_word_list));
        else
            (PyArg_Parse(args, ":getOwner"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->get_owner();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PythonTask.getOwner() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOwner(non-const PythonTask this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_get_owner_241_comment =
    "C++ Interface:\n"
    "getOwner(non-const PythonTask this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::get_owner\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"owner\" object.  See set_owner().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_get_owner_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PythonTask::__setattr__(basic_string< char > const &attr_name)
 * int PythonTask::__setattr__(basic_string< char > const &attr_name, PyObject *v)
 *******************************************************************/
static PyObject *Dtool_PythonTask_setattr_242(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int PythonTask::__setattr__(basic_string< char > const &attr_name)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"attr_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Setattr", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:Setattr", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->__setattr__(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PythonTask.Setattr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int PythonTask::__setattr__(basic_string< char > const &attr_name, PyObject *v)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"attr_name", (char *)"v", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:Setattr", key_word_list, &param1_str, &param1_len, &param2))
            {
                int return_value = (local_this)->__setattr__(basic_string<char>(param1_str, param1_len), param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PythonTask.Setattr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Setattr() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Setattr(non-const PythonTask this, string attr_name)\n"
          "Setattr(non-const PythonTask this, string attr_name, any v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_setattr_242_comment =
    "C++ Interface:\n"
    "Setattr(non-const PythonTask this, string attr_name)\n"
    "Setattr(non-const PythonTask this, string attr_name, any v)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::__setattr__\n"
    "//       Access: Published\n"
    "//  Description: Maps from an expression like \"task.attr_name = v\".\n"
    "//               This is customized here so we can support some\n"
    "//               traditional task interfaces that supported directly\n"
    "//               assigning certain values.  We also support adding\n"
    "//               arbitrary data to the Task object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::__setattr__\n"
    "//       Access: Published\n"
    "//  Description: Maps from an expression like \"del task.attr_name\".\n"
    "//               This is customized here so we can support some\n"
    "//               traditional task interfaces that supported directly\n"
    "//               assigning certain values.  We also support adding\n"
    "//               arbitrary data to the Task object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_setattr_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *PythonTask::__getattr__(basic_string< char > const &attr_name) const
 *******************************************************************/
static PyObject *Dtool_PythonTask_getattr_243(PyObject *self, PyObject *args,PyObject *kwds) {
    PythonTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PythonTask,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *PythonTask::__getattr__(basic_string< char > const &attr_name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"attr_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Getattr", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:Getattr", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const PythonTask*)local_this)->__getattr__(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Getattr(const PythonTask this, string attr_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_getattr_243_comment =
    "C++ Interface:\n"
    "Getattr(const PythonTask this, string attr_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PythonTask::__getattr__\n"
    "//       Access: Published\n"
    "//  Description: Maps from an expression like \"task.attr_name\".\n"
    "//               This is customized here so we can support some\n"
    "//               traditional task interfaces that supported directly\n"
    "//               querying certain values.  We also support adding\n"
    "//               arbitrary data to the Task object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PythonTask_getattr_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PythonTask::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PythonTask_get_class_type_244(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PythonTask::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PythonTask::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PythonTask_get_class_type_244_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PythonTask_get_class_type_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PythonTask::PythonTask(PyObject *function, basic_string< char > const &name)
 * PythonTask::PythonTask(PyObject *function, basic_string< char > const &name = ((string())))
 * PythonTask::PythonTask(PyObject *function = (Py_None), basic_string< char > const &name = ((string())))
 *******************************************************************/
int  Dtool_Init_PythonTask(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PythonTask::PythonTask(PyObject *function = (Py_None), basic_string< char > const &name = ((string())))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PythonTask", key_word_list))
            {
                PythonTask *return_value = new PythonTask();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonTask,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-PythonTask::PythonTask(PyObject *function, basic_string< char > const &name = ((string())))
            PyObject *param0;
            static char * key_word_list[] = {(char *)"function", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PythonTask", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PythonTask", &param0));
            if(!PyErr_Occurred())
            {
                PythonTask *return_value = new PythonTask(param0);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonTask,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-PythonTask::PythonTask(PyObject *function, basic_string< char > const &name)
            PyObject *param0;
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"function", (char *)"name", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:PythonTask", key_word_list, &param0, &param1_str, &param1_len))
            {
                PythonTask *return_value = new PythonTask(param0, basic_string<char>(param1_str, param1_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PythonTask,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PythonTask() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PythonTask()\n"
          "PythonTask(any function)\n"
          "PythonTask(any function, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PythonTask(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PythonTask)
    {
        printf("PythonTask ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PythonTask * local_this = (PythonTask *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PythonTask)
        return local_this;
    if(requested_type == &Dtool_AsyncTask)
        return ( AsyncTask *) local_this;
    if(requested_type == &Dtool_AsyncTaskBase)
        return ( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( AsyncTaskBase *)( AsyncTask *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PythonTask(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PythonTask)
        return from_this;
    if(from_type == &Dtool_AsyncTask)
    {
          AsyncTask* other_this = (AsyncTask*)from_this;
          return (PythonTask*)other_this;
    }
    if(from_type == &Dtool_AsyncTaskBase)
    {
          AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
          return (PythonTask*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PythonTask*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PythonTask*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PythonTask*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PythonTask*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. AsyncTask | AsyncTask
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTask[]= {
  { "getState",(PyCFunction ) &Dtool_AsyncTask_get_state_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_state_5_comment},
  { "isAlive",(PyCFunction ) &Dtool_AsyncTask_is_alive_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_is_alive_6_comment},
  { "getManager",(PyCFunction ) &Dtool_AsyncTask_get_manager_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_manager_7_comment},
  { "remove",(PyCFunction ) &Dtool_AsyncTask_remove_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_remove_8_comment},
  { "setDelay",(PyCFunction ) &Dtool_AsyncTask_set_delay_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_delay_9_comment},
  { "clearDelay",(PyCFunction ) &Dtool_AsyncTask_clear_delay_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_clear_delay_10_comment},
  { "hasDelay",(PyCFunction ) &Dtool_AsyncTask_has_delay_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_has_delay_11_comment},
  { "getDelay",(PyCFunction ) &Dtool_AsyncTask_get_delay_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_delay_12_comment},
  { "getWakeTime",(PyCFunction ) &Dtool_AsyncTask_get_wake_time_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_wake_time_13_comment},
  { "recalcWakeTime",(PyCFunction ) &Dtool_AsyncTask_recalc_wake_time_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_recalc_wake_time_14_comment},
  { "getStartTime",(PyCFunction ) &Dtool_AsyncTask_get_start_time_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_start_time_15_comment},
  { "getElapsedTime",(PyCFunction ) &Dtool_AsyncTask_get_elapsed_time_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_elapsed_time_16_comment},
  { "getStartFrame",(PyCFunction ) &Dtool_AsyncTask_get_start_frame_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_start_frame_17_comment},
  { "getElapsedFrames",(PyCFunction ) &Dtool_AsyncTask_get_elapsed_frames_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_elapsed_frames_18_comment},
  { "setName",(PyCFunction ) &Dtool_AsyncTask_set_name_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_name_19_comment},
  { "clearName",(PyCFunction ) &Dtool_AsyncTask_clear_name_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_clear_name_20_comment},
  { "getNamePrefix",(PyCFunction ) &Dtool_AsyncTask_get_name_prefix_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_name_prefix_21_comment},
  { "getTaskId",(PyCFunction ) &Dtool_AsyncTask_get_task_id_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_task_id_22_comment},
  { "setTaskChain",(PyCFunction ) &Dtool_AsyncTask_set_task_chain_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_task_chain_23_comment},
  { "getTaskChain",(PyCFunction ) &Dtool_AsyncTask_get_task_chain_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_task_chain_24_comment},
  { "setSort",(PyCFunction ) &Dtool_AsyncTask_set_sort_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_sort_25_comment},
  { "getSort",(PyCFunction ) &Dtool_AsyncTask_get_sort_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_sort_26_comment},
  { "setPriority",(PyCFunction ) &Dtool_AsyncTask_set_priority_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_priority_27_comment},
  { "getPriority",(PyCFunction ) &Dtool_AsyncTask_get_priority_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_priority_28_comment},
  { "setDoneEvent",(PyCFunction ) &Dtool_AsyncTask_set_done_event_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_done_event_29_comment},
  { "getDoneEvent",(PyCFunction ) &Dtool_AsyncTask_get_done_event_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_done_event_30_comment},
  { "setPythonObject",(PyCFunction ) &Dtool_AsyncTask_set_python_object_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_set_python_object_31_comment},
  { "getPythonObject",(PyCFunction ) &Dtool_AsyncTask_get_python_object_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_python_object_32_comment},
  { "getDt",(PyCFunction ) &Dtool_AsyncTask_get_dt_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_dt_33_comment},
  { "getMaxDt",(PyCFunction ) &Dtool_AsyncTask_get_max_dt_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_max_dt_34_comment},
  { "getAverageDt",(PyCFunction ) &Dtool_AsyncTask_get_average_dt_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_average_dt_35_comment},
  { "output",(PyCFunction ) &Dtool_AsyncTask_output_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_output_36_comment},
  { "getClassType",(PyCFunction ) &Dtool_AsyncTask_get_class_type_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_get_class_type_37_comment},
  { "downcastToAsyncTaskSequence",(PyCFunction ) &Dtool_AsyncTask_downcast_to_AsyncTaskSequence_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTask_downcast_to_AsyncTaskSequence_136_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AsyncTask
//////////////////
static PyObject *  Dtool_Repr_AsyncTask(PyObject * self)
{
    AsyncTask * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTask,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AsyncTask(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTask.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTask\n"
          "// Description : This class represents a concrete task performed by an\n"
          "//               AsyncManager.  Normally, you would subclass from this\n"
          "//               class, and override do_task(), to define the\n"
          "//               functionality you wish to have the task perform.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AsyncTaskBase._Dtool_ClassInit(NULL);
        Dtool_AsyncTask.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AsyncTaskBase.As_PyTypeObject());
        Dtool_AsyncTask.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTask.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AsyncTask.As_PyTypeObject().tp_repr = & Dtool_Repr_AsyncTask;
        // __str__ Repr Proxy
        Dtool_AsyncTask.As_PyTypeObject().tp_str = & Dtool_Repr_AsyncTask;
        // Enum  AsyncTask::DoneStatus;
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSDone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSCont",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSAgain",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSPickup",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSExit",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSPause",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"DSInterrupt",PyInt_FromLong(6));
        // Enum  AsyncTask::State;
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SInactive",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SActive",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SServicing",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SServicingRemoved",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SSleeping",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"SActiveNested",PyInt_FromLong(5));
        if(PyType_Ready(&Dtool_AsyncTask.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTask)");
             printf(" Error In PyType_ReadyAsyncTask");
             return;
        }
        Py_INCREF(&Dtool_AsyncTask.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"AsyncTask",&Dtool_AsyncTask.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTask.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTask[32],&Dtool_AsyncTask.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTask,AsyncTask::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTask.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTask",(PyObject *)&Dtool_AsyncTask.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskCollection | AsyncTaskCollection
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskCollection[]= {
  { "assign",(PyCFunction ) &Dtool_AsyncTaskCollection_operator_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_operator_40_comment},
  { "addTask",(PyCFunction ) &Dtool_AsyncTaskCollection_add_task_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_add_task_42_comment},
  { "removeTask",(PyCFunction ) &Dtool_AsyncTaskCollection_remove_task_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_remove_task_43_comment},
  { "addTasksFrom",(PyCFunction ) &Dtool_AsyncTaskCollection_add_tasks_from_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_add_tasks_from_44_comment},
  { "removeTasksFrom",(PyCFunction ) &Dtool_AsyncTaskCollection_remove_tasks_from_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_remove_tasks_from_45_comment},
  { "removeDuplicateTasks",(PyCFunction ) &Dtool_AsyncTaskCollection_remove_duplicate_tasks_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_remove_duplicate_tasks_46_comment},
  { "hasTask",(PyCFunction ) &Dtool_AsyncTaskCollection_has_task_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_has_task_47_comment},
  { "clear",(PyCFunction ) &Dtool_AsyncTaskCollection_clear_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_clear_48_comment},
  { "findTask",(PyCFunction ) &Dtool_AsyncTaskCollection_find_task_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_find_task_49_comment},
  { "getNumTasks",(PyCFunction ) &Dtool_AsyncTaskCollection_get_num_tasks_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_get_num_tasks_50_comment},
  { "getTask",(PyCFunction ) &Dtool_AsyncTaskCollection_get_task_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_get_task_51_comment},
  { "__getitem__",(PyCFunction ) &Dtool_AsyncTaskCollection_operator_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_operator_52_comment},
  { "size",(PyCFunction ) &Dtool_AsyncTaskCollection_size_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_size_53_comment},
  { "__iadd__",(PyCFunction ) &Dtool_AsyncTaskCollection_operator_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_operator_54_comment},
  { "__add__",(PyCFunction ) &Dtool_AsyncTaskCollection_operator_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_operator_55_comment},
  { "output",(PyCFunction ) &Dtool_AsyncTaskCollection_output_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_output_56_comment},
  { "write",(PyCFunction ) &Dtool_AsyncTaskCollection_write_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_write_57_comment},
  { "downcastToAsyncTaskSequence",(PyCFunction ) &Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_138_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getTasks",(PyCFunction) &MakeSeq_AsyncTaskCollection_get_tasks, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     AsyncTaskCollection ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_54__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_AsyncTaskCollection_operator_54(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     AsyncTaskCollection ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_AsyncTaskCollection_operator_52__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_AsyncTaskCollection_operator_52(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     AsyncTaskCollection ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_AsyncTaskCollection_size_53size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_AsyncTaskCollection_size_53(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     AsyncTaskCollection ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_55__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_AsyncTaskCollection_operator_55(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     AsyncTaskCollection
//////////////////
static PyObject *  Dtool_Repr_AsyncTaskCollection(PyObject * self)
{
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AsyncTaskCollection
//////////////////
static PyObject *  Dtool_Str_AsyncTaskCollection(PyObject * self)
{
    AsyncTaskCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AsyncTaskCollection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskCollection\n"
          "// Description : A list of tasks, for instance as returned by some of\n"
          "//               the AsyncTaskManager query functions.  This also\n"
          "//               serves to define an AsyncTaskSequence.\n"
          "//\n"
          "//               TODO: None of this is thread-safe yet.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskCollection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskCollection.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_AsyncTaskCollection_operator_54__iadd__;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_AsyncTaskCollection_operator_52__getitem__;
        // tp_as_sequence->sq_length = size
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_AsyncTaskCollection_size_53size;
        // tp_as_number->nb_add = __add__
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_as_number->nb_add = &Dtool_AsyncTaskCollection_operator_55__add__;
        // __repr__
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_repr = & Dtool_Repr_AsyncTaskCollection;
        // __str__
        Dtool_AsyncTaskCollection.As_PyTypeObject().tp_str = & Dtool_Str_AsyncTaskCollection;
        if(PyType_Ready(&Dtool_AsyncTaskCollection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskCollection)");
             printf(" Error In PyType_ReadyAsyncTaskCollection");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskCollection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskCollection.As_PyTypeObject().tp_dict,"AsyncTaskCollection",&Dtool_AsyncTaskCollection.As_PyObject());
        RegisterRuntimeClass(&Dtool_AsyncTaskCollection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskCollection.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskCollection",(PyObject *)&Dtool_AsyncTaskCollection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskChain | AsyncTaskChain
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskChain[]= {
  { "setTickClock",(PyCFunction ) &Dtool_AsyncTaskChain_set_tick_clock_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_tick_clock_66_comment},
  { "getTickClock",(PyCFunction ) &Dtool_AsyncTaskChain_get_tick_clock_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_tick_clock_67_comment},
  { "setNumThreads",(PyCFunction ) &Dtool_AsyncTaskChain_set_num_threads_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_num_threads_68_comment},
  { "getNumThreads",(PyCFunction ) &Dtool_AsyncTaskChain_get_num_threads_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_num_threads_69_comment},
  { "getNumRunningThreads",(PyCFunction ) &Dtool_AsyncTaskChain_get_num_running_threads_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_num_running_threads_70_comment},
  { "setThreadPriority",(PyCFunction ) &Dtool_AsyncTaskChain_set_thread_priority_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_thread_priority_71_comment},
  { "getThreadPriority",(PyCFunction ) &Dtool_AsyncTaskChain_get_thread_priority_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_thread_priority_72_comment},
  { "setFrameBudget",(PyCFunction ) &Dtool_AsyncTaskChain_set_frame_budget_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_frame_budget_73_comment},
  { "getFrameBudget",(PyCFunction ) &Dtool_AsyncTaskChain_get_frame_budget_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_frame_budget_74_comment},
  { "setFrameSync",(PyCFunction ) &Dtool_AsyncTaskChain_set_frame_sync_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_frame_sync_75_comment},
  { "getFrameSync",(PyCFunction ) &Dtool_AsyncTaskChain_get_frame_sync_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_frame_sync_76_comment},
  { "setTimeslicePriority",(PyCFunction ) &Dtool_AsyncTaskChain_set_timeslice_priority_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_set_timeslice_priority_77_comment},
  { "getTimeslicePriority",(PyCFunction ) &Dtool_AsyncTaskChain_get_timeslice_priority_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_timeslice_priority_78_comment},
  { "stopThreads",(PyCFunction ) &Dtool_AsyncTaskChain_stop_threads_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_stop_threads_79_comment},
  { "startThreads",(PyCFunction ) &Dtool_AsyncTaskChain_start_threads_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_start_threads_80_comment},
  { "isStarted",(PyCFunction ) &Dtool_AsyncTaskChain_is_started_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_is_started_81_comment},
  { "hasTask",(PyCFunction ) &Dtool_AsyncTaskChain_has_task_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_has_task_82_comment},
  { "waitForTasks",(PyCFunction ) &Dtool_AsyncTaskChain_wait_for_tasks_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_wait_for_tasks_83_comment},
  { "getNumTasks",(PyCFunction ) &Dtool_AsyncTaskChain_get_num_tasks_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_num_tasks_84_comment},
  { "getTasks",(PyCFunction ) &Dtool_AsyncTaskChain_get_tasks_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_tasks_85_comment},
  { "getActiveTasks",(PyCFunction ) &Dtool_AsyncTaskChain_get_active_tasks_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_active_tasks_86_comment},
  { "getSleepingTasks",(PyCFunction ) &Dtool_AsyncTaskChain_get_sleeping_tasks_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_sleeping_tasks_87_comment},
  { "poll",(PyCFunction ) &Dtool_AsyncTaskChain_poll_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_poll_88_comment},
  { "getNextWakeTime",(PyCFunction ) &Dtool_AsyncTaskChain_get_next_wake_time_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_next_wake_time_89_comment},
  { "output",(PyCFunction ) &Dtool_AsyncTaskChain_output_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_output_90_comment},
  { "write",(PyCFunction ) &Dtool_AsyncTaskChain_write_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_write_91_comment},
  { "getClassType",(PyCFunction ) &Dtool_AsyncTaskChain_get_class_type_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_get_class_type_92_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_60_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_AsyncTaskChain_upcast_to_Namable_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskChain_upcast_to_Namable_63_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AsyncTaskChain
//////////////////
static PyObject *  Dtool_Repr_AsyncTaskChain(PyObject * self)
{
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AsyncTaskChain
//////////////////
static PyObject *  Dtool_Str_AsyncTaskChain(PyObject * self)
{
    AsyncTaskChain * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskChain,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AsyncTaskChain(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskChain.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskChain\n"
          "// Description : The AsyncTaskChain is a subset of the\n"
          "//               AsyncTaskManager.  Each chain maintains a separate\n"
          "//               list of tasks, and will execute them with its own set\n"
          "//               of threads.  Each chain may thereby operate\n"
          "//               independently of the other chains.\n"
          "//\n"
          "//               The AsyncTaskChain will spawn a specified number of\n"
          "//               threads (possibly 0) to serve the tasks.  If there\n"
          "//               are no threads, you must call poll() from time to\n"
          "//               time to serve the tasks in the main thread.  Normally\n"
          "//               this is done by calling AsyncTaskManager::poll().\n"
          "//\n"
          "//               Each task will run exactly once each epoch.  Beyond\n"
          "//               that, the tasks' sort and priority values control the\n"
          "//               order in which they are run: tasks are run in\n"
          "//               increasing order by sort value, and within the same\n"
          "//               sort value, they are run roughly in decreasing order\n"
          "//               by priority value, with some exceptions for\n"
          "//               parallelism.  Tasks with different sort values are\n"
          "//               never run in parallel together, but tasks with\n"
          "//               different priority values might be (if there is more\n"
          "//               than one thread).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskChain.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_AsyncTaskChain.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskChain.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskChain.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AsyncTaskChain.As_PyTypeObject().tp_repr = & Dtool_Repr_AsyncTaskChain;
        // __str__
        Dtool_AsyncTaskChain.As_PyTypeObject().tp_str = & Dtool_Str_AsyncTaskChain;
        if(PyType_Ready(&Dtool_AsyncTaskChain.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskChain)");
             printf(" Error In PyType_ReadyAsyncTaskChain");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskChain.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskChain.As_PyTypeObject().tp_dict,"AsyncTaskChain",&Dtool_AsyncTaskChain.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTaskChain.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTaskChain[26],&Dtool_AsyncTaskChain.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTaskChain,AsyncTaskChain::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskChain.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskChain",(PyObject *)&Dtool_AsyncTaskChain.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskManager | AsyncTaskManager
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskManager[]= {
  { "cleanup",(PyCFunction ) &Dtool_AsyncTaskManager_cleanup_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_cleanup_100_comment},
  { "setClock",(PyCFunction ) &Dtool_AsyncTaskManager_set_clock_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_set_clock_101_comment},
  { "getClock",(PyCFunction ) &Dtool_AsyncTaskManager_get_clock_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_clock_102_comment},
  { "getNumTaskChains",(PyCFunction ) &Dtool_AsyncTaskManager_get_num_task_chains_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_num_task_chains_103_comment},
  { "getTaskChain",(PyCFunction ) &Dtool_AsyncTaskManager_get_task_chain_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_task_chain_104_comment},
  { "makeTaskChain",(PyCFunction ) &Dtool_AsyncTaskManager_make_task_chain_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_make_task_chain_105_comment},
  { "findTaskChain",(PyCFunction ) &Dtool_AsyncTaskManager_find_task_chain_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_find_task_chain_106_comment},
  { "removeTaskChain",(PyCFunction ) &Dtool_AsyncTaskManager_remove_task_chain_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_remove_task_chain_107_comment},
  { "add",(PyCFunction ) &Dtool_AsyncTaskManager_add_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_add_108_comment},
  { "hasTask",(PyCFunction ) &Dtool_AsyncTaskManager_has_task_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_has_task_109_comment},
  { "findTask",(PyCFunction ) &Dtool_AsyncTaskManager_find_task_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_find_task_110_comment},
  { "findTasks",(PyCFunction ) &Dtool_AsyncTaskManager_find_tasks_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_find_tasks_111_comment},
  { "findTasksMatching",(PyCFunction ) &Dtool_AsyncTaskManager_find_tasks_matching_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_find_tasks_matching_112_comment},
  { "remove",(PyCFunction ) &Dtool_AsyncTaskManager_remove_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_remove_113_comment},
  { "waitForTasks",(PyCFunction ) &Dtool_AsyncTaskManager_wait_for_tasks_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_wait_for_tasks_114_comment},
  { "stopThreads",(PyCFunction ) &Dtool_AsyncTaskManager_stop_threads_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_stop_threads_115_comment},
  { "startThreads",(PyCFunction ) &Dtool_AsyncTaskManager_start_threads_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_start_threads_116_comment},
  { "getNumTasks",(PyCFunction ) &Dtool_AsyncTaskManager_get_num_tasks_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_num_tasks_117_comment},
  { "getTasks",(PyCFunction ) &Dtool_AsyncTaskManager_get_tasks_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_tasks_118_comment},
  { "getActiveTasks",(PyCFunction ) &Dtool_AsyncTaskManager_get_active_tasks_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_active_tasks_119_comment},
  { "getSleepingTasks",(PyCFunction ) &Dtool_AsyncTaskManager_get_sleeping_tasks_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_sleeping_tasks_120_comment},
  { "poll",(PyCFunction ) &Dtool_AsyncTaskManager_poll_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_poll_121_comment},
  { "getNextWakeTime",(PyCFunction ) &Dtool_AsyncTaskManager_get_next_wake_time_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_next_wake_time_122_comment},
  { "output",(PyCFunction ) &Dtool_AsyncTaskManager_output_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_output_123_comment},
  { "write",(PyCFunction ) &Dtool_AsyncTaskManager_write_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_write_124_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_AsyncTaskManager_get_global_ptr_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_global_ptr_125_comment},
  { "getClassType",(PyCFunction ) &Dtool_AsyncTaskManager_get_class_type_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_get_class_type_126_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_94_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_AsyncTaskManager_upcast_to_Namable_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskManager_upcast_to_Namable_96_comment},
  { "getTaskChains",(PyCFunction) &MakeSeq_AsyncTaskManager_get_task_chains, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     AsyncTaskManager
//////////////////
static PyObject *  Dtool_Repr_AsyncTaskManager(PyObject * self)
{
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     AsyncTaskManager
//////////////////
static PyObject *  Dtool_Str_AsyncTaskManager(PyObject * self)
{
    AsyncTaskManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AsyncTaskManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AsyncTaskManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskManager\n"
          "// Description : A class to manage a loose queue of isolated tasks,\n"
          "//               which can be performed either synchronously (in the\n"
          "//               foreground thread) or asynchronously (by a background\n"
          "//               thread).\n"
          "//\n"
          "//               The AsyncTaskManager is actually a collection of\n"
          "//               AsyncTaskChains, each of which maintains a list of\n"
          "//               tasks.  Each chain can be either foreground or\n"
          "//               background (it may run only in the main thread, or it\n"
          "//               may be serviced by one or more background threads).\n"
          "//               See AsyncTaskChain for more information.\n"
          "//\n"
          "//               If you do not require background processing, it is\n"
          "//               perfectly acceptable to create only one\n"
          "//               AsyncTaskChain, which runs in the main thread.  This\n"
          "//               is a common configuration.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskManager.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_AsyncTaskManager.As_PyTypeObject().tp_repr = & Dtool_Repr_AsyncTaskManager;
        // __str__
        Dtool_AsyncTaskManager.As_PyTypeObject().tp_str = & Dtool_Str_AsyncTaskManager;
        if(PyType_Ready(&Dtool_AsyncTaskManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskManager)");
             printf(" Error In PyType_ReadyAsyncTaskManager");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict,"AsyncTaskManager",&Dtool_AsyncTaskManager.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_AsyncTaskManager[25],&Dtool_AsyncTaskManager.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTaskManager.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTaskManager[26],&Dtool_AsyncTaskManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTaskManager,AsyncTaskManager::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskManager.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskManager",(PyObject *)&Dtool_AsyncTaskManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskPause | AsyncTaskPause
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskPause[]= {
  { "getClassType",(PyCFunction ) &Dtool_AsyncTaskPause_get_class_type_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskPause_get_class_type_132_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AsyncTaskPause(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskPause.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskPause\n"
          "// Description : A special kind of task that simple returns DS_pause,\n"
          "//               to pause for a specified number of seconds and then\n"
          "//               finish.  It's intended to be used within an\n"
          "//               AsyncTaskSequence.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AsyncTask._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskPause.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AsyncTask.As_PyTypeObject());
        Dtool_AsyncTaskPause.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskPause.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskPause.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AsyncTaskPause.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskPause)");
             printf(" Error In PyType_ReadyAsyncTaskPause");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskPause.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskPause.As_PyTypeObject().tp_dict,"AsyncTaskPause",&Dtool_AsyncTaskPause.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTaskPause.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTaskPause[0],&Dtool_AsyncTaskPause.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTaskPause,AsyncTaskPause::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskPause.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskPause",(PyObject *)&Dtool_AsyncTaskPause.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AsyncTaskSequence | AsyncTaskSequence
//********************************************************************
PyMethodDef Dtool_Methods_AsyncTaskSequence[]= {
  { "setRepeatCount",(PyCFunction ) &Dtool_AsyncTaskSequence_set_repeat_count_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_set_repeat_count_144_comment},
  { "getRepeatCount",(PyCFunction ) &Dtool_AsyncTaskSequence_get_repeat_count_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_get_repeat_count_145_comment},
  { "getCurrentTaskIndex",(PyCFunction ) &Dtool_AsyncTaskSequence_get_current_task_index_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_get_current_task_index_146_comment},
  { "getClassType",(PyCFunction ) &Dtool_AsyncTaskSequence_get_class_type_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_get_class_type_147_comment},
  { "upcastToAsyncTask",(PyCFunction ) &Dtool_AsyncTaskSequence_upcast_to_AsyncTask_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTask_135_comment},
  { "upcastToAsyncTaskCollection",(PyCFunction ) &Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_137_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AsyncTaskSequence(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AsyncTaskSequence.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AsyncTaskSequence\n"
          "// Description : A special kind of task that serves as a list of tasks\n"
          "//               internally.  Each task on the list is executed in\n"
          "//               sequence, one per epoch.\n"
          "//\n"
          "//               This is similar to a Sequence interval, though it has\n"
          "//               some slightly different abilities.  For instance,\n"
          "//               although you can't start at any arbitrary point in\n"
          "//               the sequence, you can construct a task sequence whose\n"
          "//               duration changes during playback.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AsyncTask._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskCollection._Dtool_ClassInit(NULL);
        Dtool_AsyncTaskSequence.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_AsyncTask.As_PyTypeObject(),&Dtool_AsyncTaskCollection.As_PyTypeObject());
        Dtool_AsyncTaskSequence.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AsyncTaskSequence.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AsyncTaskSequence.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AsyncTaskSequence.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AsyncTaskSequence)");
             printf(" Error In PyType_ReadyAsyncTaskSequence");
             return;
        }
        Py_INCREF(&Dtool_AsyncTaskSequence.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AsyncTaskSequence.As_PyTypeObject().tp_dict,"AsyncTaskSequence",&Dtool_AsyncTaskSequence.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AsyncTaskSequence.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AsyncTaskSequence[3],&Dtool_AsyncTaskSequence.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AsyncTaskSequence,AsyncTaskSequence::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AsyncTaskSequence.As_PyTypeObject());
        PyModule_AddObject(module, "AsyncTaskSequence",(PyObject *)&Dtool_AsyncTaskSequence.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EventParameter | EventParameter
//********************************************************************
PyMethodDef Dtool_Methods_EventParameter[]= {
  { "assign",(PyCFunction ) &Dtool_EventParameter_operator_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_operator_150_comment},
  { "isEmpty",(PyCFunction ) &Dtool_EventParameter_is_empty_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_empty_152_comment},
  { "isInt",(PyCFunction ) &Dtool_EventParameter_is_int_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_int_153_comment},
  { "getIntValue",(PyCFunction ) &Dtool_EventParameter_get_int_value_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_int_value_154_comment},
  { "isDouble",(PyCFunction ) &Dtool_EventParameter_is_double_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_double_155_comment},
  { "getDoubleValue",(PyCFunction ) &Dtool_EventParameter_get_double_value_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_double_value_156_comment},
  { "isString",(PyCFunction ) &Dtool_EventParameter_is_string_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_string_157_comment},
  { "getStringValue",(PyCFunction ) &Dtool_EventParameter_get_string_value_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_string_value_158_comment},
  { "isWstring",(PyCFunction ) &Dtool_EventParameter_is_wstring_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_wstring_159_comment},
  { "getWstringValue",(PyCFunction ) &Dtool_EventParameter_get_wstring_value_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_wstring_value_160_comment},
  { "isTypedRefCount",(PyCFunction ) &Dtool_EventParameter_is_typed_ref_count_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_is_typed_ref_count_161_comment},
  { "getTypedRefCountValue",(PyCFunction ) &Dtool_EventParameter_get_typed_ref_count_value_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_typed_ref_count_value_162_comment},
  { "getPtr",(PyCFunction ) &Dtool_EventParameter_get_ptr_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_get_ptr_163_comment},
  { "output",(PyCFunction ) &Dtool_EventParameter_output_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventParameter_output_164_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     EventParameter
//////////////////
static PyObject *  Dtool_Repr_EventParameter(PyObject * self)
{
    EventParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventParameter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_EventParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_EventParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : EventParameter\n"
          "// Description : An optional parameter associated with an event.  Each\n"
          "//               event may have zero or more of these.  Each parameter\n"
          "//               stores a pointer to a TypedWritableReferenceCount\n"
          "//               object, which of course could be pretty much\n"
          "//               anything.  To store a simple value like a double or a\n"
          "//               string, the EventParameter constructors transparently\n"
          "//               use the EventStoreValue template class, defined\n"
          "//               below.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_EventParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_EventParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EventParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EventParameter.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_EventParameter.As_PyTypeObject().tp_repr = & Dtool_Repr_EventParameter;
        // __str__ Repr Proxy
        Dtool_EventParameter.As_PyTypeObject().tp_str = & Dtool_Repr_EventParameter;
        if(PyType_Ready(&Dtool_EventParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EventParameter)");
             printf(" Error In PyType_ReadyEventParameter");
             return;
        }
        Py_INCREF(&Dtool_EventParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EventParameter.As_PyTypeObject().tp_dict,"EventParameter",&Dtool_EventParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_EventParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EventParameter.As_PyTypeObject());
        PyModule_AddObject(module, "EventParameter",(PyObject *)&Dtool_EventParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EventStoreValueBase | EventStoreValueBase
//********************************************************************
PyMethodDef Dtool_Methods_EventStoreValueBase[]= {
  { "output",(PyCFunction ) &Dtool_EventStoreValueBase_output_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventStoreValueBase_output_167_comment},
  { "getClassType",(PyCFunction ) &Dtool_EventStoreValueBase_get_class_type_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventStoreValueBase_get_class_type_168_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     EventStoreValueBase
//////////////////
static PyObject *  Dtool_Repr_EventStoreValueBase(PyObject * self)
{
    EventStoreValueBase * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventStoreValueBase,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_EventStoreValueBase(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_EventStoreValueBase.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : EventStoreValueBase\n"
          "// Description : A non-template base class of EventStoreValue (below),\n"
          "//               which serves mainly to define the placeholder for the\n"
          "//               virtual output function.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_EventStoreValueBase.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject());
        Dtool_EventStoreValueBase.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EventStoreValueBase.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EventStoreValueBase.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_EventStoreValueBase.As_PyTypeObject().tp_repr = & Dtool_Repr_EventStoreValueBase;
        // __str__ Repr Proxy
        Dtool_EventStoreValueBase.As_PyTypeObject().tp_str = & Dtool_Repr_EventStoreValueBase;
        if(PyType_Ready(&Dtool_EventStoreValueBase.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EventStoreValueBase)");
             printf(" Error In PyType_ReadyEventStoreValueBase");
             return;
        }
        Py_INCREF(&Dtool_EventStoreValueBase.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EventStoreValueBase.As_PyTypeObject().tp_dict,"EventStoreValueBase",&Dtool_EventStoreValueBase.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EventStoreValueBase.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EventStoreValueBase[1],&Dtool_EventStoreValueBase.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EventStoreValueBase,EventStoreValueBase::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EventStoreValueBase.As_PyTypeObject());
        PyModule_AddObject(module, "EventStoreValueBase",(PyObject *)&Dtool_EventStoreValueBase.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EventStoreTypedRefCount | EventStoreTypedRefCount
//********************************************************************
PyMethodDef Dtool_Methods_EventStoreTypedRefCount[]= {
  { "setValue",(PyCFunction ) &Dtool_EventStoreTypedRefCount_set_value_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventStoreTypedRefCount_set_value_171_comment},
  { "getValue",(PyCFunction ) &Dtool_EventStoreTypedRefCount_get_value_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventStoreTypedRefCount_get_value_172_comment},
  { "getClassType",(PyCFunction ) &Dtool_EventStoreTypedRefCount_get_class_type_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventStoreTypedRefCount_get_class_type_173_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_EventStoreTypedRefCount(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : EventStoreTypedRefCount\n"
          "// Description : A class object for storing specifically objects of\n"
          "//               type TypedReferenceCount, which is different than\n"
          "//               TypedWritableReferenceCount.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_EventStoreValueBase._Dtool_ClassInit(NULL);
        Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_EventStoreValueBase.As_PyTypeObject());
        Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_EventStoreTypedRefCount.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EventStoreTypedRefCount)");
             printf(" Error In PyType_ReadyEventStoreTypedRefCount");
             return;
        }
        Py_INCREF(&Dtool_EventStoreTypedRefCount.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_dict,"EventStoreTypedRefCount",&Dtool_EventStoreTypedRefCount.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EventStoreTypedRefCount.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EventStoreTypedRefCount[2],&Dtool_EventStoreTypedRefCount.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EventStoreTypedRefCount,EventStoreTypedRefCount::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EventStoreTypedRefCount.As_PyTypeObject());
        PyModule_AddObject(module, "EventStoreTypedRefCount",(PyObject *)&Dtool_EventStoreTypedRefCount.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Event | Event
//********************************************************************
PyMethodDef Dtool_Methods_Event[]= {
  { "assign",(PyCFunction ) &Dtool_Event_operator_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_operator_176_comment},
  { "setName",(PyCFunction ) &Dtool_Event_set_name_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_set_name_177_comment},
  { "clearName",(PyCFunction ) &Dtool_Event_clear_name_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_clear_name_178_comment},
  { "hasName",(PyCFunction ) &Dtool_Event_has_name_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_has_name_179_comment},
  { "getName",(PyCFunction ) &Dtool_Event_get_name_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_get_name_180_comment},
  { "addParameter",(PyCFunction ) &Dtool_Event_add_parameter_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_add_parameter_181_comment},
  { "getNumParameters",(PyCFunction ) &Dtool_Event_get_num_parameters_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_get_num_parameters_182_comment},
  { "getParameter",(PyCFunction ) &Dtool_Event_get_parameter_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_get_parameter_183_comment},
  { "hasReceiver",(PyCFunction ) &Dtool_Event_has_receiver_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_has_receiver_184_comment},
  { "clearReceiver",(PyCFunction ) &Dtool_Event_clear_receiver_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_clear_receiver_187_comment},
  { "output",(PyCFunction ) &Dtool_Event_output_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_output_188_comment},
  { "getClassType",(PyCFunction ) &Dtool_Event_get_class_type_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Event_get_class_type_189_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getParameters",(PyCFunction) &MakeSeq_Event_get_parameters, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Event
//////////////////
static PyObject *  Dtool_Repr_Event(PyObject * self)
{
    Event * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Event,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Event(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Event.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Event\n"
          "// Description : A named event, possibly with parameters.  Anyone in\n"
          "//               any thread may throw an event at any time; there will\n"
          "//               be one process responsible for reading and dispacting\n"
          "//               on the events (but not necessarily immediately).\n"
          "//\n"
          "//               This function use to inherit from Namable, but that\n"
          "//               makes it too expensive to get its name the Python\n"
          "//               code.  Now it just copies the Namable interface in.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Event.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_Event.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Event.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Event.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Event.As_PyTypeObject().tp_repr = & Dtool_Repr_Event;
        // __str__ Repr Proxy
        Dtool_Event.As_PyTypeObject().tp_str = & Dtool_Repr_Event;
        if(PyType_Ready(&Dtool_Event.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Event)");
             printf(" Error In PyType_ReadyEvent");
             return;
        }
        Py_INCREF(&Dtool_Event.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Event.As_PyTypeObject().tp_dict,"Event",&Dtool_Event.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Event.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Event[11],&Dtool_Event.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Event,Event::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Event.As_PyTypeObject());
        PyModule_AddObject(module, "Event",(PyObject *)&Dtool_Event.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EventHandler | EventHandler
//********************************************************************
PyMethodDef Dtool_Methods_EventHandler[]= {
  { "processEvents",(PyCFunction ) &Dtool_EventHandler_process_events_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventHandler_process_events_193_comment},
  { "dispatchEvent",(PyCFunction ) &Dtool_EventHandler_dispatch_event_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventHandler_dispatch_event_194_comment},
  { "write",(PyCFunction ) &Dtool_EventHandler_write_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventHandler_write_195_comment},
  { "getGlobalEventHandler",(PyCFunction ) &Dtool_EventHandler_get_global_event_handler_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventHandler_get_global_event_handler_196_comment},
  { "getClassType",(PyCFunction ) &Dtool_EventHandler_get_class_type_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventHandler_get_class_type_197_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     EventHandler
//////////////////
static PyObject *  Dtool_Str_EventHandler(PyObject * self)
{
    EventHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_EventHandler,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_EventHandler(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_EventHandler.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : EventHandler\n"
          "// Description : A class to monitor events from the C++ side of\n"
          "//               things.  It maintains a set of \"hooks\", function\n"
          "//               pointers assigned to event names, and calls the\n"
          "//               appropriate hooks when the matching event is\n"
          "//               detected.\n"
          "//\n"
          "//               This class is not necessary when the hooks are\n"
          "//               detected and processed entirely by the scripting\n"
          "//               language, e.g. via Scheme hooks or the messenger\n"
          "//               in Python.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_EventHandler.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_EventHandler.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EventHandler.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EventHandler.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_EventHandler.As_PyTypeObject().tp_str = & Dtool_Str_EventHandler;
        if(PyType_Ready(&Dtool_EventHandler.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EventHandler)");
             printf(" Error In PyType_ReadyEventHandler");
             return;
        }
        Py_INCREF(&Dtool_EventHandler.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EventHandler.As_PyTypeObject().tp_dict,"EventHandler",&Dtool_EventHandler.As_PyObject());
        //  Static Method getGlobalEventHandler
        PyDict_SetItemString(Dtool_EventHandler.As_PyTypeObject().tp_dict,"getGlobalEventHandler",PyCFunction_New(&Dtool_Methods_EventHandler[3],&Dtool_EventHandler.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EventHandler.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EventHandler[4],&Dtool_EventHandler.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EventHandler,EventHandler::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EventHandler.As_PyTypeObject());
        PyModule_AddObject(module, "EventHandler",(PyObject *)&Dtool_EventHandler.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EventQueue | EventQueue
//********************************************************************
PyMethodDef Dtool_Methods_EventQueue[]= {
  { "queueEvent",(PyCFunction ) &Dtool_EventQueue_queue_event_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_queue_event_202_comment},
  { "clear",(PyCFunction ) &Dtool_EventQueue_clear_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_clear_203_comment},
  { "isQueueEmpty",(PyCFunction ) &Dtool_EventQueue_is_queue_empty_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_is_queue_empty_204_comment},
  { "isQueueFull",(PyCFunction ) &Dtool_EventQueue_is_queue_full_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_is_queue_full_205_comment},
  { "dequeueEvent",(PyCFunction ) &Dtool_EventQueue_dequeue_event_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_dequeue_event_206_comment},
  { "getGlobalEventQueue",(PyCFunction ) &Dtool_EventQueue_get_global_event_queue_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EventQueue_get_global_event_queue_207_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_EventQueue(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_EventQueue.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : EventQueue\n"
          "// Description : A queue of pending events.  As events are thrown,\n"
          "//               they are added to this queue; eventually, they will\n"
          "//               be extracted out again by an EventHandler and\n"
          "//               processed.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_EventQueue.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_EventQueue.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EventQueue.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EventQueue.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_EventQueue.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EventQueue)");
             printf(" Error In PyType_ReadyEventQueue");
             return;
        }
        Py_INCREF(&Dtool_EventQueue.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EventQueue.As_PyTypeObject().tp_dict,"EventQueue",&Dtool_EventQueue.As_PyObject());
        //  Static Method getGlobalEventQueue
        PyDict_SetItemString(Dtool_EventQueue.As_PyTypeObject().tp_dict,"getGlobalEventQueue",PyCFunction_New(&Dtool_Methods_EventQueue[5],&Dtool_EventQueue.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EventQueue,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EventQueue.As_PyTypeObject());
        PyModule_AddObject(module, "EventQueue",(PyObject *)&Dtool_EventQueue.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PointerEventList | PointerEventList
//********************************************************************
PyMethodDef Dtool_Methods_PointerEventList[]= {
  { "getNumEvents",(PyCFunction ) &Dtool_PointerEventList_get_num_events_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_num_events_210_comment},
  { "getInWindow",(PyCFunction ) &Dtool_PointerEventList_get_in_window_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_in_window_211_comment},
  { "getXpos",(PyCFunction ) &Dtool_PointerEventList_get_xpos_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_xpos_212_comment},
  { "getYpos",(PyCFunction ) &Dtool_PointerEventList_get_ypos_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_ypos_213_comment},
  { "getDx",(PyCFunction ) &Dtool_PointerEventList_get_dx_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_dx_214_comment},
  { "getDy",(PyCFunction ) &Dtool_PointerEventList_get_dy_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_dy_215_comment},
  { "getSequence",(PyCFunction ) &Dtool_PointerEventList_get_sequence_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_sequence_216_comment},
  { "getLength",(PyCFunction ) &Dtool_PointerEventList_get_length_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_length_217_comment},
  { "getDirection",(PyCFunction ) &Dtool_PointerEventList_get_direction_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_direction_218_comment},
  { "getRotation",(PyCFunction ) &Dtool_PointerEventList_get_rotation_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_rotation_219_comment},
  { "getTime",(PyCFunction ) &Dtool_PointerEventList_get_time_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_time_220_comment},
  { "clear",(PyCFunction ) &Dtool_PointerEventList_clear_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_clear_221_comment},
  { "popFront",(PyCFunction ) &Dtool_PointerEventList_pop_front_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_pop_front_222_comment},
  { "addEvent",(PyCFunction ) &Dtool_PointerEventList_add_event_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_add_event_223_comment},
  { "encircles",(PyCFunction ) &Dtool_PointerEventList_encircles_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_encircles_224_comment},
  { "totalTurns",(PyCFunction ) &Dtool_PointerEventList_total_turns_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_total_turns_225_comment},
  { "matchPattern",(PyCFunction ) &Dtool_PointerEventList_match_pattern_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_match_pattern_226_comment},
  { "getClassType",(PyCFunction ) &Dtool_PointerEventList_get_class_type_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PointerEventList_get_class_type_227_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PointerEventList(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PointerEventList.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PointerEventList\n"
          "// Description : Records a set of pointer events that happened\n"
          "//               recently.  This class is usually used only in the\n"
          "//               data graph, to transmit the recent pointer presses,\n"
          "//               but it may be used anywhere a list of PointerEvents\n"
          "//               is desired.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_EventStoreValueBase._Dtool_ClassInit(NULL);
        Dtool_PointerEventList.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_EventStoreValueBase.As_PyTypeObject());
        Dtool_PointerEventList.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PointerEventList.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PointerEventList.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PointerEventList.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PointerEventList)");
             printf(" Error In PyType_ReadyPointerEventList");
             return;
        }
        Py_INCREF(&Dtool_PointerEventList.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PointerEventList.As_PyTypeObject().tp_dict,"PointerEventList",&Dtool_PointerEventList.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PointerEventList.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PointerEventList[17],&Dtool_PointerEventList.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PointerEventList,PointerEventList::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PointerEventList.As_PyTypeObject());
        PyModule_AddObject(module, "PointerEventList",(PyObject *)&Dtool_PointerEventList.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PythonTask | PythonTask
//********************************************************************
PyMethodDef Dtool_Methods_PythonTask[]= {
  { "setFunction",(PyCFunction ) &Dtool_PythonTask_set_function_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_set_function_234_comment},
  { "getFunction",(PyCFunction ) &Dtool_PythonTask_get_function_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_get_function_235_comment},
  { "setArgs",(PyCFunction ) &Dtool_PythonTask_set_args_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_set_args_236_comment},
  { "getArgs",(PyCFunction ) &Dtool_PythonTask_get_args_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_get_args_237_comment},
  { "setUponDeath",(PyCFunction ) &Dtool_PythonTask_set_upon_death_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_set_upon_death_238_comment},
  { "getUponDeath",(PyCFunction ) &Dtool_PythonTask_get_upon_death_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_get_upon_death_239_comment},
  { "setOwner",(PyCFunction ) &Dtool_PythonTask_set_owner_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_set_owner_240_comment},
  { "getOwner",(PyCFunction ) &Dtool_PythonTask_get_owner_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_get_owner_241_comment},
  { "Setattr",(PyCFunction ) &Dtool_PythonTask_setattr_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_setattr_242_comment},
  { "Getattr",(PyCFunction ) &Dtool_PythonTask_getattr_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_getattr_243_comment},
  { "getClassType",(PyCFunction ) &Dtool_PythonTask_get_class_type_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PythonTask_get_class_type_244_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PythonTask ...tp_getattro = Getattr
//////////////////
static PyObject * Dtool_PythonTask_getattr_243Getattr( PyObject * self, PyObject * one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PythonTask_getattr_243(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        PyErr_Clear();
        return PyObject_GenericGetAttr(self, one);
    }
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PythonTask ...tp_setattro = Setattr
//////////////////
static int Dtool_PythonTask_setattr_242Setattr( PyObject * self, PyObject * one, PyObject * two)
{
    PyObject *args;
    if (two == NULL) {
        args = Py_BuildValue("(O)", one);
    } else {
        args = Py_BuildValue("(OO)", one, two);
    }
    PyObject *py_result = Dtool_PythonTask_setattr_242(self, args, NULL);
    Py_DECREF(args);
    if (py_result == NULL) return -1;
    int result = PyInt_AsLong(py_result);
    Py_DECREF(py_result);
    return result;
}

void   Dtool_PyModuleClassInit_PythonTask(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PythonTask.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PythonTask\n"
          "// Description : This class exists to allow association of a Python\n"
          "//               function with the AsyncTaskManager.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AsyncTask._Dtool_ClassInit(NULL);
        Dtool_PythonTask.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AsyncTask.As_PyTypeObject());
        Dtool_PythonTask.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PythonTask.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PythonTask.As_PyTypeObject().tp_dict);
        // tp_getattro = Getattr
        Dtool_PythonTask.As_PyTypeObject().tp_getattro = &Dtool_PythonTask_getattr_243Getattr;
        // tp_setattro = Setattr
        Dtool_PythonTask.As_PyTypeObject().tp_setattro = &Dtool_PythonTask_setattr_242Setattr;
        if(PyType_Ready(&Dtool_PythonTask.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PythonTask)");
             printf(" Error In PyType_ReadyPythonTask");
             return;
        }
        Py_INCREF(&Dtool_PythonTask.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PythonTask.As_PyTypeObject().tp_dict,"PythonTask",&Dtool_PythonTask.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PythonTask.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PythonTask[10],&Dtool_PythonTask.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PythonTask,PythonTask::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PythonTask.As_PyTypeObject());
        PyModule_AddObject(module, "PythonTask",(PyObject *)&Dtool_PythonTask.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..ThreadPriority
//********************************************************************
   PyModule_AddIntConstant(module,"TPLow",0);
   PyModule_AddIntConstant(module,"TPNormal",1);
   PyModule_AddIntConstant(module,"TPHigh",2);
   PyModule_AddIntConstant(module,"TPUrgent",3);
//********************************************************************
//*** Module Init Updcall ..AsyncTask
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTask(module);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskCollection
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskCollection(module);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskChain
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskChain(module);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskManager
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskManager(module);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskPause
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskPause(module);
//********************************************************************
//*** Module Init Updcall ..AsyncTaskSequence
//********************************************************************
   Dtool_PyModuleClassInit_AsyncTaskSequence(module);
//********************************************************************
//*** Module Init Updcall ..EventParameter
//********************************************************************
   Dtool_PyModuleClassInit_EventParameter(module);
//********************************************************************
//*** Module Init Updcall ..EventStoreValueBase
//********************************************************************
   Dtool_PyModuleClassInit_EventStoreValueBase(module);
//********************************************************************
//*** Module Init Updcall ..EventStoreTypedRefCount
//********************************************************************
   Dtool_PyModuleClassInit_EventStoreTypedRefCount(module);
//********************************************************************
//*** Module Init Updcall ..Event
//********************************************************************
   Dtool_PyModuleClassInit_Event(module);
//********************************************************************
//*** Module Init Updcall ..EventHandler
//********************************************************************
   Dtool_PyModuleClassInit_EventHandler(module);
//********************************************************************
//*** Module Init Updcall ..EventQueue
//********************************************************************
   Dtool_PyModuleClassInit_EventQueue(module);
//********************************************************************
//*** Module Init Updcall ..PointerEventList
//********************************************************************
   Dtool_PyModuleClassInit_PointerEventList(module);
//********************************************************************
//*** Module Init Updcall ..PythonTask
//********************************************************************
   Dtool_PyModuleClassInit_PythonTask(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libevent_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212822,  /* file_identifier */
  "libevent",  /* library_name */
  "fkxo",  /* library_hash_name */
  "panda",  /* module_name */
  "libevent.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  544  /* next_index */
};

Configure(_in_configure_libevent);
ConfigureFn(_in_configure_libevent) {
  interrogate_request_module(&_in_module_def);
}

